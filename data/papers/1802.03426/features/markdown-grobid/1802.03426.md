# UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction

## Abstract

## 

UMAP (Uniform Manifold Approximation and Projection) is a novel manifold learning technique for dimension reduction. UMAP is constructed from a theoretical framework based in Riemannian geometry and algebraic topology.

e result is a practical scalable algorithm that is applicable to real world data. e UMAP algorithm is competitive with t-SNE for visualization quality, and arguably preserves more of the global structure with superior run time performance. Furthermore, UMAP has no computational restrictions on embedding dimension, making it viable as a general purpose dimension reduction technique for machine learning.

## Introduction

Dimension reduction plays an important role in data science, being a fundamental technique in both visualisation and as pre-processing for machine 1 learning. Dimension reduction techniques are being applied in a broadening range of elds and on ever increasing sizes of datasets. It is thus desirable to have an algorithm that is both scalable to massive data and able to cope with the diversity of data available. Dimension reduction algorithms tend to fall into two categories; those that seek to preserve the pairwise distance structure amongst all the data samples and those that favor the preservation of local distances over global distance. Algorithms such as PCA [[27]](#b26), MDS [[30]](#b29), and Sammon mapping [[50]](#b49) fall into the former category while t-SNE [[59,](#b59)[58]](#b58), Isomap [[56]](#b56), LargeVis [[54]](#b53), Laplacian eigenmaps [[6,](#b5)[7]](#b6) and di usion maps [[16]](#b15) all fall into the la er category.

In this paper we introduce a novel manifold learning technique for dimension reduction. We provide a sound mathematical theory grounding the technique and a practical scalable algorithm that applies to real world data. UMAP (Uniform Manifold Approximation and Projection) builds upon mathematical foundations related to the work of Belkin and Niyogi on Laplacian eigenmaps. We seek to address the issue of uniform data distributions on manifolds through a combination of Riemannian geometry and the work of David Spivak [[52]](#b51) in category theoretic approaches to geometric realization of fuzzy simplicial sets. t-SNE is the current state-of-the-art for dimension reduction for visualization. Our algorithm is competitive with t-SNE for visualization quality and arguably preserves more of the global structure with superior run time performance. Furthermore the algorithm is able to scale to signi cantly larger data set sizes than are feasible for t-SNE. Finally, UMAP has no computational restrictions on embedding dimension, making it viable as a general purpose dimension reduction technique for machine learning.

Based upon preliminary releases of a so ware implementation, UMAP has already found widespread use in the elds of bioinformatics [[5,](#b4)[12,](#b11)[17,](#b16)[46,](#b45)[2,](#b1)[45,](#b44)[15]](#b14), materials science [[34,](#b33)[23]](#b22), and machine learning [[14,](#b13)[20,](#b19)[21,](#b20)[24,](#b23)[19,](#b18)[47]](#b46) among others.

is paper is laid out as follows. In Section 2 we describe the theory underlying the algorithm. Section 2 is necessary to understand both the theory underlying why UMAP works and the motivation for the choices that where made in developing the algorithm. A reader without a background (or interest) in topological data analysis, category theory or the theoretical underpinnings of UMAP should skip over this section and proceed directly to Section 3.

at being said, we feel that strong theory and mathematically justi ed algorithmic decisions are of particular importance in the eld of unsupervised learning. is is, at least partially, due to plethora of proposed objec-tive functions within the area. We a empt to highlight in this paper that UMAPs design decisions were all grounded in a solid theoretic foundation and not derived through experimentation with any particular task focused objective function. ough all neighbourhood based manifold learning algorithms must share certain fundamental components we believe it to be advantageous for these components to be selected through well grounded theoretical decisions. One of the primary contributions of this paper is to reframe the problem of manifold learning and dimension reduction in a different mathematical language allowing pracitioners to apply a new eld of mathemtaics to the problems.

In Section 3 we provide a more computational description of UMAP. Section 3 should provide readers less familiar with topological data analysis with a be er foundation for understanding the theory described in Section 2. Appendix C contrasts UMAP against the more familiar algorithms t-SNE and LargeVis, describing all these algorithms in similar language. is section should assist readers already familiar with those techniques to quickly gain an understanding of the UMAP algorithm though they will grant li le insite into its theoretical underpinnings.

In Section 4 we discuss implementation details of the UMAP algorithm. is includes a more detailed algorithmic description, and discussion of the hyper-parameters involved and their practical e ects.

In Section 5 we provide practical results on real world datasets as well as scaling experiments to demonstrate the algorithm's performance in real world scenarios as compared with other dimension reduction algorithms.

In Section 6 we discuss relative weakenesses of the algorithm, and applications for which UMAP may not be the best choice.

Finally, in Section 7 we detail a number of potential extensions of UMAP that are made possible by its construction upon solid mathematical foundations.

ese avenues for further development include semi-supervised learning, metric learning and heterogeneous data embedding.

## eoretical Foundations for UMAP

e theoretical foundations for UMAP are largely based in manifold theory and topological data analysis. Much of the theory is most easily explained in the language of topology and category theory. Readers may consult [[39]](#b38), [[49]](#b48) and [[40]](#b39) for background. Readers more interested in practical computational aspects of the algorithm, and not necessarily the theoretical motivation for the computations involved, may wish to skip this section.

Readers more familiar with traditional machine learning may nd the relationships between UMAP, t-SNE and Largeviz located in Appendix C enlightening. Unfortunately, this purely computational view fails to shed any light upon the reasoning that underlies the algorithmic decisions made in UMAP. Without strong theoretical foundations the only arguments which can be made about algorithms amount to empirical measures, for which there are no clear universal choices for unsupervised problems.

At a high level, UMAP uses local manifold approximations and patches together their local fuzzy simplicial set representations to construct a topological representation of the high dimensional data. Given some low dimensional representation of the data, a similar process can be used to construct an equivalent topological representation. UMAP then optimizes the layout of the data representation in the low dimensional space, to minimize the cross-entropy between the two topological representations.

e construction of fuzzy topological representations can be broken down into two problems: approximating a manifold on which the data is assumed to lie; and constructing a fuzzy simplicial set representation of the approximated manifold. In explaining the algorithm we will rst discuss the method of approximating the manifold for the source data. Next we will discuss how to construct a fuzzy simplicial set structure from the manifold approximation. Finally, we will discuss the construction of the fuzzy simplicial set associated to a low dimensional representation (where the manifold is simply R d ), and how to optimize the representation with respect to our objective function.

## Uniform distribution of data on a manifold and geodesic approximation

e rst step of our algorithm is to approximate the manifold we assume the data (approximately) lies on.

e manifold may be known apriori (as simply R n ) or may need to be inferred from the data. Suppose the manifold is not known in advance and we wish to approximate geodesic distance on it. Let the input data be X = {X 1 , . . . , X N }. As in the work of Belkin and Niyogi on Laplacian eigenmaps [[6,](#b5)[7]](#b6), for theoretical reasons it is bene cial to assume the data is uniformly distributed on the manifold, and even if that assumption is not made (e.g [[26]](#b25)) results are only valid in the limit of in nite data. In practice, nite real world data is rarely so nicely behaved. However, if we assume that the manifold has a Riemannian metric not inherited from the ambient space, we can nd a metric such that the data is approximately uniformly distributed with regard to that metric.

Formally, let M be the manifold we assume the data to lie on, and let g be the Riemannian metric on M. us, for each point p ∈ M we have g p , an inner product on the tangent space T p M. Lemma 1. Let (M, g) be a Riemannian manifold in an ambient R n , and let p ∈ M be a point. If g is locally constant about p in an open neighbourhood U such that g is a constant diagonal matrix in ambient coordinates, then in a ball B ⊆ U centered at p with volume π n/2 Γ(n/2+1) with respect to g, the geodesic distance from p to any point q ∈ B is 1 r d R n (p, q), where r is the radius of the ball in the ambient space and d R n is the existing metric on the ambient space.

See Appendix A of the supplementary materials for a proof of Lemma 1.

If we assume the data to be uniformly distributed on M (with respect to g) then, away from any boundaries, any ball of xed volume should contain approximately the same number of points of X regardless of where on the manifold it is centered. Given nite data and small enough local neighborhoods this crude approximation should be accurate enough even for data samples near manifold boundaries. Now, conversely, a ball centered at X i that contains exactly the k-nearest-neighbors of X i should have approximately xed volume regardless of the choice of X i ∈ X. Under Lemma 1 it follows that we can approximate geodesic distance from X i to its neighbors by normalising distances with respect to the distance to the k th nearest neighbor of X i .

In essence, by creating a custom distance for each X i , we can ensure the validity of the assumption of uniform distribution on the manifold. e cost is that we now have an independent notion of distance for each and every X i , and these notions of distance may not be compatible. We have a family of discrete metric spaces (one for each X i ) that we wish to merge into a consistent global structure.

is can be done in a natural way by converting the metric spaces into fuzzy simplicial sets.

## Fuzzy topological representation

We will use functors between the relevant categories to convert from metric spaces to fuzzy topological representations.

is will provide a means to merge the incompatible local views of the data. e topological structure of choice is that of simplicial sets. For more details on simplicial sets we refer the reader to [[25]](#b24), [[40]](#b39), [[48]](#b47), or [[22]](#b21). Our approach draws heavily upon the work of Michael Barr [[3]](#b2) and David Spivak in [[52]](#b51), and many of the de nitions and theorems below are drawn or adapted from those sources. We assume familiarity with the basics of category theory. For an introduction to category theory readers may consult [[39]](#b38) or [[49]](#b48).

To start we will review the de nitions for simplicial sets. Simplicial sets provide a combinatorial approach to the study of topological spaces. ey are related to the simpler notion of simplicial complexes -which construct topological spaces by gluing together simple building blocks called simplices -but are more general. Simplicial sets are most easily de ned purely abstractly in the language of category theory.

## De nition 1.

e category ∆ has as objects the nite order sets [n] = {1, . . . , n}, with morphims given by (non-strictly) order-preserving maps.

Following standard category theoretic notation, ∆ op denotes the category with the same objects as ∆ and morphisms given by the morphisms of ∆ with the direction (domain and codomain) reversed.

## De nition 2.

A simplicial set is a functor from ∆ op to Sets, the category of sets; that is, a contravariant functor from ∆ to Sets.

Given a simplicial set X : ∆ op → Sets, it is common to denote the set X([n]) as X n and refer to the elements of the set as the n-simplices of X.

e simplest possible examples of simplicial sets are the standard simplices ∆ n , de ned as the representable functors hom ∆ (•, [n]). It follows from the Yoneda lemma that there is a natural correspondence between n-simplices of X and morphisms ∆ n → X in the category of simplicial sets, and it is o en helpful to think in these terms. us for each x ∈ X n we have a corresponding morphism x : ∆ n → X. By the density theorem and employing a minor abuse of notation we then have

$colim x∈Xn ∆ n ∼ = X ere is a standard covariant functor | • | : ∆ → Top mapping from the category ∆ to the category of topological spaces that sends [n] to the standard n-simplex |∆ n | ⊂ R n+1 de ned as |∆ n | (t 0 , . . . , t n ) ∈ R n+1 | n i=0 t i = 1, t i ≥ 0$with the standard subspace topology. If X : ∆ op → Sets is a simplicial set then we can construct the realization of X (denoted |X|) as the colimit

$|X| = colim x∈Xn |∆ n |$and thus associate a topological space with a given simplicial set. Conversely given a topological space Y we can construct an associated simplicial set S(Y ), called the singular set of Y , by de ning

$S(Y ) : [n] → hom Top (|∆ n |, Y ).$It is a standard result of classical homotopy theory that the realization functor and singular set functors form an adjunction, and provide the standard means of translating between topological spaces and simplicial sets. Our goal will be to adapt these powerful classical results to the case of nite metric spaces. We draw signi cant inspiration from Spivak, speci cally [[52]](#b51), where he extends the classical theory of singular sets and topological realization to fuzzy singular sets and metric realization. To develop this theory here we will rst outline a categorical presentation of fuzzy sets, due to [[3]](#b2), that will make extending classical simplicial sets to fuzzy simplicial sets most natural.

Classically a fuzzy set [[65]](#b65) is de ned in terms of a carrier set A and a map µ : A → [0, 1] called the membership function. One is to interpret the value µ(x) for x ∈ A to be the membership strength of x to the set A. us membership of a set is no longer a bi-valent true or false property as in classical set theory, but a fuzzy property taking values in the unit interval. We wish to formalize this in terms of category theory.

Let I be the unit interval (0, 1] ⊆ R with topology given by intervals of the form [0, a) for a ∈ (0, 1]. e category of open sets (with morphisms given by inclusions) can be imbued with a Grothendieck topology in the natural way for any poset category.

## De nition 3.

A presheaf P on I is a functor from I op to Sets. A fuzzy set is a presheaf on I such that all maps P(a ≤ b) are injections.

Presheaves on I form a category with morphisms given by natural transformations. We can thus form a category of fuzzy sets by simply restricting to the sub-category of presheaves that are fuzzy sets. We note that such presheaves are trivially sheaves under the Grothendieck topology on I. As one might expect, limits (including products) of such sheaves are well de ned, but care must be taken to de ne colimits (and coproducts) of sheaves. To link to the classical approach to fuzzy sets one can think of a section P([0, a)) as the set of all elements with membership strength at least a. We can now de ne the category of fuzzy sets.

De nition 4. e category Fuzz of fuzzy sets is the full subcategory of sheaves on I spanned by fuzzy sets.

With this categorical presentation in hand, de ning fuzzy simplicial sets is simply a ma er of considering presheaves of ∆ valued in the category of fuzzy sets rather than the category of sets.

De nition 5. e category of fuzzy simplicial sets sFuzz is the category with objects given by functors from ∆ op to Fuzz, and morphisms given by natural transformations.

Alternatively, a fuzzy simplicial set can be viewed as a sheaf over ∆×I, where ∆ is given the trivial topology and ∆ × I has the product topology. We will use ∆ n <a to denote the sheaf given by the representable functor of the object ([n], [0, a)). e importance of this fuzzy (shea ed) version of simplicial sets is their relationship to metric spaces. We begin by considering the larger category of extended-pseudo-metric spaces.

De nition 6. An extended-pseudo-metric space (X, d) is a set X and a map d : X × X → R ≥0 ∪ {∞} such that 1. d(x, y) 0, and x = y implies d(x, y) = 0;

$2. d(x, y) = d(y, x); and 3. d(x, z) d(x, y) + d(y, z) or d(x, z) = ∞.$e category of extended-pseudo-metric spaces EPMet has as objects extendedpseudo-metric spaces and non-expansive maps as morphisms. We denote the subcategory of nite extended-pseudo-metric spaces FinEPMet.

e choice of non-expansive maps in De nition 6 is due to Spivak, but we note that it closely mirrors the work of Carlsson and Memoli in [[13]](#b12) on topological methods for clustering as applied to nite metric spaces. is choice is signi cant since pure isometries are too strict and do not provide large enough Hom-sets.

In [[52]](#b51) Spivak constructs a pair of adjoint functors, Real and Sing between the categories sFuzz and EPMet. ese functors are the natural extension of the classical realization and singular set functors from algebraic topology. e functor Real is de ned in terms of standard fuzzy simplices ∆ n <a as

$Real(∆ n <a ) (t 0 , . . . , t n ) ∈ R n+1 | n i=0 t i = -log($a), t i ≥ 0 similarly to the classical realization functor | • |. e metric on Real(∆ n <a ) is simply inherited from R n+1 . A morphism ∆ n <a → ∆ m <b exists only if a ≤ b, and is determined by a ∆ morphism σ : [n] → [m]. e action of Real on such a morphism is given by the map

$(x 0 , x 1 , . . . , x n ) → log(b) log(a)   i 0 ∈σ -1 (0) x i 0 , i 0 ∈σ -1 (1)$x i 0 , . . . ,

$i 0 ∈σ -1 (m) x i 0   . Such a map is clearly non-expansive since 0 ≤ a ≤ b ≤ 1 implies that log(b)/ log(a) ≤ 1.$We then extend this to a general simplicial set X via colimits, de ning Real(X) colim

$∆ n <a →X Real(∆ n <a ).$Since the functor Real preserves colimits, it follows that there exists a right adjoint functor. Again, analogously to the classical case, we nd the right adjoint, denoted Sing, is de ned for an extended pseudo metric space Y in terms of its action on the category ∆ × I:

$Sing(Y ) : ([n], [0, a)) → hom EPMet (Real(∆ n <a ), Y ).$For our case we are only interested in nite metric spaces. To correspond with this we consider the subcategory of bounded fuzzy simplicial sets Fin-sFuzz. We therefore use the analogous adjoint pair FinReal and FinSing. Formally we de ne the nite fuzzy realization functor as follows: De nition 7. De ne the functor FinReal : Fin-sFuzz → FinEPMet by se ing FinReal(∆ n <a ) ({x 1 , x 2 , . . . , x n }, d a ), where

$d a (x i , x j ) =    -log(a) if i = j,0 otherwise$. and then de ning

$FinReal(X) colim ∆ n <a →X FinReal(∆ n <a ).$Similar to Spivak's construction, the action of FinReal on a map ∆ n <a → ∆ m <b , where a ≤ b de ned by σ : ∆ n → ∆ m , is given by

$({x 1 , x 2 , . . . , x n }, d a ) → ({x σ(1) , x σ(2) , . . . , x σ(n) }, d b ), which is a non-expansive map since a ≤ b implies d a ≥ d b .$Since FinReal preserves colimits it admits a right adjoint, the fuzzy singular set functor FinSing. We can then de ne the ( nite) fuzzy singular set functor in terms of the action of its image on ∆ × I, analogously to Sing. We then have the following theorem. e proof of this is by construction. Appendix B provides a full proof of the theorem.

With the necessary theoretical background in place, the means to handle the family of incompatible metric spaces described above becomes clear. Each metric space in the family can be translated into a fuzzy simplicial set via the fuzzy singular set functor, distilling the topological information while still retaining metric information in the fuzzy structure. Ironing out the incompatibilities of the resulting family of fuzzy simplicial sets can be done by simply taking a (fuzzy) union across the entire family. e result is a single fuzzy simplicial set which captures the relevant topological and underlying metric structure of the manifold M.

It should be noted, however, that the fuzzy singular set functor applies to extended-pseudo-metric spaces, which are a relaxation of traditional metric spaces.

e results of Lemma 1 only provide accurate approximations of geodesic distance local to X i for distances measured from X ithe geodesic distances between other pairs of points within the neighborhood of X i are not well de ned. In deference to this lack of information we de ne distances between X j and X k in the extended-pseudo metric space local to X i (where i = j and i = k) to be in nite (local neighborhoods of X j and X k will provide suitable approximations).

For real data it is safe to assume that the manifold M is locally connected. In practice this can be realized by measuring distance in the extendedpseudo-metric space local to X i as geodesic distance beyond the nearest neighbor of X i . Since this sets the distance to the nearest neighbor to be equal to 0 this is only possible in the more relaxed se ing of extendedpseudo-metric spaces. It ensures, however, that each 0-simplex is the face of some 1-simplex with fuzzy membership strength 1, meaning that the resulting topological structure derived from the manifold is locally connected. We note that this has a similar practical e ect to the truncated similarity approach of Lee and Verleysen [[33]](#b32), but derives naturally from the assumption of local connectivity of the manifold.

Combining all of the above we can de ne the fuzzy topological representation of a dataset. De nition 9. Let X = {X 1 , . . . , X N } be a dataset in R n . Let {(X, d i )} i=1...N be a family of extended-pseudo-metric spaces with common carrier set X such that

$d i (X j , X k ) =    d M (X j , X k ) -ρ if i = j or i = k, ∞ otherwise ,$where ρ is the distance to the nearest neighbor of X i and d M is geodesic distance on the manifold M, either known apriori, or approximated as per Lemma 1. e fuzzy topological representation of X is n i=1

FinSing((X, d i )).

e (fuzzy set) union provides the means to merge together the di erent metric spaces. is provides a single fuzzy simplicial set as the global representation of the manifold formed by patching together the many local representations.

Given the ability to construct such topological structures, either from a known manifold, or by learning the metric structure of the manifold, we can perform dimension reduction by simply nding low dimensional representations that closely match the topological structure of the source data. We now consider the task of nding such a low dimensional representation.

## Optimizing a low dimensional representation

$Let Y = {Y 1 , . . . , Y N } ⊆ R d be a low dimensional (d n)$representation of X such that Y i represents the source data point X i . In contrast to the source data where we want to estimate a manifold on which the data is uniformly distributed, a target manifold for Y is chosen apriori (usually this will simply be R d itself, but other choices such as d-spheres or d-tori are certainly possible) . erefore we know the manifold and manifold metric apriori, and can compute the fuzzy topological representation directly. Of note, we still want to incorporate the distance to the nearest neighbor as per the local connectedness requirement. is can be achieved by supplying a parameter that de nes the expected distance between nearest neighbors in the embedded space.

Given fuzzy simplicial set representations of X and Y , a means of comparison is required. If we consider only the 1-skeleton of the fuzzy simplicial sets we can describe each as a fuzzy graph, or, more speci cally, a fuzzy set of edges. To compare two fuzzy sets we will make use of fuzzy set cross entropy. For these purposes we will revert to classical fuzzy set notation. at is, a fuzzy set is given by a reference set A and a membership strength function µ : A → [0, 1]. Comparable fuzzy sets have the same reference set. Given a sheaf representation P we can translate to classical fuzzy sets by se ing A = a∈(0,1] P([0, a)) and µ

$(x) = sup{a ∈ (0, 1] | x ∈ P([0, a))}.$De nition 10. e cross entropy C of two fuzzy sets (A, µ) and (A, ν) is de ned as

$C((A, µ), (A, ν)) a∈A µ(a) log µ(a) ν(a) + (1 -µ(a)) log 1 -µ(a) 1 -ν(a) .$Similar to t-SNE we can optimize the embedding Y with respect to fuzzy set cross entropy C by using stochastic gradient descent. However, this requires a di erentiable fuzzy singular set functor. If the expected minimum distance between points is zero the fuzzy singular set functor is di erentiable for these purposes, however for any non-zero value we need to make a di erentiable approximation (chosen from a suitable family of di erentiable functions).

is completes the algorithm: by using manifold approximation and patching together local fuzzy simplicial set representations we construct a topological representation of the high dimensional data. We then optimize the layout of data in a low dimensional space to minimize the error between the two topological representations.

We note that in this case we restricted a ention to comparisons of the 1-skeleton of the fuzzy simplicial sets. One can extend this to -skeleta by de ning a cost function C as

$C (X, Y ) = i=1 λ i C(X i , Y i ),$where X i denotes the fuzzy set of i-simplices of X and the λ i are suitably chosen real valued weights. While such an approach will capture the overall topological structure more accurately, it comes at non-negligible computational cost due to the increasingly large numbers of higher dimensional simplices. For this reason current implementations restrict to the 1-skeleton at this time.

## A Computational View of UMAP

To understand what computations the UMAP algorithm is actually making from a practical point of view, a less theoretical and more computational description may be helpful for the reader. is description of the algorithm lacks the motivation for a number of the choices made. For that motivation please see Section 2.

e theoretical description of the algorithm works in terms of fuzzy simplicial sets. Computationally this is only tractable for the one skeleton which can ultimately be described as a weighted graph. is means that, from a practical computational perspective, UMAP can ultimately be described in terms of, construction of, and operations on, weighted graphs. In particular this situates UMAP in the class of k-neighbour based graph learning algorithms such as Laplacian Eigenmaps, Isomap and t-SNE.

As with other k-neighbour graph based algorithms, UMAP can be described in two phases. In the rst phase a particular weighted k-neighbour graph is constructed. In the second phase a low dimensional layout of this graph is computed.

e di erences between all algorithms in this class amount to speci c details in how the graph is constructed and how the layout is computed. e theoretical basis for UMAP as described in Section 2 provides novel approaches to both of these phases, and provides clear motivation for the choices involved.

Finally, since t-SNE is not usually described as a graph based algorithm, a direct comparison of UMAP with t-SNE, using the similarity/probability notation commonly used to express the equations of t-SNE, is given in the Appendix C.

In section 2 we made a few basic assumptions about our data. From these assumptions we made use of category theory to derive the UMAP algorithms. at said, all these derivations assume these axioms to be true.

## 1.

ere exists a manifold on which the data would be uniformly distributed.

## 2.

e underlying manifold of interest is locally connected.

3. Preserving the topological structure of this manifold is the primary goal.

As highlighted in Appendix C any algorithm that a empts to use a mathematical structure akin to a k-neighbour graph to approximate a manifold must follow a similar basic structure.

• Graph Construction 1. Construct a weighted k-neighbour graph 2. Apply some transform on the edges to ambient local distance.

3. Deal with the inherent asymmetry of the k-neighbour graph.

• Graph Layout 1. De ne an objective function that preserves desired characteristics of this k-neighbour graph. 2. Find a low dimensional representation which optimizes this objective function.

Many dimension reduction algorithms can be broken down into these steps because they are fundamental to a particular class of solutions. Choices for each step must be either chosen through task oriented experimentation or by selecting a set of believable axioms and building strong theoretical arguments from these. Our belief is that basing our decisions on a strong foundational theory will allow for a more extensible and generalizable algorithm in the long run.

We theoretically justify using the choice of using a k-neighbour graph to represent a manifold in Section 2.1. e choices for our kernel transform an symmetrization function can be found in Section 2.2. Finally, the justications underlying our choices for our graph layout are outlined in Section 2.3.

## Graph Construction

e rst phase of UMAP can be thought of as the construction of a weighted k-neighbour graph. Let X = {x 1 , . . . , x N } be the input dataset, with a metric (or dissimilarity measure) d : X ×X → R ≥0 . Given an input hyperparameter k, for each x i we compute the set {x i 1 , . . . , x i k } of the k nearest neighbors of x i under the metric d. is computation can be performed via any nearest neighbour or approximate nearest neighbour search algorithm. For the purposes of our UMAP implemenation we prefer to use the nearest neighbor descent algorithm of [[18]](#b17).

For each x i we will de ne ρ i and σ i . Let

$ρ i = min{d(x i , x i j ) | 1 ≤ j ≤ k, d(x i , x i j ) > 0},$and set σ i to be the value such that

$k j=1 exp -max(0, d(x i , x i j ) -ρ i ) σ i = log 2 (k).$e selection of ρ i derives from the local-connectivity constraint described in Section 2.2. In particular it ensures that x i connects to at least one other data point with an edge of weight 1; this is equivalent to the resulting fuzzy simplicial set being locally connected at x i . In practical terms this significantly improves the representation on very high dimensional data where other algorithms such as t-SNE begin to su er from the curse of dimensionality.

e selection of σ i corresponds to (a smoothed) normalisation factor, de ning the Riemannian metric local to the point x i as described in Section 2.1.

We can now de ne a weighted directed graph Ḡ = (V, E, w). e vertices V of Ḡ are simply the set X. We can then form the set of directed edges

$E = {(x i , x i j ) | 1 ≤ j ≤ k, 1 ≤ i ≤ N },$and de ne the weight function w by se ing

$w((x i , x i j )) = exp -max(0, d(x i , x i j ) -ρ i ) σ i .$For a given point x i there exists an induced graph of x i and outgoing edges incident on x i . is graph is the 1-skeleton of the fuzzy simplicial set associated to the metric space local to x i where the local metric is de ned in terms of ρ i and σ i . e weight associated to the edge is the membership strength of the corresponding 1-simplex within the fuzzy simplicial set, and is derived from the adjunction of eorem 1 using the right adjoint (nearest inverse) of the geometric realization of a fuzzy simplicial set. Intuitively one can think of the weight of an edge as akin to the probability that the given edge exists. Section 2 demonstrates why this construction faithfully captures the topology of the data. Given this set of local graphs (represented here as a single directed graph) we now require a method to combine them into a uni ed topological representation. We note that while patching together incompatible nite metric spaces is challenging, by using eorem 1 to convert to a fuzzy simplicial set representation, the combining operation becomes natural.

Let A be the weighted adjacency matrix of Ḡ, and consider the symmetric matrix

$B = A + A -A • A ,$where • is the Hadamard (or pointwise) product. is formula derives from the use of the probabilistic t-conorm used in unioning the fuzzy simplicial sets. If one interprets the value of A ij as the probability that the directed edge from x i to x j exists, then B ij is the probability that at least one of the two directed edges (from x i to x j and from x j to x i ) exists. e UMAP graph G is then an undirected weighted graph whose adjacency matrix is given by B. Section 2 explains this construction in topological terms, providing the justi cation for why this construction provides an appropriate fuzzy topological representation of the data -that is, this construction captures the underlying geometric structure of the data in a faithful way.

## Graph Layout

In practice UMAP uses a force directed graph layout algorithm in low dimensional space. A force directed graph layout utilizes of a set of a ractive forces applied along edges and a set of repulsive forces applied among vertices. Any force directed layout algorithm requires a description of both the a ractive and repulsive forces. e algorithm proceeds by iteratively applying a ractive and repulsive forces at each edge or vertex. is amounts to a non-convex optimization problem. Convergence to a local minima is guaranteed by slowly decreasing the a ractive and repulsive forces in a similar fashion to that used in simulated annealing.

In UMAP the a ractive force between two vertices i and j at coordinates y i and y j respectively, is determined by:

$-2ab y i -y j 2(b-1) 2 1 + y i -y j 2 2 w((x i , x j )) (y i -y j )$where a and b are hyper-parameters. Repulsive forces are computed via sampling due to computational constraints.

us, whenever an a ractive force is applied to an edge, one of that edge's vertices is repulsed by a sampling of other vertices. e repulsive force is given by

$2b + y i -y j 2 2 1 + a y i -y j 2b 2 (1 -w((x i , x j ))) (y i -y j ) .$is a small number to prevent division by zero (0.001 in the current implementation). e algorithm can be initialized randomly but in practice, since the symmetric Laplacian of the graph G is a discrete approximation of the Laplace-Beltrami operator of the manifold, we can use a spectral layout to initialize the embedding. is provides both faster convergence and greater stability within the algorithm. e forces described above are derived from gradients optimising the edge-wise cross-entropy between the weighted graph G, and an equivalent weighted graph H constructed from the points {y i } i=1..N . at is, we are seeking to position points y i such that the weighted graph induced by those points most closely approximates the graph G, where we measure the di erence between weighted graphs by the total cross entropy over all the edge existence probabilities. Since the weighted graph G captures the topology of the source data, the equivalent weighted graph H constructed from the points {y i } i=1..N matches the topology as closely as the optimization allows, and thus provides a good low dimensional representation of the overall topology of the data.

## Implementation and Hyper-parameters

Having completed a theoretical description of the approach, we now turn our a ention to the practical realization of this theory. We begin by providing a more detailed description of the algorithm as implemented, and then discuss a few implementation speci c details. We conclude this section with a discussion of the hyper-parameters for the algorithm and their practical e ects.

## Algorithm description

In overview the UMAP algorithm is relatively straightforward (see Algorithm 1). When performing a fuzzy union over local fuzzy simplicial sets we have found it most e ective to work with the probabilistic t-conorm (as one would expect if treating membership strengths as a probability that the simplex exists).

e individual functions for constructing the local fuzzy simplicial sets, determining the spectral embedding, and optimizing the embedding with regard to fuzzy set cross entropy, are described in more detail below.

e inputs to Algorithm 1 are: X, the dataset to have its dimension reduced; n, the neighborhood size to use for local metric approximation; d, the dimension of the target reduced space; min-dist, an algorithmic pa-

$Algorithm 1 UMAP algorithm function UMAP(X, n, d, min-dist, n-epochs) # Construct the relevant weighted graph for all x ∈ X do fs-set[x] ← L F S S (X, x, n) top-rep ← x∈X fs-set[x] # We recommend the probabilistic t-conorm # Perform optimization of the graph layout Y ← S E (top-rep, d) Y ← O E (top-rep, Y , min-dist, n-epochs) return Y$rameter controlling the layout; and n-epochs, controlling the amount of optimization work to perform.

Algorithm 2 describes the construction of local fuzzy simplicial sets. To represent fuzzy simplicial sets we work with the fuzzy set images of [0] and [[1]](#b0) (i.e. the 1-skeleton), which we denote as fs-set 0 and fs-set 1 . One can work with higher order simplices as well, but the current implementation does not. We can construct the fuzzy simplicial set local to a given point x by nding the n nearest neighbors, generating the appropriate normalised distance on the manifold, and then converting the nite metric space to a simplicial set via the functor FinSing, which translates into exponential of the negative distance in this case.

Rather than directly using the distance to the n th nearest neighbor as the normalization, we use a smoothed version of knn-distance that xes the cardinality of the fuzzy set of 1-simplices to a xed value. We selected log 2 (n) for this purpose based on empirical experiments. is is described brie y in Algorithm 3.

Spectral embedding is performed by considering the 1-skeleton of the global fuzzy topological representation as a weighted graph and using standard spectral methods on the symmetric normalized Laplacian.

is process is described in Algorithm 4.

e nal major component of UMAP is the optimization of the embedding through minimization of the fuzzy set cross entropy. Recall that Algorithm 2 Constructing a local fuzzy simplicial set

$function L F S S (X, x, n) knn, knn-dists ← A N N (X, x, n) ρ ← knn-dists[1] # Distance to nearest neighbor σ ← S KNND (knn-dists, n, ρ) # Smooth approximator to knn-distance fs-set 0 ← X fs-set 1 ← {([x, y], 0) | y ∈ X} for all y ∈ knn do d x,y ← max{0, dist(x, y) -ρ}/σ fs-set 1 ← fs-set 1 ∪ ([x, y], exp(-d x,y ))$return fs-set (

$)1$e rst sum depends only on µ which takes xed values during the optimization, thus the minimization of cross entropy depends only on the second sum, so we seek to minimize

$- a∈A (µ(a) log(ν(a)) + (1 -µ(a)) log(1 -ν(a))) .$Following both [[54]](#b53) and [[41]](#b40), we take a sampling based approach to the optimization. We sample 1-simplices with probability µ(a) and update according to the value of ν(a), which handles the term µ(a) log(ν(a)). e term (1 -µ(a)) log(1 -ν(a)) requires negative sampling -rather than computing this over all potential simplices we randomly sample potential 1-simplices and assume them to be a negative example (i.e. with membership strength 0) and update according to the value of 1 -ν(a). In contrast to [[54]](#b53) the above formulation provides a vertex sampling distribution of

$P (x i ) = {a∈A|d 0 (a)=x i } 1 -µ(a) {b∈A|d 0 (b) =x i } 1 -µ(b)$for negative samples, which can be reasonably approximated by a uniform distribution for su ciently large data sets. It therefore only remains to nd a di erentiable approximation to ν(a) for a given 1-simplex a so that gradient descent can be applied for optimization. is is done as follows:

De nition 11. De ne Φ : R d × R d → [0, 1], a smooth approximation of the membership strength of a 1-simplex between two points in R d , as

$Φ(x, y) = 1 + a( x -y 2 2 ) b -1 ,$where a and b are chosen by non-linear least squares ing against the curve

$Ψ : R d × R d → [0, 1]$where

$Ψ(x, y) = 1 if x -y 2 ≤ min-dist exp(-( x -y 2 -min-dist)) otherwise .$e optimization process is now executed by stochastic gradient descent as given by Algorithm 5. 

## Implementation

Practical implementation of this algorithm requires (approximate) k-nearestneighbor calculation and e cient optimization via stochastic gradient descent. E cient approximate k-nearest-neighbor computation can be achieved via the Nearest-Neighbor-Descent algorithm of [[18]](#b17). e error intrinsic in a dimension reduction technique means that such approximation is more than adequate for these purposes. While no theoretical complexity bounds have been established for Nearest-Neighbor-Descent the authors of the original paper report an empirical complexity of O(N 1.14 ). A further bene t of Nearest-Neighbor-Descent is its generality; it works with any valid dissimilarity measure, and is e cient even for high dimensional data.

In optimizing the embedding under the provided objective function, we follow work of [[54]](#b53); making use of probabilistic edge sampling and negative sampling [[41]](#b40).

is provides a very e cient approximate stochastic gradient descent algorithm since there is no normalization requirement. Furthermore, since the normalized Laplacian of the fuzzy graph representation of the input data is a discrete approximation of the Laplace-Betrami operator of the manifold [?, see]]belkin2002laplacian, belkin2003laplacian, we can provide a suitable initialization for stochastic gradient descent by using the eigenvectors of the normalized Laplacian.

e amount of optimization work required will scale with the number of edges in the fuzzy graph (assuming a xed negative sampling rate), resulting in a complexity of O(kN ).

Combining these techniques results in highly e cient embeddings, which we will discuss in Section 5. e overall complexity is bounded by the approximate nearest neighbor search complexity and, as mentioned above, is empirically approximately O(N 1.14 ). A reference implementation can be found at [https://github.com/lmcinnes/umap](https://github.com/lmcinnes/umap), and an R implementation can be found at [https://github.com/jlmelville/uwot](https://github.com/jlmelville/uwot).

For simplicity these experiments were carried out on a single core version of our algorithm. It should be noted that at the time of this publication that both Nearest-Neighbour-Descent and SGD have been parallelized and thus the python reference implementation can be signi cantly accelerated. Our intention in this paper was to introduce the underlying theory behind our UMAP algorithm and we felt that parallel vs single core discussions would distract from our intent.

## Hyper-parameters

As described in Algorithm 1, the UMAP algorithm takes four hyper-parameters:

1. n, the number of neighbors to consider when approximating the local metric;

2. d, the target embedding dimension;

3. min-dist, the desired separation between close points in the embedding space; and 4. n-epochs, the number of training epochs to use when optimizing the low dimensional representation.

e e ects of the parameters d and n-epochs are largely self-evident, and will not be discussed in further detail here. In contrast the e ects of the number of neighbors n and of min-dist are less clear.

One can interpret the number of neighbors n as the local scale at which to approximate the manifold as roughly at, with the manifold estimation averaging over the n neighbors. Manifold features that occur at a smaller scale than within the n nearest-neighbors of points will be lost, while large scale manifold features that cannot be seen by patching together locally at charts at the scale of n nearest-neighbors may not be well detected. us n represents some degree of trade-o between ne grained and large scale manifold features -smaller values will ensure detailed manifold structure is accurately captured (at a loss of the "big picture" view of the manifold), while larger values will capture large scale manifold structures, but at a loss of ne detail structure which will get averaged out in the local approximations. With smaller n values the manifold tends to be broken into many small connected components (care needs to be taken with the spectral embedding for initialization in such cases).

In contrast min-dist is a hyperparameter directly a ecting the output, as it controls the fuzzy simplicial set construction from the low dimensional representation. It acts in lieu of the distance to the nearest neighbor used to ensure local connectivity. In essence this determines how closely points can be packed together in the low dimensional representation. Low values on min-dist will result in potentially densely packed regions, but will likely more faithfully represent the manifold structure. Increasing the value of min-dist will force the embedding to spread points out more, assisting visualization (and avoiding potential overplo ing issues). We view min-dist as an essentially aesthetic parameter, governing the appearance of the embedding, and thus is more important when using UMAP for visualization.

In Figure [1](#fig_1) we provide examples of the e ects of varying the hyperparameters for a toy dataset. e data is uniform random samples from a 3-dimensional color-cube, allowing for easy visualization of the original 3dimensional coordinates in the embedding space by using the corresponding RGB colour. Since the data lls a 3-dimensional cube there is no local manifold structure, and hence for such data we expect larger n values to be more useful. Low values will interpret the noise from random sampling as ne scale manifold structure, producing potentially spurious structure [1](#foot_1) .

Figure [1](#fig_1): Variation of UMAP hyperparameters n and min-dist result in di erent embeddings. e data is uniform random samples from a 3-dimensional colorcube, allowing for easy visualization of the original 3-dimensional coordinates in the embedding space by using the corresponding RGB colour. Low values of n spuriously interpret structure from the random sampling noise -see Section 6 for further discussion of this phenomena.

In Figure [2](#fig_4) we provides examples of the same hyperparamter choices as Figure [1](#fig_1), but for the PenDigits dataset [2](#foot_2) . In this case we expect small to medium n values to be most e ective, since there is signi cant cluster structure naturally present in the data. e min-dist parameter expands out tightly clustered groups, allowing more of the internal structure of densely packed clusters to be seen.

Finally, in Figure [3](#fig_5) we provide an equivalent example of hyperparameter choices for the MNIST dataset [3](#foot_3) . Again, since this dataset is expected to have signifcant cluster structure we expect medium sized values of n to be most e ective. We note that large values of min-dist result in the distinct clusters being compressed together, making the distinctions between the clusters less clear.

## Practical E cacy

While the strong mathematical foundations of UMAP were the motivation for its development, the algorithm must ultimately be judged by its practical e cacy. In this section we examine the delity and performance of low dimensional embeddings of multiple diverse real world data sets under UMAP. e following datasets were considered: Pen digits [1, 10] is a set of 1797 grayscale images of digits entered using a digitiser tablet. Each image is an 8x8 image which we treat as a single 64 dimensional vector, assumed to be in Euclidean vector space. COIL 20 [[43]](#b42) is a set of 1440 greyscale images consisting of 20 objects under 72 di erent rotations spanning 360 degrees. Each image is a 128x128 image which we treat as a single 16384 dimensional vector for the purposes of computing distance between images. COIL 100 [[44]](#b43) is a set of 7200 colour images consisting of 100 objects under 72 di erent rotations spanning 360 degrees. Each image consists of 3 128x128 intensity matrices (one for each color channel). We treat this as a single 49152 dimensional vector for the purposes of computing distance between images. Mouse scRNA-seq [[11]](#b10) is pro led gene expression data for 20,921 cells from an adult mouse. Each sample consists of a vector of 26,774 measurements. Statlog (Shuttle) [[35]](#b34) is a NASA dataset consisting of various data associated to the positions of radiators in the space shu le, including a timestamp. e data is the PenDigits dataset, where each point is an 8x8 grayscale image of a hand-wri en digit. e data is the MNIST dataset, where each point is an 28x28 grayscale image of a hand-wri en digit.

e dataset has 58000 points in a 9 dimensional feature space. MNIST [[32]](#b31) is a dataset of 28x28 pixel grayscale images of handwri en digits. ere are 10 digit classes (0 through 9) and 70000 total images. is is treated as 70000 di erent 784 dimensional vectors. F-MNIST [[63]](#b63) or Fashion MNIST is a dataset of 28x28 pixel grayscale images of fashion items (clothing, footwear and bags).

ere are 10 classes and 70000 total images. As with MNIST this is treated as 70000 di erent 784 dimensional vectors. Flow cytometry [[51,](#b50)[9]](#b8) is a dataset of ow cytometry measurements of CDT4 cells comprised of 1,000,000 samples, each with 17 measurements. GoogleNews word vectors [[41]](#b40) is a dataset of 3 million words and phrases derived from a sample of Google News documents and embedded into a 300 dimensional space via word2vec. For all the datasets except GoogleNews we use Euclidean distance between vectors. For GoogleNews, as per [[41]](#b40), we use cosine distance (or angular distance in t-SNE which does support non-metric distances, in contrast to UMAP).

## alitative Comparison of Multiple Algorithms

We compare a number of algorithms-UMAP, t-SNE [[60,](#b60)[58]](#b58), LargeVis [[54]](#b53),

Laplacian Eigenmaps [[7]](#b6), and Principal Component Analysis [[27]](#b26)-on the COIL20 [[43]](#b42), MNIST [[32]](#b31), Fashion-MNIST [[63]](#b63), and GoogleNews [[41]](#b40) datasets. e Isomap algorithm was also tested, but failed to complete in any reasonable time for any of the datasets larger than COIL20.

e Multicore t-SNE package [[57]](#b57) was used for t-SNE. e reference implementation [[53]](#b52) was used for LargeVis.

e scikit-learn [[10]](#b9) implementations were used for Laplacian Eigenmaps and PCA. Where possible we a empted to tune parameters for each algorithm to give good embeddings.

Historically t-SNE and LargeVis have o ered a dramatic improvement in nding and preserving local structure in the data. is can be seen qualitatively by comparing their embeddings to those generated by Laplacian Eigenmaps and PCA in Figure [4](#fig_6). We claim that the quality of embeddings produced by UMAP is comparable to t-SNE when reducing to two or three dimensions. For example, Figure [4](#fig_6) shows both UMAP and t-SNE embeddings of the COIL20, MNIST, Fashion MNIST, and Google News datasets. While the precise embeddings are di erent, UMAP distinguishes the same structures as t-SNE and LargeVis. It can be argued that UMAP has captured more of the global and topological structure of the datasets than t-SNE [[4,](#b3)[62]](#b62). More of the loops in the COIL20 dataset are kept intact, including the intertwined loops. Similarly the global relationships among di erent digits in the MNIST digits dataset are more clearly captured with 1 (red) and 0 (dark red) at far corners of the embedding space, and 4,7,9 (yellow, sea-green, and violet) and 3,5,8 (orange, chartreuse, and blue) separated as distinct clumps of similar digits. In the Fashion MNIST dataset the distinction between clothing (dark red, yellow, orange, vermilion) and footwear (chartreuse, sea-green, and violet) is made more clear. Finally, while both t-SNE and UMAP capture groups of similar word vectors, the UMAP embedding arguably evidences a clearer global structure among the various word clusters.

## antitative Comparison of Multiple Algorithms

We compare UMAP, t-SNE, LargeVis, Laplacian Eigenmaps and PCA embeddings with respect to the performance of a k-nearest neighbor classi er trained on the embedding space for a variety of datasets. e knearest neighbor classi er accuracy provides a clear quantitative measure of how well the embedding has preserved the important local structure of the dataset. By varying the hyper-parameter k used in the training we can also consider how structure preservation varies under transition from purely local to non-local, to more global structure.

e embeddings used for training the kNN classi er are for those datasets that come with de ned training labels: PenDigits, COIL-20, Shu le, MNIST, and Fashion-MNIST.

We divide the datasets into two classes: smaller datasets (PenDigits and COIL-20), for which a smaller range of k values makes sense, and larger datasets, for which much larger values of k are reasonable. For each of the small datasets a strati ed 10-fold cross-validation was used to derive a set of 10 accuracy scores for each embedding. For the Shu le dataset a 10-fold cross-validation was used due to constraints imposed by class sizes and the strati ed sampling. For MNIST and Fashion-MNIST a 20-fold cross validation was used, producing 20 accuracy scores.

In Table [1](#tab_1) we present the average accuracy across the 10-folds for the PenDigits and COIL-20 datasets. UMAP performs at least as well as t-SNE and LargeVis (given the con dence bounds on the accuracy) for k in the range 10 to 40, but for larger k values of 80 and 160 UMAP has signi cantly higher accuracy on COIL-20, and shows evidence of higher accuracy on PenDigits. Figure [5](#fig_3) provides swarm plots of the accuracy results across the COIL-20 and PenDigits datasets.

In Table [2](#) we present the average cross validation accuracy for the Shuttle, MNIST and Fashion-MNIST datasets. UMAP performs at least as well as t-SNE and LargeVis (given the con dence bounds on the accuracy) for k in the range 100 to 400 on the Shu le and MNIST datasets (but notably underperforms on the Fashion-MNIST dataset), but for larger k values of 800 and 3200 UMAP has signi cantly higher accuracy on the Shu le dataset, and shows evidence of higher accuracy on MNIST. For k values of 1600 and 3200 UMAP establishes comparable performance on Fashion-MNIST. [Fig](#) As evidenced by this comparison UMAP provides largely comparable perfomance in embedding quality to t-SNE and LargeVis at local scales, but performs markedly be er than t-SNE or LargeVis at non-local scales. is bears out the visual qualitative assessment provided in Subsection 5.1.

## Embedding Stability

Since UMAP makes use of both stochastic approximate nearest neighbor search, and stochastic gradient descent with negative sampling for optimization, the resulting embedding is necessarily di erent from run to run, and under sub-sampling of the data.

is is potentially a concern for a

k t-SNE UMAP LargeVis Eigenmaps PCA Shu le 100 0.994 (± 0.002) 0.993 (± 0.002) 0.992 (± 0.003) 0.962 (± 0.004) 0.833 (± 0.013) 200 0.992 (± 0.002) 0.990 (± 0.002) 0.987 (± 0.003) 0.957 (± 0.006) 0.821 (± 0.007) 400 0.990 (± 0.002) 0.988 (± 0.002) 0.976 (± 0.003) 0.949 (± 0.006) 0.815 (± 0.007) 800 0.969 (± 0.005) 0.988 (± 0.002) 0.957 (± 0.004) 0.942 (± 0.006) 0.804 (± 0.003) 1600 0.927 (± 0.005) 0.981 (± 0.002) 0.904 (± 0.007) 0.918 (± 0.006) 0.792 (± 0.003) 3200 0.828 (± 0.004) 0.957 (± 0.005) 0.850 (± 0.008) 0.895 (± 0.006) 0.786 (± 0.001) MNIST 100 0.967 (± 0.015) 0.967 (± 0.014) 0.962 (± 0.015) 0.668 (± 0.016) 0.462 (± 0.023) 200 0.966 (± 0.015) 0.967 (± 0.014) 0.962 (± 0.015) 0.667 (± 0.016) 0.467 (± 0.023) 400 0.964 (± 0.015) 0.967 (± 0.014) 0.961 (± 0.015) 0.664 (± 0.016) 0.468 (± 0.024) 800 0.963 (± 0.016) 0.967 (± 0.014) 0.961 (± 0.015) 0.660 (± 0.017) 0.468 (± 0.023) 1600 0.959 (± 0.016) 0.966 (± 0.014) 0.947 (± 0.015) 0.651 (± 0.014) 0.467 (± 0.0233) 3200 0.946 (± 0.017) 0.964 (± 0.014) 0.920 (± 0.017) 0.639 (± 0.017) 0.459 (± 0.022) Fashion-MNIST 100 0.818 (± 0.012) 0.790 (± 0.013) 0.808 (± 0.014) 0.631 (± 0.010) 0.564 (± 0.018) 200 0.810 (± 0.013) 0.785 (± 0.014) 0.805 (± 0.013) 0.624 (± 0.013) 0.565 (± 0.016) 400 0.801 (± 0.013) 0.780 (± 0.013) 0.796 (± 0.013) 0.612 (± 0.011) 0.564 (± 0.017) 800 0.784 (± 0.011) 0.767 (± 0.014) 0.771 (± 0.014) 0.600 (± 0.012) 0.560 (± 0.017) 1600 0.754 (± 0.011) 0.747 (± 0.013) 0.742 (± 0.013) 0.580 (± 0.014) 0.550 (± 0.017) 3200 0.727 (± 0.011) 0.730 (± 0.011) 0.726 (± 0.012) 0.542 (± 0.014) 0.533 (± 0.017)

Table 2: kNN Classi er accuracy for varying values of k over the embedding spaces of Shu le, MNIST and Fashion-MNIST datasets. Average accuracy scores are given over a 10-fold or 20-fold cross-validation for each of PCA, Laplacian Eigenmaps, LargeVis, t-SNE and UMAP. variety of uses cases, so establishing some measure of how stable UMAP embeddings are, particularly under sub-sampling, is of interest. In this subsection we compare the stability under subsampling of UMAP, LargeVis and t-SNE (the three stochastic dimension reduction techniques considered).

To measure the stability of an embedding we make use of the normalized Procrustes distance to measure the distance between two potentially comparable distributions. Given two datasets X = {x 1 , . . . , x N } and Y = {y 1 , . . . , y N } such that x i corresponds to y i , we can de ne the Procustes distance between the datasets d P (X, Y ) in the following manner. Determine Y = {y 1 , . . . , y N } the optimal translation, uniform scaling, and rotation of Y that minimizes the squared error N i=1 (x i -y i ) 2 , and de ne

$d P (X, Y ) = N i=1 (x i -y i ) 2 .$Since any measure that makes use of distances in the embedding space is potentially sensitive to the extent or scale of the embedding, we normalize the data before computing the Procrustes distance by dividing by the average norm of the embedded dataset. In Figure [7](#fig_9) we visualize the results of using Procrustes alignment of embedding of sub-samples for both  Given a measure of distance between di erent embeddings we can examine stability under sub-sampling by considering the normalized Procrustes distance between the embedding of a sub-sample, and the corresponding sub-sample of an embedding of the full dataset. As the size of the sub-sample increases the average distance per point between the subsampled embeddings should decrease, potentially toward some asymptote of maximal agreement under repeated runs. Ideally this asymptotic value would be zero error, but for stochastic embeddings such as UMAP and t-SNE this is not achievable.

We performed an empirical comparison of algorithms with respect to stability using the Flow Cytometry dataset due its large size, interesting structure, and low ambient dimensionality (aiding runtime performance for t-SNE). We note that for a dataset this large we found it necessary to increase the default n_iter value for t-SNE from 1000 to 1500 to ensure better convergence. While this had an impact on the runtime, it signi cantly improved the Procrustes distance results by providing more stable and consistent embeddings. Figure [8](#fig_0) provides a comparison between UMAP and t-SNE, demonstrating that UMAP has signifcantly more stable results than t-SNE. In particular, a er sub-sampling on 5% of the million data points, the per point error for UMAP was already below any value achieved by t-SNE.

## Computational Performance Comparisons

Benchmarks against the real world datasets were performed on a Macbook Pro with a 3.1 GHz Intel Core i7 and 8GB of RAM for Table [3](#), and on a server with Intel Xeon E5-2697v4 processors and 512GB of RAM for the large scale benchmarking in Subsections 5.4.1, 5.4.2, and 5.4.3.

For t-SNE we chose MulticoreTSNE [[57]](#b57), which we believe to be the fastest extant implementation of Barnes-Hut t-SNE at this time, even when run in single core mode. It should be noted that MulticoreTSNE is a heavily optimized implementation wri en in C++ based on Van der Maaten's bhtsne [[58]](#b58) code.

As a fast alternative approach to t-SNE we also consider the FIt-SNE algorithm [[37]](#b36). We used the reference implementation [[36]](#b35), which, like MulticoreTNSE is an optimized C++ implementation. We also note that FIt-SNE makes use of multiple cores.

LargeVis [[54]](#b53) was benchmarked using the reference implementation [[53]](#b52). It was run with default parameters including use of 8 threads on the 4core machine. e only exceptions were small datasets where we explicitly set the -samples parameter to n_samples/100 as per the recommended values in the documentation of the reference implementation.

e Isomap [[55]](#b54) and Laplacian Eigenmaps [[7]](#b6) implementations in scikitlearn [[10]](#b9) were used. We suspect the Laplacian eigenmaps implementation may not be well optimized for large datasets but did not nd a be er performing implementation that provided comparable quality results. Isomap failed to complete for the Shu le, Fashion-MNIST, MNIST and Google-News datasets, while Laplacian Eigenmaps failed to run for the Google-News dataset.

To allow a broader range of algorithms to run some of the datasets where subsampled or had their dimension reduced by PCA. e Flow Cytometry dataset was benchmarked on a 10% sample and the GoogleNews was subsampled down to 200,000 data points. Finally, the Mouse scRNA dataset was reduced to 1,000 dimensions via PCA.

Timing were performed for the COIL20 [[43]](#b42), COIL100 [[44]](#b43), Shu le [[35]](#b34), MNIST [[32]](#b31), Fashion-MNIST [[63]](#b63), and GoogleNews [[41]](#b40) datasets. Results can be seen in Table [3](#). UMAP consistently performs faster than any of the other algorithms aside from on the very small Pendigits dataset, where Laplacian Eigenmaps and Isomap have a small edge. UMAP FIt-SNE t-SNE LargeVis Eigenmaps Isomap Pen Digits 9s 48s 17s 20s 2s 2s (1797x64) COIL20 12s 75s 22s 82s 47s 58s (1440x16384) COIL100 85s 2681s 810s 3197s 3268s 3210s (7200x49152) scRNA 28s 131s 258s 377s 470s 923s (21086x1000) Shuttle 94s 108s 714s 615s 133s -(58000x9) MNIST 87s 292s 1450s 1298s 40709s -(70000x784) F-MNIST 65s 278s 934s 1173s 6356s -(70000x784) Flow 102s 164s 1135s 1127s 30654s -

Google News 361s 652s 16906s 5392s --

Table [3](#): Runtime of several dimension reduction algorithms on various datasets.

To allow a broader range of algorithms to run some of the datasets where subsampled or had their dimension reduced by PCA. e Flow Cytometry dataset was benchmarked on a 10% sample and the GoogleNews was subsampled down to 200,000 data points. Finally, the Mouse scRNA dataset was reduced to 1,000 dimensions via PCA. e fastest runtime for each dataset has been bolded.

## Scaling with Embedding Dimension

UMAP is signi cantly more performant than t-SNE[foot_4](#foot_4) when embedding into dimensions larger than 2. is is particularly important when the intention is to use the low dimensional representation for further machine learning tasks such as clustering or anomaly detection rather than merely for visualization. e computation performance of UMAP is far more e cient than t-SNE, even for very small embedding dimensions of 6 or 8 (see Figure [9](#)). is is largely due to the fact that UMAP does not require global normalisation (since it represents data as a fuzzy topological structure rather than as a probability distribution).

is allows the algorithm to work without the need for space trees -such as the quad-trees and oct-trees that t-SNE uses [[58]](#b58)-. Such space trees scale exponentially in dimension, resulting in t-SNE's relatively poor scaling with respect to embedding dimension. By contrast, we see that UMAP consistently scales well in embedding dimension, making the algorithm practical for a wider range of applications beyond visualization.

## Scaling with Ambient Dimension

rough a combination of the local-connectivity constraint and the approximate nearest neighbor search, UMAP can perform e ective dimension reduction even for very high dimensional data (see Figure [13](#fig_13) for an example of UMAP operating directly on 1.8 million dimensional data). is stands in contrast to many other manifold learning techniques, including t-SNE and LargeVis, for which it is generally recommended to reduce the dimension with PCA before applying these techniques (see [[59]](#b59) for example).

To compare runtime performance scaling with respect to the ambient dimension of the data we chose to use the Mouse scRNA dataset, which is high dimensional, but is also amenable to the use of PCA to reduce the dimension of the data as a pre-processing step without losing too much of the important structure [5](#foot_5) . We compare the performance of UMAP, FIt-SNE, MulticoreTSNE, and LargeVis on PCA reductions of the Mouse scRNA dataset to varying dimensionalities, and on the original dataset, in Figure [10](#fig_1).

While all the implementations tested show a signi cant increase in runtime with increasing dimension, UMAP is dramatically more e cient for (a) A comparison of run time for UMAP, t-SNE and LargeVis with respect to embedding dimension on the Pen digits dataset. We see that t-SNE scales worse than exponentially while UMAP and LargeVis scale linearly with a slope so slight to be undetectable at this scale.

(b) Detail of scaling for embedding dimension of six or less. We can see that UMAP and LargeVis are essentially at. In practice they appear to scale linearly, but the slope is essentially undetectable at this scale.

Figure [9](#): Scaling performance with respect to embedding dimension of UMAP, t-SNE and LargeVis on the Pen digits dataset.

Figure [10](#fig_1): Runtime performance scaling of UMAP, t-SNE, FIt-SNE and Largevis with respect to the ambient dimension of the data. As the ambient dimension increases beyond a few thousand dimensions the computational cost of t-SNE, FIt-SNE, and LargeVis all increase dramatically, while UMAP continues to perform well into the tens-of-thousands of dimensions. large ambient dimensions, easily scaling to run on the original unreduced dataset. e ability to run manifold learning on raw source data, rather than dimension reduced data that may have lost important manifold structure in the pre-processing, is a signi cant advantage. is advantage comes from the local connectivity assumption which ensures good topological representation of high dimensional data, particularly with smaller numbers of near neighbors, and the e ciency of the NN-Descent algorithm for approximate nearest neighbor search even in high dimensions.

Since UMAP scales well with ambient dimension the python implementation also supports input in sparse matrix format, allowing scaling to extremely high dimensional data, such as the integer data shown in Figures [13](#fig_13) and [14](#fig_14).

## Scaling with the Number of Samples

For dataset size performance comparisons we chose to compare UMAP with FIt-SNE [[37]](#b36), a version of t-SNE that uses approximate nearest neighbor search and a Fourier interpolation optimisation approach; MulticoreTSNE [[57]](#b57), which we believe to be the fastest extant implementation of Barnes-Hut t-SNE; and LargeVis [[54]](#b53). It should be noted that FIt-SNE, MulticoreT-SNE, and LargeVis are all heavily optimized implementations wri en in C++. In contrast our UMAP implementation was wri en in Python -making use of the numba [[31]](#b30) library for performance. MulticoreTSNE and LargeVis were run in single threaded mode to make fair comparisons to our single threaded UMAP implementation.

We benchmarked all four implementations using subsamples of the Google-News dataset. e results can be seen in Figure [11](#fig_11). is demonstrates that UMAP has superior scaling performance in comparison to Barnes-Hut t-SNE, even when Barnes-Hut t-SNE is given multiple cores. Asymptotic scaling of UMAP is comparable to that of FIt-SNE (and LargeVis). On this dataset UMAP demonstrated somewhat faster absolute performance compared to FIt-SNE, and was dramatically faster than LargeVis.

e UMAP embedding of the full GoogleNews dataset of 3 million word vectors, as seen in Figure [12](#fig_12), was completed in around 200 minutes, as compared with several days required for MulticoreTSNE, even using multiple cores.

To scale even further we were inspired by the work of John Williamson on embedding integers [[61]](#b61), as represented by (sparse) binary vectors of their prime divisibility. is allows the generation of arbitrarily large, extremely high dimension datasets that still have meaningful structure to be  explored. In Figures [13](#fig_13) and [14](#fig_14) we show an embedding of 30,000,000 data samples from an ambient space of approximately 1.8 million dimensions.

is computation took approximately 2 weeks on a large memory SMP. Note that despite the high ambient dimension, and vast amount of data, UMAP is still able to nd and display interesting structure. In Figure [15](#fig_16) we show local regions of the embedding, demonstrating the ne detail structure that was captured.

## Weaknesses

While we believe UMAP to be a very e ective algorithm for both visualization and dimension reduction, most algorithms must make trade-o s and UMAP is no exception. In this section we will brie y discuss those areas or use cases where UMAP is less e ective, and suggest potential alternatives.

For a number of use cases the interpretability of the reduced dimension results is of critical importance. Similarly to most non-linear dimension reduction techniques (including t-SNE and Isomap), UMAP lacks the strong interpretability of Principal Component Analysis (PCA) and related techniques such a Non-Negative Matrix Factorization (NMF). In particular the dimensions of the UMAP embedding space have no speci c meaning, unlike PCA where the dimensions are the directions of greatest variance in the source data. Furthermore, since UMAP is based on the distance between observations rather than the source features, it does not have an equivalent of factor loadings that linear techniques such as PCA, or Factor Analysis can provide. If strong interpretability is critical we therefore recommend linear techniques such as PCA, NMF or pLSA.

One of the core assumptions of UMAP is that there exists manifold structure in the data. Because of this UMAP can tend to nd manifold structure within the noise of a dataset -similar to the way the human mind nds structured constellations among the stars. As more data is sampled the amount of structure evident from noise will tend to decrease and UMAP becomes more robust, however care must be taken with small sample sizes of noisy data, or data with only large scale manifold structure. Detecting when a spurious embedding has occurred is a topic of further research.

UMAP is derived from the axiom that local distance is of more importance than long range distances (similar to techniques like t-SNE and LargeVis). UMAP therefore concerns itself primarily with accurately representing local structure. While we believe that UMAP can capture more global structure than these other techniques, it remains true that if global    structure is of primary interest then UMAP may not be the best choice for dimension reduction. Multi-dimensional scaling speci cally seeks to preserve the full distance matrix of the data, and as such is a good candidate when all scales of structure are of equal importance. PHATE [[42]](#b41) is a good example of a hybrid approach that begins with local structure information and makes use of MDS to a empt to preserve long scale distances as well. It should be noted that these techniques are more computationally intensive and thus rely on landmarking approaches for scalability.

It should also be noted that a signi cant contributor to UMAP's relative global structure preservation is derived from the Laplacian Eigenmaps initialization (which, in turn, followed from the theoretical foundations). is was noted in, for example, [[29]](#b28).

e authors of that paper demonstrate that t-SNE, with similar initialization, can perform equivalently to UMAP in a particular measure of global structure preservation. However, the objective function derived for UMAP (cross-entropy) is signi cantly di erent from that of t-SNE (KL-divergence), in how it penalizes failures to preserve non-local and global structure, and is also a signi cant contributor [6](#foot_6) .

It is worth noting that, in combining the local simplicial set structures, pure nearest neighbor structure in the high dimensional space is not explicitly preserved. In particular it introduces so called "reverse-nearestneighbors" into the classical knn-graph. is, combined with the fact that UMAP is preserving topology rather than pure metric structures, mean that UMAP will not perform as well as some methods on quality measures based on metric structure preservation -particularly methods, such as MDSwhich are explicitly designed to optimize metric structure preservation.

UMAP a empts to discover a manifold on which your data is uniformly distributed. If you have strong con dence in the ambient distances of your data you should make use of a technique that explicitly a empts to preserve these distances. For example if your data consisted of a very loose structure in one area of your ambient space and a very dense structure in another region region UMAP would a empt to put these local areas on an even footing.

Finally, to improve the computational e ciency of the algorithm a number of approximations are made.

is can have an impact on the results of UMAP for small (less than 500 samples) dataset sizes. In particular the use of approximate nearest neighbor algorithms, and the negative sampling used in optimization, can result in suboptimal embeddings. For this reason we encourage users to take care with particularly small datasets. A slower but exact implementation of UMAP for small datasets is a future project.

## Future Work

Having established both relevant mathematical theory and a concrete implementation, there still remains signi cant scope for future developments of UMAP.

A comprehensive empirical study which examines the impact of the various algorithmic components, choices, and hyper-parameters of the algorithm would be bene cial. While the structure and choices of the algorithm presented were derived from our foundational mathematical framework, examining the impacts that these choices have on practical results would be enlightening and a signi cant contribution to the literature.

As noted in the weaknesses section there is a great deal of uncertainty surrounding the preservation of global structure among the eld of manifold learning algorithms. In particular this is hampered by the lack clear objective measures, or even de nitions, of global structure preservation. While some metrics exist, they are not comprehensive, and are o en speci c to various downstream tasks. A systematic study of both metrics of non-local and global structure preservation, and performance of various manifold learning algorithms with respect to them, would be of great bene t. We believe this would aid in be er understanding UMAP's success in various downstream tasks.

Making use of the fuzzy simplicial set representation of data UMAP can potentially be extended to support (semi-)supervised dimension reduction, and dimension reduction for datasets with heterogeneous data types. Each data type (or prediction variables in the supervised case) can be seen as an alternative view of the underlying structure, each with a di erent associated metric -for example categorical data may use Jaccard or Dice distance, while ordinal data might use Manha an distance. Each view and metric can be used to independently generate fuzzy simplicial sets, which can then be intersected together to create a single fuzzy simplicial set for embedding. Extending UMAP to work with mixed data types would vastly increase the range of datasets to which it can be applied. Use cases for (semi-)supervised dimension reduction include semi-supervised clustering, and interactive labelling tools. e computational framework established for UMAP allows for the potential development of techniques to add new unseen data points into an existing embedding, and to generate high dimensional representations of arbitrary points in the embedded space. Furthermore, the combination of supervision and the addition of new samples to an existing embedding provides avenues for metric learning. e addition of new samples to an existing embedding would allow UMAP to be used as a feature engineering tool as part of a general machine learning pipeline for either clustering or classi cation tasks. Pulling points back to the original high dimensional space from the embedded space would potentially allow UMAP to be used as a generative model similar to some use cases for autoencoders. Finally, there are many use cases for metric learning; see [[64]](#b64) or [[8]](#b7) for example.

ere also remains signi cant scope to develop techniques to both detect and mitigate against potentially spurious embeddings, particularly for small data cases. e addition of such techniques would make UMAP far more robust as a tool for exploratory data analysis, a common use case when reducing to two dimensions for visualization purposes.

Experimental versions of some of this work are already available in the referenced implementations.

## Conclusions

We have developed a general purpose dimension reduction technique that is grounded in strong mathematical foundations.

e algorithm implementing this technique is demonstrably faster than t-SNE and provides be er scaling. is allows us to generate high quality embeddings of larger data sets than had previously been a ainable.

e use and e ectiveness of UMAP in various scienti c elds demonstrates the strength of the algorithm.

A Proof of Lemma 1 Lemma 1. Let (M, g) be a Riemannian manifold in an ambient R n , and let p ∈ M be a point. If g is locally constant about p in an open neighbourhood U such that g is a constant diagonal matrix in ambient coordinates, then in a ball B ⊆ U centered at p with volume π n/2 Γ(n/2+1) with respect to g, the geodesic distance from p to any point q ∈ B is 1 r d R n (p, q), where r is the radius of the ball in the ambient space and d R n is the existing metric on the ambient space.

Proof. Let x 1 , . . . , x n be the coordinate system for the ambient space. A ball B in M under Riemannian metric g has volume given by

$B det(g)dx 1 ∧ • • • ∧ dx n .$If B is contained in U , then g is constant in B and hence det(g) is constant and can be brought outside the integral. us, the volume of B is

$det(g) B dx 1 ∧ ... ∧ dx n = det(g) π n/2 r n Γ(n/2 + 1)$,

where r is the radius of the ball in the ambient R n . If we x the volume of the ball to be π n/2 Γ(n/2+1) we arrive at the requirement that

$det(g) = 1 r 2n .$Now, since g is assumed to be diagonal with constant entries we can solve for g itself as

$g ij =    1 r 2 if i = j, 0 otherwise .(2)$e geodesic distance on M under g from p to q (where p, q ∈ B) is de ned as inf

$c∈C b a g( ċ(t), ċ(t))dt,$where C is the class of smooth curves c on M such that c(a) = p and c(b) = q, and ċ denotes the rst derivative of c on M. Given that g is as de ned in [(2)](#b1) we see that this can be simpli ed to

$1 r inf c∈C b a ċ(t), ċ(t) dt = 1 r inf c∈C b a ċ(t), ċ(t) dt = 1 r d R n (p, q).(3)$e rst isomorphism follows from the Yoneda lemma, the equality is by construction, and the nal isomorphism follows by another application of the Yoneda lemma. Since every simplicial set can be canonically expressed as a colimit of standard simplices and FinReal commutes with colimits (as it was de ned via a colimit formula), it follows that FinReal is completely determined by its image on standard simplices. As a result the isomorphism of equation ( [4](#)) extends to the required isomorphism demonstrating the adjunction.

## C From t-SNE to UMAP

As an aid to implementation of UMAP and to illuminate the algorithmic similarities with t-SNE and LargeVis, here we review the main equations used in those methods, and then present the equivalent UMAP expressions in a notation which may be more familiar to users of those other methods.

In what follows we are concerned with de ning similarities between two objects i and j in the high dimensional input space X and low dimensional embedded space Y . ese are normalized and symmetrized in various ways. In a typical implementation, these pair-wise quantities are stored and manipulated as (potentially sparse) matrices.

antities with the subscript ij are symmetric, i.e. v ij = v ji . Extending the conditional probability notation used in t-SNE, j | i indicates an asymmetric similarity, i.e. v j|i = v i|j .

t-SNE de nes input probabilities in three stages. First, for each pair of points, i and j, in X, a pair-wise similarity, v ij , is calculated, Gaussian with respect to the Euclidean distance between x i and x j :

$v j|i = exp(-x i -x j 2 2 /2σ 2 i )(5)$where σ 2 i is the variance of the Gaussian. Second, the similarities are converted into N conditional probability distributions by normalization:

$p j|i = v j|i k =i v k|i(6)$σ i is chosen by searching for a value such that the perplexity of the probability distribution p •|i matches a user-speci ed value. ird, these probability distributions are symmetrized and then further normalized over the entire matrix of values to give a joint probability distribution:

$p ij = p j|i + p i|j 2N(7)$We note that this is a heuristic de nition and not in accordance with standard relationship between conditional and joint probabilities that would be expected under probability semantics usually used to describe t-SNE. Similarities between pairs of points in the output space Y are de ned using a Student t-distribution with one degree of freedom on the squared Euclidean distance:

$w ij = 1 + y i -y j 2 2$-1 [(8)](#b7) followed by the matrix-wise normalization, to form q ij :

$q ij = w ij k =l w kl(9)$e t-SNE cost is the Kullback-Leibler divergence between the two probability distributions:

$C t-SN E = i =j p ij log p ij q ij(10)$this can be expanded into constant and non-constant contributions:

$C t-SN E = i =j p ij log p ij -p ij log q ij(11)$Because both p ij and q ij require calculations over all pairs of points, improving the e ciency of t-SNE algorithms has involved separate strategies for approximating these quantities. Similarities in the high dimensions are e ectively zero outside of the nearest neighbors of each point due to the calibration of the p j|i values to reproduce a desired perplexity. erefore an approximation used in Barnes-Hut t-SNE is to only calculate v j|i for n nearest neighbors of i, where n is a multiple of the user-selected perplexity and to assume v j|i = 0 for all other j. Because the low dimensional coordinates change with each iteration, a di erent approach is used to approximate q ij . In Barnes-Hut t-SNE and related methods this usually involves grouping together points whose contributions can be approximated as a single point.

A further heuristic algorithm optimization technique employed by t-SNE implementations is the use of early exaggeration where, for some number of initial iterations, the p ij are multiplied by some constant greater than 1.0 (usually 12.0). In theoretical analyses of t-SNE such as [[38]](#b37) results are obtained only under an early exaggeration regimen with either large constant (of order of the number of samples), or in the limit of in nite exaggeration. Further papers such as [[37]](#b36), and [[28]](#b27), suggest the option of using exaggeration for all iterations rather than just early ones, and demonstrate the utility of this. e e ectiveness of these analyses and practical approaches suggests that KL-divergence as a measure between probability distributions is not what makes the t-SNE algorithm work, since, under exaggeration, the p ij are manifestly not a probability distribution.

is is another example of the probability semantics used to describe t-SNE are primarily descriptive rather than foundational. None the less, t-SNE is highly e ective and clearly produces useful results on a very wide variety of tasks.

LargeVis uses a similar approach to Barnes-Hut t-SNE when approximating p ij , but further improves e ciency by only requiring approximate nearest neighbors for each point. For the low dimensional coordinates, it abandons normalization of w ij entirely. Rather than use the Kullback-Leibler divergence, it optimizes a likelihood function, and hence is maximized, not minimized:

$C LV = i =j p ij log w ij + γ i =j log (1 -w ij )(12)$p ij and w ij are de ned as in Barnes-Hut t-SNE (apart from the use of approximate nearest neighbors for p ij , and the fact that, in implementation, LargeVis does not normalize the p ij by N ) and γ is a user-chosen positive constant which weights the strength of the the repulsive contributions (second term) relative to the a ractive contribution ( rst term). Note also that the rst term resembles the optimizable part of the Kullback-Leibler divergence but using w ij instead of q ij . Abandoning calculation of q ij is a crucial change, because the LargeVis cost function is amenable to optimization via stochastic gradient descent.

Ignoring speci c de nitions of v ij and w ij , the UMAP cost function, the cross entropy, is:

$C U M AP = i =j v ij log v ij w ij + (1 -v ij ) log 1 -v ij 1 -w ij(13)$Like the Kullback-Leibler divergence, this can be arranged into two constant contributions (those containing v ij only) and two optimizable contributions (containing w ij ):

$C U M AP = i =j v ij log v ij + (1 -v ij ) log (1 -v ij ) -v ij log w ij -(1 -v ij ) log (1 -w ij )(14)$Ignoring the two constant terms, the UMAP cost function has a very similar form to that of LargeVis, but without a γ term to weight the repulsive component of the cost function, and without requiring matrix-wise normalization in the high dimensional space. e cost function for UMAP can therefore be optimized (in this case, minimized) with stochastic gradient descent in the same way as LargeVis.

Although the above discussion places UMAP in the same family of methods as t-SNE and LargeVis, it does not use the same de nitions for v ij and w ij . Using the notation established above, we now provide the equivalent expressions for the UMAP similarities. In the high dimensional space, the similarities v j|i are the local fuzzy simplicial set memberships, based on the smooth nearest neighbors distances:

$v j|i = exp[(-d (x i , x j ) -ρ i )/σ i ](15)$As with LargeVis, v j|i is calculated only for n approximate nearest neighbors and v j|i = 0 for all other j. d (x i , x j ) is the distance between x i and x j , which UMAP does not require to be Euclidean. ρ i is the distance to the nearest neighbor of i. σ i is the normalizing factor, which is chosen by Algorithm 3 and plays a similar role to the perplexity-based calibration of σ i in t-SNE. Calculation of v j|i with Equation 15 corresponds to Algorithm 2.

Symmetrization is carried out by fuzzy set union using the probabilistic t-conorm and can be expressed as:

$v ij = v j|i + v i|j -v j|i v i|j(16)$Equation 16 corresponds to forming top-rep in Algorithm 1. Unlike t-SNE, further normalization is not carried out. e low dimensional similarities are given by: 

$w ij = 1 + a y i -y j 2b 2 -1(17)$![De ne the functor FinSing : FinEPMet → Fin-sFuzz by FinSing(Y ) : ([n], [0, a)) → hom FinEPMet (FinReal(∆ n <a ), Y ).]()

![e functors FinReal : Fin-sFuzz → FinEPMet and FinSing : FinEPMet → Fin-sFuzz form an adjunction with FinReal the le adjoint and FinSing the right adjoint.]()

![Compute the normalizing factor for distances σ function S KNND (knn-dists, n, ρ) Binary search for σ such that n i=1 exp(-(knn-dists i -ρ)/σ) = log 2 (n) return σ Spectral embedding for initialization function S E (top-rep, d) A ← 1-skeleton of top-rep expressed as a weighted adjacency matrix D ← degree matrix for the graph A L ← D 1/2 (D -A)D 1/2 evec ← Eigenvectors of L (sorted) Y ← evec[1..d + 1] # 0-base indexing assumed return Y fuzzy set cross entropy, with respect given membership functions µ and ν, is given by C((A, µ), (A, ν)) = a∈A µ(a) log µ(a) ν(a) + (1 -µ(a)) log 1 -µ(a) 1 -ν(a) = a∈A (µ(a) log(µ(a)) + (1 -µ(a)) log(1 -µ(a))) -a∈A (µ(a) log(ν(a)) + (1 -µ(a)) log(1 -ν(a))) .]()

![Optimizing the embeddingfunction O E (top-rep, Y , min-dist, n-epochs) α ← 1.0 Fit Φ from Ψ de ned by min-dist for e ← 1, . . . , n-epochs do for all ([a, b], p) ∈ top-rep 1 do if R ( ) ≤ p then # Sample simplex with probability p y a ← y a + α • ∇(log(Φ))(y a , y b ) for i ← 1, . . . , n-neg-samples do c ← random sample from Y y a ← y a + α • ∇(log(1 -Φ))(y a , y c ) α ← 1.0 -e/n-epochs return Yis completes the UMAP algorithm.]()

![Figure 2: Variation of UMAP hyperparameters n and min-dist result in di erent embeddings.e data is the PenDigits dataset, where each point is an 8x8 grayscale image of a hand-wri en digit.]()

![Figure 3: Variation of UMAP hyperparameters n and min-dist result in di erent embeddings.e data is the MNIST dataset, where each point is an 28x28 grayscale image of a hand-wri en digit.]()

![Figure 4: A comparison of several dimension reduction algorithms. We note that UMAP successfully re ects much of the large scale global structure that is well represented by Laplacian Eigenmaps and PCA (particularly for MNIST and Fashion-MNIST), while also preserving the local ne structure similar to t-SNE and LargeVis. 29]()

![Figure 5: kNN Classi er accuracy for varying values of k over the embedding spaces of COIL-20 and PenDigits datasets. Accuracy scores are given for each fold of a 10-fold cross-validation for each of PCA, Laplacian Eigenmaps, LargeVis, t-SNE and UMAP. We note that UMAP produces competitive accuracy scores to t-SNE and LargeVis for most cases, and outperforms both t-SNE and LargeVis for larger k values on COIL-20.]()

![Figure 6: kNN Classi er accuracy for varying values of k over the embedding spaces of Shu le, MNIST and Fashion-MNIST datasets. Accuracy scores aregiven for each fold of a 10-fold cross-validation for Shu le, and 20-fold crossvalidation for MNIST and Fashion-MNIST, for each of PCA, Laplacian Eigenmaps, LargeVis, t-SNE and UMAP. UMAP performs be er than the other algorithms for large k, particularly on the Shu le dataset. For Fashion-MNIST UMAP provides slightly poorer accuracy than t-SNE and LargeVis at small scales, but is competitive at larger k values.]()

![Figure 7: Procrustes based alignment of a 10% subsample (red) against the full dataset (blue) for the ow cytometry dataset for both UMAP and t-SNE.]()

![Figure 8: Comparison of average Procustes distance per point for t-SNE, LargeVis and UMAP over a variety of sizes of subsamples from the full Flow Cytometry dataset. UMAP sub-sample embeddings are very close to the full embedding even for subsamples of 5% of the full dataset, outperforming the results of t-SNE and LargeVis even when they use the full Flow Cytometry dataset.]()

![Figure 11: Runtime performance scaling of t-SNE and UMAP on various sized sub-samples of the full Google News dataset.e lower t-SNE line is the wall clock runtime for Multicore t-SNE using 8 cores.]()

![Figure 12: Visualization of the full 3 million word vectors from the GoogleNews dataset as embedded by UMAP.]()

![Figure 13: Visualization of 30,000,000 integers as represented by binary vectors of prime divisibility, colored by density of points.]()

![Figure 14: Visualization of 30,000,000 integers as represented by binary vectors of prime divisibility, colored by integer value of the point (larger values are green or yellow, smaller values are blue or purple).]()

![(a) Upper right spiral (b) Lower right spiral and starbursts (c) Central cloud]()

![Figure 15: Zooming in on various regions of the integer embedding reveals further layers of ne structure have been preserved.]()

![user-de ned positive values. e procedure for nding them is given in De nition 11. Use of this procedure with the default values in the UMAP implementation results in a ≈ 1.929 and b ≈ 0.7915. Se ing a = 1 and b = 1 results in the Student t-distribution used in t-SNE.]()

![]()

![]()

![ure 6 provides swarm plots of the accuracy results across the Shu le and MNIST and Fashion-MNIST datasets.]()

e topological theory of Section 2 is driven by these axioms, particularly the interest in modelling and preserving topological structure. In particular Section 2.1 highlights the underlying motivation, in terms of topological theory, of representing a manifold as a k-neighbour graph.

See the discussion of the constellation e ect in Section 6

See Section 5 for a description of the PenDigits dataset

See section 5 for details on the MNIST dataset

Comparisons were performed against MulticoreTSNE as the current implementation of FIt-SNE does not support embedding into any dimension larger than 2.

In contrast to COIL100, on which PCA destroys much of the manifold structure

e authors would like to thank Nikolay Oskolkov for his article (tSNE vs. UMAP: Global Structure) which does an excellent job of highlighting these aspects from an empirical and theoretical basis.

