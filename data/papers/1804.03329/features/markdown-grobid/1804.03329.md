# Representation Tradeoffs for Hyperbolic Embeddings

## Abstract

## 

Hyperbolic embeddings offer excellent quality with few dimensions when embedding hierarchical data structures like synonym or type hierarchies. Given a tree, we give a combinatorial construction that embeds the tree in hyperbolic space with arbitrarily low distortion without using optimization. On WordNet, our combinatorial embedding obtains a mean-average-precision of 0.989 with only two dimensions, while Nickel et al.'s recent construction obtains 0.87 using 200 dimensions. We provide upper and lower bounds that allow us to characterize the precision-dimensionality tradeoff inherent in any hyperbolic embedding. To embed general metric spaces, we propose a hyperbolic generalization of multidimensional scaling (h-MDS). We show how to perform exact recovery of hyperbolic points from distances, provide a perturbation analysis, and give a recovery result that allows us to reduce dimensionality. The h-MDS approach offers consistently low distortion even with few dimensions across several datasets. Finally, we extract lessons from the algorithms and theory above to design a PyTorch-based implementation that can handle incomplete information and is scalable.

## Introduction

Recently, hyperbolic embeddings have been proposed as a way to capture hierarchy information for use in link prediction and natural language processing tasks [[5,](#b4)[28]](#b27). These approaches are an exciting new way to fuse rich structural information (for example, from knowledge graphs or synonym hierarchies) with the continuous representations favored by modern machine learning.

To understand the intuition behind hyperbolic embeddings' superior capacity, note that trees can be embedded with arbitrarily low distortion into the Poincaré disk, a model of hyperbolic space with only two dimensions [[32]](#b31). In contrast, Bourgain's theorem [[27]](#b26) shows that Euclidean space is unable to obtain comparably low distortion for trees-even using an unbounded number of dimensions. Moreover, hyperbolic space can preserve certain properties; for example, angles between embedded vectors are the same in both Euclidean space and the Poincaré model (the mapping is conformal), which suggests embedded data may be easily able to integrate with downstream tasks.

Many graphs, such as complex networks [[24]](#b23), including the Internet [[23]](#b22) and social networks [[36]](#b35)) are known to have hyperbolic structure and thus befit hyperbolic embeddings. Recent works show that hyperbolic representations are indeed suitable for many hierarchies (e.g, the question answering system HyperQA proposed in [[35]](#b34), vertex classifiers in [[5]](#b4), and link prediction [[28]](#b27)). However, the optimization problem underlying these embeddings is challenging, and we seek to understand the subtle tradeoffs involved.

We begin by considering the situation in which we are given an input graph that is a tree or nearly tree-like, and our goal is to produce a low-dimensional hyperbolic embedding that preserves all distances. This leads to a simple strategy that is combinatorial in that it does not minimize a surrogate loss function using gradient descent. It is both fast (nearly linear time) and has formal quality guarantees. The approach proceeds in two phases: [(1)](#b0) we produce an embedding of a graph into a weighted tree, and (2) we embed that tree into the hyperbolic disk. In particular, we consider an extension of an elegant embedding of trees into the Poincaré disk by Sarkar [[32]](#b31) and recent work on low-distortion graph embeddings into tree metrics [[18]](#b17). For trees, this approach has nearly perfect quality. On the WordNet hypernym graph reconstruction, this obtains nearly perfect mean average precision (MAP) 0.989 using just two dimensions, which outperforms the best published numbers in Nickel and Kiela [[28]](#b27) by almost 0.12 points with 200 dimensions.

We analyze this construction to extract fundamental tradeoffs. One tradeoff involves the dimension, the properties of the graph, and the number of bits of precision -an important hidden cost. For example, on the WordNet graph, we require almost 500 bits of precision to store values from the combinatorial embedding. We can reduce this number to 32 bits, but at the cost of using 10 dimensions instead of two. We show that for a fixed precision, the dimension required scales linearly with the length of the longest path. On the other hand, the dimension scales logarithmically with the maximum degree of the tree. This suggests that hyperbolic embeddings should have high quality on hierarchies like WordNet but require large dimensions or high precision on graphs with long chains-which is supported by our experiments. A second observation is that in contrast to Euclidean embeddings, hyperbolic embeddings are not scale invariant. This motivates us to add a learnable scale term into a stochastic gradient descent-based Pytorch algorithm described below, and we show that it allows us to empirically improve the quality of embeddings.

To understand how hyperbolic embeddings perform for metrics that are far from tree-like, we consider a more general problem: given a matrix of distances that arise from points that are embeddable in hyperbolic space of dimension d (not necessarily from a graph), find a set of points that produces these distances. In Euclidean space, the problem is known as multidimensional scaling (MDS) which is solvable using PCA. [1](#foot_0) A key step is a transformation that effectively centers the points-without knowledge of their exact coordinates. It is not obvious how to center points in hyperbolic space, which is curved. We show that in hyperbolic space, a centering operation is still possible with respect to a non-standard mean. In turn, this allows us to reduce the hyperbolic MDS problem (h-MDS) to a standard eigenvalue problem, and so it can be solved with scalable power methods. Further, we extend classical perturbation analysis [[33,](#b32)[34]](#b33). When applied to distances from real data, h-MDS obtains low distortion on graphs that are far from tree like. However, we observe that these solutions may require high precision, which is not surprising in light of our previous analysis.

Finally, we consider handling increasing amounts of noise in the model, which leads naturally into new SGD-based formulations. In traditional PCA, one may discard eigenvectors that have correspondingly small eigenvalues to cope with noise. In hyperbolic space, this approach may produce suboptimal results. Like PCA, the underlying problem is nonconvex. In contrast to PCA, the optimization problem is more challenging: the underlying problem has local minima that are not global minima. Our main technical result is that an SGD-based algorithm initialized with a h-MDS solution can recover the submanifold the data is on-even in some cases in which the data is perturbed by noise that can be full dimensional. Our algorithm essentially provides new recovery results for convergence for Principal Geodesic Analysis (PGA) in hyperbolic space [[12,](#b11)[17]](#b16). We discuss the nuances between our optimization algorithms and previous attempts at these problems in Appendix B.

All of our results can handle incomplete distance information through standard techniques. Using the observations above, we implemented an SGD algorithm that minimizes the loss derived from the PGA loss using PyTorch. [2](#foot_1)

## Background

We provide intuition connecting hyperbolic space and tree distances, discuss the metrics used to measure embedding fidelity, and provide the relationship between reconstruction and learning for graph embeddings.

## Hyperbolic spaces

The Poincaré disk H 2 is a two-dimensional model of hyperbolic geometry with points located in the interior of the unit disk, as shown in Figure [1](#fig_1). A natural generalization of H 2 is the Poincaré ball H r , with elements inside the unit ball. The Poincaré models offer several useful properties, chief among which is mapping conformally to Euclidean space. That is, angles are preserved between hyperbolic and Euclidean space. Distances, on the other hand,  are not preserved, but are given by

$d H (x, y) = acosh 1 + 2 x -y 2 (1 -x 2 )(1 -y 2 )$.

There are some potentially unexpected consequences of this formula, and a simple example gives intuition about a key technical property that allows hyperbolic space to embed trees. Consider three points: the origin 0, and points x and y with x = y = t for some t > 0. As shown on the right of Figure [1](#fig_1), as t → 1 (i.e., the points move towards the outside of the disk), in flat Euclidean space, the ratio

$d E (x,y) d E (x,0$)+d E (0,y) is constant with respect to t (blue curve). In contrast, the ratio

$d H (x,y) d H (x,0$)+d H (0,y) approaches 1, or, equivalently, the distance d H (x, y) approaches d H (x, 0) + d H (0, y) (red and pink curves). That is, the shortest path between x and y is almost the same as the path through the origin. This is analogous to the property of trees in which the shortest path between two sibling nodes is the path through their parent. This tree-like nature of hyperbolic space is the key property exploited by embeddings. Moreover, this property holds for arbitrarily small angles between x and y.

Lines and geodesics There are two types of geodesics (shortest paths) in the Poincaré disk model of hyperbolic space: segments of circles that are orthogonal to the disk surface, and disk diameters [[3]](#b2). Our algorithms and proofs make use of a simple geometric fact: isometric reflection across geodesics (preserving hyperbolic distances) is represented in this Euclidean model as a circle inversion. A particularly important reflection associated with each point x is the one that takes x to the origin [[3, p. 268](#)].

## Embeddings and fidelity measures An embedding is a mapping

$f : U → V for spaces U, V with distances d U , d V .$We measure the quality of embeddings with several fidelity measures, presented here from most local to most global.

Recent work [[28]](#b27) proposes using the mean average precision (MAP). For a graph

$G = (V, E), let a ∈ V have neighborhood N a = {b 1 , b 2 , . . . , b deg(a) },$where deg(a) denotes the degree of a. In the embedding f , consider the points closest to f (a), and define R a,bi to be the smallest set of such points that contains b i (that is, R a,bi is the smallest set of nearest points required to retrieve the ith neighbor of a in f ). Then, the MAP is defined to be

$MAP(f ) = 1 |V | a∈V 1 |N a | |Na| i=1 Precision(R a,bi ) = 1 |V | a∈V 1 deg(a) |Na| i=1 |N a ∩ R a,bi | |R a,bi | .$We have MAP(f ) ≤ 1, with equality as the best case. Note that MAP is not concerned with the underlying distances at all, but only the ranks between the distances of immediate neighbors. It is a local metric.

The standard metric for graph embeddings is distortion D. For an n point embedding,

$D(f ) = 1 n 2   u,v∈U :u =v |d V (f (u), f (v)) -d U (u, v)| d U (u, v)   .$The best distortion is D(f ) = 0, preserving the edge lengths exactly. This is a global metric, as it depends directly on the underlying distances rather than the local relationships between distances. A variant of this, the worst-case distortion D wc , is the metric defined by

$D wc (f ) = max u,v∈U :u =v d V (f (u), f (v))/d U (u, v) min u,v∈U :u =v d V (f (u), f (v))/d U (u, v) .$That is, the wost-case distortion is the ratio of the maximal expansion and the minimal contraction of distances. Note that scaling the unit distance does not affect D wc . The best worst-case distortion is D wc (f ) = 1.

The intended application of the embedding informs the choice of metric. For applications where the underlying distances are important, distortion is useful. On the other hand, if only rankings matter, MAP may suffice. This choice is important: as we shall see, different embedding algorithms implicitly target different metrics.

## Reconstruction and learning

In the case where we lack a full set of distances, we can deal with the missing data in one of two ways. First, we can use the triangle inequality to recover the missing distances. Second, we can access the scaled Euclidean distances (the inside of the acosh in d H (x, y)), and then the resulting matrix can be recovered with standard matrix completion techniques [[4]](#b3). Afterwards, we can proceed to compute an embedding using any of the approaches discussed in this paper. We quantify the error introduced by this process experimentally in Section 5.

## Combinatorial Constructions

We first focus on hyperbolic tree embeddings-a natural approach considering the tree-like behavior of hyperbolic space. We review the embedding of Sarkar [[32]](#b31) to higher dimensions. We then provide novel analysis about the precision of the embeddings that reveals fundamental limits of hyperbolic embeddings. In particular, we characterize the bits of precision needed for hyperbolic representations. We then extend the construction to r dimensions, and we propose to use Steiner nodes to better embed general graphs as trees building on a condition from I. Abraham et al. [[18]](#b17).

## Embedding trees

The nature of hyperbolic space lends itself towards excellent tree embeddings. In fact, it is possible to embed trees into the Poincaré disk H 2 with arbitrarily low distortion [[32]](#b31). Remarkably, trees cannot be embedded into Euclidean space with arbitrarily low distortion for any number of dimensions. These notions motivate the following two-step process for embedding hierarchies into hyperbolic space.

1. Embed the graph G = (V, E) into a tree T , 2. Embed T into the Poincaré ball H d .

We refer to this process as the combinatorial construction. Note that we are not required to minimize a loss function. We begin by describing the second stage, where we extend an elegant construction from Sarkar [[32]](#b31). First, f (a) and f (b) are reflected across a geodesic (using circle inversion) so that f (a) is mapped onto the origin 0 and f (b) is mapped onto some point z. Next, we place the children nodes to vectors y 1 , . . . , y d-1 equally spaced around a circle with radius e τ -1 e τ +1 (which is a circle of radius τ in the hyperbolic metric), and maximally separated from the reflected parent node embedding z. Lastly, we reflect all of the points back across the geodesic. Note that the isometric properties of reflections imply that all children are now at hyperbolic distance exactly τ from f (a). To embed the entire tree, we place the root at the origin O and its children in a circle around it (as in Step 5 of Algorithm 1), then recursively place their children until all nodes have been placed. Notice this construction runs in linear time.

## Sarkar's Construction

## Analyzing Sarkar's Construction

The Voronoi cell around a node a ∈ T consists of points

$x ∈ H 2 such that d H (f (a), x) ≤ d H (f (b), x) for all b ∈ T distinct from a.$That is, the cell around a includes all points closer to f (a) than to any other embedded node of the tree. Sarkar's construction produces Delauney embeddings: embeddings where the Voronoi cells for points a and b touch only if a and b are neighbors in T . Thus this embedding will preserve neighborhoods.

A key technical idea exploited by Sarkar [[32]](#b31) is to scale all the edges by a factor τ before embedding. We can then recover the original distances by dividing by τ . This transformation exploits the fact that hyperbolic space is not scale invariant. Sarkar's construction always captures neighbors perfectly, but Figure [1](#fig_1) implies that increasing the scale preserves the distances between farther nodes better. Indeed, if one sets

$τ = 1+ε ε 2 log deg max π/2$, then the worst-case distortion D of the resulting embedding is no more than 1 + ε. For trees, Sarkar's construction has arbitrarily high fidelity. However, this comes at a cost: the scaling τ affects the bits of precision required. In fact, we will show that the precision scales logarithmically with the degree of the tree-but linearly with the maximum path length. We use this to better understand the situations in which hyperbolic embeddings obtain high quality.

How many bits of precision do we need to represent points in H 2 ? If x ∈ H 2 , then x < 1, so we need sufficiently many bits so that 1 -x will not be rounded to zero. This requires roughly -log(1 -x ) = log 1  1-x bits. Say we are embedding two points x, y at distance d. As described in the background, there is an isometric reflection that takes a pair of points (x, y) in H 2 to (0, z) while preserving their distance, so without loss of generality we have that

$d = d H (x, y) = d H (0, z) = acosh 1 + 2 z 2 1 -z 2 .$Rearranging the terms, we have

$cosh(d) + 1 2 = 1 1 -z 2 ≥ 1/2 1 -z .$Thus, the number of bits we want so that 1 -z will not be rounded to zero is log(cosh(d) + 1). Since cosh(d) = (exp(d) + exp(-d))/2, this is roughly d bits. That is, in hyperbolic space, we need about d bits to express distances of d (rather than log d as we would in Euclidean space). [3](#foot_2) This result will be of use below.

Now we consider the largest distance in the embeddings produced by Algorithm 1. If the longest path in the tree is , and each edge has length τ = 1 ε 2 log

$deg max π/2$, the largest distance is O( ε log deg max ), and we require this number of bits for the representation. We interpret this expression. Note that deg max is inside the log term, so that a bushy tree is not penalized much in precision. On the other hand, the longest path length is not, so that hyperbolic embeddings struggle with long paths. Moreover, by selecting an explicit graph, we derive a matching lower bound, concluding that to achieve a distortion ε, any construction requires Ω ε log(deg max ) bits, which matches the upper bound of the combinatorial construction. The argument follows from selecting a graph consisting of m(deg max + 1) nodes in a tree with a single root and deg max chains each of length m. The proof of this result is described in Appendix D.

## Improving the Construction

Our next contribution is a generalization of the construction from the disk H 2 to the ball H r . Our construction follows the same line as Algorithm 1, but since we have r dimensions, the step where we place children spaced out on a circle around their parent now uses a hypersphere.

Spacing out points on the hypersphere is a classic problem known as spherical coding [[7]](#b6). As we shall see, the number of children that we can place for a particular angle grows with the dimension. Since the required scaling factor τ gets larger as the angle decreases, we can reduce τ for a particular embedding by increasing the dimension. Note that increasing the dimension helps with bushy trees (large deg max ), but has limited effect on tall trees with small deg max .

We show Proposition 3.1. The generalized H r combinatorial construction has distortion at most 1 + ε and requires at most O( 1 ε r log deg max ) bits to represent a node component for r ≤ (log deg max )+1, and O( 1 ε ) bits for r > (log deg max )+ 1.

The algorithm for the generalized H r combinatorial construction replaces Step 5 in Algorithm 1 with a node placement step based on ideas from coding theory. The children are placed at the vertices of a hypercube inscribed into the unit hypersphere (and afterwards scaled by τ ). Each component of a hypercube vertex has the form ±1 √ r . We index these points using binary sequences a ∈ {0, 1} r in the following way:

$x a = (-1) a1 √ r , (-1) a2 √ r , . . . , (-1) ar √ r .$We can space out the children by controlling the distances between the children. This is done in turn by selecting a set of binary sequences with a prescribed minimum Hamming distance-a binary error-correcting code-and placing the children at the resulting hypercube vertices. We provide more details on this technique and our choice of code in the appendix.

## Embedding into Trees

We revisit the first step of the construction: embedding graphs into trees. There are fundamental limits to how well graphs can be embedded into trees; in general, breaking long cycles inevitably adds distortion, as shown in Figure [2](#fig_2).

We are inspired by a measure of this limit, the δ-4 points condition introduced in I. Abraham et al. [[18]](#b17). A graph on n nodes that satisfies the δ-4 points condition has distortion at most (1 + δ) c1 log n for some constant c 1 . This result enables our end-to-end embedding to achieve a distortion of at most

$D(f ) ≤ (1 + δ) c1 log n (1 + ε).$The result in I. Abraham et al. [[18]](#b17) builds a tree with Steiner nodes. These additional nodes can help control the distances in the resulting tree. Example 3.1. Embed a complete graph on {1, 2, . . . , n} into a tree. The tree will have a central node, say 1, w.l.o.g., connected to every other node; the shortest paths between pairs of nodes in {2, . . . , n} go from distance 1 in the graph to distance 2 in the tree. However, we can introduce a Steiner node n + 1 and connect it to all of the nodes, with edge weights of 1 2 . This is shown in Figure [2](#fig_2). The distance between any pair of nodes in {1, . . . , n} remains 1. Note that introducing Steiner nodes can produce a weighted tree, but Algorithm 1 readily extends to the case of weighted trees by modifying Step 5. We propose using the Steiner tree algorithm in I. Abraham et al. [[18]](#b17) (used to achieve the distortion bound) for real embeddings, and we rely on it for our experiments in Section 5. In summary, the key takeaways of our analysis in this section are:

• There is a fundamental tension between precision and quality in hyperbolic embeddings.

• Hyperbolic embeddings have an exponential advantage in space compared to Euclidean embeddings for short, bushy hierarchies, but will have less of an advantage for graphs that contain long paths.

• Choosing an appropriate scaling factor τ is critical for quality. Later, we will propose to learn this scale factor automatically for computing embeddings in PyTorch.

• Steiner nodes can help improve embeddings of graphs.

## Hyperbolic Multidimensional Scaling

In this section, we explore a fundamental and more general question than we did in the previous section: if we are given the pairwise distances arising from a set of points in hyperbolic space, can we recover the points? The equivalent problem for Euclidean distances is solved with multidimensional scaling (MDS). The goal of this section is to analyze the hyperbolic MDS (h-MDS) problem. We describe and overcome the additional technical challenges imposed by hyperbolic distances, and show that exact recovery is possible and interpretable. Afterwards we propose a technique for dimensionality reduction using principal geodesics analysis (PGA) that provides optimization guarantees. In particular, this addresses the shortcomings of h-MDS when recovering points that do not exactly lie on a hyperbolic manifold.

## Exact Hyperbolic MDS

Suppose that there is a set of hyperbolic points x 1 , . . . , x n ∈ H r , embedded in the Poincaré ball and written X ∈ R n×r in matrix form. We observe all the pairwise distances d i,j = d H (x i , x j ), but do not observe X: our goal is use the observed d i,j 's to recover X (or some other set of points with the same pairwise distances d i,j ).

The MDS algorithm in the Euclidean setting makes an important centering[foot_3](#foot_3) assumption. That is it assumes the points have mean 0, and it turns out that if an exact embedding for the distances exists, it can be recovered from a matrix factorization. In other words, Euclidean MDS always recovers a centered embedding.

In hyperbolic space, the same algorithm does not work, but we show that it is possible to find an embedding centered at a different mean. More precisely, we introduce a new mean which we call the pseudo-Euclidean mean, that behaves like the Euclidean mean in that it enables recovery through matrix factorization. Once the points are recovered in hyperbolic space, they can be recentered around a more canonical mean by translating it to the origin.

Algorithm 2 is our complete algorithm, and for the remainder of this section we will describe how and why it works.

We first describe the hyperboloid model, an alternate but equivalent model of hyperbolic geometry in which h-MDS is simpler. Of course, we can easily convert between the hyperboloid model and the Poincaré ball model we have used thus far. Next, we show how to reduce the problem to a standard PCA problem, which recovers an embedding centered at the points' pseudo-Euclidean mean. Finally, we discuss the meaning and implications of centering and prove that the algorithm preserves submanifolds as well-that is, if there is an exact embedding in k < r dimensions centered at their canonical mean, then our algorithm will recover them.

The hyperboloid model Define Q to be the diagonal matrix in R r+1 where Q 00 = 1 and

$Q ii = -1 for i > 0. For a vector x ∈ R r+1 , x T Qx is called the Minkowski quadratic form.$The hyperboloid model is defined as

$M r = x ∈ R r+1 x T Qx = 1 ∧ x 0 > 0 .$This manifold is endowed with a distance measure

$d H (x, y) = acosh(x T Qy).$As a notational convenience, for a point x ∈ M r we will let x 0 denote 0th coordinate e T 0 x, and let x ∈ R r denote the rest of the coordinates. Notice that x 0 is just a function of x (in fact, x 0 = 1 + x 2 ), and so we can equivalently consider just x as being a member of a model of hyperbolic space: this model is sometimes known as the Gans model. With this notation, the Minkowski quadratic form can be simplified to x T Qy = x 0 y 0 -x T y.

A new mean We introduce the new mean that we will use. Given points x 1 , x 2 , . . . , x n ∈ M r in hyperbolic space, define a variance term

$Ψ(z; x 1 , x 2 , . . . , x n ) = n i=1 sinh 2 (d H (x i , z)).$Using this, we define a pseudo-Euclidean mean to be any local minimum of this expression. Notice that this average is independent of the model of hyperbolic space that we are using, since it only is defined in terms of the hyperbolic distance function d H . Lemma 4.1. Define the matrix X ∈ R n×r such that X T e i = x i and the vector u ∈ R n such that u i = x 0,i . Then

$∇ z Ψ(z; x 1 , x 2 , . . . , x n )| z=0 = -2 n i=1 x 0,i x i = -2X T u.$This means that 0 is a pseudo-Euclidean mean if and only if 0 = X T u. Call some hyperbolic points x 1 , . . . , x n pseudo-Euclidean centered if their average is 0 in this sense: i.e. if X T u = 0. We can always center a set of points without affecting their pairwise distances by simply finding their average, and then sending it to 0 through an isometry.

Recovery via matrix factorization Suppose that there exist points x 1 , x 2 , . . . , x n ∈ M r for which we observe their pairwise distances d H (x i , x j ). From these, we can compute the matrix Y such that

$Y i,j = cosh (d H (x i , x j )) = x T i Qx j = x 0,i x 0,j -x i T x j .(1)$Furthermore, defining X and u as in Lemma 4.1, then we can write Y in matrix form as

$Y = uu T -XX T .(2)$Without loss of generality, we can suppose that the points we are trying to recover, x 1 , . . . , x n , are centered at their pseudo-Euclidean mean, so that X T u = 0 by Lemma 4.1.

Algorithm 2

1: Input: Distance matrix d i,j and rank r 2: Compute scaled distance matrix Y i,j = cosh(d i,j ) 3: X → PCA(-Y, r) 4: Project X from hyperboloid model to Poincaré model: x → x 1+ √ 1+ x 2 5: If desired, center X at a different mean (e.g. the Karcher mean) 6: return X

This implies that u is an eigenvector of Y with positive eigenvalue, and the rest of Y 's eigenvalues are negative. Therefore an eigendecomposition of Y will find u, X such that Y = uu T -X XT , i.e. it will directly recover X up to rotation.

In fact, running PCA on -Y = X T X -uu T to find the n most significant non-negative eigenvectors will recover X up to rotation, and then u can be found by leveraging the fact that

$x 0 = 1 + x 2 .$This leads to Algorithm 2, with optional post-processing steps for converting the embedding to the Poincaré ball model and for re-centering the points.

A word on centering The MDS algorithm in Euclidean geometry returns points centered at their Karcher mean z, which is a point minimizing d 2 (z, x i ) (where d is the distance metric). The Karcher center is particularly useful for interpreting dimensionality reduction; for example, we use the analogous hyperbolic Karcher mean to perform PGA in Section 4.2.

Although Algorithm 2 returns points centered at their pseudo-Euclidean mean instead of their Karcher mean, they can be easily recentered by finding their Karcher mean and reflecting it onto the origin. Furthermore, we show that Algorithm 2 preserves the dimension of the embedding. More precisely, we prove Lemma 4.2 in Appendix E. Lemma 4.2. If a set of points lie in a dimension-k geodesic submanifold, then both their Karcher mean and their pseudo-Euclidean mean lie in the same submanifold.

This implies that centering with the pseudo-Euclidean mean preserves geodesic submanifolds: If it is possible to embed distances in a dimension-k geodesic submanifold centered and rooted at a Karcher mean, then it is also possible to embed the distances in a dimension-k submanifold centered and rooted at a pseudo-Euclidean mean, and vice versa.

## Reducing Dimensionality with PGA

Sometimes we are given a high-rank embedding (resulting from h-MDS, for example), and wish to find a lower-rank version. In Euclidean space, one can get the optimal lower rank embedding by simply discarding components. However, this may not be the case in hyperbolic space. Motivated by this, we study dimensionality reduction in hyperbolic space.

As hyperbolic space does not have a linear subspace structure like Euclidean space, we need to define what we mean by lower-dimensional. We follow Principal Geodesic Analysis [[12]](#b11), [[17]](#b16). Consider an initial embedding with points x 1 , . . . , x n ∈ H 2 and let d H : H 2 × H 2 → R + be the hyperbolic distance. Suppose we want to map this embedding onto a one-dimensional subspace. (Note that we are considering a two-dimensional embedding and one-dimensional subspace here for simplicity, and these results immediately extend to higher dimensions.) In this case, the goal of PGA is to find a geodesic γ : [0, 1] → H 2 that passes through the mean of the points and that minimizes the squared error (or variance):

$f (γ) = n i=1 min t∈[0,1] d H (γ(t), x i ) 2 .$This expression can be simplified significantly and reduced to a minimization in Euclidean space. First, we find the mean of the points, the point x which minimizes n i=1 d H (x, x i ) 2 ; this definition in terms of distances generalizes the mean in Euclidean space. [5](#foot_4) Next, we reflect all the points x i so that their mean is 0 in the Poincaré disk model; we The PGA objective of an example task where the input dataset in the Poincaré disk is x 1 = (0.8, 0), x 2 = (-0.8, 0), x 3 = (0, 0.7) and x 4 = (0, -0.7). Note the presence of non-optimal local minima, unlike PCA. can do this using a circle inversion that maps x onto 0. In the Poincaré disk model, a geodesic through the origin is a Euclidean line, and the action of the reflection across this line is the same in both Euclidean and hyperbolic space. Coupled with the fact that reflections are isometric, if γ is a line through 0 and R γ is the reflection across γ, we have

$d H (γ, x) = min t∈[0,1] d H (γ(t), x) = 1 2 d H (R l x, x).$Combining this with the Euclidean reflection formula and the hyperbolic metric produces

$f (γ) = 1 4 n i=1 acosh 2 1 + 8d E (γ, x i ) 2 (1 -x i 2 ) 2 ,$in which d E is the Euclidean distance from a point to a line. If we define

$w i = √ 8x i /(1 -x i 2 )$this reduces to the simplified expression

$f (γ) = 1 4 n i=1 acosh 2 1 + d E (γ, w i ) 2 .$Notice that the loss function is not convex. We observe that there can be multiple local minima that are attractive and stable, in contrast to PCA. Figure [3](#) illustrates this nonconvexity on a simple dataset in H 2 with only four examples. This makes globally optimizing the objective difficult.

Nevertheless, there will always be a region Ω containing a global optimum γ * that is convex and admits an efficient projection, and where f is convex when restricted to Ω. Thus it is possible to build a gradient descent-based algorithm to recover lower-dimensional subspaces: for example, we built a simple optimizer in PyTorch. We also give a sufficient condition on the data for f above to be convex. Lemma 4.3. For hyperbolic PGA if for all i,

$acosh 2 1 + d E (γ, w i ) 2 < min 1, 1 3 w i 2 then f is locally convex at γ.$As a result, if we initialize in and optimize over a region that contains γ * and where the condition of Lemma 4.3 holds, then gradient descent will be guaranteed to converge to γ * . We can turn this result around and read it as a recovery result: if the noise is bounded in this regime, then we are able to provably recover the correct low-dimensional embedding.

## Experiments

We evaluate the proposed approaches and compare against existing methods. We hypothesize that for tree-like data, the combinatorial construction offers the best performance. For general data, we expect h-MDS to produce the lowest Table 2: MAP measure for WordNet embedding compared to values in Nickel and Kiela [28]. Closer to 1 is better.

distortion, while it may have low MAP due to precision limitations. We anticipate that dimension is a critical factor (outside of the combinatorial construction). Finally, we expect that the MAP of h-MDS techniques can be improved by learning the correct scale and weighting the loss function as suggested in earlier sections. In the Appendix, we report on additional datasets, parameters found by the combinatorial construction, and the effect of hyperparameters.

Datasets We consider trees, tree-like hierarchies, and graphs that are not tree-like. First, we consider hierarchies that form trees: fully-balanced trees along with phylogenetic trees expressing genetic heritage (of mosses growing in urban environments [[16]](#b15), available from [[31]](#b30)). Similarly, we used hierarchies that are nearly tree-like: WordNet hypernym (the largest connected component from Nickel and Kiela [[28]](#b27)) and a graph of Ph.D. advisor-advisee relationships [[10]](#b9). Also included are datasets that vary in their tree nearness, such as biological sets involving disease relationships [[14]](#b13) and protein interactions in yeast bacteria [[20]](#b19), both available from [[30]](#b29). We also include the collaboration network formed by authorship relations for papers submitted to the general relativity and quantum cosmology (Gr-QC) arXiv [[26]](#b25).

Approaches Combinatorial embeddings into H 2 are done using Steiner trees generated from a randomly selected root for the ε = 0.1 precision setting; others are considered in the Appendix. We performed h-MDS in floating point precision. We also include results for our PyTorch implementation of an SGD-based algorithm (described later), as well as a warm start version initialized with the high-dimensional combinatorial construction. We compare against classical MDS (i.e., PCA), and the optimization-based approach Nickel and Kiela [[28]](#b27), which we call FB. The experiments for h-MDS, PyTorch SGD, PCA, and FB used dimensions of 2,5,10,50,100,200; we recorded the best resulting MAP and distortion. Due to the large scale, we did not replicate the best FB numbers on large graphs (i.e., Gr-QC and WordNet).

As a result, we report their best published MAP numbers for comparison (their work does not report distortion). These  Table 4: MAP measures using combinatorial and h-MDS techniques, compared against PCA. Closer to 1 is better.

entries are marked with an asterisk. For the WordNet graph we use a random BFS tree rather than a Steiner tree. Moreover, for comparison against FB (which computes the transitive closure), we can use a weighted version of the graph that captures the ancestor relationships. The full details are in Appendix.

Quality In Table [3](#tab_4), we report the distortion. As expected, when the graph is a tree or tree-like the combinatorial construction has exceedingly low distortion. Because h-MDS is meant to recover points exactly, we hypothesized that h-MDS would offer very low distortion on these datasets. We confirm this hypothesis: among h-MDS, PCA, and FB, h-MDS consistently offers the best (lowest) distortion, producing, for example, a distortion of 0.039 on the phylogenetic tree dataset. We observe that the optimization-based approach works quite well for reducing distortion, and on tree-like datasets it is bolstered by appropriate initialization from the combinatorial construction.

Table [4](#) reports the MAP measure (this is shown in Table [2](#) for WordNet), which is a local measure. We expect that the combinatorial construction performs well for tree-like hierarchies. This is indeed the case: on trees and tree-like graphs, the MAP is close to 1, improving on approaches such as FB that rely on optimization. On larger graphs like WordNet, our approach yields a MAP of 0.989-improving on the FB MAP result of 0.870 at 200 dimensions. This is exciting because the combinatorial approach is deterministic and linear-time. In addition, it suggests that this refined understanding of hyperbolic embeddings may be used to improve the quality and runtime state of the art constructions.

As expected, the MAP of the combinatorial construction decreases as the graphs are less tree-like. Interestingly, h-MDS solved in floating point indeed struggles with MAP. We separately confirmed that it is indeed due to precision using a high-precision solver, which obtains a perfect MAP-but uses 512 bits of precision. It may be possible to compensate for this with scaling, but we did not explore this possibility.

Rank No Scale Learned Scale Exp. Weighting 50 0.481 0.508 0.775 100 0.688 0.681 0.882 200 0.894 0.907 0.963 Table 5: Ph.D. dataset. Improved MAP performance of PyTorch implementation using a modified PGA-like loss function.

## SGD-Based Algorithm

We also built an SGD-based algorithm implemented in PyTorch. Here the loss function is equivalent to the PGA loss, and so is continuously differentiable. We use this to verify two claims:

Learned Scale. In Table [5](#), we verify the importance of scaling that our analysis suggests; our implementation has a simple learned scale parameter. Moreover, we added an exponential weighting to the distances in order to penalize long paths, thus improving the local reconstruction. These techniques indeed improve the MAP; in particular, the learned scale provides a better MAP at lower rank. We hope these techniques can be useful in other embedding techniques.

Incomplete Information. To evaluate our algorithm's ability to deal with incomplete information, we examine the quality of recovered solutions as we sample the distance matrix. We set the sampling rate of non-edges to edges at 10 : 1 following Nickel and Kiela [[28]](#b27). We examine the phylogenetic tree, which is full rank in Euclidean space. In Figure [4](#fig_6), we are able to recover a good solution with a small fraction of the entries for the phylogenetic tree dataset; for example, we sampled approximately 4% of the graph but provide a MAP of 0.74 and distortion of less than 0.6.

Understanding the sample complexity for this problem is an interesting theoretical question. 

## A Glossary of Symbols

## B Related Work

Our study of representation tradeoffs for hyperbolic embeddings was motivated by exciting recent approaches towards such embeddings in Nickel and Kiela [[28]](#b27) and Chamberlain et al. [[5]](#b4). Earlier efforts proposed using hyperbolic spaces for routing, starting with Kleinberg's work on geographic routing [[22]](#b21). Cvetkovski and Crovella [[8]](#b7) performed hyperbolic embeddings and routing for dynamic networks. Recognizing that the use of hyperbolic space for routing required a large number of bits to store the vertex coordinates, Eppstein and Goodrich [[11]](#b10) introduced a scheme for succinct embedding and routing in the hyperbolic plane. Another very recent effort also proposes using hyperbolic cones (similar to the cones that are the fundamental building block used in Sarkar [[32]](#b31) and our work) as a heuristic for embedding entailment relations, i.e. directed acyclic graphs [[13]](#b12). The authors also propose to optimize on the hyperbolic manifold using its exponential map, as opposed to our approach of finding a closed form for the embedding should it exist (Section 4). An interesting avenue for future work is to compare both optimization methods empirically and theoretically, i.e., to understand the types of recovery guarantees under noise that such methods have.

There have been previous efforts to perform multidimensional scaling in hyperbolic space (the h-MDS problem), often in the context of visualization [[25]](#b24). Most propose descent methods in hyperbolic space (e.g. [[9]](#b8), [[37]](#b36)) and fundamentally differ from ours. Arguably the most relevant is Wilson et al. [[38]](#b37), which mentions exact recovery as an intermediate result, but ultimately suggests a heuristic optimization. Our h-MDS analysis characterizes the recovered embedding and manifold and obtains the correctly centered one-a key issue in MDS. For example, this allows us to properly find the components of maximal variation. Furthermore, we discuss robustness to noise and produce optimization guarantees when a perfect embedding doesn't exist.

Several papers have studied the notion of hyperbolicity of networks, starting with the seminal work on hyperbolic graphs Gromov [[15]](#b14). More recently, Chen et al. [[6]](#b5) considered the hyperbolicity of small world graphs and tree-like random graphs. Abu-Ata and Dragan [[1]](#b0) performed a survey that examines how well real-world networks can be approximated by trees using a variety of tree measures and tree embedding algorithms. To motivate their study of tree metrics, I. Abraham et al. [[18]](#b17) computed a measure of tree likeness on a Internet infrastructure network.

We use matrix completion (closure) to perform embeddings with incomplete data. Matrix completion is a celebrated problem. Candes and Tao [[4]](#b3) derive bounds on the minimum number of entries needed for completion for a fixed rank matrix; they also introduce a convex program for matrix completion operating at near the optimal rate.

Principal geodesic analysis (PGA) generalizes principal components analysis (PCA) for the manifold setting. It was introduced and applied to shape analysis in [[12]](#b11) and extended to a probabilistic setting in [[39]](#b38). There are other variants; the geodesic principal components analysis (GPCA) of Huckemann et al. [[17]](#b16) uses our loss function.

## C Low-Level Formulation Details

We plan to release our PyTorch code, high precision solver, and other routines on Github. A few comments are helpful to understand the reformulation. In particular, we simply minimize the squared hyperbolic distance with a learned scale parameter, τ , e.g., :

$min x1,...,xn,τ 1≤i<j≤n (τ d H (x i , x j ) -d i,j )2$We typically require that τ ≥ 0.1.

• On continuity of the derivative of the loss: Note that

$∂ x acosh(1 + x) = 1 (1 + x) 2 -1 = 1 x(x + 2) hence lim x→0 ∂ x acosh(1 + x) = ∞.$Thus, lim y→x ∂ x d H (x, y) = ∞. In particular, if two points happen to get near to one another during execution, gradient-based optimization becomes unstable. Note that exp{acosh(1 + x)} suffers from a similar issue, and is used in both [[5,](#b4)[28]](#b27). This change may increase numerical instability, and the public code for these approaches does indeed take steps like masking out updates to mitigate NANs. In contrast, the following may be more stable:

$∂ x acosh(1 + x) 2 = 2 acosh(1 + x) x(x + 2)$and in particular lim

$x→0 ∂ x acosh(1 + x) 2 = 2$The limits follows by simply applying L'Hopital's rule. In turn, this implies the square formulation is continuously differentiable. Note that it is not convex.

• One challenge is to make sure the gradient computed by PyTorch has the appropriate curvature correction (the Riemannian metric), as is well explained by Nickel and Kiela [[28]](#b27). The modification is straightforward: we create a subclass of NN.PARAMETER called HYPERBOLIC PARAMETER. This wrapper class allows us to walk the tree to apply the appropriate correction to the metric (which amounts to multiplying ∇ w f (w) by 1  4 (1 -w 2 ) 2 . After calling the BACKWARD function, we call a routine to walk the autodiff tree to find such parameters and correct them. This allows HYPERBOLIC PARAMETER and traditional parameters to be freely mixed.

• We project back on the hypercube following Nickel and Kiela [[28]](#b27) and use gradient clipping with bounds of [-10

5 , 10 5 ]. This allows larger batch sizes to more fully utilize the GPU. a 0 a 1 a 2 a 3 . . . a deg max a 0 a 1,1 a 1,2 a 1,3 . . . a 1,deg max a 2,1 a 2,2 a 2,3 . . . a 2,deg max . . . . . . . . . . . . . . . a m,1 a m,2 a m,3 . . . a m,deg max 

## D Combinatorial Construction Proofs

Precision vs. model We first provide a simple justification of the fact (used in Section 3.2) that representing distances d requires about d bits in hyperbolic space -independent of the model of the space. Formally, we show that the number of bits needed to represent a space depends only on the maximal and minimal desired distances and the geometry of the space. Thus although the bulk of our results are presented in the Poincaré sphere, our discussion on precision tradeoffs is fundamental to hyperbolic space.

A representation using b bits can distinguish 2 b distinct points in a space S. Suppose we wish to capture distances up to d with error tolerance ε -concretely, say every point in the ball B(0, d) must be within distance ε of a represented point. By a sphere covering argument, this requires at least V S (d) V S (ε) points to be represented, where V S (r) is the volume of a ball of radius r in the geometry. Thus at least b = log V S (d)

V S (ε) bits are needed for the representation. Notice that V E (d) ∼ d n in Euclidean R n space, so this gives the correct bit complexity of n log(d/ε). In hyperbolic space, V H is exponential instead of polynomial in d, so O(d) bits are needed in the representation (for any constant tolerance). In particular, this is independent of the model of the space.

Graph embedding lower bound Now, we derive a lower bound on the bits of precision required for embedding a graph into H 2 . Afterwards we prove a result bounding the precision for our extension of Sarkar's construction for the r-dimensional Poincaré ball H r . Finally, we give some details on the algorithm for this extension.

We derive the lower bound by exhibiting an explicit graph and lower bounding the precision needed to represent its nodes (for any embedding of the graph into H 2 ). The explicit graph G m we consider consists of a root node with deg max chains attached to it. Each of these chains has m nodes for a total of 1 + m(deg max ) nodes, as shown in Figure [5](#fig_7). Lemma D.1. The bits of precision needed to embed a graph with longest path is Ω ε log(deg max ) .

Proof. We first consider the case where m = 1. Then G 1 is a star with 1+deg max children a 1 , a 2 , . . . , a deg max . Without loss of generality, we can place the root a 0 at the origin 0.

Let x i = f (a i ) be the embedding into H 2 for vertex a i for 0 ≤ i ≤ deg max . We begin by showing that the distortion does not increase if we equalize the distances between the origin and each child x i . Let us write max = max i d H (0, x i ) and min = min i d H (0, x i ).

What is the worst-case distortion? We must consider the maximal expansion and the maximal contraction of graph distances. Our graph distances are either 1 or 2, corresponding to edges (a 0 to a i ) and paths of length 2 (a i to a 0 to a j ). By triangle inequality,

$d H (xi,xj ) 2 ≤ d H (0,xi) 2 + d H (0,xj ) 2$≤ max . This implies that the maximal expan- Equalizing the origin-to-child distances (that is, taking max = min ) reduces the distortion. Moreover, these distances are a function of the norms x i , so we set x i = v for each child.

$sion max i =j d H (f (a i ), f (a j ))/d G (a i , a j ) is max$Next, observe that since there are deg max children to place, there exists a pair of children x, y so that the angle formed by x, 0, y is no larger than θ = 2π deg max

. In order to get a worst-case distortion of 1 + ε, we need the product of the maximum expansion and maximum contraction to be no more than 1 + ε. The maximum expansion is simply d H (0, x) while the maximum contraction is 2 d H (x,y) , so we wan

$2d H (0, x) ≤ (1 + ε)d H (x, y).$We use the log-based expressions for hyperbolic distance:

$d H (0, x) = log 1 + v 1 -v ,$and

$d H (x, y) = 2 log x -y + x 2 y 2 -2 x, y + 1 (1 -x 2 )(1 -y 2 ) = 2 log 2v 2 (1 -cos θ) + √ v 4 -2v 2 cos θ + 1 1 -v 2 .$This leaves us with

$log 2v 2 (1 -cos θ) + √ v 4 -2v 2 cos θ + 1 1 -v 2 (1 + ε) ≥ log 1 + v 1 -v .$Now, since 1 > v 2 , we have that 2(1 -cos θ) ≥ 2v 2 (1 -cos θ). Some algebra shows that 3(1 -cos θ) ≥ √ v 4 -2v 2 cos θ + 1, so that we can upper bound the left-hand side to write

$log   (1 + 3 2 ) 2(1 -cos θ) 1 -v 2   (1 + ε) ≥ log 1 + v 1 -v .$Next we use the small angle approximation cos

$(θ) = 1 -θ 2 /2 to get 2(1 -cos θ) = θ. Now we have log   (1 + 3 2 )θ 1 -v 2   (1 + ε) ≥ log 1 + v 1 -v . Since v < 1, 1 1-v > 1 1-v 2 and 1+v 1-v ≥ 1 1-v$, so we can upper bound the left-hand side and lower bound the right-hand side:

$log   (1 + 3 2 )θ 1 -v   (1 + ε) ≥ log 1 1 -v .$Rearranging,

$-log(1 -v) ≥ -log 1 + 3 2 θ 1 + ε ε .$Recall that θ = 2π deg max

. Then we have that

$-log(1 -v) ≥ 1 + ε ε log(deg max ) -log((2 + √ 6)π) , so that -log(1 -v) = Ω 1 ε log(deg max ) . Since v = x = y , -log(1 -v)$is precisely the required number of bits of precision, so we have our lower bound for the m = 1 case.

Next we analyze the m > 1 case. Consider the embedded vertices x 1 , x 2 , . . . , x m corresponding to one chain and y 1 , y 2 , . . . , y m corresponding to another. There exists a pair of chains such that the angle formed by x m , 0,

$y 1 is at most θ = 2π deg max . Let u = x m and v = y 1 .$From the m = 1 case, we have a lower bound on -log(1 -v); we will now lower bound -log(1 -u). The worst-case distortion we consider uses the contraction given by the path

$x m → x m-1 → • • • → x 1 → 0 → y 1 ; this path has length m + 1.$The expansion is just the edge between 0 and y 1 . Then, to satisfy the worst-case distortion 1 + ε, we need

$(m + 1)d H (0, y 1 ) ≤ (1 + ε)d H (x m , y 1 ).$Using the hyperbolic distance formulas, we can rewrite this as

$2 log x m -y 1 + x m 2 y 1 2 -2 x m , y 1 + 1 (1 -x m 2 )(1 -y 1 2 ) (1 + ε) ≥ (m + 1) log 1 + v 1 -v ,$or,

$2 log √ u 2 + v 2 -2uv cos θ + √ u 2 v 2 -2uv cos θ + 1 (1 -u 2 )(1 -v 2 ) (1 + ε) ≥ (m + 1) log 1 + v 1 -v .$Next,

$2 log √ u 2 + v 2 -2uv cos θ + √ u 2 v 2 -2uv cos θ + 1 (1 -u 2 )(1 -v 2 ) ≤ 2 log   (1 + 3 2 )θ (1 -u 2 )(1 -v 2 )   = log   (1 + 3 2 ) 2 θ 2 (1 -u 2 )(1 -v 2 )   ≤ log   (1 + 3 2 ) 2 θ 2 (1 -u)(1 -v)   .$In the first step, we used the same arguments as earlier. Applying this result and using 1+v

$1-v ≥ 1 1-v , we have log   (1 + 3 2 ) 2 θ 2 (1 -u)(1 -v)   (1 + ε) ≥ (m + 1) log 1 1 -v , or, log   (1 + 3 2 ) 2 θ 2 1 -u   (1 + ε) ≥ (m -ε) log 1 1 -v .$Next we can apply the bound on -log(1 -v).

$log 1 1 -u ≥ -log (1 + 3 2 ) 2 θ 2 + m -ε 1 + ε log 1 1 -v ≥ -log (1 + 3 2 ) 2 θ 2 + m -ε 1 + ε 1 + ε ε log(deg max ) -log((2 + √ 6)π) ) = m -ε ε log(deg max ) - m -ε ε log((2 + √ 6)π) - 1 2 log(deg max ) -log((2 + √ 6)π) .$Here, we applied the relationship between θ and deg max we derived earlier. To conclude, note that the longest path in our graph is = 2m. Then, we have that

$-log(1 -u) = Ω ε log(deg max ) ,$as desired.

Combinatorial construction upper bounds Next, we prove our extension of Sarkar's construction for H r , restated below. Proof. The combinatorial construction achieves worst-case distortion bounded by 1 + ε in two steps [[32]](#b31). First, it is necessary to scale the embedded edges by a factor of τ sufficiently large to enable each child of a parent node to be placed in a disjoint cone. Note that there will be a cone with angle α less than π deg max . The connection between this angle and the scaling factor τ is governed by τ = -log(tan α/2). As expected, as deg max increases, α decreases, and the necessary scale τ increases.

This initial step provides a Delaunay embedding (and thus a MAP of 1.0), but perhaps not sufficient distortion. The second step is to further scale the points by a factor of 1+ε ε ; this ensures the distortion upper bound. Our generalization to the Poincaré ball of dimension r will modify the first step by showing that we can pack more children around a parent while maintaining the same angle. In other words, for a fixed number of children we can increase the angle between them, correspondingly decreasing the scale. We use the following generalization of cones for H r , defined by the maximum angle α ∈ [0, π/2] between the axis and any point in the cone. Let cone C(X, Y, α) be the cone at point X with axis XY and cone angle

$α: C(X, Y, α) = {Z ∈ H r : Z -X, Y -X ≥ Z -X Y -X cos α} .$We seek the maximum angle α for which deg max disjoint cones can be fit around a sphere. Supposing r -1 ≤ log deg max , we use the following lower bound [[19]](#b18) on the number of unit vectors A(r, θ) that can be placed on the unit sphere of dimension r with pairwise angle at least θ:

$A(r, θ) ≥ (1 + o(1)) √ 2πr cos θ (sin θ) r-1 .$Consider taking angle θ = asin(deg max

$-1 r-1 ).$Note that

$deg max -1 r-1 = exp log deg max -1 r-1 = exp - log d r -1 ≤ 1/e,$which implies that θ is bounded from above and cos θ is bounded from below. Therefore

$deg max = 1 (sin θ) r-1 ≤ O(1) cos θ (sin θ) r-1 ≤ A(r, θ).$So it is possible to place deg max children around the sphere with pairwise angle θ, or equivalently place deg max disjoint cones with cone angle α = θ/2. Note the key difference compared to the two-dimensional case where α = π deg max ; here we reduce the angle's dependence on the degree by an exponent of 1 r-1 . It remains to compute the explicit scaling factor τ that this angle yields; recall that τ = -log(tan α/2) suffices [[32]](#b31). We then have τ = -log(tan(θ/4)) = -log sin(θ/2) 1 + cos(θ/2) = log 1 + cos(θ/2) sin(θ/2)

$≤ log 2 sin(θ/2) = log 4 cos(θ/2) sin θ ≤ log 4 deg max -1 r-1 = O 1 r log deg max .$This quantity tells us the scaling factor without considering distortion (the first step). To yield the 1 + ε distortion, we just increase the scaling by a factor of 1+ε ε . The longest distance in the graph is the longest path multiplied by this quantity.

Putting it all together, for a tree with longest path , maximum degree deg max and distortion at most 1 + ε, the components of the embedding require (using the fact that distances d require d bits), is a trivial upper bound. Note that this cannot be improved asymptotically: As deg max grows, the minimum pairwise angle approaches π/2,[foot_5](#foot_5) so that τ = Ω(1) irrespective of the dimension r.

Next, we provide more details on the coding-theoretic child placement construction for r-dimensional embeddings. Recall that children are placed at the vertices of a hypercube inscribed into the unit hypersphere, with components in ±1 √ r . These points are indexed by sequences a ∈ {0, 1} r so that . Therefore, we can control the distances between the children by selecting a set of binary sequences with a prescribed minimum Hamming distance-a binary error-correcting code-and placing the children at the resulting hypercube vertices.

$x a = (-1) a1 √ r , (-1)$We introduce a small amount of terminology from coding theory. A binary code C is a set of sequences a ∈ {0, 1} r . A [r, k, h] 2 code C is a binary linear code with length r (i.e., the sequences are of length r), size 2 k (there are 2 k sequences), and minimum Hamming distance h (the minimum Hamming distance between two distinct members of the code is h).

## The Hadamard code C has parameters

$[2 k , k, 2 k-1 ]. If r = 2 k$is the dimension of the space, the Hamming distance between two members of C is at least 2 k-1 = r/2. Then, the distance between two distinct vertices of the hypercube x a and x b is 2 r/[foot_6](#foot_6) r = 2 1/2 = √ 2. Moreover, we can place up to 2 k = r points at least at this distance.

To build intuition, consider placing children on the unit circle (r = 2) compared to the r = 128-dimensional unit sphere. For r = 2, we can place up to 4 points with pairwise distance at least √ 2. However, for r = 128, we can place up to 128 children while maintaining this distance.

We briefly describe a few more practical details. Note that the Hadamard code is parametrized by k. To place c + 1 children, take k = log 2 (c + 1) . However, the desired dimension r of the embedding might be larger than the resulting code length r = 2 k . We can deal with this by repeating the codeword. If there are r dimensions and r|r , then the distance between the resulting vertices is still at least √ 2. Also, recall that when placing children, the parent node has already been placed. Therefore, we perform the placement using the hypercube, and rotate the hypersphere so that one of the c + 1 placed nodes is located at this parent.

Embedding the ancestor transitive closure Prior work embeds the transitive closure of the WordNet noun hypernym graph [[28]](#b27). Here, edges are placed between each word and its hypernym ancestors; MAP is computed over edges of the form (word, hypernym), or, equivalently, edges (a, b) where b ∈ A(a) is an ancestor of a.

In this section, we show how to achieve arbitrarily good MAP on these types of transitive closures of a tree by embedding a weighted version of the tree (which we can do using the combinatorial construction with arbitrarily low distortion for any number dimensions). The weights are simply selected to ensure that nodes are always nearer to their ancestors than to any other node.

Let T = (V, E) be our original graph. We recursively produce a weighted version of the graph called T that satisfies the desired property. Let s be the depth of node a ∈ V . We weight each of the edges (a, c), where c is a child of a with weight 2 s . Now we show the following property: Proposition D.2. Let b ∈ A(a) be an ancestor of a and e ∈ A(a) be some node not an ancestor of a. Then,

$d G (a, b) < d G (a, e).$Proof. Let a be at depth s. First, the farthest ancestor from a is the root, at distance 2 s-1 + 2 s-2 + . . .

$+ 2 + 1 = 2 s -1. Thus d G (a, b) ≤ 2 s -1.$If e is a descendant of a, then d G (a, e) is at least 2 s Next, if e is neither a descendant nor an ancestor of a, let f be their nearest common ancestor, and let the depths of a, e, f be s, s 2 , s 3 , respectively, where s 3 < min{s 1 , s 2 }. We have that d G (a, e) = (2 s-1 + . . .

$+ 2 s3 ) + (2 s2-1 + . . . + 2 s3 ) = 2 s -2 s3 + 2 s2 -2 s3 = 2 s + 2 s2 -2 s3+1 ≥ 2 s > d G (a, b).$The fourth line follows from s 2 > s 3 . This concludes the argument. Therefore, embedding the weighted tree T with the combinatorial construction enables us to keep all of a word's ancestors nearer to it than any other word. This enables us to embed a transitive closure hierarchy (like WordNet's) while still embedding a nearly tree-like graph. [7](#foot_7) Furthermore, the desirable properties of the construction still carry through (perfect MAP on trees, linear-time, etc).

## E Proof of h-MDS Results

We first prove the condition that X T u = 0 is equivalent to pseudo-Euclidean centering.

Proof of Lemma 4.1. In the hyperboloid model, the variance term Ψ can be written as

$Ψ(z; x 1 , x 2 , . . . , x n ) = k i=1 sinh 2 (d H (x i , z)) = k i=1 cosh 2 (d H (x i , z)) -1 = k i=1 (x T i Qz) 2 -1 = k i=1 (x 0,i z 0 -x T i z) 2 -1 = k i=1 x 0,i 1 + z 2 -x T i z 2 -1 .$The derivative of this with respect to z is

$∇ z Ψ(z; x 1 , x 2 , . . . , x n ) = 2 k i=1 x 0,i 1 + z 2 -x T i z x 0,i z 1 + z 2 -x i .$At z = 0 (or equivalently z = e 0 ), this becomes

$∇ z Ψ(z; x 1 , x 2 , . . . , x n )| z=0 = 2 k i=1 x 0,i √ 1 + 0 -0 x 0,i 0 √ 1 + 0 -x i = -2 k i=1 x 0,i x i .$If we define the matrix X ∈ R n×k such that X T e i = x i and the vector u ∈ R k such that u i = x 0,i , then

$∇ z Ψ(z; x 1 , x 2 , . . . , x n )| z=0 = -2 k i=1 X T e i e T i u = -2X T u.$Centering and Geodesic Submanifolds A well-known property of the hyperboloid model is that the geodesic submanifolds on M r are exactly the linear subspaces of R r+1 intersected with the hyperboloid model (Corollary A.5.5. from [[2]](#b1)). This is analogous to how the affine subspaces of R r are the linear subspaces of R r+1 intersected with the homogeneous-coordinates model of R r . Notice that this directly implies that any geodesic submanifold can be written as a geodesic submanifold centered on any of the points in that manifold. To be explicit with the definitions: Definition E.1. A geodesic submanifold is a subset S of a manifold such that for any two points x, y ∈ S, the geodesic from x to y is fully contained within S. Definition E.2. A geodesic submanifold rooted at a point x, given some local subspace of its tangent bundle T , is the subset S of the manifold that is the union of all the geodesics through x that are tangent at x in a direction contained in T .

Now we prove that centering with the pseudo-Euclidean mean preserves geodesic submanifolds.

First, we need the following technical lemma showing that projection to a manifold decreases distances. Lemma E.3. Consider a dimension-r geodesic submanifold S and point x outside of it. Let z be the projection of x onto S. Then for any point x ∈ S, d H (x, x) > d H (x, z).

Proof. As a consequence of the projection, the points x, z, x form a right angle. From the hyperbolic Pythagorean theorem, we know that cosh(d H (x, x)) = cosh(d H (x, z)) cosh(d H (z, x)).

Since cosh is increasing and at least 1 (with equality only at cosh(0) = 1), this implies that

$d H (x, x) > d H (x, z).$Lemma E.4. If some points x 1 , . . . , x k lie in a dimension-r geodesic submanifold S, then both a Karcher mean and a pseudo-Euclidean mean lie in this submanifold. Equivalently, if the points lie in a submanifold, then this submanifold can be written as centered at the Karcher mean or the pseudo-Euclidean mean.

Proof. Suppose by way of contradiction that there is a Karcher mean x that lies outside this submanifold S. Then, consider the projection z of x onto S. From Lemma E.3, projecting onto S has strictly decreased the distance to all the points on S.

As a result, the Frechet variance

$k i=1 d 2 H (x i , x)$also decreases when x is projected onto S. From this, it follows that there is a minimum value of the Frechet variance (a Karcher mean) that lies on S. An identical argument works for the pseudo-Euclidean distance, since the pseudo-Euclidean distance uses a variance that is just the sum of monotonically increasing functions of the hyperbolic distance.

Lemma E.5. Given some pairwise distances d i,j , if it is possible to embed the distances in a dimension-r geodesic submanifold rooted and centered at a pseudo-Euclidean mean, then it is possible to embed the distances in a dimension-r geodesic submanifold rooted and centered at a Karcher mean, and vice versa.

Proof. Suppose that it is possible to embed the distances as some points x 1 , . . . , x k in a dimension-r geodesic submanifold S. Then, by Lemma E.4, S contains both a Karcher mean x and a pseudo-Euclidean mean xP of these points. If we reflect all the points such that x is reflected to the origin, then the new reflected points will also be an embedding of the distances (since reflection is isometric) and they will also be centered at the origin. Furthermore, we know that they will still lie in a dimension-r submanifold (now containing the origin) since reflection also preserves the dimension of geodesic submanifolds. So the reflected points that we have constructed are an embedding of d i,j into a dimension-r geodesic submanifold rooted and centered at a Karcher mean. The same argument will show that (by reflecting xP to the origin instead of x) we can construct an embedding of d i,j into a dimension-r geodesic submanifold rooted and centered at the pseudo-Euclidean mean. This proves the lemma.

## F Perturbation Analysis F.1 Handling Perturbations

Now that we have shown that h-MDS recovers an embedding exactly, we consider the impact of perturbations on the data. Given the necessity of high precision for some embeddings, we expect that in some regimes the algorithm should be very sensitive. Our results identify the scaling of those perturbations.

First, we consider how to measure the effect of a perturbation on the resulting embedding. We measure the gap between two configurations of points, written as matrices in R n×r , by the sum of squared differences D(X, Y ) = trace((X -Y ) T (X -Y )). Of course, this is not immediately useful, since X and Y can be rotated or reflected without affecting the distance matrix used for MDS-as these are isometries, while scalings and Euclidean translations are not. Instead, we measure the gap by D E (X, Y ) = inf{D(X, P Y ) : P T P = I}.

In other words, we look for the configuration of Y with the smallest gap relative to X. For Euclidean MDS, Sibson [[33]](#b32) provides an explicit formula for D E (X, Y ) and uses this formulation to build a perturbation analysis for the case where Y is a configuration recovered by performing MDS on the perturbed matrix XX T + ∆(E), with ∆(E) symmetric.

Problem setup In our case, the perturbations affect the hyperbolic distances. Let H ∈ R n×n be the distance matrix for a set of points in hyperbolic space. Let ∆(H) ∈ R n×n be the perturbation, with H i,i = 0 and ∆(H) symmetric (so that Ĥ = H + ∆ H remains symmetric). The goal of our analysis is to estimate the gap D E (X, Y ) between X recovered from H with h-MDS and X recovered from the perturbed distances H + ∆(H). Lemma F.1. Under the above conditions, if λ min denotes the smallest nonzero eigenvalue of XX T then up to second order in ∆(H),

$D E (X, X) ≤ 2n 2 λ min sinh 2 ( H ∞ ) ∆(H) 2 ∞ .$The key takeaway is that this upperbound matches our intuition for the scaling: if all points are close to one another, then H ∞ is small and the space is approximately flat (since sinh 2 (z) is dominated by 2z 2 close to the origin). On the other hand, points at great distance are sensitive to perturbations in an absolute sense.

Proof of Lemma F.1. Similarly to our development of h-MDS, we proceed by accessing the underlying Euclidean distance matrix, and then apply the perturbation analysis from Sibson [[34]](#b33). There are three steps: first, we get rid of the acosh in the distances to leave us with scaled Euclidean distances. Next, we remove the scaling factors, and apply Sibson's result. Finally, we bound the gap when projecting to the Poincaré sphere.

Hyperbolic to scaled Euclidean distortion Let Y denote the scaled-Euclidean distance matrix, as in [(1)](#b0), so that Y i,j = cosh(H i,j ). Let Ŷi,j = cosh(H i,j + ∆(H) i,j ). We write ∆(Y ) = Ŷ -Y for the scaled Euclidean version of the perturbation. We can use the hyperbolic-cosine difference formula on each term to write ∆(Y ) i,j = cosh( Ĥi,j ) -cosh(H i,j ) = (cosh(H i,j + ∆(H) i,j ) -cosh(H i,j ))

= 2 sinh 2H i,j + ∆(H) i,j 2 sinh ∆(H) i,j 2 .

In terms of the infinity norm, as long as H ∞ ≥ ∆(H) ∞ (it is fine to assume this because we are only deriving a bound up to second order, so we can suppose that ∆(H) is small), we can simplify this to ∆(Y ) ∞ ≤ 2 sinh ( H ∞ ) sinh ( ∆(H) ∞ /2) .

Scaled Euclidean to Euclidean inner product. Recall that if X is the embedding in the hyperboloid model, then Y = uu T -XX T from equation (2), and furthermore X T u = 0 so that X can be recovered through PCA. Now we are in the Euclidean setting, and can thus measure the result of the perturbation on the recovered X. The proof of Theorem 4.1 in Sibson [[34]](#b33) transfers to this setting. This result states that if X is the configuration recovered from the perturbed inner products, then, the lowest-order term of the expansion of the error D E (X, X) in the perturbation ∆(Y ) is

$D E (X, X) = 1 2 j,k (v T j ∆(Y )v k ) 2 λ j + λ k .$Here, the λ i and v i are the eigenvalues and corresponding orthonormal eigenvectors of XX T and the sum is taken over pairs of λ j , λ k that are not both 0. Let λ min be the smallest nonzero eigenvalue of XX T . Then,

$D E (X, X) ≤ 1 2λ min j,k (v T j ∆(Y )v k ) 2 ≤ 1 2λ min ∆(Y ) 2 F ≤ n 2 2λ min ∆(Y ) 2 ∞ .$Combining this with the previous bounds, and restricting to second-order terms in ∆(H) 2 ∞ proves Lemma F.1 for the embedding X in the hyperboloid model.

Proof of Lemma 4.3. We begin by considering the component function

$f i (γ) = acosh 2 (1 + d 2 E (γ, v i )).$Here, the γ is a geodesic through the origin. We can identify this geodesic on the Poincaré disk with a unit vector u such that γ(t) = (2t -1)u. In this case, simple Euclidean projection gives us

$d 2 E (γ, v i ) = (I -uu T )v i 2 .$Optimizing over γ is equivalent to optimizing over u, and so

$f i (u) = acosh 2 1 + (I -uu T )v i 2 .$If we define the functions h(γ) = acosh 2 (1 + γ)

and

$R(u) = (I -uu T )v i 2 = v i 2 -(u T v i ) 2$then we can rewrite f i as f i (u) = h(R(u)).

Now, optimizing over u is an geodesic optimization problem on the hypersphere. Every goedesic on the hypersphere can be isometrically parameterized in terms of an angle θ as u(θ) = x cos(θ) + y sin(θ) for orthogonal unit vectors x and y. Without loss of generality, suppose that y T v i = 0 (we can always choose such a y because there will always be some point on the geodesic that is orthogonal to v i ). Then, we can write Differentiating again, d 2 dθ 2 h(R(θ)) = 4h (R(θ)) • (v T i x) 4 • sin 2 (θ) cos 2 (θ) + 2h (R(θ)) • (v T i x) 2 • cos 2 (θ) -sin 2 (θ) .

$R(θ) = v i 2 -(x T v i ) 2 cos 2 (θ) = v i 2 -(x T v i ) 2 + (x T v i ) 2 sin 2 (θ).$Now, suppose that we are interested in the Hessian at a point z = x cos(θ) + y sin(θ) for some fixed angle θ. Here, R(θ) = R(z), and as always v T i z = v T i x cos(θ), so

$d 2 dθ 2 h(R(θ)) u(θ)=z = 4h (R(θ)) • (v T i x) 4 • sin 2 (θ) cos 2 (θ) + 2h (R(θ)) • (v T i x) 2 • cos 2 (θ) -sin 2 (θ) = 4h (R(z)) • (v T i z) 4 cos 4 (θ)$• sin 2 (θ) cos 2 (θ) + 2h (R(z)) • (v T i x) 2 cos 2 (θ)

• cos 2 (θ) -sin 2 (θ) = 4h (R(z))

$• (v T i z) 4 • tan 2 (θ) + 2h (R(z)) • (v T i z) 2 • 1 -tan 2 (θ) = 2h (R(z)) • (v T i z) 2 + 4h (R(z)) • (v T i z) 4 -2h (R(z)) • (v T i z) 2 tan 2 (θ).$But we know that since h is concave and increasing, this last expression in parenthesis must be negative. It follows that a lower bound on this expression for fixed z will be attained when tan[foot_8](#foot_8) (θ) is maximized. For any geodesic through z, the angle θ is the distance along the geodesic to the point that is (angularly) closest to v i . By the Triangle inequality, this will be no greater than the distance θ along the Geodesic that connects z with the normalization of v i . On this worst-case geodesic, v T i z = v i cos(θ), and so 2 . Thus, for any geodesic, for the worst-case angle θ,

$cos 2 (θ) = (v T i z) 2 v i 2 and tan 2 (θ) = sec 2 (θ) -1 = v i 2 (v T i z) 2 -1 = R(z) (v T i z)$$d 2 dθ 2 h(R(θ)) u(θ)=z ≥ 2h (R(z)) • (v T i z) 2 + 4h (R(z)) • (v T i z) 4 -2h (R(z)) • (v T i z) 2 tan 2 (θ) = 2h (R(z)) • (v T i z) 2 + 4h (R(z)) • (v T i z) 2 -2h (R(z)) R(z).$From here, it is clear that this lower bound on the second derivative (and as a consequence local convexity) is a function solely of the norm of v i and the residual to z. From simple evaluation, we can compute that For any γ that satisfies 0 ≤ γ ≤ 1, 4γ γ 2 + 2γ ≥ (3γ 2 + 2γ) acosh(1 + γ)

and so 4γh (γ) + h (γ) ≥ 0.

Thus, if 0 ≤ R(z) ≤ 1,

$d 2 dθ 2 h(R(θ)) u(θ)=z ≥ 2h (R(z)) • (v T i z) 2 + 4h (R(z)) • (v T i z) 2 -2h (R(z)) R(z) = h (R(z)) • (v T i z) 2 + (4h (R(z)) • R(z) + h (R(z))) • (v T i z) 2 -2h (R(z)) • R(z) ≥ h (R(z)) • (v T i z) 2 -2h (R(z)) • R(z) = h (R(z)) • v i 2 -R(z) -2h (R(z)) • R(z) = h (R(z)) • v i 2 -3R(z) .$Thus, a sufficient condition for convexity is for (as we assumed above) R(z) ≤ 1 and

$v i 2 ≥ 3R(z).$Combining these together shows that if

$acosh 2 1 + d E (γ, v i ) 2 = R(z) ≤ min 1, 1 3 v i$![Figure 1: Geodesics and distances in the Poincaré disk. As x and y move towards the outside of the disk (i.e., letting x , y → 1), the distance d H (x, y) approaches d H (x, O) + d H (O, y).]()

![The algorithm takes as input a scaling factor τ a node a (of degree deg(a)) from the tree with parent node b. Suppose a and b have already been embedded into H 2 and have corresponding embedded vectors f (a) and f (b). The algorithm places the children c 1 , c 2 , . . . , c deg(a)-1 into H 2 through a two-step process.]()

![Input: Node a with parent b, children to place c 1 , c 2 , . . . , c deg(a)-1 , partial embedding f containing an embedding for a and b, scaling factor τ2: (0, z) ← reflect f (a)→0 (f (a), f (b)) 3: θ ← arg(z){angle of z from x-axis in the plane} 4: for i ∈ {1, . . . , deg(a) -1} do 5: y i ← e τ -1 e τ +1 • cos θ + 2πi deg(a) , e τ -1 e τ +1 • sin θ + 2πi deg(a) 6: end for 7: (f (a), f (b), f (c 1 ), . . . , f (c deg(a)-1 )) ← reflect 0→f (a) (0, z, y 1 , . . . , y deg(x)-1 ) Output: Embedded H 2 vectors f (c 1 ), f (c 2 ), . . . , f (c deg(a)-1 )]()

![Figure 2: Top. Cycles are a challenge for tree embeddings: d G (a, b) goes from 1 to 5. Bottom. Steiner nodes can help: adding a node (blue) and weighting edges maintains the pairwise distances.]()

![Figure3: The PGA objective of an example task where the input dataset in the Poincaré disk is x 1 = (0.8, 0), x 2 = (-0.8, 0), x 3 = (0, 0.7) and x 4 = (0, -0.7). Note the presence of non-optimal local minima, unlike PCA.]()

![Figure 4: Learning from incomplete information. The distance matrix is sampled, completed, and embedded.]()

![Figure 5: Explicit graphs G m used to derive precision lower bound. Left: m = 1 case (star graph). Right: m > 1.]()

![max occuring at a parent-child edge. Similarly, the maximal contraction is at least 1 min . With this, D wc (f ) ≥ max min .]()

![The generalized H r combinatorial construction has distortion at most 1 + ε and requires at most O( 1 ε r log deg max ) bits to represent a node component for r ≤ (log deg max )+1, and O( 1 ε ) bits for r > (log deg max )+ 1.]()

![bits per component. This big-O is with respect to deg max and any r ≤ log deg max +1. When r > log deg max +1, O 1 ε]()

![The Euclidean distance between x a and x b is a function of the Hamming distance d Hamming (a, b) between a and b. The Euclidean distance is exactly 2 dHamming(a,b) r]()

![Differentiating the objective with respect to θ,d dθ h(R(θ)) = h (R(θ))R (θ) = 2h (R(θ)) • (v T i x)2 • sin(θ) cos(θ).]()

![+ 2γ -(1 + γ) acosh(1 + γ) (γ 2 + 2γ) 3/2 .As a result4γh (γ) + h (γ) = 8 γ γ 2 + 2γ -(γ 2 + γ) acosh(1 + γ) (γ 2 + 2γ) 3/2 + 2 (γ 2 + 2γ) acosh(1 + γ) (γ 2 + 2γ) 3/+ 2γ -4(γ 2 + γ) acosh(1 + γ) + (γ 2 + 2γ) acosh(1 + γ) (γ 2 + 2γ) 3/+ 2γ -(3γ 2 + 2γ) acosh(1 + γ) (γ 2 + 2γ) 3/2 .]()

![Datasets Statistics.]()

![Distortion measures using combinatorial and h-MDS techniques, compared against PCA and results from Nickel and Kiela[28]. Closer to 0 is better.]()

![Glossary of variables and symbols used in this paper.]()

There is no perfect analogue of PCA in hyperbolic space[[29]](#b28).

A minor instability with Chamberlain et al.[[5]](#b4), Nickel and Kiela[[28]](#b27)'s formulation is that one must guard against NANs. This instability may be unavoidable in formulations that minimize hyperbolic distance with gradient descent, as the derivative of the hyperbolic distance has a singularity, that is, limy→x ∂x|d H (x, y)| → ∞ for any x ∈ H in which d H is the hyperbolic distance function. This issue can be mitigated by minimizing d 2 H , which does have a continuous derivative throughout H. We propose to do so in Section 4.2 and discuss this further in the Appendix.

Although it is particularly easy to bound precision in the Poincaré model, this fact holds generally for hyperbolic space independent of model. See Appendix D for a general lower bound argument.

We say that points are centered at a particular mean if this mean is at 0. The act of centering refers to applying an isometry that makes the mean of the points 0.

As we noted earlier, considering the distances without squares leads to a non-continuously-differentiable formulation.

Given points x 1 , . . . , xn on the unit sphere, 0 ≤x i

= n + i =j x i , x j implies there is a pair such that x i • x j ≥ -1 n-1 , i.e. an angle bounded by cos -1 (-1/(n -1)).

Note that further separation can be achieved by picking weights with a base larger than 2.

then f i is locally convex at z. The result of the lemma now follows from the fact that f is the sum of many f i and the sum of convex functions is also convex.

