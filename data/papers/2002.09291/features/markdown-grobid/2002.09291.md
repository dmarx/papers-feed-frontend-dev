# Transformer Hawkes Process

## Abstract

## 

Modern data acquisition routinely produce massive amounts of event sequence data in various domains, such as social media, healthcare, and financial markets. These data often exhibit complicated short-term and long-term temporal dependencies. However, most of the existing recurrent neural network based point process models fail to capture such dependencies, and yield unreliable prediction performance. To address this issue, we propose a Transformer Hawkes Process (THP) model, which leverages the self-attention mechanism to capture longterm dependencies and meanwhile enjoys computational efficiency. Numerical experiments on various datasets show that THP outperforms existing models in terms of both likelihood and event prediction accuracy by a notable margin. Moreover, THP is quite general and can incorporate additional structural knowledge. We provide a concrete example, where THP achieves improved prediction performance for learning multiple point processes when incorporating their relational information.

## Introduction

Event sequence data are naturally observed in our daily life. Through social media such as Twitter and Facebook, we share our experiences and respond to other users' information [(Yang et al., 2011)](#b33). In these websites, each user has a sequence of events such as tweets and interactions. Hundreds of millions of users generate large amounts of tweets, which are essentially sequences of events at different time stamps. Besides social media, event data also exist in domains like financial transactions [(Bacry et al., 2015)](#b1) and personalized healthcare [(Wang et al., 2018)](#b30). For example, in electronic medical records, tests and diagnoses of each patient can be treated as a sequence of events. Unlike other sequential data such as time series, event sequences tend to be asynchronous [(Ross et al., 1996)](#b25), which means time intervals between events are just as important as the order of them to describe their dynamics. Also, depending on specific application requirements, event data show sophisticated dependencies on their history.

Published as a conference paper in ICML 2020. â€  Zuo, Jiang and Zhao are affiliated with Georgia Tech, Li is affiliated with University of Science and Technology of China, and Zha is affiliated with Shenzhen Research Institute of Big Data, The Chinese University of Hong Kong (currently on leave from Georgia Tech). Correspondence to simiaozuo@gatech.edu, tourzhao@gatech.edu, zhahy@ cuhk.edu.cn.

Point process is a powerful tool for modeling sequences of discrete events in continuous time, and the technique has been widely applied. Hawkes process [(Hawkes, 1971;](#b10)[Isham and Westcott, 1979)](#b14) and Poisson point process are traditionally used as examples of point processes. However, the simplified assumptions of the complicated dynamics of point processes limit the models' practicality. As an example, Hawkes process states that all past events should have positive influences on the occurrence of current events. However, a user on Twitter may initiate tweets on different topics, and these events should be considered as unrelated instead of mutually-excitepd.

To alleviate the over-simplifications, likelihood-free methods [(Xiao et al., 2017a;](#)[Li et al., 2018](#b18)) and non-parametric models like kernel methods and splines [(Vere-Jones et al., 1990)](#b29) have been proposed, but the increasing complexity and quantity of collected data crave for more powerful models. With the development of neural networks, in particular deep neural networks, focuses have been placed on incorporating these flexible models into classical point processes. Because of the sequential nature of event steams, existing methods rely heavily on Recurrent Neural Networks (RNNs). Neural networks are known for their ability to capture complicated high-level features, in particular, RNNs have the representation power to model the dynamics of event sequence data. In previous works, either vanilla RNN [(Du et al., 2016)](#b7) or its variants [(Mei and Eisner, 2017;](#b20)[Xiao et al., 2017b)](#) have been used and significant progress in terms of likelihood and event prediction have been achieved.

However, there are two significant drawbacks with RNN-based models. First, recurrent neural networks, even those equipped with forget gates, such as Long Short-Term Memory [(Hochreiter and Schmidhuber, 1997)](#b13) and Gated Recurrent Units [(Chung et al., 2014)](#b5), are unlikely to capture long-term dependencies. In financial transactions, short-term effects such as policy changes are important for modeling buy-sell behaviors of stocks. On the other hand, because of the delays in asset returns, stock transactions and prices often exhibit long-term dependencies on their history. As another example, in medical domains, at times we are interested in examining short-term dependencies on symptoms such as fever and cough for acute diseases like pneumonia. But for certain types of chronic diseases such as diabetes, long-term dependencies on disease diagnoses and medications are more critical. Desirable models should be able to capture these long-term dependencies. Yet with recurrent structures, interactions between two events located far in the temporal domain are always weak [(Hochreiter et al., 2001)](#b12), even though in reality they may be highly correlated. The reason is that the probability of keeping information in a state that is far away from the current state decreases exponentially with distance.

The second drawback is trainability of recurrent neural networks. Training deep RNNs (including LSTMs) is notoriously difficult because of gradient explosion and gradient vanishing [(Pascanu et al., 2013)](#b22). In practice, single-layer and two-layer RNNs are mostly used, and they may not successfully model sophisticated dependencies among data [(Bengio et al., 1994)](#b3). Additionally, inputs are fed into the recurrent models sequentially, which means future states must be processed after the current state, rendering it impossible to process all the events in parallel. This limits RNNs' ability to scale to large problems.

Recently, convolutional neural network variants that are tailored for analyzing sequential data [(Oord et al., 2016;](#b21)[Gehring et al., 2017;](#b9)[Yin et al., 2017)](#b34) have been proposed to better capture long-Figure [1](#): Illustration of dependency computation between the last event (the red triangle) and its history (the blue circles). RNN-based NHP models dependencies through recursion. THP directly and adaptively models the event's dependencies on its history. Convolution-based models enforce static dependency patterns. term effects. However, these models enforce many unnecessary dependencies. This particular downside plus the increased computational burdens deem these models insufficient.

To address the above concerns, we propose the Transformer Hawkes Process (THP) model that is able to capture both short-term and long-term dependencies whilst enjoying computational efficiency. Even though the Transformer [(Vaswani et al., 2017)](#b28) is widely adopted in natural language processing, it has rarely been used in other applications. We remark that such an architecture is not readily applicable to event sequences that are defined in a continuous-time domain. To the best of our knowledge, our proposed THP is the first of this type in point process literature.

Building blocks of THP are the self-attention modules [(Bahdanau et al., 2014)](#b2). These modules directly model dependencies among events by assigning attention scores. A large score between two events implies a strong dependency, and a small score implies a weak one. In this way, the modules are able to adaptively select events that are at any temporal distance from the current event. Therefore, THP has the ability to capture both short-term and long-term dependencies. Figure [1](#) demonstrates dependency computation of different models.

The non-recurrent structure of THP facilitates efficient training of multi-layer models. Transformerbased architectures can be as deep as dozens of layers [(Devlin et al., 2018;](#b6)[Radford et al., 2019)](#b23), where deeper layers capture higher order dependencies. The ability to capture such dependencies creates models that are more powerful than RNNs, which are often shallow. Also, THP allows full parallelism when calculating dependencies across all events, i.e., the computation between any two event pairs is independent with each other. This yields a model presenting strong efficiency.

Our proposed model is quite general, and can incorporate additional structural knowledge to learn more complicated event sequence data, such as multiple point processes over a graph.

In social networks, each user has her own sequence of events, like tweets and comments. Sequences among users can be related, for example, a tweet from a user may trigger retweets from her followers. We can use graphs to model these follower-followee relationships [(Zhou et al., 2013;](#b37)[Farajtabar et al., 2017)](#b8), where each vertex corresponds to a specific user and each edge represents connections between the two associated users. We propose an extension to THP that integrates these relational graphs [(Borgatti et al., 2009;](#b4)[Linderman and Adams, 2014)](#b19) into the self-attention module via a similarity metric among users. Such a metric can be learned by our proposed graph regularization.

We experiment THP on five datasets to evaluate both validation likelihood and event prediction accuracy. Our THP model exhibits superior performance to RNN-based models in all these experiments. We further test our structured-THP on two additional datasets, where the model achieves improved prediction performance for learning multiple point processes when incorporating their relational information. Our code is available at [https://github.com/SimiaoZuo/ Transformer-Hawkes-Process](https://github.com/SimiaoZuo/Transformer-Hawkes-Process).

The rest of this paper is organized as follows: Section 2 introduces the background; Section 3 introduces our proposed transformer Hawkes process model; Section 4 demonstrates an extension of our model to multiple event sequences on graphs; Section 5 presents numerical experiments on various real datasets; Section 6 draws a brief conclusion.

## Background

We briefly review Hawkes Process [(Hawkes, 1971)](#b10), [Neural Hawkes Process (Mei and Eisner, 2017)](#), and Transformer [(Vaswani et al., 2017)](#b28) in this section.

â€¢ Hawkes Process is a doubly stochastic point process, whose intensity function is defined as

$Î»(t) = Âµ + j:t j <t Ïˆ(t -t j ). (1$$)$Here Âµ is the base intensity and Ïˆ(â€¢) is a pre-specified decaying function, i.e., exponential function and power-law function. Intuitively, Eq. 1 means that each of the past events has a positive contribution to occurrence of the current event, and this influence decreases through time. However, a major limitation of this formulation is the simplification that history events can never inhibit occurrence of future events, which is unrealistic in complex real-life scenarios.

â€¢ Neural Hawkes Process generalizes the classical Hawkes process by parameterizing its intensity function with recurrent neural networks. Specifically,

$Î»(t) = K k=1 Î» k (t) = K k=1 f k w k h(t) , t âˆˆ (0, T ], where f k (x) = Î² k log 1 + exp x Î² k . Prediction is then P[k t = k] = Î» k (t)/Î»(t).$Here, Î»(t) is the intensity function, K is the number of event types, and h(t)s are the hidden states of the event sequence, obtained by a continuous-time LSTM (CLSTM) module. CLSTM is an interpolated version of the standard LSTM, and it allows us to generate outputs in a continuous-time domain. Also, f k (â€¢) is the softplus function with parameter Î² k that guarantees a positive intensity. One downside of the neural Hawkes process is that intrinsic weaknesses of RNNs are inherited, namely the model is unable to capture long-term dependencies and is difficult to train.

â€¢ Transformer is an attention-based model that has been broadly applied in tasks such as machine translation [(Devlin et al., 2018)](#b6) and language modeling [(Radford et al., 2019)](#b23). Despite its success in natural language processing, it has rarely been used in other areas. We remark that the Transformer architecture is not directly applicable to model point processes. In particular, time intervals between any two events can be arbitrary in event streams, while in natural languages, words are observed on regularly spaced time intervals. Therefore, we need to generalize the architecture to a continuous-time domain.

## Model

We introduce our proposed Transformer Hawkes Process. Suppose we are given an event sequence S = {(t j , k j )} L j=1 of L events, where each event has type k j âˆˆ {1, 2, . . . , K}, with a total number of K types. Then each pair (t j , k j ) corresponds to an event of type k j occurs at time t j .

## Transformer Hawkes Process

The key ingredient of our proposed THP model is the self-attention module. Different from RNNs, the attention mechanism discards recurrent structures. However, our model still needs to be aware of the temporal information of inputs, i.e., time stamps. Therefore, analogous to the original positional encoding method [(Vaswani et al., 2017)](#b28), we propose to use a temporal encoding procedure, defined by

$[z(t j )] i = ï£± ï£´ ï£´ ï£´ ï£² ï£´ ï£´ ï£´ ï£³ cos t j /10000 i-1 M , if i is odd, sin t j /10000 i M , if i is even. (2)$Eq. 2 uses trigonometric functions to define a temporal encoding for each time stamp, i.e., for each t j , we deterministically computes z(t j ) âˆˆ R M , where M is the dimension of encoding. Other temporal encoding methods can also be applied, such as the relative position representation model [(Shaw et al., 2018)](#b26), where two temporal encoding matrices are learned instead of predefined.

Besides temporal encoding, we train an embedding matrix U âˆˆ R MÃ—K for the event types, where the k-th column of U is a M-dimensional embedding for event type k. For any event of type k j , let k j be its one-hot encoding (a K-dimensional vector with all 0s except for the k j -th index, which has value 1), then its embedding is Uk j . Notice that for any event and its corresponding time stamp (t j , k j ), the temporal encoding z(t j ) and the event embedding Uk j both reside in R M . Embedding of the event sequence S = {(t j , k j )} L j=1 is then specified by

$X = UY + Z , (3$$)$where

$Y = [k 1 , k 2 , . . . , k L ] âˆˆ R KÃ—L$is the collection of event type one-hot encodings, and Z = [z(t 1 ), z(t 2 ), . . . , z(t L )] âˆˆ R MÃ—L is the concatenation of event time encodings. Notice that X âˆˆ R LÃ—M and each row of X corresponds to the embedding of a specific event in the sequence.

After the initial encoding and embedding layers, we pass X through the self-attention module. Specifically, we compute the attention output S by

$S = Softmax QK âˆš M K V, where Q = XW Q , K = XW K , V = XW V . (4$$)$Here Q, K, and V are the query, key, and value matrices obtained by different transformations of X, and

$W Q , W K âˆˆ R MÃ—M K , W V âˆˆ R MÃ—M V$are weights for the linear transformations, respectively. In practice using multi-head self-attention to increase model flexibility is more beneficial for data fitting. To facilitate this, different attention outputs S 1 , S 2 , . . . , S H are computed using different sets of weights

${W Q h , W K h , W V h } H h=1 .$The final attention output for the event sequence is then

$S = S 1 , S 2 , . . . , S H W O ,$where W O âˆˆ R HM V Ã—M is an aggregation matrix.

We highlight that the self-attention module is able to directly select events whose occurrence time is at any distance from the current time. The j-th column of the attention weights Softmax(QK / âˆš M K ) signifies event t j 's extent of dependency on its history. In contrast, RNNbased models encode history information sequentially via hidden representations of the events, i.e., the state of t j depends on that of t j-1 , which in turn depends on t j-2 , etc. Should any of these encodings be weak, i.e., the RNN fails to learn sufficient relevant information for event t k , hidden representations of any event t j where j â‰¥ k will be inferior.

The attention output S is then fed through a position-wise feed-forward neural network, generating hidden representations h(t) of the input event sequence:

$H = ReLU SW FC 1 + b 1 W FC 2 + b 2 , h(t j ) = H(j, :). (5$$)$Here

$W FC 1 âˆˆ R MÃ—M H , W FC 2 âˆˆ R M H Ã—M , b 1 âˆˆ R M H$, and b 2 âˆˆ R M are parameters of the neural network, and W FC 2 has identical columns. The resulting matrix H âˆˆ R LÃ—M contains hidden representations of all the events in the input sequence, where each row corresponds to a particular event.

To avoid "peeking into the future", our attention algorithm is equipped with masks. That is, when computing the attention output S(j, :) (the j-th row of S), we mask all the future positions, i.e., we set Q(j, j+1), Q(j, j+1), . . . , Q(j, L) to inf. This will avoid the softmax function from assigning dependency to events in the future.

In practice we stack multiple self-attention modules together, and inputs are passed through each of these modules sequentially. In this way our model is able to capture high level dependencies. We remark that stacking RNN/LSTM is not plausible because gradient explosion and gradient vanishing will render the stacked model difficult to train. Figure [2](#fig_0) illustrates the architecture of THP.

## Continuous Time Conditional Intensity

Dynamics of temporal point processes are described by a continuous conditional intensity function. Eq. 5 only generates hidden representations for discrete time stamps, and the associated intensity is also discrete. Therefore an interpolated continuous time intensity function is in need.

Let Î»(t|H t ) be the conditional intensity function for our model, where H t = {(t j , k j ) : t j < t} is the history up to time t. We define different intensity functions for different event types, i.e., for every k âˆˆ {1, 2, . . . , K}, define Î» k (t|H t ) as the conditional intensity function for events of type k. The conditional intensity function for the entire event sequence is defined by

$Î»(t|H t ) = K k=1 Î» k (t|H t ),$where each of the type-specific intensity takes the form

$Î» k (t|H t ) = f k Î± k t -t j t j current + w k h(t j ) history + b k base . (6$$)$In Eq. 6, time is defined on interval t âˆˆ [t j , t j+1 ), and f k (x) = Î² k log 1 + exp(x/Î² k ) is the softplus function with "softness" parameter Î² k . The reason for choosing this particular function is twofold: first, the softplus function ensures that the intensity is positive; second, "softness" of the softplus function guarantees stable computation and avoids dramatic changes in the intensity. Now we explain each term in Eq. 6 in detail: â€¢ The "current" influence is an interpolation between two observed time stamps t j and t j+1 , and Î± k modulates importance of the interpolation. When t = t j , i.e., a new observation comes in, this influence is 0. When t â†’ t j+1 , the conditional intensity function is no longer continuous. As a matter of fact, Eq. 6 is continuous everywhere except for the observed events {(t j , k j )}. However, these "jumps" in intensity is a non-factor when computing likelihood.

â€¢ The "history" term contains two parts: a vector w k that transforms the hidden states of the THP model into a scalar, and the hidden states h(t) (Sec. 3.1) themselves that encode past events up to time t.

â€¢ The "base" intensity represents probability of occurrence of events without considering history information.

With our proposed conditional intensity function, next time stamp prediction and next event type prediction is given by[foot_0](#foot_0)

$p(t|H t ) = Î»(t|H t ) exp - t t j Î»(Ï„|H Ï„ )dÏ„ , t j+1 = âˆž t j t â€¢ p(t|H t )dt, and k j+1 = argmax k Î» k (t j+1 |H j+1 ) Î»(t j+1 |H j+1$) .

(7)

## Training

For any sequence S over an observation interval [t 1 , t L ], given its conditional intensity function Î»(t|H t ), the log-likelihood is

$(S) = L j=1 log Î»(t j |H j ) event log-likelihood - t L t 1 Î»(t|H t )dt non-event log-likelihood . (8$$)$Model parameters are learned by maximizing the log-likelihood across all sequences. Concretely, suppose we have N sequences S 1 , S 2 , . . . , S N , then the goal is to find parameters that solve max N i=1

$(S i ),$where (S i ) is the log-likelihood of event sequence S i . This optimization problem can be efficiently solved by stochastic gradient type algorithms like ADAM [(Kingma and Ba, 2014)](#b16). Additionally, techniques that help stabilizing training such as layer normalization [(Ba et al., 2016)](#b0) and residual connection [(He et al., 2016)](#b11) are also applied.

In Eq. 8, one challenge is to compute

$Î› = t L t 1$Î»(t|H t )dt, the non-event log-likelihood. Because of the softplus function, there is no closed-form computation for this integral, and a proper approximation is needed.

The first approach to approximate the non-event log-likelihood is by using Monte Carlo integration [(Robert and Casella, 2013)](#b24): Here u i âˆ¼ Unif(t j-1 , t j ) is sampled from a uniform distribution with support [t j-1 , t j ]. Notice that Î»(u i ) and âˆ‡Î»(u i ) can be calculated by feed-forward and back-propagation through the model, respectively. Moreover, Eq. 9 yields an unbiased estimation to the integral, i.e., E[ Î› MC ] = Î›.

$Î› MC = L j=2 (t j -t j-1 ) 1 N N i=1 Î»(u i ) , âˆ‡ Î› MC = L j=2 (t j -t j-1 ) 1 N N i=1 âˆ‡Î»(u i ) . (9)$The second approach is to apply numerical integration methods, which are faster because of the elimination of sampling. For example, the trapezoidal rule [(Stoer and Bulirsch, 2013)](#b27) states that

$Î› NU = L j=2 t j -t j-1 2 Î»(t j |H j ) + Î»(t j-1 |H j-1 )(10)$qualifies as an approximation to Î›. Other higher order methods such as the Simpson's rule [(Stoer and Bulirsch, 2013)](#b27) can also be applied. Even though approximations build upon numerical integration algorithms are biased, in practice they are affordable. This is because the conditional intensity (Eq. 6) uses softplus as its activation function, which is highly smooth and ensures bias introduced by linear interpolations (Eq. 10) between consecutive events are small.

## Structured Transformer Hawkes Process

THP is quite general and can incorporate additional structural knowledge. We consider multiple point processes, where any two of them can be related. Such relationships are often described by a graph G = (V , E), where V is the vertex set, and each vertex is associated with a point process. Also, E is the edge set, where each edge signifies relational information between the corresponding two vertices. Figure [3](#fig_1) illustrates event sequences on a graph. The graph encodes relationships among vertices, and further indicates potential interactions. We propose to model all the point processes with a single THP, and the heterogeneity of the vertices' point processes is handled by a vertex embedding approach.

Suppose we have an event sequence S = {(t j , k j , v j )} L j=1 , where t j and k j are time stamps and event types as before. Further, v j âˆˆ {1, 2, . . . , |V |} is an indicator to which vertex the event belongs. In addition to the event embedding and the temporal encoding (Eq. 3), we introduce a vertex embedding matrix E âˆˆ R MÃ—|V | , where the j-th column of E denotes the M-dimensional embedding for vertex j. Let v j be the one-hot encoding of v j , then embedding of S is specified by

$X = UY + EV + Z , where V = [v 1 , v 2 , . . . , v L ] âˆˆ R |V |Ã—L$is the concatenation of vertices, and other terms are defined in Eq. 3.

The graph attention output is defined by

$S = Softmax QK âˆš M K + A V value , where A = (EV) â„¦(EV),(11)$where Q, K, and V value are the same[foot_1](#foot_1) as in Eq. 4. Matrix A âˆˆ R LÃ—L is the vertex similarity matrix, where each entry A ij signifies the similarity between two vertices v i and v j , and â„¦ âˆˆ R MÃ—M is a metric to be learned. To extend the graph self-attention module to a multi-head setting, we use different metric matrices {â„¦ j } H j=1 for different heads. We remark that unlike RNN-based shallow models, in structured-THP, multiple multi-head self-attention modules can be stacked (Figure [2](#fig_0)) to learn high level representations, a feature that enables learning of complicated similarities among vertices. Moreover, the vertex similarity matrix enables modeling of even more complicated structured data, such as sequences on dynamically evolving graphs.

With the incorporation of relational information, we need to modify the conditional intensity function accordingly. As an extension to Eq. 6, where each type of events has its own intensity, we define a different intensity function for each event type and each vertex. Specifically,

$Î»(t|H t ) = K k=1 |V | v=1 Î» k,v (t|H t ), t âˆˆ [t j , t j+1 ), where Î» k,v (t|H t ) = f k,v Î± k,v t -t j t j + w k,v h(t) + b k,v .$Model parameters are learned by maximizing the log-likelihood (Eq. 8) across all sequences. Concretely, suppose we have N sequences S 1 , S 2 , . . . , S N , then parameters are obtained by solving max N i=1

$(S i ) + ÂµL graph (V, â„¦),$where Âµ is a hyper-parameter and

$L graph (V, â„¦) = |V | k=1 k j=1 -log 1 + exp(V j â„¦V k ) + 1{(v j , v k ) âˆˆ E} V j â„¦V k .$Here L graph (V, â„¦) is a regularization term that encourages V j â„¦V k to be large when there exists an edge between v j and v k . Which means if two vertices are connected in graph G, then the regularizer will promote attention between them, and vice versa.

Notice that in the simplest case, A in Eq. 11 can be some transformation of the adjacency matrix, i.e., A ij = 1 if (v i , v j ) âˆˆ E, and 0 otherwise. However, we believe that this constraint is too strict, i.e., some connected vertices may not behave similarly. Therefore, we treat the graph as a guide and introduce a regularization term that encourages A to be similar to the adjacency matrix, but not enforce it. In this way, our model is more flexible.

## Experiments

We compare THP against existing models: Recurrent Marked Temporal Point Process (RMTPP, [Du et al. (2016)](#b7)), Neural Hawkes Process (NHP, [Mei and Eisner (2017)](#b20)), Time Series Event Sequence (TSES, [Xiao et al. (2017b)](#)), and Self-attentive Hawkes Processes (SAHP, Zhang et al. ( [2019](#)))[foot_2](#foot_2) . We evaluate the models by per-event log-likelihood (in nats) and event prediction accuracy on heldout test sets. Details about training are deferred to the appendix.

## Datasets

We adopt several datasets to evaluate the models. Table [1](#tab_0) summarizes statistics of the datasets.

â€¢ Retweets [(Zhao et al., 2015)](#b36): The Retweets dataset contains sequences of tweets, where each sequence contains an origin tweet (i.e., some user initiates a tweet), and some follow-up tweets. We record the time and the user tag of each tweet. Further, users are grouped into three categories based on the number of their followers: "small", "medium", and "large".

â€¢ MemeTrack [(Leskovec and Krevl, 2014)](#b17): This dataset contains mentions of 42 thousand different memes spanning ten months. We collect data on over 1.5 million documents (blogs, web articles, etc.) from over 5000 websites. Each sequence in this dataset is the life-cycle of a particular meme, where each event (usage of meme) is associated with a time stamp and a website id.

â€¢ Financial Transactions [(Du et al., 2016)](#b7): This financial dataset contains transaction records of a stock in one day. We record the time (in milliseconds) and the action that was taken in each transaction. The dataset is a single long sequence with only two types of events: "buy" and "sell". The event sequence is further partitioned by time stamps.

â€¢ Electrical Medical Records [(Johnson et al., 2016)](#b15): MIMIC-II medical dataset collects patients' visit to a hospital's ICU in a seven-year period. We treat the visits of each patient as a separate sequence, where each event in the sequence contains a time stamp and a diagnosis.

â€¢ StackOverflow [(Leskovec and Krevl, 2014)](#b17): StackOverflow is a question-answering website. The website rewards users with badges to promote engagement in the community, and the same badge can be rewarded multiple times to the same user. We collect data in a two-year period, and we treat each user's reward history as a sequence. Each event in the sequence signifies receipt of a particular medal.

â€¢ 911-Calls[foot_3](#foot_3) : The 911-Calls dataset contains emergency phone call records. Calling time, location of the caller, and nature of the emergency are logged for each record. We consider three types of emergencies: EMS, fire, and traffic. We treat location of callers (given by zipcodes) as vertices on a relational information graph. Zipcodes are ranked based on the number of recorded calls, and only the top 75 zipcodes are kept. An undirected edge exists between two vertices if their zipcodes are within 10 of each other. â€¢ Earthquake[foot_4](#foot_4) : This dataset contains time and location of earthquakes in China in an eight-year period. We partition the records into two categories: "small" and "large". A relational information graph is built based on geographical locations of the earthquakes, i.e., each province is a vertex and earthquakes are sequences on the vertices. Two vertices are connected if their associated provinces are neighbors.

## Training Details

To facilitate comparison with previous works, all the datasets are used by [Du et al. (2016)](#b7) and [Mei and Eisner (2017)](#b20), except for 911-Calls and Earthquake. Details about data pre-processing and train-dev-test split, as well as downloadable links, can be found in the aforementioned papers.

For the 911-Calls dataset, we exclude zipcodes (and the associated events) whose occurrences are scarce, i.e., we only keep zipcodes that have the top 75 frequent occurrences. The dataset contains 141 types of events, and we cluster them into three categories, namely EMS, fire, and traffic. We do not exclude any events in the Earthquake dataset. Earthquakes are partitioned into two categories, "small" and "large", where small earthquakes are the ones whose Richter scale is equal to or lower than 1.0. We perform this partition because of the imbalance in data, i.e., most of the recorded earthquakes are on small magnitude. Models are trained on 911-Calls and Earthquake with different number of training events. In each experiment, we equally divide the events that are not in the training set in half to construct the development set and the test set.

There are three sets of hyper-parameters that we use, and they are summarized in Table [2](#). Besides layer normalization and residual connection, we also employ the dropout technique to avoid overfitting. Table [3](#) contains the specific parameters that are applied for the training of each dataset. In the table, from left to right columns specify: name of the dataset, the set of applied hyper-parameters, batch size, learning rate, and solver for the integral approximation (MC stands for Monte Carlo integration, and NU stands for numerical integration with the trapezoidal rule), respectively. In the 911-Calls and the Earthquakes datasets, we also employ the graph regularization method, and the corresponding regularization parameter is set to be 0.01 in all the experiments. We use a single NVIDIA RTX graphics card to run all the experiments.  model fits the data well and outperforms all the baselines in all the experiments. Figure [5](#fig_2) visualizes attention patterns of THP. We can see that each attention head employs a different pattern to capture dependencies. Moreover, while attention heads in the first layer tend to focus on individual events, the attention patterns in the last layer are more uniformly distributed. This is because features in deeper layers are already transformed by attention heads in shallow layers.

## Event Prediction Comparison

For point processes, event prediction is just as important as data fitting. Eq. 7 enables us to predict future events. In practice, however, adding additional prediction layers on top of the THP model yields better performance. Specifically, given the hidden representation h(t j ) for event (t j , k j ), the next event type and time predictions are as follows.

â€¢ The next event type prediction is

$k j+1 = argmax k p j+1 (k), where p j+1 = Softmax W type h(t j ) ,$where W type âˆˆ R KÃ—M is the predictor parameter, and p j (k) is the k-th element of p j âˆˆ R K .

â€¢ The next event time prediction is

$t j+1 = W time h(t j ),$where W time âˆˆ R 1Ã—M is the predictor parameter.

To learn the predictor parameters, the loss function is equipped with a cross-entropy term for event type prediction and a mean square error term for event time prediction. Concretely, for  an event sequence S = {(t j , k j )} L j=1 , let k 1 , k 2 , . . . , k L be the ground-truth one-hot encodings for the event types, we define

$L type (S) = L j=2 -k j log( p j ), and L time (S) = L j=2 (t j -t j ) 2 .$Notice that we do not predict the first event. Then, given event sequences {S i } N i=1 , we seek to solve min

$N i=1 -(S i ) + L type (S i ) + L time (S i ),$where (S i ) is the log-likelihood (Eq. 8) of S i .

To evaluate model performance, we predict every held-out event (t j , k j ) given its history H j , i.e., for a test sequence of length L, we make L -1 predictions. We evaluate event type prediction by accuracy and event time prediction by Root Mean Square Error (RMSE). Table [5](#tab_2) and [Table 6](#tab_3) summarize experiment results. We can see that THP outperforms the baselines in all these tasks. The datasets we adopted vary significantly in average sequence length, i.e., the average length in Financial Transactions is 2074 while it is only 4 in MIMIC-II. In all the three datasets, THP improves upon RNN-based models by a notable margin. The results demonstrate that THP is able to capture both short-term and long-term dependencies better than existing methods.

Figure [6](#fig_3) illustrates run-to-run variance of THP, NHP, and RMTPP. The error bars are wide because of how the data are split. Held-out test sets are constructed by randomly sampling some events from the entire dataset. That is, at times "important" events are sampled out, which will yield unsatisfactory model performance. Our results are better than all the baselines in all the individual experiments.

## THP vs. Structured-THP

Now we demonstrate by incorporating relational information, THP achieves improved performance.

Baseline models are constructed as following: for each vertex on a relational graph G, there exists a point process that consists of time and type of events. These event sequences are learned separately by both THP and NHP, i.e., we do not allow information sharing among vertices in these models.

To integrate G into THP, we consider two approaches. The first approach is by allowing full attention, i.e., information from one vertex can be shared with all the other vertices. The second approach is by using the neighborhood graph, which is constructed based on spatial proximity. In this approach, a specific vertex can only share information with its neighbors. We fit a structured-THP to both of the cases.

Figure [7](#fig_4) summarizes experimental results. We can see that THP is comparable or better than NHP in both validation likelihood and event prediction, which further demonstrates that THP can model complicated dynamics better than RNN-based models. Notice that THP-F, the structured-THP with full attention, yields a much better likelihood than the baseline models, which means relational information sharing can help the models in capturing latent dynamics. However, unlike likelihood, THP-F does not show consistent improvements in event prediction. This is because when the number of training events is small, the model cannot build a sufficient informationsharing heuristic. Also, the performance drop when the number of training events is large is due to the inhomogeneity of data. This demonstrates that the full attention scheme results in undesirable dependencies on which the attention heads focus. THP-S successfully resolves this issue by eliminating such dependencies from the attention heads' span based on spatial closeness of vertices. In this way, THP-S further improves upon THP-F, especially in event prediction tasks.

## Ablation Study

We perform ablation study on Retweets and MemeTrack, and we evaluate models by validation log-likelihood. We inspect variants of THP by removing the self-attention and the temporal encoding mechanisms. Moreover, we test the effect of temporal encoding on NHP. Table [7](#) summarizes experimental results. As shown, both the self-attention module and the temporal encoding contribute to model performance.

We examine the models' sensitivity to the number of parameters on the Retweets dataset. As shown in Table [8](#tab_4), our model is not sensitive to its number of parameters. Without the recurrent structure, Transformer-based models often have large number of parameters, but our THP model can outperform RNN-based models with fewer parameters. In all the experiments, using a small model (about 100-200k parameters) will suffice. In comparison, NHP has about 1000k and TSES has about 2000k parameters to achieve the best performance, which are much larger than THP. We also include run-time comparison in Table [8](#tab_4). We conclude that THP is efficient in both model size and training speed.

Table [7](#): Log-likelihood of variants of NHP and THP fitted on Retweets and Meme-Track. TE stands for temporal encoding (Eq. 2), and PE stands for positional encoding [(Vaswani et al., 2017)](#b28)

## Conclusion

In this paper we present Transformer Hawkes Process, a framework for analyzing event streams. Event sequence data are common in our daily life, and they exhibit sophisticated short-term and long-term dependencies. Our proposed model utilizes the self-attention mechanism to capture both of these dependencies, and meanwhile enjoys computational efficiency. Moreover, THP is quite general and can integrate structural knowledge into the model. This facilitates analyzing more complicated data, such as event sequences on graphs. Experiments on various real-world datasets demonstrate that THP achieves state-of-the-art performance in terms of both likelihood and event prediction accuracy.

![Figure 2: Architecture of the Transformer Hawkes Process. Each event sequence S is fed through embedding layers and N multi-head self-attention modules. Outputs of the THP are hidden representations of events in S, with history information encoded.]()

![Figure 3: Illustration of event sequences on a graph. Sequences on vertices are aligned temporally to form a long sequence, and relational information among events are shown in arrows. Notice that only the structural information of the last event (the blue circle) and the third to the last event (the purple diamond) are shown. Like before, events cannot attend to future.]()

![Figure 5: Visualization of attention patterns of different attention heads in different layers. Pixel (i, j) in each figure signifies the attention weight of event (t j , k j ) attending to event (t i , k i ). Attention heads in the upper two figures are from the first layer, while they are from the last layer in the lower two figures.]()

![Figure 6: Prediction error rates of THP, NHP, and RMTPP. Based on a same train-dev-test splitting ratio, each dataset is sampled five times to produce different train, development and test sets. Error bars are generated according to these experiments.]()

![Figure 7: Log-likelihood and prediction accuracy of NHP, THP, THP with full attention (THP-F), and structured-THP (THP-S) fitted on the 911-Calls (upper two figures) and the Earthquake (lower two figures) datasets. Models are trained using different number of events.]()

![]()

![Datasets statistics. From left to right columns: name of the dataset, number of event types, number of events in the dataset, and average length per sequence.]()

![Log-likelihood comparison.]()

![Event type prediction accuracy comparison. Here FIN is the Financial Transactions dataset, and SO is the StackOverflow dataset.]()

![Event time prediction RMSE comparison. Here FIN is the Financial Transactions dataset, and SO is the StackOverflow dataset.]()

![Sensitivity to the number of parameters and run-time comparison. Speedup is the speed of THP against NHP.]()

Without causing any confusion, denote H t j as H j .

We use V value to denote the value matrix instead of V, which denotes the vertices.

This is a concurrent work that also employs the Transformer architecture, and we only include results reported in their paper.

The dataset is available on www.kaggle.com/mchirico/montcoalert.

The dataset is provided by China Earthquake Data Center. (http://data.earthquake.cn)

