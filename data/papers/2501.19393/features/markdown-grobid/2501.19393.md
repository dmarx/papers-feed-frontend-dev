# s1: Simple test-time scaling

## Abstract

## 

Test-time scaling is a promising new approach to language modeling that uses extra test-time compute to improve performance. Recently, OpenAI's o1 model showed this capability but did not publicly share its methodology, leading to many replication efforts. We seek the simplest approach to achieve test-time scaling and strong reasoning performance. First, we curate a small dataset s1K of 1,000 questions paired with reasoning traces relying on three criteria we validate through ablations: difficulty, diversity, and quality. Second, we develop budget forcing to control test-time compute by forcefully terminating the model's thinking process or lengthening it by appending "Wait" multiple times to the model's generation when it tries to end. This can lead the model to doublecheck its answer, often fixing incorrect reasoning steps. After supervised finetuning the Qwen2.5-32B-Instruct language model on s1K and equipping it with budget forcing, our model s1-32B exceeds o1-preview on competition math questions by up to 27% (MATH and AIME24). Further, scaling s1-32B with budget forcing allows extrapolating beyond its performance without test-time intervention: from 50% to 57% on AIME24. Our model, data, and code are open-source at [https: //github.com/simplescaling/s1](https://github.com/simplescaling/s1). * Equal contribution. ZY and NM started the project. WS, NM and ZY collected the prompts, XL, ZY and NM, built the data pipeline, LZ and WS proposed using a 1K subset and ZY and NM built budget forcing.

## Introduction

Performance improvements of language models (LMs) over the past years have largely relied on scaling up train-time compute using large-scale self-supervised pretraining [(Kaplan et al., 2020;](#b31)[Hoffmann et al., 2022)](#b21). The creation of these powerful models has set the stage for a new scaling paradigm built on top of them: test-time scaling. The aim of this approach is to increase the compute at test time to get better results. There has been much work exploring this idea [(Snell et al., 2024;](#b51)[Welleck et al., 2024)](#b64), and the viability of this paradigm was recently validated by OpenAI o1 [(OpenAI, 2024)](#). o1 has demonstrated strong reasoning performance with consistent gains from scaling test-time compute. OpenAI describes their approach as using largescale reinforcement learning (RL) implying the use of sizable amounts of data [(OpenAI, 2024)](#). This has led to various attempts to replicate their models relying on techniques like Monte Carlo Tree Search [(Gao et al., 2024b;](#)[Zhang et al., 2024a)](#), multi-agent approaches [(Qin et al., 2024)](#b47), and others [(Wang et al., 2024a;](#)[Huang et al., 2024b;](#)[2025)](#). Among these approaches, DeepSeek R1 [(DeepSeek-AI et al., 2025)](#b9) has successfully replicated o1-level performance, also employing reinforcement learning via millions of samples and multiple training stages. However, despite the large number of o1 replication attempts, none have openly replicated a clear test-time scaling behavior. Thus, we ask: what is the simplest approach to achieve both test-time scaling and strong reasoning performance?

We show that training on only 1,000 samples with next-token prediction and controlling thinking duration via a simple test-time technique we refer to as budget forcing leads to a strong reasoning model that scales in performance with more test-time compute. Specifically, we construct s1K, which consists of 1,000 carefully curated questions paired with reasoning traces and answers distilled from Gemini Thinking Experimental [(Google, 2024)](#b17). We perform supervised fine-tuning (SFT) of an off-the-shelf pretrained model 1 arXiv: [2501.19393v2 [cs.CL]](#) 3 Feb 2025 s1: Simple test-time scaling on our small dataset requiring just 26 minutes of training on 16 H100 GPUs. After training, we control the amount of test-time compute our model spends using budget forcing: (I) If the model generates more thinking tokens than a desired limit, we forcefully end the thinking process by appending an end-of-thinking token delimiter. Ending the thinking this way makes the model transition to generating its answer. (II) If we want the model to spend more test-time compute on a problem, we suppress the generation of the end-of-thinking token delimiter and instead append "Wait" to the model's current reasoning trace to encourage more exploration. Equipped with this simple recipe -SFT on 1,000 samples and test-time budget forcing -our model s1-32B exhibits test-time scaling (Figure [1](#fig_0)). Further, s1-32B is the most sample-efficient reasoning model and outperforms closed-source models like OpenAI's o1-preview (Figure [2](#)). We conduct extensive ablation experiments targeting (a) our selection of 1,000 (1K) reasoning samples and (b) our testtime scaling. For (a), we find that jointly incorporating difficulty, diversity, and quality measures into our selection algorithm is important. Random selection, selecting samples with the longest reasoning traces, or only selecting maximally diverse samples all lead to significantly worse performance (around -30% on AIME24 on average). Training on our full data pool of 59K examples, a superset of s1K, does not offer substantial gains over our 1K selection. This highlights the importance of careful data selection and echoes prior findings for instruction tuning [(Zhou et al., 2023)](#b85). For (b), we define desiderata for test-time scaling methods to compare different approaches. Budget forcing leads to the best scaling as it has perfect controllability with a clear positive slope leading to strong performance.

In summary, our contributions are: We develop simple methods for creating a sample-efficient reasoning dataset ( §2) and test-time scaling ( §3); Based on these we build s1-32B which is competitive with o1-preview ( §4); We ablate subtleties of data ( §5.1) and test-time scaling ( §5.2). We end with a discussion to motivate future work on simple reasoning ( §6). Our code, model, and data are open-source at [https://github.com/simplescaling/s1](https://github.com/simplescaling/s1).

## Reasoning data curation to create s1K

In this section, we describe our process for creating a large dataset first in §2.1 and then filtering it down to s1K in §2.2.

## Initial collection of 59K samples

We collect an initial 59,029 questions from 16 diverse sources following three guiding principles. Quality: Datasets should be of high quality; we always inspect samples and ignore datasets with, e.g., poor formatting; Difficulty: Datasets should be challenging and require significant reasoning effort; Diversity: Datasets should stem from different fields to cover different reasoning tasks. We collect datasets of two categories: Curation of existing datasets Our largest source is [Nu-minaMATH (LI et al., 2024)](#) with 30,660 mathematical problems from online websites. We also include historical AIME problems . To enhance diversity, we add OlympicArena [(Huang et al., 2024a)](#) with 4,250 questions spanning Astronomy, Biology, Chemistry, Computer Science, Geography, Mathematics, and Physics from various Olympiads. OmniMath [(Gao et al., 2024a)](#) adds 4,238 competition-level mathematics problems. We also include 2,385 problems from AGIEval [(Zhong et al., 2023)](#b83), which features questions from standardized tests like SAT and LSAT, covering English, Law, and Logic. We refer to Table [6](#) in §B for our other sources.

## New datasets in quantitative reasoning

To complement these existing datasets, we create two original datasets. s1-prob consists of 182 questions from the probability section of Stanford University's Statistics Department's PhD Qualifying Exams ([https://statistics. stanford.edu](https://statistics.stanford.edu)), accompanied by handwritten solutions that cover difficult proofs. The probability qualifying exam is held yearly and requires professional-level mathematical problem-solving. s1-teasers comprises 23 challenging brain-teasers commonly used in interview questions for quantitative trading positions. Each sample consists of a problem and solution taken from PuzzledQuant ([https: //www.puzzledquant.com/](https://www.puzzledquant.com/)). We only take examples with the highest difficulty level ("Hard").

For each question, we generate a reasoning trace and solution using the Google Gemini Flash Thinking API [(Google, 2024)](#b17) extracting its reasoning trace and response. This yields 59K triplets of a question, generated reasoning trace, and generated solution. Examples from our dataset are in §C.2. We decontaminate all samples against our evaluation questions (MATH500, GPQA Diamond, AIME24; §B.5) using 8-grams and deduplicate the data.

## Final selection of 1K samples

We could directly train on our pool of 59K questions, however, our goal is to find the simplest approach with minimal resources. Thus, we go through three stages of filtering to arrive at a minimal set of 1,000 samples relying on our three guiding data principles: Quality, Difficulty, and Diversity.

## Quality

We first remove any questions where we ran into any API errors reducing our dataset to 54,116 samples. Next, we filter out low-quality examples by checking if they contain any string patterns with formatting issues, such as ASCII art diagrams, non-existent image references, or inconsistent on topics in mathematics but also includes other sciences such as biology, physics, and economics. To select our final examples from the pool of 24,496 questions, we first choose one domain uniformly at random. Then, we sample one problem from this domain according to a distribution that favors longer reasoning traces (see §B.4 for details) as motivated in Difficulty. We repeat this process until we have 1,000 total samples. This three-stage process yields a dataset spanning 50 different domains (see Table [5](#tab_10)). In §5.1, we will show that using our three criteria in combination is important, as only relying on quality, diversity, or difficulty in isolation leads to worse datasets. Examples from our dataset are in §C.2.

## Test-time scaling

## Method

We classify test-time scaling methods into 1) Sequential, where later computations depend on earlier ones (e.g., a long reasoning trace), and 2) Parallel, where computations run independently (e.g., majority voting) [(Snell et al., 2024;](#b51)[Brown et al., 2024)](#b5). We focus on sequential scaling as intuitively we believe it should scale better, since later computations can build on intermediate results, allowing for deeper reasoning and iterative refinement. We propose new sequential scaling methods and ways to benchmark them.

## Budget forcing

We propose a simple decoding-time intervention by forcing a maximum and/or minimum number of thinking tokens at test time. Specifically, we enforce a maximum token count by simply appending the end-of-thinking token delimiter and "Final Answer:" to early exit the Figure [3](#). Budget forcing with s1-32B. The model tries to stop after "...is 2.", but we suppress the end-of-thinking token delimiter instead appending "Wait" leading s1-32B to self-correct its answer.

thinking stage and make the model provide its current best answer. To enforce a minimum, we suppress the generation of the end-of-thinking token delimiter and optionally append the string "Wait" to the model's current reasoning trace to encourage the model to reflect on its current generation. Figure [3](#) contains an example of how this simple approach can lead the model to arrive at a better answer.

## Baselines

We benchmark budget forcing with: (I) Conditional length-control methods, which rely on telling the model in the prompt how long it should generate for. We group them by granularity into (a) Token-conditional control: We specify an upper bound of thinking tokens in the prompt; [(b)](#) Step-conditional control: We specify an upper bound of thinking steps, where each step is around 100 tokens; (c) Class-conditional control: We write two generic prompts that tell the model to either think for a short or long amount of time (see §D.1 for details). (II) Rejection sampling, which samples until a generation fits a predetermined compute budget. This oracle captures the posterior over responses conditioned on its length.

## Metrics

We establish a set of desiderata as evaluation metrics to measure test-time scaling across methods. Importantly, we do not only care about the accuracy a method can achieve but also its controllability and test-time scaling slope. For each method we consider, we run a set of evaluations 𝑎 ∈  varying test-time compute on a fixed benchmark, e.g. AIME24. This produces a piece-wise linear function 𝑓 with compute as the x-axis measured in thinking tokens and accuracy as the y-axis (see Figure [1](#fig_0), where the rightmost dot for AIME24 corresponds to 𝑓 (7320) = 57%). We measure three metrics:

$Control = 1 || ∑ 𝑎∈ 𝕀(𝑎 min ≤ 𝑎 ≤ 𝑎 max ) (1)$where 𝑎 min , 𝑎 max refer to a pre-specified minimum and maximum amount of test-time compute; in our case thinking tokens. We usually only constrain 𝑎 max . As tokens generated correspond to the amount of test-time compute spent, this metric measures the extent to which a method allows controllability over the use of that test-time compute. We report it as a percentage with 100% being perfect control.

$Scaling = 1 ( || 2 ) ∑ 𝑎,𝑏∈ 𝑏>𝑎 𝑓 (𝑏) -𝑓 (𝑎) 𝑏 -𝑎 (2)$Scaling is the average slope of the piece-wise linear function.

It must be positive for useful methods and larger is better.

$Performance = max 𝑎∈ 𝑓 (𝑎)(3)$Performance is simply the maximum performance the method achieves on the benchmark. A method with monotonically increasing scaling achieves 100% performance on any benchmark in the limit. However, the methods we investigate eventually flatten out or further scaling fails due to control or context window limitations.

## Results

## Setup

Training We perform supervised finetuning on Qwen2.5-32B-Instruct using s1K to obtain our model s1-32B using basic hyperparameters outlined in §C. Finetuning took 26 minutes on 16 NVIDIA H100 GPUs with PyTorch FSDP.

Evaluation We select three representative reasoning benchmarks widely used in the field: AIME24 (of America, 2024) consists of 30 problems that were used in the 2024 American Invitational Mathematics Examination (AIME) held from Wednesday, January 31 -Thursday, February 1, 2024. AIME tests mathematical problem-solving with arithmetic, algebra, counting, geometry, number theory, probability, and other secondary school math topics. High-scoring high school students in the test are invited to participate in the United States of America Mathematics Olympiad (USAMO).

All AIME answers are integers ranging from 000 to 999, inclusive. Some AIME problems rely on figures that we provide to our model using the vector graphics language Asymptote as it cannot take image inputs. MATH500 [(Hendrycks et al., 2021)](#b20) is a benchmark of competition math problems of varying difficulty. We evaluate on the same 500 samples selected by OpenAI in prior work [(Lightman et al., 2023)](#b37). GPQA Diamond [(Rein et al., 2023)](#b49) consists of 198 s1: Simple test-time scaling Forcing 2048/4096 max thinking tokens Ignoring end-of-thinking 2x/4x/6x and appending "Wait" thus forcing it to continue reasoning when it tries to stop  PhD-level science questions from Biology, Chemistry and Physics. Experts with PhDs in the corresponding domains only achieved 69.7% on GPQA Diamond (OpenAI, 2024). When we write "GPQA" in the context of evaluation in this work, we always refer to the Diamond subset. We build on the "lm-evaluation-harness" framework [(Gao et al., 2021;](#b14)[Biderman et al., 2024)](#b4).

Other models We benchmark s1-32B against: OpenAI o1 series [(OpenAI, 2024)](#), which are closed-source models that popularized the idea of test-time scaling; DeepSeek r1 series [(Team, 2024a)](#), which are open-weight reasoning models with up to o1-level performance, concurrently released to ours; Qwen's QwQ-32B-preview [(Team, 2024b)](#), a 32B open-weight reasoning model without disclosed methodology; Sky-T1-32B-Preview [(Team, 2025)](#b57) and Bespoke-32B [(Labs, 2025)](#b34), which are open models with open reasoning data distilled from QwQ-32B-preview and r1; Google Gemini 2.0 Flash Thinking Experimental [(Google, 2024)](#b17), the API that we distill from. As it has no official evaluation scores, we use the Gemini API to benchmark it ourselves. However, the "recitation error" of the Gemini API makes evaluation challenging. [2](#foot_1) We circumvent this, by manually inserting all 30 AIME24 questions in its web interface where the error does not appear. However, we leave out MATH500 (500 questions) and GPQA Diamond (198 questions), thus they are N.A. in Table [1](#). Our model, s1-32B, is fully open including weights, reasoning data, and code.

Table 1. s1-32B is an open and sample-efficient reasoning model.

We evaluate s1-32B, Qwen, and Gemini (some entries are unknown (N.A.), see §4). Other results are from the respective reports [(Qwen et al., 2024;](#b48)[Team, 2024b;](#)[OpenAI, 2024;](#)[DeepSeek-AI et al., 2025;](#b9)[Labs, 2025;](#b34)[Team, 2025)](#b57). # ex. = number examples used for reasoning finetuning; BF = budget forcing. Model # ex. AIME 2024 MATH 500 GPQA Diamond API only o1-preview N.A. 44.6 85.5 73.3 o1-mini N.A. 70.0 90.0 60.0 o1 N.A. 74.4 94.8 77.3 Gemini 2.0 N.A. 60.0 N.A. N.A. Flash Think. Open Weights Qwen2.5-N.A. 26.7 84.0 49.0 32B-Instruct QwQ-32B N.A. 50.0 90.6 65.2 r1 ≫800K 79.8 97.3 71.5 r1-distill 800K 72.6 94.3 62.1 Open Weights and Open Data Sky-T1 17K 43.3 82.4 56.8 Bespoke-32B 17K 63.3 93.0 58.1 s1 w/o BF 1K 50.0 92.6 56.6 s1-32B 1K 56.7 93.0 59.6 4.2. Performance Test-time scaling Figure 1 shows the performance of s1-32B with budget forcing scales with more test-time compute.

In Figure [4](#fig_2) (left), we expand the plot from Figure [1](#fig_0) (middle) showing that while we can improve AIME24 performance using our budget forcing technique ( §3) and more test-time compute it does eventually flatten out at six times. Suppressing the end-of-thinking token delimiter too often can lead the model into repetitive loops instead of continued reasoning.

In Figure [4](#fig_2) (right), we show that after training Qwen2.5-32B-Instruct on our 1,000 samples to produce s1-32B and equipping it with the simple budget forcing technique, it operates in a different scaling paradigm. Scaling test-time compute on the base model via majority voting cannot catch up with the performance of s1-32B which validates our intuition from §3 that sequential scaling is more effective than parallel. We provide example generations of s1-32B in Figure [5](#).

## Sample-efficiency

In Figure [2](#) (right) and Table [1](#) we compare s1-32B with other models. We find that s1-32B is the most sample-efficient open data reasoning model. It performs significantly better than our base model (Qwen2.5-32B-Instruct) despite just training it on an additional 1,000 samples. The concurrently released r1-32B shows stronger performance than s1-32B while also only using SFT [(DeepSeek-AI et al., 2025)](#b9). However, it is trained on 800 × more reasoning samples. It is an open question whether one can achieve their performance with just 1,000 samples. Finally, our model nearly matches Gemini 2.0 Thinking on AIME24. As s1-32B is distilled from Gemini 2.0, this shows our distillation procedure was likely effective.

## Ablations

## Data Quantity, Diversity, and Difficulty

In §2 we outlined our three guiding principles in curating s1K: Quality, Difficulty, and Diversity. Here we test the importance of combining them and the overall efficacy of our selection. Only Quality (1K-random): After obtaining our high-quality reasoning chains from Gemini, we select 1,000 samples at random; not relying on our difficulty and diversity filtering at all. Table [2](#) shows this approach performs much worse than s1K across all benchmarks. Only Diversity (1K-diverse): For this dataset, we sample uniformly across domains to maximize diversity disregarding any notion of difficulty. This approach also leads to poor performance similar to 1K-random. Only Difficulty (1K-longest): Here we rely on one of our difficulty indicators introduced in §2 by selecting the 1,000 samples with the longest reasoning traces. This approach significantly boosts GPQA performance but overall still falls short of using s1K. Maximize Quantity: Finally, we compare with just training on all of our 59K Table [2](#). s1K data ablations. We budget force (BF) a maximum of around 30,000 thinking tokens for all scores in this table. This performs slightly better than the scores without BF (Table [1](#)) as it allows the model to finish with a best guess when stuck in an infinite loop. We report 95% paired bootstrap confidence intervals for differences relative to the s1K model using 10,000 bootstrap samples. E.g., the interval [-13%, 20%] means that, with 95% confidence, the true difference between 59K-full and s1K is between -13% and +20%. If the entire interval is negative, e.g. [-27%, -3%], we can confidently say that the performance is worse than s1K.

## Model

AIME 2024 MATH 500 GPQA Diamond 1K-random 36.7 90.6 52.0 s1K 50.0 93.0 57.6

samples, a superset of all the 1K-sample versions. This leads to a strong model but uses much more resources. To finetune on 59K samples, we use 394 H100 GPU hours while s1-32B only required 7 H100 GPU hours. Moreover, relying only on s1K is extremely competitive as shown in §2.

Overall, combining all three criteria -Quality, Difficulty, Diversity -via our methodology in §2 is key for sampleefficient reasoning training.

## Test-time scaling methods

Table 3. Ablations on methods to scale test-time compute on AIME24. || refers to the number of evaluation runs used to estimate the properties; thus a higher value indicates more robustness. Bold indicates our chosen method and the best values. BF = budget forcing, TCC/SCC/CCC = token/step/class-conditional control, RS = rejection sampling. Method Control Scaling Performance || BF 100% 15 56.7 5 TCC 40% -24 40.0 5 TCC + BF 100% 13 40.0 5 SCC 60% 3 36.7 5 SCC + BF 100% 6 36.7 5 CCC 50% 25 36.7 2 RS 100% -35 40.0 5 s1: Simple test-time scaling [AIME24]

Alice and Bob play the following game. A stack of 𝑛 tokens lies before them. The players take turns with Alice going first. On each turn, the player removes either 1 token or 4 tokens from the stack. Whoever removes the last token wins. Find the number of positive integers 𝑛 less than or equal to 2024 for which there exists a strategy for Bob that guarantees that Bob will win the game regardless of Alice's play.

The problem asks for the number of positive integers 𝑛 ≤ 2024 such that Bob has a winning strategy. This is a typical impartial game that can be analyzed using the Sprague-Grundy theorem or by directly finding the winning and losing positions. Let 𝑊 be the set of winning positions (number of tokens 𝑛 such that the player whose turn it is can force a win) and 𝐿 be the set of losing positions. [...]

Let 𝑃 (𝑛) be the statement "the player whose turn it is when there are 𝑛 tokens has a winning strategy. 𝑃 (0) is false (the player whose turn it is and faces 0 tokens has already lost). Consider the small values of 𝑛: 𝑛 = 1: The player whose turn it is can take 1 token and win. So 𝑃 (1) is true.

$1 ∈ 𝑊 . 𝑛 = 2:$The player whose turn it is can take 1 token, leaving 1 token for the opponent.

Since 1 ∈ 𝑊 , the opponent wins. So 𝑃 (2) is false. 2 ∈ 𝐿. 𝑛 = 3: The player whose turn it is can take 1 token, leaving 2 tokens for the opponent. Since 2 ∈ 𝐿, the player whose turn it is wins. So 𝑃 (3) is true. 3 ∈ 𝑊 .[...] We are looking for the number of positive integers 𝑛 ≤ 2024 for which Bob has a winning strategy. This means that if the game starts with 𝑛 tokens, and Alice goes first, Bob can win. This happens if and only if 𝑛 is a losing position (because if 𝑛 ∈ 𝐿, then Alice's first move must lead to a winning position for Bob). [...] Let's try to find a pattern in the losing positions 𝐿 = {0 [, 2, 5, 7, 10, 12, 15, 17, 20, 22, ...}.](#) Differences between consecutive terms: 2, 3, 2, 3, 2, 3, 2, 3, 2, ... The pattern of differences is alternating 2, 3. [...] The losing positions are of the form 5𝑚 or 5𝑚 + 2, where 𝑚 ≥ 0. We need to find the number of positive integers 𝑛 ≤ 2024 that are in the set of losing positions 𝐿.

$[...] Case 1: 𝑛 = 5𝑚, where 𝑚 ≥ 1. 1 ≤ 5𝑚 ≤ 2024 1∕5 ≤ 𝑚 ≤ 2024∕5 = 404.8 Since 𝑚 is an integer, 1 ≤ 𝑚 ≤ 404. The number of values of 𝑚 is 404. Case 2: 𝑛 = 5𝑚 + 2, where 𝑚 ≥ 0. 5𝑚 + 2 ≤ 2024 5𝑚 ≤ 2022 𝑚 ≤ 2022∕5 = 404.4 Since 𝑚 is an in- teger, 0 ≤ 𝑚 ≤ 404. The number of values of 𝑚 is 404 -0 + 1 = 405.$The total number of positive integers 𝑛 ≤ 2024 that are losing positions is 404 + 405 = 809 .

## [MATH500]

Find the projection of 𝑎 onto 𝑏 = ( 2 6 3

$) if 𝑎 ⋅ 𝑏 = 8.$The projection of vector 𝐚 onto vector 𝐛 is given by the formula:

$proj 𝐛 𝐚 = 𝐚 ⋅ 𝐛 ‖𝐛‖ 2 𝐛$We are given 𝐛 =

( 2 6 3

) and 𝐚 ⋅ 𝐛 = 8.

First, we need to find the magnitude squared of 𝐛, which is ‖𝐛‖ 2 .

$‖𝐛‖ 2 = 𝐛⋅𝐛 = 2 2 +6 2 +3 2 = 4+36+9 = 49.$
## Now we can plug the values into the projection formula:

proj 𝐛 𝐚 = 8 49 𝐛 Substitute the vector 𝐛:

$proj 𝐛 𝐚 = 8 49$( 2 6 3

)

Multiply the scalar by each component of the vector:

$proj 𝐛 𝐚 = ⎛ ⎜ ⎜ ⎜ ⎝ 8 49 × 2 8 49 × 6 8 49 × 3 ⎞ ⎟ ⎟ ⎟ ⎠ = ⎛ ⎜ ⎜ ⎜ ⎝ 16 49 48 49 24 49 ⎞ ⎟ ⎟ ⎟ ⎠$Final Answer: The final answer is

$⎛ ⎜ ⎜ ⎜ ⎝ 16 49 48 49 24 49 ⎞ ⎟ ⎟ ⎟ ⎠ [GPQA]$A quantum mechanical particle of mass 𝑚 moves in two dimensions in the following potential, as a function of the polar coordinates (𝑟, 𝜃):

$𝑉 (𝑟, 𝜃) = 1 2 𝑘𝑟 2 + 3 2 𝑘𝑟 2 cos 2 (𝜃)$Find the energy spectrum. Hint: Write the potential in Cartesian coordinates.

The problem asks for the energy spectrum of a particle in a given 2D potential. The potential is given in polar coordinates (𝑟, 𝜃):

$𝑉 (𝑟, 𝜃) = 1 2 𝑘𝑟 2 + 3 2 𝑘𝑟 2 cos 2 (𝜃).$We can rewrite the potential as:

$𝑉 (𝑟, 𝜃) = 1 2 𝑘𝑟 2 (1 + 3 cos 2 (𝜃)).$The Hamiltonian for a particle in 2D is given by:

$𝐻 = - ℏ 2 2𝑚 ( 𝜕 2 𝜕𝑥 2 + 𝜕 2 𝜕𝑦 2 ) + 𝑉 (𝑥, 𝑦).$In polar coordinates (𝑟, 𝜃), the Laplacian operator is:

$∇ 2 = 1 𝑟 𝜕 𝜕𝑟 ( 𝑟 𝜕 𝜕𝑟 ) + 1 𝑟 2 𝜕 2 𝜕𝜃 2 .$So the Hamiltonian in polar coordinates is:

$𝐻 = - ℏ 2 2𝑚 [ 1 𝑟 𝜕 𝜕𝑟 ( 𝑟 𝜕 𝜕𝑟 ) + 1 𝑟 2 𝜕 2 𝜕𝜃 2 ] +𝑉 (𝑟, 𝜃).$The time-independent Schrödinger equation is 𝐻𝜓 = 𝐸𝜓. We can try to separate variables by assuming a solution of the form 𝜓(𝑟, 𝜃) = 𝑅(𝑟)Θ(𝜃). [[...]](#) This confirms the energy spectrum is:

$𝐸 = ℏ √ 𝑘 𝑚 ( 2𝑛 𝑥 + 𝑛 𝑦 + 3 2$) .

## Final

Answer:

$𝐸 = ℏ √ 𝑘 𝑚 ( 2𝑛 𝑥 + 𝑛 𝑦 + 3 2 ) .$Figure [5](#). Example model outputs. We pick a question from AIME24 (left), MATH500 (middle), and GPQA (right), where our model generates the correct answer. The black text is the prompt, the light blue text is the reasoning trace, and the blue text is the answer of s1-32B. The gray ellipsis [...] indicates that the text was trimmed to fit this page, but the generated text is actually longer.

## Budget forcing

In Table [3](#) we compare the test-time scaling methods we have introduced in §3. Overall, we find that budget forcing provides perfect control, good scaling, and leads to our best AIME24 score. Thus, this is the method we use for s1-32B in Figure [1](#fig_0) and in §4. In Table [4](#tab_7), we compare different strings for extrapolating performance. We find that "Wait" generally gives the best performance.

## Class-conditional control

We provide benchmark scores for this method in §D.1 and summarize three findings here:

(1) Token-conditional control fails without budget forcing, as our model cannot reliably count tokens -even when trained to do so.

(2) Under step-conditional control, the model generates a similar total number of tokens when given different step targets, as the model goes from few steps with many tokens per step, to many steps with few tokens in each step. Thus, the model learns to hack its way around the compute constraint making the controllability of this method mediocre.

(3) Class-conditional control can work -telling a model to simply think longer can increase its test-time compute and performance, which leads good scaling in Table [3](#). Figure [6](#). Rejection sampling on AIME24 with s1-32B. We sample with a temperature of 1 until all generations have less than (from left to right) 3500, 4000, 5000, 8000, and 16000 thinking tokens requiring an average of 655, 97, 8, 3, 2, and 1 tries per sample. spect a question, which was answered correctly by the model when rejection sampling for ≤ 4000, but not for the ≤ 8000 token setting. In the ≤ 4000 setting the model directly jumps to the correct approach, while for the ≤ 8000 setting it backtracks a lot. We hypothesize that there is a correlation such that shorter generations tend to be the ones where the model was on the right track from the start, whereas longer ones tend to be ones where the model made mistakes and thus backtracks or questions itself. This leads to longer samples often being wrong when rejection sampling and thus the inverse scaling trend.

## Discussion and related work

## Sample-efficient reasoning

Models There are a number of concurrent efforts to build models that replicate the performance of o1 (OpenAI, 2024). For example, DeepSeek-r1 and k1.5 [(DeepSeek-AI et al., 2025;](#b9)[Team et al., 2025)](#b56) are built with reinforcement learning methods, while others rely on SFT using tens of thousands of distilled examples [(Team, 2025;](#b57)[Xu et al., 2025;](#b70)[Labs, 2025)](#b34). We show that SFT on only 1,000 examples suffices to build a competitive reasoning model matching o1-preview and produces a model that lies on the pareto frontier (Figure [2](#)). Further, we introduce budget forcing which combined with our reasoning model leads to the first reproduction of OpenAI's test-time scaling curves [(OpenAI, 2024)](#). Why does supervised finetuning on just 1,000 samples lead to such performance gains? We hypothesize that the model is already exposed to large amounts of reasoning data during pretraining which spans trillions of tokens. Thus, the ability to perform reasoning is already present in our model. Our sample-efficient finetuning stage just activates it and we scale it further at test time with budget forcing. This is similar to the "Superficial Alignment Hypothesis" presented in LIMA [(Zhou et al., 2023)](#b85), where the authors find that 1,000 examples can be sufficient to align a model to adhere to user preferences.

## Benchmarks and methods

To evaluate and push the limits of these models, increasingly challenging benchmarks have been introduced, such as Olympiad-level science competitions [(He et al., 2024;](#b19)[Jain et al., 2024;](#b29)[Zhong et al., 2023)](#b83) and others [(Srivastava et al., 2023;](#b52)[Glazer et al., 2024;](#b16)[Su et al., 2024;](#b53)[Kim et al., 2024;](#b32)[Phan et al., 2025)](#b46). To enhance models' performance on reasoning-related tasks, researchers have pursued several strategies: Prior works have explored continuing training language models on specialized corpora related to mathematics and science [(Azerbayev et al., 2023;](#b2)[Yang et al., 2024)](#b71), sometimes even synthetically generated data [(Yu et al., 2024)](#b74). Others have developed training methodologies specifically aimed at reasoning performance [(Zelikman et al., 2022;](#b76)[2024;](#)[Luo et al., 2025;](#b42)[Yuan et al., 2025;](#b75)[Wu et al., 2024a)](#). Another significant line of work focuses on prompting-based methods to elicit and improve reasoning abilities, including methods like Chainof-Thought prompting [(Wei et al., 2023;](#b63)[Yao et al., 2023a;](#)[b;](#b34)[Bi et al., 2023;](#b3)[Fu et al., 2023;](#b11)[Zhang et al., 2024b;](#)[Xiang et al., 2025;](#b67)[Hu et al., 2024)](#b23). These combined efforts aim to advance the reasoning ability of language models, enabling them to handle more complex and abstract tasks effectively.

## Test-time scaling

Methods As we introduce in §3, we differentiate two methods to scale test-time compute: parallel and sequential. The former relies on multiple solution attempts generated in parallel and selecting the best outcome via specific criteria. These criteria include choosing the most frequent response for majority voting or the best response based on an external reward for Best-of-N [(Brown et al., 2024;](#b5)[Irvine et al., 2023;](#)[Snell et al., 2024)](#b51). Unlike repeated sampling, previous sequential scaling methods let the model generate solution attempts sequentially based on previous attempts, allowing it to refine each attempt based on previous outcomes [(Snell et al., 2024;](#b51)[Hou et al., 2025;](#b22)[Lee et al., 2025)](#b35). Tree-based search methods [(Gandhi et al., 2024;](#b12)[Wu et al., 2024b)](#) offer a hybrid approach between sequential and parallel scaling, such as Monte-Carlo Tree Search (MCTS) [(Liu et al., 2024;](#b40)[Zhang et al., 2023;](#b79)[Zhou et al., 2024;](#b84)[Choi et al., 2023)](#b8) and guided beam search [(Xie et al., 2023)](#b68). REBASE [(Wu et al., 2024b)](#) employs a process reward model to balance exploitation and pruning during tree search. Empirically, REBASE has been shown to outperform sampling-based methods and MCTS [(Wu et al., 2024b)](#). Reward models [(Lightman et al., 2023;](#b37)[Wang et al., 2024b](#);c) play a key role in these methods. They come in two variants: outcome reward models and process reward models. Outcome reward models [(Xin et al., 2024;](#b69)[Ankner et al., 2024)](#b0) assign a score to complete solutions and are particularly useful in Best-of-N selection, while process reward models [(Lightman et al., 2023;](#b37)[Wang et al., 2024b;](#)[Wu et al., 2024b)](#) assess individual reasoning steps and are effective in guiding tree-based search methods.

## Limits to further test-time scaling

We have shown that budget forcing allows extrapolating test-time compute in §4, e.g., improving AIME24 performance from 50% to 57%. However, it has two key limitations when scaling further: it eventually flattens out (Figure [4](#fig_2)), and the context window of the underlying language model constrains it. Despite these constraints, our work shows test-time scaling across a wide range of accuracies (Figure [1](#fig_0)), partly because scaling down test-time compute behaves predictably and does not suffer from these constraints.

Continuing test-time scaling will require approaches that can further extrapolate test-time compute. How can we get such extrapolation? There may be improvements to budget 2048 8192 32768 131072 Average thinking time (tokens) 30 40 50 60 Accuracy (%) REBASE Majority Sequential scaling Figure 7. Scaling further with parallel scaling methods. All metrics averaged over the 30 questions in AIME24. Average thinking tokens for REBASE do not account for the additional compute from the reward model. For sequential scaling, we prompt the model to use up to (from left to right) 32, 64, 256, and 512 steps. For REBASE and majority voting we generate 16 parallel trajectories to aggregate across. forcing such as rotating through different strings, not only "Wait", or combining it with frequency penalties or higher temperature to avoid repetitive loops. An exciting direction for future work is also researching whether applying budget forcing to a reasoning model trained with reinforcement learning yields better extrapolation; or if RL allows for new ways of test-time scaling beyond budget forcing. Our work defines the right metrics ( §3.2) -Control, Scaling, and Performance -to enable future research and progress on extrapolating test-time compute. Parallel scaling as a solution Parallel scaling offers one solution to the limits of sequential scaling, thus we augment our sequentially scaled model with two methods: (I) Majority voting: After generating 𝑘 solutions, the final solution is the most frequent one across generations; (II) Tree search via REBASE: We use the REBASE process reward model, which is initialized from LLaMA-34B and further finetuned on a synthetic process reward modeling dataset [(Wu et al., 2024b)](#). We then aggregate the solutions generated by REBASE via majority voting. As shown in Figure [7](#), augmenting our model with REBASE scales better than majority voting, and even sequential scaling in this scenario. However, REBASE requires an additional forward pass at each step for the reward model adding some computation overhead. For sequential scaling, when prompted to use up to 512 steps, for 12 out of the 30 evaluation questions the model generates a response that exceeds the context window leading to a large performance drop. Overall, we find that these parallel scaling methods complement sequential scaling thus they offer an avenue for scaling test-time compute even further; beyond fixed context windows.

## Impact Statement

Language models with strong reasoning capabilities have the potential to greatly enhance human productivity, from assisting in complex decision-making to driving scientific breakthroughs. However, recent advances in reasoning, such as OpenAI's o1 and DeepSeek's r1, lack transparency, limiting broader research progress. Our work aims to push the frontier of reasoning in a fully open manner, fostering innovation and collaboration to accelerate advancements that ultimately benefit society.

Contents 1 Introduction 2 Reasoning data curation to create s1K 2.1 Initial collection of 59K samples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.2 Final selection of 1K samples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Test-time scaling 3.1 Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2 Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 Results 4.1 Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.2 Performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 Ablations 5.1 Data Quantity, Diversity, and Difficulty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.2 Test-time scaling methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Discussion and related work 6.1 Sample-efficient reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6.2 Test-time scaling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A Evaluation determinism B s1K details B.1 s1K summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B.2 Dataset composition for full 59K questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B.3 s1K grading prompt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B.4 s1K diversity selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B.5 Decontamination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C Training details C.1 Training Ablations: Sequence length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C.2 Training Samples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D Test-time scaling details D.1 Sequential scaling ablations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D.2 Examples for rejection sampling ablation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

## A. Evaluation determinism

We run our evaluations using vLLM [(Kwon et al., 2023)](#b33) as it is faster than the alternatives we tried. However, we find that even when using the same random seeds and greedy sampling, evaluation scores can change significantly across runs:

• Different batch sizes causing different results see [https://github.com/vllm-project/vllm/issues/ 5898](https://github.com/vllm-project/vllm/issues/5898)

• Continuing generations causing different results see [https://github.com/vllm-project/vllm/issues/ 11783](https://github.com/vllm-project/vllm/issues/11783)

• Changes in tensor parallelism causing different results

As our model generates long reasoning traces prior to its answer, small numeric changes can snowball into large differences. We encounter many generations that are exactly the same for thousands of tokens and then suddenly differ in one token eventually ending up with an entirely different answer. To partly counter this issue we generally run our final evaluations using full precision unless otherwise indicated. Dataset composition for full 59K questions

## B. s1K details B.1. s1K summary

Table 6. Composition of full 59K questions.

Thinking and response lengths are measured in tokens using the Qwen2.5-32B-Instruct tokenizer [(Qwen et al., 2024)](#b48). In addition to excluding our evaluation benchmark, AIME24, we also exclude AIME questions from 2022-2023 as we use these 90 questions during our development stage of s1-32B.

## Source

Description #Samples Avg. thinking length NuminaMATH (LI et al., 2024) Math problems from online websites 30660 4.1K MATH (Hendrycks et al., 2021) Math problems from competitions 11999 2.9K OlympicArena (Huang et al., 2024a) Astronomy, Biology, Chemistry, Computer Science, Geography, Math, and Physics olympiad questions 4250 3.2K OmniMath (Gao et al., 2024a) Math problems from competitions 4238 4.4K AGIEval (Zhong et al., 2023; Ling et al., 2017; Hendrycks et al., 2021; Liu et al., 2020; Zhong et al., 2019; Wang et al., 2021) English, Law, Logic and Math problems from the SAT, LSAT and other exams 2385 1.2K xword Crossword puzzles 999 0.7K OlympiadBench (He et al., 2024) Math and Physics olympiad questions 896 3.9K AIME (1983-2021) American Invitational Mathematics Examination 890 4.7K TheoremQA (Chen et al., 2023) Computer Science, Finance, Math, and Physics university-level questions relating to theorems 747 2.1K USACO (Shi et al., 2024) Code problems from the USA Computing Olympiad 519 3.6K JEEBench (Arora et al., 2023) Chemistry, Math, and Physics problems used in the university entrance examination of the Indian Institute of Technology 515 2.9K GPQA (Rein et al., 2023) PhD-Level Science Questions 348 2.9K SciEval (Sun et al., 2024) Biology, Chemistry, and Physics problems from various sources 227 0.7K s1-prob Stanford statistics qualifying exams 182 4.0K LiveCodeBench (Jain et al., 2024) Code problems from coding websites (LeetCode, AtCoder, and CodeForces) 151 3.5K s1-teasers Math brain-teasers crawled from the Internet 23 4.1K All 59K questions Composite of the above datasets with reasoning traces and solutions 59029 3.6K s1: Simple test-time scaling

## B.3. s1K grading prompt

To grade whether an example is correct for our dataset selection in §2, we use the prompt in Figure [8](#fig_3).

You are an AI assistant for grading a science problem. The user will provide you with the question itself, an attempt made by a student and the correct answer to the problem. Your job is to judge whether the attempt is correct by comparing it with the correct answer. If the expected solution concludes with a number or choice, there should be no ambiguity. If the expected solution involves going through the entire reasoning process, you should judge the attempt based on whether the reasoning process is correct with correct answer if helpful.

The user will provide the attempt and the correct answer in the following format:

## # Problem {problem} ## Attempt {attempt} ## Correct answer {solution}

Explain your reasoning, and end your response on a new line with only "Yes" or "No" (without quotes). 

## B.4. s1K diversity selection

Algorithm 1 provides our algorithm for selecting data in our diversity selection stage. As mentioned in §2, we also include samples from some specific benchmarks we perceive as high-quality. None of the samples overlap with our final evaluation.

## B.5. Decontamination

We filter all samples by checking for an 8-gram overlap between the selected examples and the evaluation benchmarks: MATH500, GPTQA Diamond, and AIME24. We exclude questions with more than an 8-gram overlap.

s1: Simple test-time scaling Algorithm 1 Two-stage sampling for s1K 1: Input:  := Set of 24,496 questions with features 2: Output:  := Set of 1,000 selected questions 3:  ← ∅ Initialize the output set (only tracks unique elements) 4: for 𝑞 ∈  do 5: if IsGeminiCorrect(𝑞) and (IsAIME(𝑞) or IsGPQA(𝑞)) then 6:  ←  ∪ {𝑞} 7: Select all correct AIME/GPQA solutions 8: else if IsGeminiCorrect(𝑞) and IsMATH(𝑞) and ThinkingLength(𝑞) > 5600 then 9:  ←  ∪ {𝑞} 10: Select correct MATH500 solutions with long chains 11: end if 12: end for 13:  ← All available domains 14: Initialize domain pool 15: while || < 1000 do 16: 𝑑 ← RandomChoice() 17: Randomly select a domain 18: 𝑄 𝑑 ← Questions in domain 𝑑 19: Get questions from this domain 20: ranks ← RankByThinkingLength(𝑄 𝑑 ) 21: Rank by thinking length 22: weights ← 2 -ranks 23: Apply power-law weighting 24: 𝑞 ← WeightedSample(𝑄 𝑑 , weights) 25: Sample favoring longer chains 26:  ←  ∪ {𝑞} 27: Add selected question 28: 𝑄 𝑑 ← 𝑄 𝑑 ⧵ {𝑞} 29: if 𝑄 𝑑 = ∅ then 30:  ←  ⧵ {𝑑} 31: Remove exhausted domains 32: end if 33: end while

## C. Training details

We take a model that has already been pretrained and instruction tuned and further finetune it for reasoning. Specifically, we use Qwen2.5-32B-Instruct [(Qwen et al., 2024)](#b48), which on math tasks generally matches or outperforms the larger Qwen2.5-72B-Instruct [(Qwen et al., 2024)](#b48) or other open models [(Dubey et al., 2024;](#b10)[Groeneveld et al., 2024;](#b18)[Muennighoff et al., 2024)](#b43). We use token delimiters to separate the thinking stage from the answering stage. We enclose the thinking stage with <|im_start|>think and <|im_start|>answer; both preceded and followed by a newline. Samples from our dataset are in §C.2. We use basic fine-tuning hyperparameters: we train for 5 epochs with a batch size of 16 for a total of 315 gradient steps. We train in bfloat16 precision with a learning rate of 1𝑒 -5 warmed up linearly for 5% (16 steps) and then decayed to 0 over the rest of training (299 steps) following a cosine schedule. We use the AdamW optimizer [(Loshchilov & Hutter, 2019)](#b41) with 𝛽 1 = 0.9, 𝛽 2 = 0.95 and weight decay of 1𝑒 -4. We do not compute loss on questions, only on reasoning traces and solutions. We ensure the sequence length is large enough to avoid cutting off any samples; a setting we ablate in §C.1. The training takes just 26 minutes on 16 NVIDIA H100 GPUs.  We find that a shorter training sequence length leads to longer reasoning traces at test time. This is because when training with a shorter sequence length the answer section of the training sample is more commonly cut off. Inversely, when the training sequence length is longer, more samples appear in their entirety with the section where the model answers. Thus the model receives more gradient updates where it learns to generate an answer following its chain. This in turn leads to a higher log probability of the answer section at any point during the generation and thus shorter reasoning traces at test time.

## C.1. Training Ablations: Sequence length

Performance-wise, we also find that the model trained with a longer sequence length performs better. Thus we opt for the longest training sequence length as it leads to better performance and makes inference more efficient by leading to shorter reasoning traces.

## C.2. Training Samples

Table 8, Table 9, Table 10 contain training samples from s1K.

Table 8. s1K sample stemming from s1-prob. The black text is the question and the yellow text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with Gemini, which we use for training.

You are given integrable random variables 𝑋, 𝑌 0 and 𝑍 0 on the same probability space (Ω,  , ℙ), and two 𝜎-algebras

$ ⊂  ,  ⊂  . For 𝑘 = 1, 2, … ,, let 𝑌 𝑘 ∶= 𝔼[𝑋|𝜎(, 𝑍 0 , … , 𝑍 𝑘-1 )], 𝑍 𝑘 ∶= 𝔼[𝑋|𝜎(, 𝑌 0 , … , 𝑌 𝑘-1 )].$(a) Show that there exist integrable random variables 𝑌 ∞ and 𝑍 ∞ such that as

$𝑛 → ∞ both 𝔼[|𝑌 𝑛 -𝑌 ∞ |] → 0 and 𝔼[|𝑍 𝑛 -𝑍 ∞ |] → 0. (b) Prove that almost surely 𝑌 ∞ = 𝑍 ∞ .$1. Introduce the notations,  𝑛 ∶= 𝜎(, 𝑍 0 , … , 𝑍 𝑛-1 ) and  𝑛 ∶= 𝜎(, 𝑌 0 , … , 𝑌 𝑛-1 ), for all 𝑛 ≥ 1 and  0 ∶= ,  0 ∶= .

Clearly, both are filtrations and by definition,

$𝑌 𝑛 = 𝔼 [ 𝑋| 𝑛 ] and 𝑍 𝑛 = 𝔼 [ 𝑋| 𝑛 ] , for all 𝑛 ≥ 0. Thus { 𝑌 𝑛 } 𝑛≥0 (or { 𝑍 𝑛 } 𝑛≥0 ) is a Doob's Martingale with respect to filtration {  𝑛 } 𝑛≥0 (or {  𝑛 } 𝑛≥0$) and hence is U.I., 𝑋 being integrable. Now apply the fact that a Martingale is U.I. if and only if it converges in 𝐿 1 and conclude.

2. We provide two different proofs.

1. Observe the following identity which follows from Tower Property.

## 𝔼

[

$𝑌 𝑛 | 𝑛 ] = 𝔼 [ 𝔼 [ 𝑋| 𝑛 ] | 𝑛 ] = 𝔼 [ 𝔼 [ 𝑋| 𝑛 ] | 𝑛 ] = 𝔼 [ 𝑍 𝑛 | 𝑛 ] . (4$$) Note that 𝔼|𝔼 [ 𝑌 𝑛 | 𝑛 ] -𝔼 [ 𝑌 ∞ | 𝑛 ] | ≤ 𝔼|𝑌 𝑛 -𝑌 ∞ | = 𝑜(1) and by Levy's Upward Theorem, 𝔼 [ 𝑌 ∞ | 𝑛 ] 𝐿 1 ⟶ 𝔼 [ 𝑌 ∞ | ∞ ] , where  ∞ = 𝜎 ( ∪ 𝑛≥0  𝑛 ) = 𝜎(, 𝑌 0 , 𝑌 1 …). It is evident that 𝑌 ∞ ∈ 𝑚 ∞ (since it is almost sure limit of 𝑌 𝑛 ∈ 𝑚 𝑛 ) and hence 𝔼 [ 𝑌 ∞ | ∞ ] = 𝑌 ∞ almost surely. Combining the above observations we conclude that 𝔼 [ 𝑌 𝑛 | 𝑛 ] 𝐿 1 ⟶ 𝑌 ∞ . Similarly, 𝔼 [ 𝑍 𝑛 | 𝑛 ] 𝐿 1 ⟶ 𝑍 ∞ . Now invoke Equation (4), to conclude that 𝑌 ∞ = 𝑍 ∞ almost surely.$2. Since 𝑋 is integrable, we have by Levy's Upward Theorem,

$𝑌 ∞ = lim 𝑛→∞ 𝑌 𝑛 = lim 𝑛→∞ 𝔼 [ 𝑋| 𝑛 ] = 𝔼 [ 𝑋| ∞ ] . Similarly, 𝑍 ∞ = 𝔼 [ 𝑋| ∞ ]$. On the otherhand, in first proof we have observed that

$𝑌 ∞ ∈ 𝑚 ∞ and hence 𝑌 ∞ ∈ 𝑚 ∞ ∩ 𝑚 ∞ = 𝑚 (  ∞ ∩  ∞ )$. This yields the following.

$𝑌 ∞ = 𝔼 [ 𝑌 ∞ | ∞ ∩  ∞ ] = 𝔼 [ 𝔼 [ 𝑋| ∞ ] | ∞ ∩  ∞ ] = 𝔼 [ 𝑋| ∞ ∩  ∞ ] . Similarly, 𝑍 ∞ = 𝔼 [ 𝑋| ∞ ∩  ∞ ]$. This proves that 𝑌 ∞ = 𝑍 ∞ almost surely.

Let's analyze the problem. We are given two sequences of random variables 𝑌 𝑘 and 𝑍 𝑘 defined by conditional expectations. We need to show that these sequences converge in 𝐿 1 and that their limits are equal almost surely. Part (a): Convergence in 𝐿 1 . The sigma-algebras involved are increasing:

$ 𝑘 = 𝜎(, 𝑍 0 , … , 𝑍 𝑘-1 )  𝑘 = 𝜎(, 𝑌 0 , … , 𝑌 𝑘-1 )$For the 𝑌 𝑘 sequence:

$𝑌 1 = 𝔼[𝑋|𝜎()] 𝑌 2 = 𝔼[𝑋|𝜎(, 𝑍 0 )] 𝑌 3 = 𝔼[𝑋|𝜎(, 𝑍 0 , 𝑍 1 )] ...$The sequence of sigma-algebras 𝜎(, 𝑍 0 , … , 𝑍 𝑘-1 ) is increasing. By the Martingale Convergence Theorem (for conditional expectations), since 𝑋 is integrable, the sequence 𝑌 𝑘 converges almost surely and in

$𝐿 1 to 𝔼[𝑋|𝜎(, 𝑍 0 , 𝑍 1 , …)]. Let 𝑌 ∞ = 𝔼[𝑋|𝜎(, 𝑍 0 , 𝑍 1 , …)].$s1: Simple test-time scaling

Consider the limit sigma-algebra  = 𝜎( ∪  ∪ 𝜎(𝑌 0 , 𝑍 0 , …)).

We have

$𝑌 ∞ = 𝔼[𝑋|𝜎(, 𝑍 0 , 𝑍 1 , …)] and 𝑍 ∞ = 𝔼[𝑋|𝜎(, 𝑌 0 , 𝑌 1 , …)]. Let  = 𝜎(, 𝑍 0 , 𝑍 1 , …) ∨ 𝜎(, 𝑌 0 , 𝑌 1 , …). Consider 𝔼[𝑋|]. Consider the random variable 𝑋. Then 𝑌 ∞ = lim 𝑛 𝔼[𝑋| 𝑛 ] and 𝑍 ∞ = lim 𝑛 𝔼[𝑋| 𝑛 ]. Let  ∞ = 𝜎( ∪  ∪ 𝜎(𝑌 0 , 𝑍 0 , …)). Consider 𝐸 = {𝜔 ∶ 𝑌 ∞ (𝜔) ≠ 𝑍 ∞ (𝜔)}. Suppose 𝑃 (𝐸) > 0.$Consider the conditional expectation with respect to the join of the sigma-algebras.

Let

$ ∞ = 𝜎(, , 𝑌 0 , 𝑍 0 , …). Consider 𝔼[𝑋| ∞ ]. Then 𝔼[𝔼[𝑋| ∞ ]|, 𝑍 0 , …] = 𝔼[𝑋|, 𝑍 0 , …] = 𝑌 𝑛+1 . And 𝔼[𝔼[𝑋| ∞ ]|, 𝑌 0 , …] = 𝔼[𝑋|, 𝑌 0 , …] = 𝑍 𝑛+1 . So 𝑌 ∞ = 𝔼[𝑋|𝜎(, 𝑍 0 , 𝑍 1 , …)] and 𝑍 ∞ = 𝔼[𝑋|𝜎(, 𝑌 0 , 𝑌 1 , …)]. Let  ∞ = 𝜎(, 𝑍 0 , 𝑍 1 , …) and  ∞ = 𝜎(, 𝑌 0 , 𝑌 1 , …). Consider 𝔼[𝑋| ∞ ∨  ∞ ]. Then 𝔼[𝔼[𝑋| ∞ ∨  ∞ ]| ∞ ] = 𝔼[𝑋| ∞ ] = 𝑌 ∞ . And 𝔼[𝔼[𝑋| ∞ ∨  ∞ ]| ∞ ] = 𝔼[𝑋| ∞ ] = 𝑍 ∞ . This means 𝑌 ∞ = 𝔼[𝑋| ∞ ∨  ∞ ] a.s. and 𝑍 ∞ = 𝔼[𝑋| ∞ ∨  ∞ ] a.s. Therefore, 𝑌 ∞ = 𝑍 ∞ a.s. Solution:$(a) For the sequence 𝑌 𝑘 , the 𝜎-algebras  𝑘 = 𝜎(, 𝑍 0 , … , 𝑍 𝑘-1 ) are increasing as 𝑘 increases. Since 𝑋 is integrable, by the Martingale Convergence Theorem for conditional expectations, the sequence 𝑌 𝑘 = 𝔼[𝑋| 𝑘 ] converges almost surely and in

$𝐿 1 to 𝑌 ∞ = 𝔼[𝑋|𝜎(, 𝑍 0 , 𝑍 1 , …)].$Similarly, for the sequence 𝑍 𝑘 , the 𝜎-algebras  𝑘 = 𝜎(, 𝑌 0 , … , 𝑌 𝑘-1 ) are increasing.

Since 𝑋 is integrable, by the Martingale Convergence Theorem, the sequence 𝑍 𝑘 = 𝔼[𝑋| 𝑘 ] converges almost surely and in

$𝐿 1 to 𝑍 ∞ = 𝔼[𝑋|𝜎(, 𝑌 0 , 𝑌 1 , …)]. (b) Let  ∞ = 𝜎(, 𝑍 0 , 𝑍 1 , …) and  ∞ = 𝜎(, 𝑌 0 , 𝑌 1 , …). We have 𝑌 ∞ = 𝔼[𝑋| ∞ ] and 𝑍 ∞ = 𝔼[𝑋| ∞ ]. Consider the 𝜎-algebra  =  ∞ ∨  ∞ = 𝜎(, , 𝑌 0 , 𝑍 0 , 𝑌 1 , 𝑍 1 , …). Consider 𝑊 = 𝔼[𝑋|]. We have  ∞ ⊆ , so 𝔼[𝑊 | ∞ ] = 𝔼[𝔼[𝑋|]| ∞ ] = 𝔼[𝑋| ∞ ] = 𝑌 ∞ . Since 𝑊 is -measurable, 𝔼[𝑊 | ∞ ] = 𝑌 ∞ implies that 𝑌 ∞ is the conditional expectation of 𝑊 given  ∞ . But since 𝑌 ∞ is already  ∞ -measurable, we have 𝔼[𝑊 | ∞ ] = 𝑊 if 𝑊 is  ∞ -measurable, which is not necessarily true. However, we know that 𝔼[𝑌 ∞ | ∞ ] = 𝑌 ∞ and 𝔼[𝑍 ∞ | ∞ ] = 𝑍 ∞ . Consider 𝔼[𝑋| ∞ ∨  ∞ ]. Then 𝔼[𝔼[𝑋| ∞ ∨  ∞ ]| ∞ ] = 𝔼[𝑋| ∞ ] = 𝑌 ∞ . This implies that 𝔼[𝑋| ∞ ∨  ∞ ] = 𝑌 ∞ almost surely. Similarly, 𝔼[𝔼[𝑋| ∞ ∨  ∞ ]| ∞ ] = 𝔼[𝑋| ∞ ] = 𝑍 ∞ . This implies that 𝔼[𝑋| ∞ ∨  ∞ ] = 𝑍 ∞ almost surely. Therefore, 𝑌 ∞ = 𝑍 ∞ almost surely.$Final Answer: The final answer is 𝑌 ∞ = 𝑍 ∞ s1: Simple test-time scaling Table [9](#). s1K sample stemming from s1-teasers. The black text is the question and the yellow text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with Gemini, which we use for training.

Alice and Bob each have a coin and flip it until they get a heads. If Bob flipped his coin more times than Alice, what is the expected number of times Alice flipped her coin?

## 4/3

The problem asks for the expected number of times Alice flipped her coin, given that Bob flipped his coin more times than Alice.

Let 𝑋 be the number of flips Alice makes until she gets a head.

Let 𝑌 be the number of flips Bob makes until he gets a head. 𝑋 and 𝑌 are independent random variables following a geometric distribution with parameter 𝑝 = 0.5 (probability of getting a head).

The probability mass function for a geometric distribution is 𝑃 (𝐾 = 𝑘) = (1 -𝑝) 𝑘-1 𝑝, for 𝑘 = 1, 2, … .

In this case, 𝑝 = 0.5, so 𝑃 (𝐾 = 𝑘) = (0.5) 𝑘-1 (0.5) = (0.5) 𝑘 = 1 2 𝑘 . We are given the condition that Bob flipped his coin more times than Alice, which means 𝑌 > 𝑋. We want to find the expected value of 𝑋 given that 𝑌 > 𝑋, i.e., 𝐸 [[𝑋|𝑌 > 𝑋]](#). The formula for conditional expectation is

$𝐸[𝑋|𝐴] = ∑ 𝑥 𝑥𝑃 (𝑋 = 𝑥|𝐴). Also, 𝑃 (𝑋 = 𝑥|𝐴) = 𝑃 (𝑋=𝑥∩𝐴) 𝑃 (𝐴)$. In our case, 𝐴 is the event 𝑌 > 𝑋. We need to find 𝑃 (𝑌 > 𝑋).

$𝑃 (𝑌 > 𝑋) = ∑ ∞ 𝑥=1 ∑ ∞ 𝑦=𝑥+1 𝑃 (𝑋 = 𝑥, 𝑌 = 𝑦) Since 𝑋 and 𝑌 are independent, 𝑃 (𝑋 = 𝑥, 𝑌 = 𝑦) = 𝑃 (𝑋 = 𝑥)𝑃 (𝑌 = 𝑦) = 1 2 𝑥 1 2 𝑦 = 1 2 𝑥+𝑦 . 𝑃 (𝑌 > 𝑋) = ∑ ∞ 𝑥=1 ∑ ∞ 𝑦=𝑥+1 1 2 𝑥+𝑦 = ∑ ∞ 𝑥=1 1 2 𝑥 ∑ ∞ 𝑦=𝑥+1 1 2 𝑦$The inner sum is a geometric series:

$∑ ∞ 𝑦=𝑥+1 ( 1 2 ) 𝑦 = ( 1 2 ) 𝑥+1 + ( 1 2 ) 𝑥+2 + … This is a geometric series with first term 𝑎 = ( 1 2 ) 𝑥+1 and common ratio 𝑟 = 1 2 . The sum is 𝑎 1-𝑟 = ( 1 2 ) 𝑥+1 1-1 2 = ( 1 2 ) 𝑥+1 1 2 = ( 1 2 ) 𝑥 . So, 𝑃 (𝑌 > 𝑋) = ∑ ∞ 𝑥=1 1 2 𝑥 ( 1 2 ) 𝑥 = ∑ ∞ 𝑥=1 ( 1 4$) 𝑥 . This is another geometric series with first term 𝑎 = 1 4 and common ratio 𝑟 = 1 4 . The sum is 𝑎

$1-𝑟 = 1 4 1-1 4 = 1 4 3 4 = 1 3 . Now, we need to find 𝑃 (𝑋 = 𝑥 ∩ 𝑌 > 𝑋) = 𝑃 (𝑋 = 𝑥, 𝑌 > 𝑥). 𝑃 (𝑋 = 𝑥, 𝑌 > 𝑥) = 𝑃 (𝑋 = 𝑥)𝑃 (𝑌 > 𝑥), due to independence. 𝑃 (𝑌 > 𝑥) = ∑ ∞ 𝑦=𝑥+1 𝑃 (𝑌 = 𝑦) = ∑ ∞ 𝑦=𝑥+1 1 2 𝑦 = ( 1 2 ) 𝑥+1 + ( 1 2 ) 𝑥+2 + ⋯ = ( 1 2 ) 𝑥 . So, 𝑃 (𝑋 = 𝑥, 𝑌 > 𝑥) = 1 2 𝑥 × ( 1 2 ) 𝑥 = ( 1 4 ) 𝑥 . Now, we can find 𝑃 (𝑋 = 𝑥|𝑌 > 𝑋) = 𝑃 (𝑋=𝑥∩𝑌 >𝑋) 𝑃 (𝑌 >𝑋) = ( 1 4 ) 𝑥 1 3$= 3( 1 4 ) 𝑥 . Finally, we can calculate the conditional expectation:

$𝐸[𝑋|𝑌 > 𝑋] = ∑ ∞ 𝑥=1 𝑥𝑃 (𝑋 = 𝑥|𝑌 > 𝑋) = ∑ ∞ 𝑥=1 𝑥 ⋅ 3( 1 4 ) 𝑥 = 3 ∑ ∞ 𝑥=1 𝑥( 1 4 ) 𝑥 . Consider the series 𝑆 = ∑ ∞ 𝑥=1 𝑥𝑟 𝑥 , where |𝑟| < 1. 𝑆 = 𝑟 + 2𝑟 2 + 3𝑟 3 + 4𝑟 4 + … 𝑆 𝑟 = 1 + 2𝑟 + 3𝑟 2 + 4𝑟 3 + … Consider the geometric series 𝐺 = 1 + 𝑟 + 𝑟 2 + 𝑟 3 + ⋯ = 1$1-𝑟 . Differentiating with respect to 𝑟:

$𝑑𝐺 𝑑𝑟 = 1 + 2𝑟 + 3𝑟 2 + 4𝑟 3 + ⋯ = 𝑑 𝑑𝑟 ( 1 1-𝑟 ) =$1 (1-𝑟) 2 . So, 𝑆 𝑟 = 1 (1-𝑟) 2 , which means 𝑆 = 𝑟 (1-𝑟) 2 . In our case, 𝑟 = 1 4 . s1: Simple test-time scaling Now, let's find 𝐸[𝑋|𝑌 > 𝑋]. 𝐸[𝑋|𝑌 >

$𝑋] = ∑ ∞ 𝑥=1 𝑥𝑃 (𝑋 = 𝑥|𝑌 > 𝑋) = ∑ ∞ 𝑥=1 𝑥 𝑃 (𝑋=𝑥,𝑌 >𝑥) 𝑃 (𝑌 >𝑋) . 𝑃 (𝑋 = 𝑥, 𝑌 > 𝑥) = 𝑃 (𝑋 = 𝑥)𝑃 (𝑌 > 𝑥) (independence) 𝑃 (𝑋 = 𝑥) = (1 -𝑝) 𝑥-1 𝑝. 𝑃 (𝑌 > 𝑥) = ∑ ∞ 𝑦=𝑥+1 (1 -𝑝) 𝑦-1 𝑝 = 𝑝[(1 -𝑝) 𝑥 + (1 -𝑝) 𝑥+1 + … ] = 𝑝 (1-𝑝) 𝑥 1-(1-𝑝) = (1 -𝑝) 𝑥 . 𝑃 (𝑋 = 𝑥, 𝑌 > 𝑥) = (1 -𝑝) 𝑥-1 𝑝(1 -𝑝) 𝑥 = 𝑝(1 -𝑝) 2𝑥-1 . 𝐸[𝑋|𝑌 > 𝑋] = 1 𝑃 (𝑌 >𝑋) ∑ ∞ 𝑥=1 𝑥𝑝(1 -𝑝) 2𝑥-1 = 2-𝑝 1-𝑝 𝑝(1 -𝑝) -1 ∑ ∞ 𝑥=1 𝑥((1 -𝑝) 2 ) 𝑥 (error in power) 𝑃 (𝑌 > 𝑥) = (1-𝑝) 𝑥 1-(1-𝑝) 𝑝 = (1 -𝑝) 𝑥 . 𝐸[𝑋|𝑌 > 𝑋] = 1 𝑃 (𝑌 >𝑋) ∑ ∞ 𝑥=1 𝑥𝑃 (𝑋 = 𝑥)𝑃 (𝑌 > 𝑥) = 1 𝑃 (𝑌 >𝑋) ∑ ∞ 𝑥=1 𝑥(1 -𝑝) 𝑥-1 𝑝(1 -𝑝) 𝑥 = 𝑝 𝑃 (𝑌 >𝑋) ∑ ∞ 𝑥=1 𝑥(1 -𝑝) 2𝑥-1 = 𝑝 (1-𝑝)∕(2-𝑝) (1 -𝑝) -1 ∑ ∞ 𝑥=1 𝑥((1 -𝑝) 2 ) 𝑥 = 𝑝 2-𝑝 (1-𝑝) 2 ∑ ∞ 𝑥=1 𝑥((1 -𝑝) 2 ) 𝑥 . Let 𝑟 = (1 -𝑝) 2 . ∑ ∞ 𝑥=1 𝑥𝑟 𝑥 = 𝑟 (1-𝑟) 2 . 1 -𝑟 = 1 -(1 -𝑝) 2 = 1 -(1 -2𝑝 + 𝑝 2 ) = 2𝑝 -𝑝 2 = 𝑝(2 -𝑝). (1 -𝑟) 2 = 𝑝 2 (2 -𝑝) 2 . ∑ ∞ 𝑥=1 𝑥((1 -𝑝) 2 ) 𝑥 = (1-𝑝) 2 𝑝 2 (2-𝑝) 2 . 𝐸[𝑋|𝑌 > 𝑋] = 𝑝 2-𝑝 (1-𝑝) 2 (1-𝑝) 2 𝑝 2 (2-𝑝) 2 = 1 𝑝(2-𝑝) . If 𝑝 = 0.5, 𝐸[𝑋|𝑌 > 𝑋] = 1 0.5×1.5 = 1 0.75 = 1 3∕4 = 4∕3.$
## Solution:

Let 𝑋 be the number of flips Alice makes until she gets a head, and 𝑌 be the number of flips Bob makes until he gets a head. 𝑋 and 𝑌 are independent geometric random variables with parameter 𝑝 = 0.5. The probability mass function is 𝑃 (𝐾 = 𝑘) = (1 -𝑝) 𝑘-1 𝑝.

We are interested in the expected number of times Alice flipped her coin, given that Bob flipped his coin more times than Alice, i.e., 𝐸 [[𝑋|𝑌 > 𝑋]](#).

Using the definition of conditional expectation,  [10](#). s1K sample stemming from the astronomy subset of OlympicArena. The black text is the question and the blue text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with Gemini, which we use for training.

$𝐸[𝑋|𝑌 > 𝑋] = ∑ ∞ 𝑥=1 𝑥𝑃 (𝑋 = 𝑥|𝑌 > 𝑋). 𝑃 (𝑋 = 𝑥|𝑌 > 𝑋) = 𝑃 (𝑋=𝑥,𝑌 >𝑥) 𝑃 (𝑌 >𝑋) . First, calculate 𝑃 (𝑌 > 𝑋). 𝑃 (𝑌 > 𝑋) = ∑ ∞ 𝑥=1 ∑ ∞ 𝑦=𝑥+1 𝑃 (𝑋 = 𝑥, 𝑌 = 𝑦) = ∑ ∞ 𝑥=1 𝑃 (𝑋 = 𝑥)𝑃 (𝑌 > 𝑥). 𝑃 (𝑋 = 𝑥) = (0.5) 𝑥-1 (0.5) = (0.5) 𝑥 = 1 2 𝑥 . 𝑃 (𝑌 > 𝑥) = ∑ ∞ 𝑦=𝑥+1 (0.5) 𝑦-1 (0.5) = (0.5) 𝑥 . 𝑃 (𝑌 > 𝑋) = ∑ ∞ 𝑥=1 1 2 𝑥 ( 1 2 ) 𝑥 = ∑ ∞ 𝑥=1 ( 1 4 ) 𝑥 = 1∕4 1-1∕4 = 1∕4 3∕4 = 1 3 . Next, calculate 𝑃 (𝑋 = 𝑥, 𝑌 > 𝑥) = 𝑃 (𝑋 = 𝑥)𝑃 (𝑌 > 𝑥) = 1 2 𝑥 ( 1 2 ) 𝑥 = ( 1 4 ) 𝑥 . Now, find 𝑃 (𝑋 = 𝑥|𝑌 > 𝑋) = 𝑃 (𝑋=𝑥,𝑌 >𝑥) 𝑃 (𝑌 >𝑋) = (1∕4) 𝑥 1∕3 = 3( 1 4 ) 𝑥 . Finally, calculate the conditional expectation: 𝐸[𝑋|𝑌 > 𝑋] = ∑ ∞ 𝑥=1 𝑥𝑃 (𝑋 = 𝑥|𝑌 > 𝑋) = ∑ ∞ 𝑥=1 𝑥 ⋅ 3( 1 4 ) 𝑥 = 3 ∑ ∞ 𝑥=1 𝑥( 1 4 ) 𝑥 . Using the formula ∑ ∞ 𝑥=1 𝑥𝑟 𝑥 = 𝑟 (1-𝑟) 2 with 𝑟 = 1∕4: ∑ ∞ 𝑥=1 𝑥( 1 4 ) 𝑥 = 1∕4 (1-1∕4) 2 = 1∕4($An often-repeated fun fact is that humans produce more power per unit volume than stars. If the sun were the same size, but it produced the same amount of power per unit volume as a human, what would its surface temperature be? Assume the "average human" produces 100 watts of power and has a volume of 66400 cubic centimeters. A: 3500 K B: 10000 K C: 25000 K D: 40000 K E: 50000 K Using the numbers from the problem, the average human produces 𝑢 = 100 66400 × 10 -6

= 1506 W∕m 3

The volume of the sun is 4 3 𝜋𝑅 3 ⊙ , so its new power output would be 𝑃 = 4 3 𝜋𝑅 3 ⊙ 𝑢. To find the equilibrium temperature, we use

$𝑃 = 𝜎𝐴𝑇 4 = 4𝜋𝜎𝑅 2 ⊙ 𝑇 4 Solving for 𝑇 , we get 𝑇 = 4 √ 𝑅 ⊙ 𝑢 3𝜎 = 4 √ √ √ √ ( 6.96 × 10 8 ) (1506) 3 ( 5.67 × 10 -8 ) = 49823 ≈ 50000 K.$The problem asks for the surface temperature of the sun if it had the same size but produced power per unit volume as a human.

First, let's find the power density of a human. Power produced by a human, 𝑃 ℎ𝑢𝑚𝑎𝑛 = 100 W Volume of a human, 𝑉 ℎ𝑢𝑚𝑎𝑛 = 66400 cm 3 Convert the volume to cubic meters: 1 m = 100 cm 1 m 3 = (100 cm) 3 = 10 6 cm 3 𝑉 ℎ𝑢𝑚𝑎𝑛 = 66400 cm 3 = 66400 × 10 -6 m 3 = 0.0664 m 3 Power density of a human, 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 = 𝑃 ℎ𝑢𝑚𝑎𝑛 𝑉 ℎ𝑢𝑚𝑎𝑛 = 100 W 0.0664 m 3 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 = 1506.024 W∕m 3 Now, consider the sun with the same size as it currently is, but with a power density equal to that of a human. We need the radius of the sun to calculate its volume. The average radius of the sun is 𝑅 𝑠𝑢𝑛 = 6.95 × 10 8 m. Volume of the sun, 𝑉 𝑠𝑢𝑛 = 4 3 𝜋𝑅 3 𝑠𝑢𝑛 = 4 3 𝜋(6.95 × 10 8 m) 3 𝑉 𝑠𝑢𝑛 = 4 3 𝜋(337.159375 × 10 24 ) m 3 𝑉 𝑠𝑢𝑛 = 1410.24 × 10 24 × 𝜋 m 3 𝑉 𝑠𝑢𝑛 = 4.4307 × 10 27 m 3 If the sun had the same power density as a human, the total power produced by this modified sun would be: 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 × 𝑉 𝑠𝑢𝑛 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 1506.024 W∕m 3 × 4.4307 × 10 27 m 3 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 6.6726 × 10 30 W

The surface temperature of a star is related to its luminosity (total power output) through the Stefan-Boltzmann law: 𝐿 = 4𝜋𝑅 2 𝜎𝑇 4 where 𝐿 is the luminosity (total power output), 𝑅 is the radius of the star, 𝜎 is the Stefan-Boltzmann constant, and 𝑇 is the surface temperature. In this case, the luminosity of the modified sun is 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 . The radius of the modified sun is the same as the actual sun, 𝑅 𝑠𝑢𝑛 . The Stefan-Boltzmann constant, 𝜎 = 5.67 × 10 -8 Wm -2 K -4 . 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 4𝜋𝑅 2 𝑠𝑢𝑛 𝜎𝑇 4 6.6726 × 10 30 W = 4𝜋(6.95 × 10 8 m) 2 × 5.67 × 10 -8 Wm

-2 K -4 × 𝑇 4 Calculate the term 4𝜋𝑅 2 𝑠𝑢𝑛 𝜎: 𝑅 2 𝑠𝑢𝑛 = (6.95 × 10 8 ) 2 = 48.3025 × 10 16 m 2 4𝜋𝑅 2 𝑠𝑢𝑛 = 4𝜋 × 48.3025 × 10 16 = 607.08 × 10 16 m 2 4𝜋𝑅 2 𝑠𝑢𝑛 𝜎 = 607.08 × 10 16 m 2 × 5.67 × 10 -8 Wm -2 K -4 4𝜋𝑅 2 𝑠𝑢𝑛 𝜎 = 3441.93 × 10 8 WK -4 = 3.44193 × 10 11 WK -4 Now, substitute this back into the equation: 6.6726 × 10 30 = 3.44193 × 10 11 × 𝑇 4 Solve for 𝑇 4 : 𝑇 4 = 6.6726×10 30 3.44193×10 11 = 1.9386 × 10 19 Solve for 𝑇 : 𝑇 = (1.9386 × 10 19 ) 1∕4 = (193.86 × 10 17 ) 1∕4 𝑇 = (1.9386) 1∕4 × (10 19 ) 1∕4 = (1.9386) 0.25 × 10 4.75

Calculate (1.9386) 0.25 : Let 𝑦 = 1.9386 0.25 , then ln 𝑦 = 0.25 ln(1.9386) ln(1.9386) ≈ 0.6619 ln 𝑦 = 0.25 × 0.6619 = 0.165475 𝑦 = 𝑒 0.165475 ≈ 1.1799 So, 𝑇 = 1.1799 × 10 4.75 = 1.1799 × 10 4 × 10 0.75 10 0.75 = 10 3∕4 = (10 3 ) 1∕4 = (1000) 1∕4  We know 5 4 = 625 and 6 4 = 1296, so (1000) 1∕4 is between 5 and 6. Alternatively, 10 0.75 = 10 0.5 × 10 0.25 = √ 10 × 10 0.25 ≈ 3.16 × 1.778 = 5.62 𝑇 = 1.1799 × 10 4 × 5.62 = 6.63 × 10 4 K = 66300 K Let's double-check the calculations. Power density of human: 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 = 1506.02 W∕m 3 Volume of sun: 𝑉 𝑠𝑢𝑛 = 4.43 × 10 27 m 3 Power of modified sun: 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 1506.02 × 4.43 × 10 27 = 6671.67 × 10 27 = 6.67 × 10 30 W Stefan-Boltzmann law:

$𝑃 = 4𝜋𝑅 2 𝜎𝑇 4 𝑇 4 = 𝑃 4𝜋𝑅 2 𝜎 4𝜋𝑅 2$𝑠𝑢𝑛 𝜎 = 3.44 × 10 11 𝑇 4 = 6.67×10 30 3.44×10 11 = 1.939 × 10 19 𝑇 = (1.939 × 10 19 ) 1∕4 = (193.9 × 10 17 ) 1∕4 𝑇 = (193.9) 0.25 × (10 17 ) 0.25 = (193.9) 0.25 × 10 4.25 Calculate (193.9) 0.25 : Let 𝑦 = 193.9 0.25 , then ln 𝑦 = 0.25 ln(193.9) ln(193.9) ≈ 5.267 ln 𝑦 = 0.25 × 5.267 = 1.31675 𝑦 = 𝑒 1.31675 ≈ 3.73 𝑇 = 3.73 × 10 4.25 = 3.73 × 10 4 × 10 0.25 = 37300 × 1.778 = 66329 K The result is around 66000 K. This is not among the options. Let's review the assumptions and calculations. Assumption: The sun radiates as a black body, which is reasonable for estimating surface temperature.

## Solution:

The power produced by an average human is 𝑃 ℎ𝑢𝑚𝑎𝑛 = 100 W, and the volume of an average human is 𝑉 ℎ𝑢𝑚𝑎𝑛 = 66400 cm 3 = 0.0664 m 3 . The power density of a human is 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 = 𝑃 ℎ𝑢𝑚𝑎𝑛 𝑉 ℎ𝑢𝑚𝑎𝑛 = 100 W 0.0664 m 3 ≈ 1506.02 W∕m 3 . If the sun were the same size but produced the same amount of power per unit volume as a human, its power density would be 𝜌 𝑝𝑜𝑤𝑒𝑟,𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 . The radius of the sun is 𝑅 𝑠𝑢𝑛 = 6.95 × 10 8 m. The volume of the sun is 𝑉 𝑠𝑢𝑛 = 4

3 𝜋𝑅 3 𝑠𝑢𝑛 . The power density of the modified sun is given by 𝜌 𝑝𝑜𝑤𝑒𝑟,𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 𝑉 𝑠𝑢𝑛 . We also know that 𝑃 𝑚𝑜𝑑𝑖𝑓 𝑖𝑒𝑑_𝑠𝑢𝑛 = 4𝜋𝑅

2 𝑠𝑢𝑛 𝜎𝑇 4 , where 𝑇 is the surface temperature of the modified sun. Equating the power density: 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 = 4𝜋𝑅 2 𝑠𝑢𝑛 𝜎𝑇 4 4 3 𝜋𝑅 3 𝑠𝑢𝑛 = 3𝜎𝑇 4 𝑅 𝑠𝑢𝑛 Solving for 𝑇 4 : 𝑇 4 = 𝜌 𝑝𝑜𝑤𝑒𝑟,ℎ𝑢𝑚𝑎𝑛 𝑅 𝑠𝑢𝑛 3𝜎 Substitute the values: 𝑇 4 = 1506.02 W∕m 3 ×6.95×10 8 m 3×5.67×10 -8 Wm -2 K -4

𝑇 4 = 1.0466×10 12 1.701×10 -7 = 6.1528 × 10 18 K 4 Solving for 𝑇 : 𝑇 = (6.1528 × 10 18 ) 1∕4 = (6152.8) 0.25 × 10 18∕4 = (6152.8) 0.25 × 10 4.5 Using logarithms: log 10 (6152.8) ≈ 3.789 0.25 × 3.789 = 0.94725 (6152.8) 0.25 = 10 0.94725 ≈ 8.856 𝑇 = 8.856 × 10 4.5 = 8.856 × 10 4 × 10 0.5 = 88560 × √ 10 ≈ 88560 × 3.16 = 280000 K Let's redo the exponent calculation: 18∕4 = 4.5. 𝑇 = 8.856 × 10 4.5 = 8.856 × 10 4 × 10 0.5 -error in previous step. 𝑇 = (6.1528 × 10 18 ) 0.25 = 49806 K The surface temperature would be approximately 49806 K, which is closest to 50000 K. Final Answer: The final answer is 𝐸 when counting down ("3 steps left...2 steps left") rather than counting up ("Step2...Step3..."). This is likely because if counting down, the final step is always 1, which will act as a strong prior to the model to finish its generation. If counting up, the final step before the answer varies, thus if the model does not remember the original step instruction, it may fail to stop. We conclude the following from our results in Table [12:](#) (1) The model still struggles to adhere to the step limit. The model sometimes simply continues counting into negative steps, e.g. "-1 steps left". To solve this issue, we automatically stop the thinking process once 0 steps are reached and then force the model to transition to answering mode by appending the answer token delimiter ( §3). This leads to perfect step adherence (lower half of Table [12](#)), yet problems remain. (2) The model compensates for fewer steps by making each step longer. For example, when forced to use up to 16 steps vs 256 steps, the model generates an average of 96 tokens per step vs 56. Despite this issue, more steps still clearly correlate with more total thinking tokens in Table [12](#) and better performance leading to a positive slope (3) Step instructions are more costly than other methods. The step delimiters require around 6 tokens each which for e.g. 64 steps adds up to a total of around 380 tokens. When ignoring the step delimiters in token counts as in Table [12](#), the model still requires 7551 thinking tokens on average to achieve only 33.3% on AIME24. To compute Control reported in Table [3](#) for step-conditional control variants, we first decide that 100 tokens are an upper limit per step and then multiply this number by the steps instructed to arrive at a proxy total token limit, e.g. 1600 for 16 steps instructed. We then check whether the thinking tokens in Table [12](#) fit within the respective limit for each evaluation run (3/5 for without intervention; 5/5 for with intervention). For the model in Figure [7](#), we use a model with step-conditional control trained on an earlier version of our data and using an earlier version of our evaluation codebase.

Class-conditional control OpenAI exposes test-time compute control to users via a "reasoning_effort" API parameter with three possible settings: low, medium, and high. [3](#foot_3) The OpenAI documentation also states that "Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response." suggesting that they are unable to control test-time compute with guarantees. Thus, maybe OpenAI simply adjusts the prompt or system instruction depending on the reasoning effort desired. In Table [13](#), we show that separate prompts for short and long thinking allow us to control thinking time to some extent: Prompting the model to think for longer leads to longer thinking. However, it does not reliably improve performance and control is not precise. The current adherence to control may suffice when we only have three classes, but it might not scale to finer-grained classes. To compute Control reported in Table [3](#) for this method, we assume that prompting the model to think for a short time in Table [13](#) should produce fewer tokens than the default for AIME24, while the long prompt should produce more. As 8033 > 6109 and 9651 > 6109, one out of two follows our expected control thus Control is 50%.

## D.2. Examples for rejection sampling ablation s1: Simple test-time scaling

Table [14](#tab_7). Answers generated by an earlier version of s1-32B when rejection sampling on AIME24. The black text is the question and the yellow text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with s1-32B using a temperature of 1. We generate until the reasoning trace has less than 4000 tokens for the first and less than 8000 tokens for the second example. It required on average 199 (1) tries per example until thinking was ≤ 4000 (≤ 8000 tokens).

Let 𝑂(0, 0), 𝐴( 1 2 , 0), and 𝐵(0, √

2 ) be points in the coordinate plane. Let  be the family of segments 𝑃 𝑄 of unit length lying in the first quadrant with 𝑃 on the 𝑥-axis and 𝑄 on the 𝑦-axis. There is a unique point 𝐶 on 𝐴𝐵, distinct from 𝐴 and 𝐵, that does not belong to any segment from  other than 𝐴𝐵. Then 𝑂𝐶 2 = 𝑝 𝑞 , where 𝑝 and 𝑞 are relatively prime positive integers. Find 𝑝 + 𝑞.

## [Incorrect generation with 5923 thinking tokens and 754 answer tokens]

The problem asks for a point 𝐶 on the segment 𝐴𝐵 such that 𝐶 is not on any other segment from the family  , except 𝐴𝐵 itself. The family  consists of segments 𝑃 𝑄 of unit length, with 𝑃 on the 𝑥-axis and 𝑄 on the 𝑦-axis in the first quadrant. Let 𝑃 = (𝑥, 0) and 𝑄 = (0, 𝑦), where 𝑥 > 0 and 𝑦 > 0. The length of the segment 𝑃 𝑄 is 1, so the distance between 𝑃 and 𝑄 is 1. √ (𝑥 -0) 2 + (0 -𝑦) 2 = 1 √ 𝑥 2 + 𝑦 2 = 1 𝑥 2 + 𝑦 2 = 1 The segment 𝑃 𝑄 lies in the first quadrant, so 𝑥 > 0 and 𝑦 > 0. The equation 𝑥 2 + 𝑦 2 = 1 represents the quarter circle in the first quadrant, with endpoints at (1, 0) and (0, 1). The points on the segment 𝑃 𝑄 can be parameterized as (1 -𝑡)𝑥 + 𝑡(0), (1 -𝑡)0 + 𝑡𝑦) = (𝑥(1 -𝑡), 𝑦𝑡), where 0 ≤ 𝑡 ≤ 1.

The segment 𝐴𝐵 connects 𝐴( 1 2 , 0) and 𝐵(0, √

2 ). The equation of the line containing 𝐴𝐵 can be found using the two points:

$Slope 𝑚 = √ 3 2 -0 0-1 2 = √ 3 2 -1 2 = - √ 3.$Using point-slope form with point 𝐴( 1 2 , 0):

$𝑦 -0 = - √ 3(𝑥 -1 2 ) 𝑦 = - √ 3𝑥 + √ 3 2$The segment 𝐴𝐵 lies in the first quadrant, between 𝑥 = 0 and 𝑥 = 1 2 . Alternatively, we can parameterize the points on 𝐴𝐵.

Let 𝐶 be a point on 𝐴𝐵. Then 𝐶 = (1 -𝜆)𝐴 + 𝜆𝐵 for some 0 ≤ 𝜆 ≤ 1.

$𝐶 = (1 -𝜆)( 1 2 , 0) + 𝜆(0, √3$2 ) = ( 1 2 -1 2 𝜆, √ 3 2 𝜆). We are looking for a unique point 𝐶 on 𝐴𝐵, distinct from 𝐴 and 𝐵, that does not belong to any segment from  other than 𝐴𝐵. Consider a segment from  , with endpoints 𝑃 = (𝑥, 0) and 𝑄 = (0, 𝑦), where 𝑥 2 + 𝑦 2 = 1. A point on this segment is of the form (𝑥(1 -𝑡), 𝑦𝑡), where 0 ≤ 𝑡 ≤ 1. We want to find a point 𝐶 on 𝐴𝐵, 𝐶 ≠ 𝐴, 𝐵, such that if 𝐶 lies on a segment 𝑃 𝑄 ∈  , then 𝑃 𝑄 = 𝐴𝐵.

$Let 𝐶 = ( 1 2 -1 2 𝜆, √3$2 𝜆), where 0 < 𝜆 < 1. If 𝐶 lies on a segment 𝑃 𝑄 from  , then there exist 𝑥, 𝑦 > 0 with 𝑥 2 + 𝑦 2 = 1, and 𝑡 ∈ [0, 1] such that: Also, 𝑥 > 0, so 1-𝜆 2𝑥 > 0, which implies 1 -𝜆 > 0, or 𝜆 < 1. This is consistent with the condition for point on 𝐴𝐵. We have 1 -𝑡 = 1-𝜆 2𝑥 and 𝑡 = √ 3𝜆 2𝑦 . Adding these equations:

$1 = 1-𝜆 2𝑥 + √ 3𝜆 2𝑦 2𝑥𝑦 = (1 -𝜆)𝑦 + √ 3𝜆𝑥$![Figure 1. Test-time scaling with s1-32B. We benchmark s1-32B on reasoning-intensive tasks and vary test-time compute.]()

![Figure 4. Sequential and parallel test-time scaling. (a):Budget forcing shows clear scaling trends and extrapolates to some extent. For the three rightmost dots, we prevent the model from stopping its thinking 2/4/6 times, each time appending "Wait" to its current reasoning trace. (b): For Qwen2.5-32B-Instruct we perform 64 evaluations for each sample with a temperature of 1 and visualize the performance when majority voting across 2, 4, 8, 16, 32, and 64 of these.]()

![Figure 8. Grading prompt.]()

![Figure 9. Training dynamics of s1-32B on s1K.]()

![Answer: The final answer is 4∕3 s1: Simple test-time scaling Table]()

![𝑡 ∈ [0, 1], we have 1 -𝑡 ∈ [0, 1].]()

![Budget]()

![Summary]()

![Training sequence length ablation. We report "accuracy / average thinking tokens per sample"; the higher the accuracy and the fewer the thinking tokens (inference cost) the better.Besides our scaling ablations in §5.2, the main training hyperparameter we ablate is the sequence length used during training.]()

https://mathscinet.ams.org/mathscinet/ msc/msc2020.html

https://github.com/google/ generative-ai-docs/issues/257

s1: Simple test-time scaling

https://github.com/openai/openai-python/blob/44d6210f101abedeb2dd68507fcffcb329df70ea/ src/openai/types/chat/completion_create_params.py#L172

𝑥 -1∕3 + 2 3 𝑦 -1∕3 𝑦 ′ = 0 𝑦 ′ = -𝑦 1∕3 𝑥 1∕3 = -( 𝑦 𝑥 ) 1∕3

𝜆) 2 = 1. We found no solution for 𝜆 ∈ (0, 1).

