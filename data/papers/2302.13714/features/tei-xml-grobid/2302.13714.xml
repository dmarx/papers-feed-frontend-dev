<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On the Design of Codes for DNA Computing: Secondary Structure Avoidance Codes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Tuan</forename><forename type="middle">Thanh</forename><surname>Nguyen</surname></persName>
							<email>tuanthanhnguyen@sutd.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">Science, Mathematics and Technology Cluster</orgName>
								<orgName type="institution">Singapore University of Technology and Design</orgName>
								<address>
									<postCode>487372</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kui</forename><surname>Cai</surname></persName>
							<email>caikui@sutd.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">Science, Mathematics and Technology Cluster</orgName>
								<orgName type="institution">Singapore University of Technology and Design</orgName>
								<address>
									<postCode>487372</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Han</forename><forename type="middle">Mao</forename><surname>Kiah</surname></persName>
							<email>hmkiah@ntu.edu.sg</email>
							<affiliation key="aff1">
								<orgName type="department">School of Physical and Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<postCode>637371</postCode>
									<settlement>Singapore</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><roleName>Duc</roleName><forename type="first">Tu</forename><surname>Dao</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">School of Physical and Mathematical Sciences</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<postCode>637371</postCode>
									<settlement>Singapore</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kees</forename><forename type="middle">A</forename><surname>Schouhamer Immink</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Turing Machines Inc</orgName>
								<address>
									<addrLine>Willemskade 15d</addrLine>
									<postCode>3016 DK</postCode>
									<settlement>Rotterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">On the Design of Codes for DNA Computing: Secondary Structure Avoidance Codes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">87ECAC185123B702634D5F87CB8D31A3</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2-SNAPSHOT" ident="GROBID" when="2025-02-21T16:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this work, we investigate a challenging problem, which has been considered to be an important criterion in designing codewords for DNA computing purposes, namely secondary structure avoidance in single-stranded DNA molecules. In short, secondary structure refers to the tendency of a singlestranded DNA sequence to fold back upon itself, thus becoming inactive in the computation process. While some design criteria that reduces the possibility of secondary structure formation has been proposed by <ref type="bibr" target="#b7">Milenkovic and Kashyap (2006)</ref>, the main contribution of this work is to provide an explicit construction of DNA codes that completely avoid secondary structure of arbitrary stem length.</p><p>Formally, given codeword length n and arbitrary integer m 2, we provide efficient methods to construct DNA codes of length n that avoid secondary structure of any stem length more than or equal to m. Particularly, when m = 3, our constructions yield a family of DNA codes of rate 1.3031 bits/nt, while the highest rate found in the prior art was 1.1609 bits/nt. In addition, for m 3 log n + 4, we provide an efficient encoder that incurs only one redundant symbol.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>DNA computing is an emerging branch of computing that uses DNA, biochemistry, and molecular biology hardware. The field of DNA computation started with the following demonstration by Adleman in 1994 <ref type="bibr" target="#b0">[1]</ref>. In this seminal experiment, Adleman solved an instance of the directed traveling salesperson problem by first representing each city with a synthetic DNA molecule. Then by allowing the strands to hybridize in a highly parallel fashion, Adleman obtained the desired solution. Since then, similar methods have been expanded to several attractive applications, including the development of storage technologies <ref type="bibr" target="#b1">[2]</ref>- <ref type="bibr" target="#b4">[5]</ref>, and cell-based computation systems for cancer diagnostics and treatment <ref type="bibr" target="#b5">[6]</ref>. Recently, the hybridization process was exploited to allow random access in DNA data storage <ref type="bibr" target="#b6">[7]</ref>.</p><p>In DNA computing, only short single-stranded DNA sequences (or oligonucleotide sequences) are used, where each of them is an oriented word consisting of four bases (or nucleotides): Adenine (A), Thymine (T), Cytosine (C), and Guanine (G). A set of encoded DNA sequences (also called DNA codewords), that satisfies certain special properties (or constraints) for DNA computing purposes, is called a DNA code. A broad description of the kinds of constraint problems that arise in coding for DNA computing was introduced by Milenkovic and Kashyap in 2006 <ref type="bibr" target="#b7">[8]</ref>, including constant GCcontent constraint (refers to the percentage of nucleotides that are either G or C), Hamming distance constraint (that requires DNA codewords to be sufficiently different among themselves), and secondary structure formation avoidance constraint (that prevents DNA sequence to fold back upon itself, and consequently becoming inactive in the computation process). Similar considerations were described in <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref> for the design of primer address sequences in random access of DNA-based data storage systems. While constant GCcontent constraint and Hamming distance constraint have been extensively investigated <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b10">[11]</ref>- <ref type="bibr" target="#b16">[17]</ref>, the study for secondary structure avoidance is much less profound.</p><p>For a DNA sequence, a secondary structure is formed by a chemically active to fold back onto itself by complementary base pair hybridization (illustrated via Figure <ref type="figure" target="#fig_0">1</ref>). Here, the Watson-Crick complement is defined as: A = T, T = A, C = G, and G = C. For a sequence x = x 1 x 2 x 3 . . . x n-1 x n over the DNA alphabet D = {A, T, C, G}, the reverse-complement of x is defined as RC(x) = x n x n-1 . . . x 3 x 2 x 1 . In Figure <ref type="figure" target="#fig_0">1</ref>, sub-sequences x = ATACC and y = RC(x) = GGTAT of the DNA sequence σ bind to each other after pairing of A with T and G with C, forming a secondary structure with a loop and a stem of length 5. DNA sequences with secondary structures are less active in the computation process <ref type="bibr" target="#b7">[8]</ref>, and hence, before reading such sequences in a wet lab, they need to be unfolded, costing more resources and energy. There exist some simple dynamic programming techniques <ref type="bibr" target="#b17">[18]</ref>, <ref type="bibr" target="#b18">[19]</ref> that can approximately predict the secondary structures in a given DNA sequence (for example, see the Nussinov-Jacobson (NJ) algorithm in <ref type="bibr" target="#b18">[19]</ref> as one of the most widely used schemes). Based on the NJ algorithm, the authors in <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b12">[13]</ref> found some design criteria that reduce the possibility of secondary structure formation in a codeword. A natural question is whether there exists efficient design of DNA constrained codes that avoid the formation of secondary structures.</p><p>It has been shown experimentally that the number of base pairs in stem regions (or stem length) is one important factor influencing the secondary structure of a DNA sequence. Given codeword length n and an integer m 2, we study the problem of constructing DNA codes of length n that avoid secondary structure of any stem length more than or equal to m. To the best of our knowledge, this work is the first attempt aimed at providing a rigorous solution for DNA codes avoiding secondary structure for general stem lengths. Given two sequences x and y, we let xy denote the concatenation of the two sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>arXiv:2302.13714v1 [cs.IT] 27 Feb 2023</head><p>Throughout this work, given a sequence x of length n, we say y is a subsequence of length k of x, where k n, if y = x i x i+1 . . . x i+k-1 for some 1 i n -k + 1. In other words, we only consider the subsequences including consecutive symbols in x. Two subsequences y and z of x are said to be non-overlapping if we have y</p><formula xml:id="formula_0">= x i x i+1 . . . x i+k-1 , z = x j x j+1 . . . x j+ -1 , where i &gt; j + -1 or j &gt; i + k -1. Definition 1. For a DNA sequence x ∈ D n , x = x 1 x 2 . . . x n , the reverse-complement of x, is defined as RC(x) = x n x n-1 . . . x 3 x 2 x 1 .</formula><p>Definition 2. Given 0 &lt; m n, a DNA sequence x ∈ D n is said to be m-secondary structure avoidance (or m-SSA) sequence if for all k m, there does not exist any pair of non-overlapping subsequences y, z of length k of x such that y = RC(z). A code C is said to be an (n, D; m) SSA code if for every codeword x ∈ C ∩ D n , we have x is m-SSA.</p><p>The following result is immediate.</p><formula xml:id="formula_1">Lemma 1. Given m, n &gt; 0, if a sequence x ∈ D n is m-SSA then x is m -SSA for all m &gt; m.</formula><p>For a code C ⊆ D n , the code rate is measured by the value log |C|/n. Intuitively, it measures the number of information bits stored in each DNA symbol. Suppose that we have an infinite family of codes {C n } ∞ n=1 , where C n is a code of length n, then the asymptotic rate of the family is r lim n→∞ log |Cn| n</p><p>. Here, we adopt the notation log to mean logarithm base two. Definition 3. Given m &gt; 0, for n &gt; 0, let A(n, D; m) be the total number of DNA sequences of length n that are m-SSA. The channel capacity, denoted by c m , is defined by:</p><formula xml:id="formula_2">cm = lim n→∞ log A(n, D; m) n .</formula><p>The following result is immediate.</p><p>Lemma 2. Given m &gt; 0, let S m be the set of all DNA sequences of length m such that, there is no pair of sequences y, z ∈ S m , not necessary distinct, such that y = RC(z). We</p><formula xml:id="formula_3">then have c m 1/m log |S m |.</formula><p>Observe that the size of S m can be computed easily for constant m, a trivial upper bound is that |S m | 4 m /2, and consequently, we obtain c 2 1.5 and c 3 1.67.</p><p>To construct an (n, D; m) SSA code for arbitrary m &gt; 0 by concatenation method, one can find the largest set S N for some suitable value of N , such that, for n = N k, each codeword is a concatenation of k sequences of length N from S N and each concatenation does not create a reverse-complement subsequence from previous concatenations. The construction yields a family of DNA codes of rate 1/N log |S N | bits/nt. For example, for m = 3, Krishna Gopal Benerjee and Adrish Banerjee <ref type="bibr" target="#b10">[11]</ref> constructed an (n, D; 3) SSA code via such a set S = {AA, CC, AC, CA, TC}.</p><p>Theorem 1 (Benerjee and Banerjee <ref type="bibr" target="#b10">[11]</ref>). Set S = {AA, CC, AC, CA, TC}. Let C be the DNA code of length 2n where each codeword is a concatenation of words of length two from S. We then have C is an (n, D; 3) SSA code, i.e. every codeword of C is 3-SSA. The size of the code is |C| = 5 n , and the code rate is 1/2 log 5 = 1.1609 bits/nt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Paper Organisation and Our Main Contribution</head><p>Since the number of base pairs in stem regions (or stem length) is one important factor influencing the secondary structure of a DNA sequence, this work aims at providing a rigorous solution for (n, D; m) SSA codes given arbitrary m. The paper is organised as follows.</p><p>• Section III presents two efficient constructions of (n, D; m) SSA codes for arbitrary m &gt; 0. The first construction is based on block concatenation, which concatenates blocks of fixed length m from a predetermined set. On the other hand, crucial to the second construction is the concept of symbol-composition constrained codes.</p><p>Particularly, when m = 3, the second construction yields a family of DNA codes of rate 1.3031 bits/nt, which is higher than the code rate in <ref type="bibr" target="#b10">[11]</ref>. • Section IV presents a linear-time encoding method for (n, D; m) SSA code with only one redundant symbol whenever m 3 log n + 4. The coding method is based on sequence replacement technique.</p><p>III. CONSTRUCTIONS OF (n, D; m) SSA CODES FOR ARBITRARY m &gt; 0 The first method is based on block concatenation, which concatenates blocks of length m from a predetermined set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Constructions via Block Concatenation</head><p>Construction 1. Given m &gt; 0, n = mk for some integer k &gt; 0, set t = m/3 . Let S * m be the set of all DNA sequences of length m such that for any pair of sequences x 1 , x 2 ∈ S * m , not necessary distinct, there is no pair of subsequences y of x 1 and z of x 2 of length t such that y = RC(z). Let C be the DNA code of length n, where each codeword is a concatenation of k sequences of length m in S * m . Theorem 2. The constructed code C from Construction 1 is an (n, D; m) SSA code.</p><p>Proof. We prove the correctness of Theorem 2 by contradiction. Suppose that, there exists a codeword c ∈ C, c = x 1 x 2 . . . x k , where x i ∈ S * m , and c is not m-SSA. In other words, there exists two non-overlapping subsequences y,z of c of length m m such that y = RC(z). Suppose that y = Y 1 Y 2 where Y 1 is a subsequence of x i , and Y 2 is a subsequence of x i+1 x i+2 . . . x i+h for some h 1. We have</p><formula xml:id="formula_4">z = RC(Y 2 )RC(Y 1 ). The trivial case is if h &gt; 1, or Y 2 is of length more than m, then x i+1 is a subsequence of Y 2 and RC(x i+1 ) is a subsequence of z.</formula><p>Clearly, if RC(x i+1 ) ≡ x j , we have a contradiction. On the other hand, if RC(x i+1 ) = W 1 W 2 where W 1 is a subsequence of x j and W 2 is a subsequence of x j+1 for some j, then at least one subsequence W 1 or W 2 is of size more than t, we also have a contradiction. We conclude that h = 1, or Y 2 is simply a subsequence of x i+1 . Now, since y = Y 1 Y 2 is of length m m, at least Y 1 t or Y 2 t. W.l.o.g, assume that Y 1 t.</p><p>We observe that RC(Y 1 ) cannot be a subsequence of any x j by Construction 1. In other words, RC(Y 1 ) = W 1 W 2 where W 1 is a subsequence of x j and W 2 is a subsequence of x j+1 for some j. Similarly, we observe that the length of W 1 , W 2 must be strictly smaller than t, otherwise, for example, if the length of W 1 is more than or equal to t, then two sequences x i and x j in S * m contain RC(W 1 ) and W 1 as subsequences, we have a contradiction. Since both the length of W 1 , W 2 must be strictly smaller than t, causing the length of Y 1 is smaller than 2t, we conclude that the length of Y 2 is at least t. Now, let U = RC(Y 2 ) ∩ x j+1 , the subsequence that belongs to both x j+1 and RC(Y 2 ), which is of size at least t. We then have U is a subsequence of x j+1 while RC(U) is a subsequence of RC(RC(Y 2 )) = Y 2 , a subsequence of x i+1 . We then have a contradiction.</p><p>In conclusion, we have C is an (n, D; m) SSA code. We highlight our proof sketch of Theorem 2 in Figure <ref type="figure" target="#fig_1">2</ref>.</p><p>Remark 1. Observe that, the set S * m can be constructed via exhaustive search with complexity O(2 m ). In Section IV, we show that when m is sufficiently large, m 3 log n + 4 = Θ(log n), there exists an efficient encoding/decoding Claim 1: When |Y 1 | t, we observe that RC(Y 1 ) cannot be a subsequence of any x j+1 .</p><formula xml:id="formula_5">x i x i+1 . . . . . . Y 1 2 j x j+1 . . . . . . RC(Y 1 ) RC(Y 2 )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>When</head><p>, cannot be a subsequence of any</p><formula xml:id="formula_6">| Y 1 | ≥ t RC(Y 1 ) x j+1 Claim 2: When Y 1 = W W 2 RC(Y 1 ) = RC(W 2 )RC(W 1 ), we must have |W 1 | t, |W 2 | t. x i x i+1 . . . . . . Y 1 = W 1 W 2 Y 2 x j x j+1 . . . . . . RC(W 1 ) RC(Y 2 )</formula><p>Suppose that , then .</p><formula xml:id="formula_7">Y 1 = W 1 W 2 , RC(Y 1 ) = RC(W 2 )RC(W 1 ) | W 1 | &lt; t, | W 2 | &lt; t RC(W 2 )</formula><p>and form a pair in that violates the condition</p><formula xml:id="formula_8">| Y 2 | ≥ t (x i+1 , x j ) S* m</formula><p>Consequently, |Y 2 | and we have (x i+1 , x j ) form a pair in S * m that violate the condition. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Constructions via Symbol-Composition Constrained Codes</head><p>In this subsection, we present an efficient construction for (n, D; m) SSA codes by simply restricting the symbolcomposition for every subsequence of length m. Particularly, when m = 3, our method yields a family of DNA codes of rate 1.3031 bits/nt, which is higher than the code rate in <ref type="bibr" target="#b10">[11]</ref>.</p><p>High Level Description. We select a nucleotide x ∈ D = {A, T, C, G}, and let y = x ∈ D. For some 0 &lt; k m, we present an efficient method to construct an (n, D; m) SSA code C as follows. For every codeword c ∈ C, every subsequence z of length m of c contains at least k symbols x while z contains at most (k -1) symbols y. We refer such a constraint to as the symbol-composition constraint. It is easy to verify that such a constructed code C is an (n, D; m) SSA code. Clearly, suppose on the other hand, there exists a pair of subsequences z 1 , z 2 of length m in c ∈ C, such that z 2 = RC(z 1 ). It implies that there exists two subsequences of length m, which are z 1 of z 1 and z 2 of z 2 , and z 2 = RC(z 1 ). Since z 1 contains at least k symbols x, we have z 2 = RC(z 1 ) must contain at least k symbols y = x. We then have a contradiction.</p><p>The following construction is for m = 3 and k = 1. </p><formula xml:id="formula_9">|C n | = |C n-1 | + 2|C n-2 | + 4|C n-3 |.</formula><p>In addition, C n is an (n, D; 3) SSA code for all n &gt; 0. The asymptotic rate of this code family is given by log(λ) ≈ 1.3031, where λ ≈ 2.4675 is the largest real root of</p><formula xml:id="formula_10">x 3 -x 2 -2x -4 = 0.</formula><p>Proof. Consider the code C n . For a codeword c ∈ C n , for any subsequence x of length 3 of c, we have x includes A. On the other hand, since A = T is not used in c, there is no reverse-complement of x in c. In conclusion, c is 3-SSA, or C n is an (n, D; 3) SSA code.</p><p>We now prove the cardinality of C n . it is easy to verify that</p><formula xml:id="formula_11">|C 1 | = 3, |C 2 | = 9, |C 3 | = 19.</formula><p>For n 4, we construct C n recursively as follows:</p><formula xml:id="formula_12">S 1 n ={xA : for x ∈ Cn-1} S 2 n ={xAC, xAG : for x ∈ Cn-2} S 3 n ={xACC, xACG, xAGC, xAGG : for x ∈ Cn-3}, and Cn =S 1 n ∪ S 2 n ∪ S 3 n .</formula><p>In other words, S 1 n is the set formed by concatenating all sequences in C n-1 with A, S 2 n is the set formed by concatenating all sequences in C n-2 with AC or AG, and lastly, S 2 n is the set formed by concatenating all sequences in C n-3 with ACC, ACG, AGC, or AGG. It is easy to verify that S i n ∩ S j n ≡ ∅, and the union S 1 n ∪ S 2 n ∪ S 3 n includes all possible sequences in C n . Therefore, we have</p><formula xml:id="formula_13">|C n | = |C n-1 | + 2|C n-2 | + 4|C n-3 |.</formula><p>Construction 2 can be generalized to construct (n, D; m) SSA codes with k = 1 as follows.</p><p>Theorem 4 (Symbol-Composition Constrained Codes for General m, k = 1). Given n, m &gt; 0. Set D * = {A, C, G}, and C n (m) to be the set of all sequences x of length n from alphabet D * such that every subsequence of length m of x include an A. We then have |C i (m)| = 3 i for 0 i m -1, and</p><formula xml:id="formula_14">|C n (m)| = m-1 j=0 2 j |C n-j-1 (m)| for n m.</formula><p>We then have C n (m) is (n, D; m) SSA code for all n &gt; 0. The asymptotic rate of this code family is given by log(λ), where λ is the largest real root of x mm-1 j=0 2 j x m-j = 0. In this section, we show that when the stem length is sufficiently large, m 3 log n + 4 = Θ(log n), there exists an efficient encoding/decoding algorithm for (n, D; m) SSA codes with at most one redundant symbol. For simplicity, we assume that log 4 n is an integer, and define the DNArepresentation of an integer as follows. We now present explicit construction of the encoder ENC SSA and the corresponding decoder DEC SSA . Our method is based on the sequence replacement technique. This method has been widely used in the literature <ref type="bibr" target="#b20">[21]</ref>- <ref type="bibr" target="#b22">[23]</ref>. In addition, we also restrict the length of the repeated patterns of size 2 (also known as pattern length limited (PLL) constraint, as introduced in <ref type="bibr" target="#b23">[24]</ref>). • If it finds a pair of non-overlapping subsequences y, z, suppose that c = X 1 yX 2 zX 3 , where X 1 , X 2 , X 3 are subsequences of c, and y starts at index i, ends at index j in c, where j = i + 1 -1, and z starts at index k in c. We have i, j, k n -1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Construction of ENC</head><p>Type-I Replacement. The encoder sets a pointer P I , starting with symbol T, and P I = Tp 1 p 2 p 3 , where p 1 , p 2 , p 3 are the DNA-representation of i, j, and k, respectively. Since p 1 , p 2 , p 3 are of length log 4 n, the pointer sequence P I is of length 1+3 log 4 n = 1+1.5 log n. It then removes z from c and prepends P I to c. The replacing step can be illustrated as follows.</p><formula xml:id="formula_15">X 1 yX 2 zX 3 → X 1 yX 2 X 3 → Tp 1 p 2 p 3 X 1 yX 2 X 3</formula><p>Noted that the removed sequence z is of length 1 m = 1.5 log n + 2, while the insertion pointer P I is of length 1.5 log n + 1. Consequently, such a replacement reduces the length of the current sequence by at least one symbol. • On the other hand, suppose that it finds a subsequence u of c of the form u = (x 1 x 2 ) t whose length is 2 = 2t m , where x 1 , x 2 ∈ D = {A, T, C, G}. We further suppose that c = U 1 (x 1 x 2 ) t U 2 , where U 1 , U 2 are subsequences of c, and u starts at index i, and ends at index j in c, where j = i + 2 -1. We have i, j n -1.</p><p>Type-II Replacement. Similarly, the encoder sets a pointer P II , starting with symbol C, and P II = Cx 1 x 2 q 1 q 2 , where q 1 , q 2 are the DNA-representation of i and j, respectively. Since q 1 , q 2 are of length log 4 n, the pointer sequence P II is of length 1 + + 2 log 4 n = 3 + log n. It then removes (x 1 x 2 ) 2 from c and prepends P II to c. The replacing step can be illustrated as follows.</p><formula xml:id="formula_16">U 1 (x 1 x 2 ) t U 2 → U 1 U 2 → Cx 1 x 2 q 1 q 2 U 1 U 2 .</formula><p>Noted that the removed sequence is of length 2 m = 1.5 log n + 2, while the insertion pointer P II is of length log n+3. Hence, such a replacement reduces the length of the current sequence by at least (0.5 log n -1) symbols. Observe that 0.5 log n -1 &gt; 1 for n &gt; 16.</p><p>The encoder repeats the scanning and replacing steps until the current sequence c contains no pair of non-overlapping subsequences of length more than or equal to m such that one is the reverse-complement of the other, no subsequence u of the form u = (x 1 x 2 ) t whose length is 2 = 2t m , or the current sequence is of length m -1. Note that each replacement (either Type-I or Type-II) reduces the length of the current sequence by at least one symbol, and hence, this procedure is guaranteed to terminate. Here, we also note that the order of the scanning step is defined according to the starting index of the corresponding subsequences. In case the first subsequence y forming a secondary structure, is also the starting of such a subsequence u, the encoder proceeds to type-I replacement.</p><p>Extending phase. If the length of the current sequence c is N 0 where N 0 &lt; n, the encoder appends a suffix of length N 1 = n -N 0 to obtain a sequence of length n. Surprisingly, regardless the choice of the appending suffix, there is an efficient algorithm to decode the source DNA sequence uniquely (refer to the construction of DEC SSA ). Here, we present one efficient method to generate a suitable suffix so that the output codeword remains m-SSA.</p><p>• If N 1 is even, we append s = (AC) N1/2 to the end of c.</p><p>• If N 1 is odd, we append s = (AC) (N1-1)/2 A to the end of c.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: DNA secondary structure model. Here, the Watson-Crick complement is: A = T, T = A, C = G, and G = C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Proof Sketch of Theorem 2. algorithm for (n, D; m) SSA codes with at most one redundant symbol. Hence, for the case m = o(log n), we can use Construction 1 to construct (n, D; m) SSA codes with complexity 2 m = Θ(n).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Construction 2 (Theorem 3 .</head><label>23</label><figDesc>Symbol-Composition Constrained Codes for m = 3, k = 1). Given n &gt; 0, we select x = A and y = x = T. Set D * = {A, C, G}. Let C n be the set of all DNA sequences of length n from alphabet D * such that for any c ∈ C n , every subsequence of length three of c must contain an A. We have |C 1 | = 3, |C 2 | = 9, |C 3 | = 19, and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Remark 2 .</head><label>2</label><figDesc>In general, given m &gt; k &gt; 0, set x = A and y = x = T. we use C n (m, k) to denote the set of all sequences c ∈ D n such that every subsequence z of length m of c contains at least k symbols A while z contains at most (k -1) symbols T. As shown earlier, C n (m, k) is an (n, D; m) SSA code for all m, k. A natural question is, for a given number m &gt; 0, what is the value of k, where 1 k m, such that the code C n (m, k) has the largest cardinality? We defer the study of C n (m, k), including the code's cardinality and the design of efficient encoding algorithms to map arbitrary DNA sequences into such a code, to future research work. IV. CONSTRUCTIONS OF (n, D; m) SSA CODES FOR m 3 log n + 4 WITH ONE REDUNDANT SYMBOL</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 4 .</head><label>4</label><figDesc>For a positive integer N , the DNA-representation of N is the replacement of symbols in the quaternary representation of N over Σ 4 = {0, 1, 2, 3} by the following rule:0 ↔ A, 1 ↔ T, 2 ↔ C,and 3 ↔ G. Example 1. If N = 100, the quaternary representation of length 4 of N is 1210, hence, the DNA-representation of N is TCTA. Similarly, when N = 55, the quaternary representation of length 4 of N is 0313, thus the DNArepresentation of N is AGTG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><figDesc>SSA . Given n &gt; m &gt; 0, n &gt; 16, and m 3 log n + 4. Set m = 1.5 log n + 2. The source DNA sequence x ∈ D n-1 . The encoding algorithm includes three phases: prepending phase, scanning and replacing phase, and extending phase. Prepending phase. The source sequence x ∈ D n-1 is prepended with A, to obtain c = Ax of length n. If c is an m-SSA sequence, then the encoder outputs c. Otherwise, it proceeds to the next phase. Scanning and replacing phase. The encoder searches for the first pair of non-overlapping subsequences y, z of length 1 of c, where 1 m , such that y = RC(z), or the first subsequence u of c of the form u = (x 1 x 2 ) t whose length is 2 = 2t m = 1.5 log n + 2, where x 1 , x 2 ∈ D = {A, T, C, G}.</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Theorem 5. The encoder ENC SSA is correct. In other words, ENC SSA (x) is an m-SSA sequence of length n for all x ∈ D n-1 . The redundancy of ENC SSA is one redundant symbol.</p><p>Proof. Suppose that c = ENC SSA (x) ∈ D n , and c = c 1 s, where c 1 is m -SSA and the length of the repeated patterns of size 2 in c 1 is of length at most m = 1.5 log n + 2, and s is the generated suffix of c 1 at the extending phase. Consider an arbitrary sequence y of length 3 log n + 4. Suppose that y = y 1 y 2 , where y 1 is a subsequence of c 1 while y 2 is a subsequence of s. We have the following cases.</p><p>• If y 1 is of length less than m (particularly including the case y 1 ≡ ∅), hence the length of y 2 is more than m . Clearly, there is no subsequence z in c 1 s that y = RC(z), as the length of the repeated patterns of size 2 in c 1 is of length at most m . • If y 1 is of length more than or equal to m , we also conclude that there is no subsequence</p><p>We now present the corresponding decoding algorithm.</p><p>Construction of DEC SSA . From a DNA sequence c of length n, the decoder scans from left to right. If the first symbol is A, the decoder simply removes A and identifies the last (n -1) symbols as the source sequence. On the other hand,</p><p>• if it starts with T, the decoder takes the prefix of length (1 + 1.5 log n) and concludes that this prefix is a pointer prepended after a type-I replacement. In other words, the pointer is of the form Tp 1 p 2 p 3 , where p 1 , p 2 , p 3 , each is of length log 4 n = 0.5 log n. The decoder sets i, j, k to be the positive integers whose DNA-representations are p 1 , p 2 , p 3 , respectively and sets y to be the subsequence containing the symbols from index i to index j. It removes the pointer, adds z ≡ RC(y) to c at index k. • if it starts with C, the decoder takes the prefix of length (3 + log n) and concludes that this prefix is a pointer prepended after a type-II replacement. In other words, the pointer is of the form Cx 1 x 2 q 1 q 2 , where q 1 , q 2 , each is of length log 4 n = 0.5 log n. The decoder sets i, j to be the positive integers whose DNA-representations are q 1 , q 2 , respectively. It then removes the pointer, adds z ≡ (x 1 x 2 ) (j-i+1)/2 to c at index i.</p><p>The decoding procedure terminates when the first symbol is A, and takes the following (n -1) symbols as the user data.</p><p>Complexity analysis. For codeword of length n, the time complexity of the encoder (and the corresponding decoder) is linear in n, which follows from: the number of replacing operations is at most n-m, which is Θ(n), and the complexity of the each replacing operation (including the prepending prefix step or converting quaternary representation to DNArepresentation of an integer) is constant time Θ(1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION</head><p>We have presented efficient algorithms to construct DNA codes that avoid secondary structure of arbitrary stem length. Particularly, when m 3 log n + 4, we have provided an efficient encoder that incurs only one redundant symbol, and when m = 3, our constructions yield a family of DNA codes of rate 1.3031 bits/nt, that improve the previous highest code rate in the literature.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Molecular computation of solutions to combinatorial problems</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Adleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">266</biblScope>
			<biblScope unit="page" from="1021" to="1024" />
			<date type="published" when="1994-11">Nov. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Next-generation digital information storage in DNA</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Church</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kosuri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">337</biblScope>
			<biblScope unit="issue">6102</biblScope>
			<biblScope unit="page" from="1628" to="1628" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">DNA fountain enables a robust and efficient storage architecture</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Erlich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Zielinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">355</biblScope>
			<biblScope unit="issue">6328</biblScope>
			<biblScope unit="page" from="950" to="954" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Random access in large-scale DNA data storage</title>
		<author>
			<persName><forename type="first">L</forename><surname>Organick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Lopez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yekhanin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Makarychev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Racz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kamath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Gopalan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Takahashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Newman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Y</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rashtchian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Stewart</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Carlson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Mulligan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Carmean</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Seelig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Strauss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Biotechnology</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="242" to="248" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Towards practical, high-capacity, lowmaintenance information storage in synthesized DNA</title>
		<author>
			<persName><forename type="first">N</forename><surname>Goldman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bertone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dessimoz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Leproust</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Sipos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Birney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">494</biblScope>
			<biblScope unit="page" from="77" to="80" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An autonomous molecular computer for logical control of gene expression</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Benenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Ben-Dor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Adar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">429</biblScope>
			<biblScope unit="page" from="423" to="429" />
			<date type="published" when="2004-05">May 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Portable and error-free DNA-based data storage</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M H T</forename><surname>Yazdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gabrys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Milenkovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific reports</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="6" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the design of codes for DNA computing</title>
		<author>
			<persName><forename type="first">O</forename><surname>Milenkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kashyap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Coding Cryptogr</title>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-03">Mar. 2006</date>
			<biblScope unit="page" from="100" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mutually uncorrelated primers for DNA-based data storage</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M H T</forename><surname>Yazdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Kiah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gabrys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Milenkovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="6283" to="6296" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient and explicit balanced primer codes</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Chee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Kiah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="5344" to="5357" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On DNA Codes With Multiple Constraints</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Benerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Banerjee</surname></persName>
		</author>
		<idno type="DOI">10.1109/LCOMM.2020.3029071</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Letters</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="365" to="368" />
			<date type="published" when="2021-02">Feb. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On conflict free DNA codes</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Benerjee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Deb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">K</forename><surname>Gupta</surname></persName>
		</author>
		<idno>12095- 020-00459-7</idno>
		<ptr target="https://doi.org/10.1007/s" />
	</analytic>
	<monogr>
		<title level="j">Cryptogr. Commun</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="143" to="171" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">DNA codes that avoid secondary structures</title>
		<author>
			<persName><forename type="first">O</forename><surname>Milenkovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Kashyap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. International Symposium on Information Theory</title>
		<meeting>International Symposium on Information Theory</meeting>
		<imprint>
			<date type="published" when="2005-09">Sep. 2005</date>
			<biblScope unit="page" from="288" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Capacity-Approaching Constrained Codes With Error Correction for DNA-Based Data Storage</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Schouhamer Immink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Kiah</surname></persName>
		</author>
		<idno type="DOI">10.1109/TIT.2021.3066430</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Information Theory</title>
		<imprint>
			<date type="published" when="2021-08">Aug. 2021</date>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="5602" to="5613" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Bounds for DNA codes with constant GC-content</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">D</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Electronic Journal of Combinatorics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Linear constructions for DNA codes</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gaborit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">D</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">334</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="99" to="113" />
			<date type="published" when="2005-04">April 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Coding for Segmented Edits with Local Weight Constraints</title>
		<author>
			<persName><forename type="first">K</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Kiah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Motani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISIT45174.2021.9517851</idno>
	</analytic>
	<monogr>
		<title level="m">2021 IEEE International Symposium on Information Theory (ISIT)</title>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="1694" to="1699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Predicting DNA duplex stability from the base sequence</title>
		<author>
			<persName><forename type="first">K</forename><surname>Breslauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Blocker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Marky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Natl. Acad. Sci. USA</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="3746" to="3750" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fast algorithms for predicting the secondary structure of single stranded RNA</title>
		<author>
			<persName><forename type="first">R</forename><surname>Nussinov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci., USA</title>
		<meeting>Natl. Acad. Sci., USA</meeting>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="6309" to="6313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A characterization of the DNA data storage channel</title>
		<author>
			<persName><forename type="first">R</forename><surname>Heckel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Mikutis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">N</forename><surname>Grass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Rep</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2019-07">Jul. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Binary Subblock Energy-Constrained Codes: Knuth&apos;s Balancing and Sequence Replacement Techniques</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Thanh</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Schouhamer Immink</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISIT44484.2020.9174430</idno>
	</analytic>
	<monogr>
		<title level="m">2020 IEEE International Symposium on Information Theory (ISIT)</title>
		<meeting><address><addrLine>Los Angeles, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="37" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Repeated-Free Codes</title>
		<author>
			<persName><forename type="first">O</forename><surname>Elishco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gabrys</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Medard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Yaakobi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Int. Symp. Inf. Theory (ISIT)</title>
		<meeting>IEEE Int. Symp. Inf. Theory (ISIT)<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Using One Redundant Bit to Construct Two-Dimensional Almost-Balanced Codes</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">M</forename><surname>Kiah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">A</forename><surname>Schouhamer Immink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Chee</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISIT50566.2022.9834724</idno>
	</analytic>
	<monogr>
		<title level="m">2022 IEEE International Symposium on Information Theory (ISIT)</title>
		<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="3091" to="3096" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Non-binary Codes for Correcting a Burst of at Most 2 Deletions</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Farnoud</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISIT45174.2021.9517917</idno>
	</analytic>
	<monogr>
		<title level="m">2021 IEEE International Symposium on Information Theory (ISIT)</title>
		<meeting><address><addrLine>Melbourne, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="2804" to="2809" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
