# Probabilistic Programming Interfaces for Random Graphs: Markov Categories, Graphons, and Nominal Sets

## Abstract

## 

We study semantic models of probabilistic programming languages over graphs, and establish a connection to graphons from graph theory and combinatorics. We show that every well-behaved equational theory for our graph probabilistic programming language corresponds to a graphon, and conversely, every graphon arises in this way.

We provide three constructions for showing that every graphon arises from an equational theory. The first is an abstract construction, using Markov categories and monoidal indeterminates. The second and third are more concrete. The second is in terms of traditional measure theoretic probability, which covers 'black-and-white' graphons. The third is in terms of probability monads on the nominal sets of Gabbay and Pitts. Specifically, we use a variation of nominal sets induced by the theory of graphs, which covers Erd≈ës-R√©nyi graphons. In this way, we build new models of graph probabilistic programming from graphons.

CCS Concepts: ‚Ä¢ Theory of computation ‚Üí Semantics and reasoning; Probabilistic computation.

## INTRODUCTION

This paper is about the semantic structures underlying probabilistic programming with random graphs. Random graphs have applications in statistical modelling across biology, chemistry, epidemiology, and so on, as well as theoretical interest in graph theory and combinatorics (e.g. [[Bornholdt and Schuster 2002]](#)). Probabilistic programming, i.e. programming for statistical modelling [van de [Meent et al. 2018]](#b81), is useful for building the statistical models for the applications. Moreover, as we show (Theorem 23 and Corollary 26), the semantic aspects of programming languages for random graphs correspond to graphons [[Lov√°sz 2012](#b62)], a core structure in graph theory and combinatorics.

To set the scene more precisely, we recall the setting of probabilistic programming with realvalued distributions, and contrast it with the setting with graphs. Many probabilistic programming languages provide a type of real numbers (real) and distributions such as the normal distribution normal : real * real ‚Üí real

(1)

together with arithmetic operations such as (+) : real * real ‚Üí real.

(2)

Even if we encounter an unfamiliar distribution over (real) in a library, we have a rough idea of how to explain what it could be, in terms of probability densities and measures.

In this paper, we consider the setting of probabilistic programming with graphs, where the probabilistic programming language or library provides a type (vertex) and some distribution new : unit ‚Üí vertex

(3) together with a test edge : vertex * vertex ‚Üí bool.

(4)

Our goal is to analyze the interface (vertex, new, edge) for graphs semantically, and answer, for instance, what they could be and what they could do. We give one example analysis in Section 1.1 first, and the general one later in Theorem 23 and Corollary 26, which says that to give an implementation of (vertex, new, edge), satisfying the laws of probabilistic programming, is to give a graphon. In doing so, we connect the theory of probabilistic programming with graph theory and combinatorics.

Probabilistic programming is generally used for statistical inference, in which we describe a generative model by writing a program using primitives such as (1)-( [4](#)) above, and then infer a distribution on certain parameters, given particular observed data. This paper is focused on the generative model aspect, and not inference (although for simple examples, generic inference methods apply immediately, see ¬ß1.5).

## Example of an Implementation of a Random Graph: Geometric Random Graphs

To illustrate the interface (vertex, new, edge) of ( [3](#))-( [4](#)), we consider for illustration a random geometric graph (e.g. [[Bubeck et al. 2016;](#b14)[Penrose 2003]](#b70)) where the vertices are points on the surface of the unit sphere, chosen uniformly at random, and where there is an edge between two vertices if the angle between them is less than some fixed ùúÉ . This random graph might be used, for instance, to model the connections between people on the earth.

For example, a simple statistical inference problem might start from the observed connectivity in Figure [1](#fig_1)(a). We might ask for the distribution on ùúÉ given that this graph arose from the spherical random geometric graph. One sample from this posterior distribution on random geometric graphs with ùúÉ = ùúã/3 is shown in Figure [1(b)](#fig_1). Another, unconditioned sample from the random geometric graph with ùúÉ = ùúã/6 is shown in Figure [1(c)](#fig_1). We can regard this example as an implementation of the interface (vertex, new, edge) as follows: we implement (vertex) as the surface of the sphere (e.g. implemented as Euclidean coordinates).

‚Ä¢ new() : vertex randomly picks a new vertex as a point on the sphere uniformly at random. Figure [1](#fig_1)(c) shows the progress after calling new() 15 times. ‚Ä¢ edge : vertex * vertex ‚Üí bool checks whether there is an edge between two vertices; this amounts to checking whether the angle between two points is less than ùúÉ . randomly returns true or false; the probability of true is the probability of a triangle. This implementation using the sphere is only one way to implement (vertex, new, edge). There are implementations using higher-dimensional spheres, or other geometric objects. We can also consider random equivalence relations as graphs, i.e. disjoint unions of complete graphs, or random bipartite graphs, which are triangle-free. We can consider the Erd≈ës-R√©nyi random graph, where the chance of an edge between two vertices is independent of the other edges, and has a fixed probability. These are all different implementations of the same abstract interface, (vertex, new, edge), and programs such as (5) make sense for all of them. The point of this paper is to characterize all these implementations, as graphons.

## Implementations Regarded as Equational Theories

The key method of this paper is to treat implementations of the interface (vertex, new, edge) extensionally, as equational theories. That is, rather than looking at specific implementation details, we look at the equations between programs that a user of the implementation would rely on. (This is analogous to the idea in model theory of studying first-order theories rather than specific models; similar ideas arise in the algebraic theory of computational effects [Plotkin and [Power 2002]](#).) For example, if an implementation always provides a bipartite random graph, we have the equation [Program (5)](#) ‚â° false between programs, because a triangle is never generated. This equation does not hold in the example of Figure [1(b-c](#fig_1)), since triangles are possible. We focus on a class of equational theories that are well behaved, as follows. First, we suppose that they contain basic laws for probabilistic programming (eqns. ( [7](#)) -(11), ¬ß2.2). This basic structure already appears broadly in different guises, including in Moggi's monadic metalanguage [[Moggi 1989](#b67)], in linear logic [[Ehrhard and Tasson 2019]](#b26), and in synthetic probability theory [[Fritz 2020](#b32)]. Second, we suppose that the equational theories are equipped with a 'Bernoulli base', which means that although we do not specify an implementation for the type (vertex), each closed program of type (bool) is equated with some ordinary Bernoulli distribution, in such a way as to satisfy the classical laws of traditional finite probability theory ( ¬ß 2.4). Finally, we suppose that the edge relation is symmetric (the graphs are undirected) and that it doesn't change when the same question is asked multiple times ('deterministic'), e.g. let ùëé = new() in let ùëè = new() in edge(ùëé, ùëè) & ¬¨edge(ùëé, ùëè) ‚â° false.

(6)

A graphon is a symmetric measurable function [0, 1] 2 ‚Üí [0, 1]. We show that every equational theory for the interface [(vertex, new, edge)](#) gives rise to a graphon (Theorem 23), and conversely that every graphon arises in this way [(Corollary 26)](#).

We emphasize that this abstract treatment of implementations, in terms of equational theories, is very open-ended, and permits a diverse range of implementation methods. Indeed, we show in Section 5 that any implementation using traditional measure-theoretic methods will only produce black-and-white graphons, so this abstract treatment is crucial.

## From Equational Theories to Graphons

In Section 3, we show how an equational theory over programs in the interface [(vertex, new, edge)](#) gives rise to a graphon. The key first step is that graphons (modulo equivalence) can be characterized in terms of sequences of finite random graphs that satisfy three conditions: exchangeability, consistency, and locality.

To define a graphon, we show how to define programs that describe finite random graphs, by using new and edge to build boolean-valued ùëõ √ó ùëõ adjacency matrices, for all ùëõ (shown in ( [18](#formula_30))). Assuming that the equational theory of programs is Bernoulli-based, these programs can be interpreted as probability distributions on the finite spaces of adjacency matrices which, we show, are finite random graphs.

It remains to show that the induced sequence of random graphs satisfies the three conditions for graphons (exchangeability, consistency, and locality). These can be formulated as equational properties, and so they can be verified by using the equational reasoning in the equational theory. This is Theorem 23. A key part of the proof is the observation that exchangeability for graphons connects to commutativity of let (9): we can permute the order in which vertices are instantiated without changing the distributions.

## From Graphons to Equational Theories

We also show the converse: every graphon arises from a good equational theory for the interface [(vertex, new, edge)](#). We look at this from three angles: first, we prove this in the general case using an abstract method, and then, we use concrete methods for two special cases.

Fixing a graphon, we build an equational theory by following a categorical viewpoint. A good equational theory for probabilistic programming amounts to a 'distributive Markov category', which is a monoidal category with coproducts that is well-suited to probability ( ¬ß2.2 and [[Fritz 2020]](#b32)). The idea that distributive categories are a good way to analyze abstract interfaces goes back at least to [[Walters 1989](#b83)], which used distributive categories to study interfaces for stacks and storage. We can thus use now-standard abstract methods for building monoidal and distributive categories to build an equational theory for the programming language.

We proceed in two steps. We first use methods such as [[Hermida and Tennent 2012;](#b39)[Hu and Tholen 1995]](#b41) to build an abstract distributive Markov category that supports the interface (vertex, new, edge) in a generic way. This equational theory is generic and not Bernoulli-based: although it satisfies the equational laws of probabilistic programming, there is no given connection to traditional probability. The second step is to show that (a) it is possible to quotient this generic category to get Bernoulli-based equational theories; (b) the choices of quotient are actually in bijective correspondence with graphons. Thus, we can build an equational theory from which any given graphon arises, via (18): this is Corollary 26. (The framework of Bernoulli-based Markov categories is new here, and the techniques of [[Hermida and Tennent 2012;](#b39)[Hu and Tholen 1995]](#b41) have not previously been applied in categorical probability, so a challenge for future work is to investigate these ideas in other aspects of categorical probability.)

Although this is a general method, it is an abstract method involving quotient constructions. The ideal form of denotational semantics is to explain what programs are by regarding them as functions between certain kinds of spaces. Although Corollary 26 demonstrates that every graphon arises from an equational theory, the type (vertex) is interpreted as an object of an abstract category, and programs are equivalence classes of abstract morphisms. In the remainder of the paper, we give two situations where we can interpret (vertex) as a genuine concrete space, and programs are functions or distributions on spaces. Such an interpretation immediately yields an equational theory, where two programs are equal if they have the same interpretation.

‚Ä¢ Section 5: For 'black-and-white graphons', we present measure-theoretic models of the interface, based on a standard measure-theoretic interpretation of probabilistic programming (e.g. [[Kozen 1981]](#b60)). We interpret (vertex) as a measurable space, and (new) as a probability measure on it, and (edge) in terms of a measurable predicate. Then, the composition of programs is defined in terms of probability kernels and Lebesgue integration. This kind of model exactly captures the black-and-white graphons (Prop. 29). ‚Ä¢ Section 6: For 'Erd≈ës-R√©nyi' graphons, which are constantly gray, and not black-and-white, we present a model based on Rado-nominal sets ( ¬ß6.1). These are a variant of nominal sets ( [[Gabbay and Pitts 1999;](#b34)[Pitts 2013]](#b71)) where the atoms are vertices of the Rado graph (following [[Boja≈Ñczyk et al. 2014]](#b12)). We consider a new notion of 'internal probability measure' in this setting, and use this to give a compositional semantics that gives rise to the Erd≈ës-R√©nyi graphons (Corollary 45).

Together, these more concrete sections then provide further intuition for the correspondence between equational theories and graphons.

## Connection to Practice

We conclude this introduction with remarks on the connection to practical modelling. In practice, the graph interface might form part of a generative model, on which we perform inference. The structure is clearest in a typed language, and one example is the LazyPPL library for Haskell [[Dash et al. 2023](#b24) We can use this as a building block for more complex models. For a simple example, we generated Figure [1](#fig_1)(b) by using the generic Metropolis-Hastings inference of the LazyPPL library to infer ùúÉ given a particular graph (Fig. [1](#fig_1)(a)). We have also implemented other random graphs; our implementation of the Erd≈ës-R√©nyi graph uses stochastic memoization [[Kaddar and Staton 2023;](#b52)[Roy et al. 2008](#b74)].

Summary and context. As we have discussed, our main result is that equational theories for the programming interface ( ¬ß1.1) give rise to graphons ( ¬ß1.3) and every graphon arises in this way ( ¬ß1.4). These results open up new ways to study random graphs, by using programming semantics. On the other hand, our results here put the abstractions of practical probabilistic programming on a solid theoretical foundation (see also ¬ß7).

## PROGRAMMING INTERFACES FOR RANDOM GRAPHS: EQUATIONAL THEORIES AND MARKOV CATEGORIES

In Section 1.1, we considered probabilistic programming over a graph interface. To make this formal, we now recall syntax, types, and equational reasoning for simple probabilistic programming languages. We begin with a general syntax ( ¬ß2.1), which can accommodate various interfaces in the form of type and term constants, including the interface for graphs (Ex. 1(3)).

We study different instantiations of the probabilistic programming language in terms of the equational theories that they satisfy. We consider two equivalent ways of understanding equational theories: as distributive Markov categories ( ¬ß2.2) and in terms of affine monads ( ¬ß2.3). Markov categories are a categorical formulation of probability theory (e.g. [[Fritz 2020]](#b32)), and affine monads arise in the categorical analysis of probability (e.g. [[Fritz et al. 2023;](#b33)[Jacobs 2018;](#b45)[Kock 2012]](#b59)) as well as in the semantics for probabilistic programming (e.g. [Azevedo de [Amorim 2023;](#b10)[Dahlqvist et al. 2018;](#b23)[Dash et al. 2023]](#b24)). We make a connection with traditional probability via the notion of Bernoulli base ( ¬ß2.4).

Much of this section will be unsurprising to experts: the main purpose is to collect definitions and results. The definition of distributive Markov category appears to be novel, and so we go over that definition and correspondence with monads (Propositions 8 and 13). In Section 2.5, we give a construction for quotienting a distributive Markov category, which we will need in Section 4. We include the result in the section because it may be of independent interest.

## Syntax for a Generic Probabilistic Programming Language

Our generic probabilistic programming language is, very roughly, an idealized, typed fragment of a typical language like Church [[Goodman et al. 2008](#b37)]. We start with a simple programming language (following [[Ehrhard and Tasson 2019;](#b26)[Staton 2017;](#)[Stein 2021]](#b78) but also [[Moggi 1989](#b67)]) with at least the following product and sum type constructors:

$Œì ‚ä¢ ùë° : 0 Œì ‚ä¢ case ùë° of {} : ùêµ Œì ‚ä¢ ùë° : ùê¥ 1 + ùê¥ 2 Œì, ùë• ùëñ : ùê¥ ùëñ ‚ä¢ ùë¢ ùëñ : ùêµ ùëñ ‚àà {1,2} Œì ‚ä¢ case ùë° of {in 1 (ùë• 1 ) ‚áí ùë¢ 1 ; in 2 (ùë• 2 ) ‚áí ùë¢ 2 } : ùêµ (Here, a context Œì is a sequence of assignments of types ùê¥ to variables ùë•.)$In what follows, we use shorthands such as bool = unit + unit, and if-then-else instead of case. This language is intended to be a generic probabilistic programming language, but so far there is nothing specifically probabilistic about this syntax. Different probabilistic programming languages support distributions over different kinds of structures. Thus, our language is extended according to an 'interface' by specifying type constants and typed term constants ùëì : ùê¥ ‚Üí ùêµ. For each term constant ùëì : ùê¥ ‚Üí ùêµ, we include a new typing rule, Œì ‚ä¢ ùë° : ùê¥ Œì ‚ä¢ ùëì (ùë°) : ùêµ Example 1. We consider the following examples of interfaces.

(1) For probabilistic programming over finite domains, we may have term constants such as bernoulli 0.5 : unit ‚Üí bool, intuitively a fair coin toss.

(2) For probabilistic programming over real numbers, we may have a type constant real and term constants such as normal : real * real ‚Üí real, intuitively a parameterized normal distribution, and arithmetic operations such as (+) : real * real ‚Üí real.

(3) The main interface of this paper is for random graphs: this has a type constant vertex and term constants new : unit ‚Üí vertex and edge : vertex * vertex ‚Üí bool.

(We have kept this language as simple as possible, to focus on the interesting aspects. A practical probabilistic programming language will include other features, which are largely orthogonal, and indeed within our implementation in Haskell ( ¬ß1.5), programming features like higher order functions and recursion are present and useful. See also the discussion in ¬ß2.3.4.)

## Equational Theories and Markov Categories

Section 2.1 introduced a syntax for various probabilistic programming interfaces. The idea is that this is a generic language which applies to different interfaces with different distributions that are implemented in different ways. Rather than considering various ad hoc operational semantics, we study the instances of interfaces by the program equations that they support.

Regardless of the specifics of a particular implementation, we expect basic equational reasoning principles for probabilistic programming to hold, such as the following laws:

$(let ùë¶=(let ùë•=ùë° in ùë¢) in ùë° ‚Ä≤ ) ‚â° (let ùë•=ùë° in let ùë¶=ùë¢ in ùë° ‚Ä≤ ) (where ùë• ‚àâ fv(ùë° ‚Ä≤ )) (7) (ùë°, ùë¢) ‚â° (let ùë• = ùë° in let ùë¶ = ùë¢ in (ùë•, ùë¶)) (8) (let ùë•=ùë° in let ùë• ‚Ä≤ =ùë° ‚Ä≤ in ùë¢) ‚â° (let ùë• ‚Ä≤ =ùë° ‚Ä≤ in let ùë•=ùë° in ùë¢)$(where ùë• ‚àâ fv(ùë° ‚Ä≤ ) and ùë• ‚Ä≤ ‚àâ fv(ùë°)) (9)

$(let ùë• = ùë° ‚Ä≤ in ùë°) ‚â° ùë° (where ùë• ‚àâ fv(ùë°))(10)$The following law does not always hold, but does hold when ùë£ is 'deterministic'.

$(let ùë• = ùë£ in ùë°) ‚â° ùë° [ùë£/ùë•](11)$Equations ( [9](#)) and (10) say that parts of programs can be re-ordered and discarded, as long as the dataflow is respected. This is a feature of probabilistic programming. For example, coins do not remember the order nor how many times they have been tossed. But these equations would typically not hold in a language with state.

The cleanest way to study equational theories of programs is via a categorical semantics, and for Markov categories have arisen as a canonical setting for categorical probability. Informally, a category is a structure for composition, and this matches the composition structure of let in our language. We also have monoidal structure which allows for the type constructor ùê¥ √ó ùêµ and for the compound contexts Œì, comonoid structure which allows duplication of variables, and distributive coproduct structure which allows for the sum types. Definition 2. A symmetric monoidal category (C, ‚äó, ùêº ) is a category C equipped with a functor ‚äó : C √ó C ‚Üí C and an object ùêº together with associativity, unit and symmetry structure ( [[Mac Lane 1998, XI.1.]](#)). A Markov category ( [[Fritz 2020]](#b32)) is a symmetric monoidal category in which

‚Ä¢ the monoidal unit ùêº is a terminal object (ùêº = 1), and ‚Ä¢ every object ùëã is equipped with a comonoid Œî ùëã : ùëã ‚Üí ùëã ‚äó ùëã , compatible with the tensor product (Œî ùëã ‚äóùëå = (ùëã ‚äó swp ‚äó ùëå ) ‚Ä¢ (Œî ùëã ‚äó Œî ùëå ), where swp is the swap map of C).

A morphism ùëì : ùëã ‚Üí ùëå in a Markov category is deterministic if it commutes with the comonoids:

$(ùëì ‚äó ùëì ) ‚Ä¢ Œî ùëã = Œî ùëå ‚Ä¢ ùëì .$A distributive symmetric monoidal category (e.g. [[Jay 1993;](#b48)[Walters 1989]](#b83)) is a symmetric monoidal category equipped with chosen finite coproducts such that the canonical maps ùëã ‚äó ùëç + ùëå ‚äó ùëç ‚Üí (ùëã + ùëå ) ‚äó ùëç and 0 ‚Üí 0 ‚äó ùëç are isomorphisms. A distributive Markov category is a Markov category whose underlying monoidal category is also distributive and whose chosen coproduct injections ùëã ‚Üí ùëã + ùëå ‚Üê ùëå are deterministic. A distributive category [[Carboni et al. 1993;](#b18)[Cockett 1993](#b20)] is a distributive Markov category where all morphisms are deterministic.

A (strict) distributive Markov functor is a functor ùêπ : C ‚Üí D between distributive Markov categories which strictly preserves the chosen symmetric monoidal, coproduct, and comonoid structures.

In this paper we mainly focus on functors between distributive Markov categories that strictly preserve the relevant structure, so we elide 'strict'. (Nonetheless, non-strict functors are important, e.g. [[Fritz 2020, ¬ß10](#).2] and Prop. 13.)

We interpret the language of Section 2.1 in a distributive Markov category C by interpreting types ùê¥ and type contexts Œì as objects ùê¥ and Œì , and typed terms Œì ‚ä¢ ùë° : ùê¥ as morphisms

$Œì Œî Œì ---‚Üí Œì ‚äó Œì Œì ‚äó ùë° ------‚Üí Œì ‚äó ùê¥ 1 + ùê¥ 2 Œì, ùë• : ùê¥ 1 + Œì, ùë• : ùê¥ 2 ‚ü® ùë¢ 1 , ùë¢ 2 ‚ü© --------‚Üí ùêµ Œì ‚ä¢ ùëì (ùë°) : ùêµ = Œì ùë° --‚Üí ùê¥ ùëì --‚Üí ùêµ$An interpretation in a Markov category induces an equational theory between programs: let Œì ‚ä¢ ùë° = ùë¢ : ùê¥ if ùë° = ùë¢ . Proposition 3 (e.g. [[Stein 2021](#b78)], ¬ß7.1). The equational theory induced by the interpretation in a distributive Markov category, with given interpretations of type and term constants, always includes the equations (7)-( [10](#formula_2)), and also (11) whenever ùë£ is a deterministic morphism.

Example 4. The category (FinSet, √ó, 1) of finite sets is a distributive Markov category. As in any category with products, each object has a unique comonoid structure, and all morphisms are deterministic. This is a good Markov category for interpreting the plain language with no type or term constants. For example, bool is a set with two elements.

Example 5. The category FinStoch has natural numbers as objects and the morphisms are stochastic matrices. In more detail, a morphism ùëö ‚Üí ùëõ is a matrix in (R ‚â•0 ) ùëö√óùëõ such that each row sums to 1. Composition is by matrix multiplication. The monoidal structure is given on objects by multiplication of numbers, and on morphisms by Kronecker product of matrices. By choosing an enumeration of each finite set, we get a functor FinSet ‚Üí FinStoch that converts a function to the corresponding (0/1)-valued matrix. So every object of FinStoch can be regarded with the comonoid structure from FinSet. The deterministic morphisms in FinStoch are exactly the morphisms from FinSet [[Fritz 2020, 10.3]](#). This is a good Markov category for interpreting the language with Bernoulli distributions (Ex. 1(1)). We interpret the fair coin as the 1 √ó 2 matrix (0.5, 0.5).

We can also give some interpretations for the graph interface (Ex. 1(3)) in FinStoch. For instance, consider random graphs made of two disjoint complete subgraphs, as is typical in a clustering model. We can interpret this by putting vertex = 2, edge = ( 1 0 0 1 0 1 1 0 ) ‚ä§ , and new = (0.5, 0.5).

We look at other examples of distributive Markov categories and interpretations of these interfaces in [Sections 2.3.2](#) and [2.3.3,](#) and [then in Sections 4-6.](#) 2.3 Equational Theories and Affine Monads 2.3.1 Distributive Markov Categories from Affine Monads. One way to generate equational theories via Markov categories is by considering certain kinds of monads, following Moggi [[Moggi 1989](#b67)]. Definition 6. A strong monad on a category A with finite products is given by

‚Ä¢ for each object ùëã , an object ùëá (ùëã );

‚Ä¢ for each object ùëã , a morphism ùúÇ ùëã : ùëã ‚Üí ùëá (ùëã );

‚Ä¢ for objects ùëç, ùëã, ùëå , a family of functions natural in ùëç

$(>>=) : A(ùëç,ùëá (ùëã )) √ó A(ùëç √ó ùëã,ùëá (ùëå )) ‚Üí A(ùëç,ùëá (ùëå ))$such that >>= is associative with unit ùúÇ.

(There are various different formulations of this structure. When A is cartesian closed, as in Defs. 9 and 41, then the bind (>>=) is represented by a morphism (>>=) : ùëá (ùëã ) √ó (ùëã ‚áí ùëá (ùëå )) ‚Üí ùëá (ùëå ), by the Yoneda lemma.) Definition 7 ( [[Jacobs 1994;](#b43)[Kock 1970;](#b58)[Lindner 1979]](#b61)). Given a strong monad ùëá , we say that two morphisms ùëì :

$ùëã 1 ‚Üí ùëá (ùëã 2 ), ùëî : ùëã 1 ‚Üí ùëá (ùëã 3 ) commute if ùëì >>= ((ùëî ‚Ä¢ ùúã 1 ) >>= (ùúÇ ‚Ä¢ ‚ü®ùúã 2 ‚Ä¢ ùúã 1 , ùúã 2 ‚ü©)) = ùëî >>= ((ùëì ‚Ä¢ ùúã 1 ) >>= (ùúÇ ‚Ä¢ ‚ü®ùúã 2 , ùúã 2 ‚Ä¢ ùúã 1 ‚ü©)) : ùëã 1 ‚Üí ùëá (ùëã 2 √ó ùëã 3 ). A strong monad is commutative if all morphisms commute. It is affine if ùëá (1) ‚Üí 1 is an isomorphism.$The Kleisli category Kl(ùëá ) of a strong monad ùëá has the same objects as A, but the morphisms are different: Kl(ùëá ) (ùê¥, ùêµ) = A(ùê¥,ùëá (ùêµ)). There is a functor ùêΩ : A ‚Üí Kl(ùëá ), given on morphisms by composing with ùúÇ (e.g. [[Mac Lane 1998, ¬ßVI.5](#)], [[Moggi 1989]](#b67)). Proposition 8. Let ùëá be a strong monad on a category A. If ùëá is commutative and affine and A has finite products, then the Kleisli category Kl(ùëá ) has a canonical structure of a Markov category. Furthermore, if A is distributive, then Kl(ùëá ) can be regarded as a distributive Markov category.

Proof notes. The Markov structure follows [[Fritz 2020, ¬ß3]](#). Since ùëá is commutative, the product structure of A extends to a symmetric monoidal structure on Kl(ùëá ). Since ùëá (1) = 1, the monoidal unit (1) is terminal in Kl(ùëá ). Every object in A has a comonoid structure, and this is extended to Kl(ùëá ) via ùêΩ . The morphisms in the image of ùêΩ are deterministic, although this need not be a full characterization of determinism.

For the distributive structure, recall that ùêΩ preserves coproducts and indeed it has a right adjoint. Hence, the coproduct injections will be deterministic. ‚ñ°

We can thus interpret the language of Section 2.1 using any strong monad, interpreting the types ùê¥ as objects ùê¥ of A, and a term Œì ‚ä¢ ùë° : ùê¥ as a morphism ùë° : Œì ‚Üí ùëá ( ùê¥ ). This interpretation matches Moggi's interpretation of the language of Section 2.1 in a strong monad.

## Example Affine Monad: Distribution Monad.

Definition 9 (e.g. [[Jacobs 2016](#b44)], ¬ß4.1). The distribution monad D on Set is defined as follows:

‚Ä¢ On objects: each set ùëã is mapped to the set of all finitely-supported discrete probability measures on ùëã , that is, all functions ùëù : ùëã ‚Üí R that are non-zero for only finitely many elements and satisfy ùë• ‚ààùëã ùëù (ùë•) = 1. ‚Ä¢ The unit ùúÇ ùëã : ùëã ‚Üí D (ùëã ) maps ùë• ‚àà ùëã to the indicator function ùúÜùë¶. [ùë¶ = ùë•], i.e. the Dirac distribution ùõø ùë• . ‚Ä¢ The bind function (>>=) is defined as follows:

$(ùëì >>= ùëî) (ùëß) (ùë¶) = ùë• ‚ààùëã ùëì (ùëß) (ùë•) ‚Ä¢ ùëî(ùëß, ùë•) (ùë¶)$By the standard construction for strong monads, each morphism ùëì : ùëã ‚Üí ùëå gets mapped to D ùëì : Dùëã ‚Üí Dùëå , that is, the pushforward in this case:

$D ùëì (ùëù) (ùë¶) = ùë• ‚àà ùëì -1 (ùë¶) ùëù (ùë•).$Consider the language with no type constants, and just the term constant bernoulli 0.5 (Ex. 1( [1](#))). This can be interpreted in the distribution monad. Since every type ùê¥ is interpreted as a finite set ùê¥ , and every context Œì as a finite set Œì , a term Œì ‚ä¢ ùë° : ùê¥ is interpreted as a function Œì ‚Üí D ùê¥ . To give a Kleisli morphism between finite sets is to give a stochastic matrix, and so the induced equational theory is the same as the interpretation in FinStoch (Ex. 5).

## Example Affine

Monad: Giry Monad. We recall some rudiments of measure-theoretic probability.

Definition 10. A ùúé-algebra on a set is a non-empty collection of subsets that contains the empty set and is closed under countable unions and complements. A measurable space is a pair (ùëã, Œ£) of a set and a ùúé-algebra on it. A measurable function

$(ùëã, Œ£ ùëã ) ‚Üí (ùëå , Œ£ ùëå ) is a function ùëì : ùëã ‚Üí ùëå such that ùëì -1 (ùëà ) ‚àà Œ£ ùëã for all ùëà ‚àà Œ£ ùëå .$A probability measure on a measurable space (ùëã, Œ£) is a function ùúá : Œ£ ‚Üí [0, 1] that has total mass 1 (ùúá (ùëã ) = 1) and that is ùúé-additive: ùúá ( ‚àû ùëñ=1 ùëà ùëñ ) = ‚àû ùëñ=1 ùúá (ùëà ùëñ ) for any sequence of disjoint ùëà ùëñ . Examples of measurable spaces include: the finite sets ùëã equipped with their powerset ùúé-algebras; the unit interval [0, 1] equipped with its Borel ùúé-algebra, which is the least ùúé-algebra containing the open sets. Examples of probability measures include: discrete probability measures (Def. 9); the uniform measure on [0, 1]; the Dirac distribution

$ùõø ùë• (ùëà ) = [ùë• ‚àà ùëà ].$The product of two measurable spaces (ùëã, Œ£ ùëã ) √ó (ùëå , Œ£ ùëå ) = (ùëã √ó ùëå , Œ£ ùëã ‚äó Œ£ ùëå ) comprises the product of sets with the least ùúé-algebra making the projections ùëã ‚Üê ùëã √ó ùëå ‚Üí ùëå measurable. The category of measurable spaces and measurable functions is a distributive category.

A probability kernel between measurable spaces (ùëã, Œ£ ùëã ) and (ùëå , Œ£ ùëå ) is a function ùëò : ùëã √ó Œ£ ùëå ‚Üí [0, 1] that is measurable in the first argument and that is ùúé-additive and has mass 1 in the second argument.

To compose probability kernels, we briefly recall Lebesgue integration. Consider a measurable space (ùëã, Œ£ ùëã ), a measure ùúá : Œ£ ùëã ‚Üí [0, 1], and a measurable function

$ùëì : ùëã ‚Üí [0, 1]. If ùëì is a simple function, i.e. ùëì (ùë•) = ùëö ùëñ=1 ùëü ùëñ ‚Ä¢ [ùë• ‚àà ùëà ùëñ ] for some ùëö, ùëü ùëñ ‚àà [0, 1], and ùëà ùëñ ‚àà Œ£ ùëã , the Lebesgue integral ‚à´ ùëì dùúá = ‚à´ ùëì (ùë•) ùúá (dùë•) ‚àà [0, 1] is defined to be ùëö ùëñ=1 ùëü ùëñ √ó ùúá (ùëà ùëñ ).$If ùëì is not a simple function, there exists a sequence of increasing simple functions ùëì 1 , ùëì 2 , . . . : ùëã ‚Üí [0, 1] such that sup ùëò ùëì ùëò (ùë•) = ùëì (ùë•) (for example, by taking ùëì ùëò (ùë•) def = ‚åä10 ùëò ùëì (ùë•)‚åã/10 ùëò ). In that case, the integral is defined to be the limit of the integrals of the ùëì ùëò 's (which exists by monotone convergence).

Probability kernels can be equivalently formulated as morphisms ùëã ‚Üí G(ùëå ), where G is the Giry monad: Definition 11 ( [[Giry 1980]](#b36)). The Giry monad G is a strong monad on the category Meas of measurable spaces given by ‚Ä¢ G(ùëã ) is the set of probability measures on ùëã , with the least ùúé-algebra making ‚à´ ùëì d(-) : G(ùëã ) ‚Üí [0, 1] measurable for all measurable ùëì : ùëã ‚Üí [0, 1];

‚Ä¢ the unit ùúÇ maps ùë• to the Dirac distribution ùõø ùë• ;

‚Ä¢ the bind is given by composing kernels:

$(ùëò >>= ùëô) (ùëß, ùëà ) = ‚à´ ùëô ((ùëß, ùë•), ùëà ) ùëò (ùëß, dùë•). (12$$)$Proposition 12. The monad G is commutative and affine.

Proof notes. Commutativity boils down to Fubini's theorem for reordering integrals and affineness is marginalization (since probability measures have mass 1). See also [[Jacobs 2018](#b45)]. ‚ñ° Consider the real-numbers language (Ex. 1(2)). Let real = R, with the Borel sets, and interpret normal as the normal probability measure on R. The basic arithmetic operations are all measurable.

Among the following three programs

$let ùë• = normal(0, 1) in ùë• + ùë• (13) let ùë• = normal(0, 1) in let ùë¶ = normal(0, 1) in ùë• + ùë¶ (14) normal(0, 1) + normal(0, 1)(15)$the programs ( [14](#)) and ( [15](#formula_15)) denote the same normal distribution with variance 2, whereas (13) denotes a distribution with variance 4. Notice that we cannot use ( [11](#formula_3)) to equate all the programs, because normal is not deterministic. We can also interpret the Bernoulli language (Ex. 1(1)) in the Giry monad; this interpretation gives the same equational theory as the interpretation in FinStoch and in the distribution monad in Section 2.3.2.

We can also give some interpretations for the graph interface (Ex. 1(3)) in the Giry monad. For an informal example, consider the geometric example from Section 1.1, let vertex = ùëÜ 2 (the sphere), and define new to be the uniform distribution on the sphere. (See also Section 5.2.) 2.3.4 Affine Monads from Distributive Markov Categories. The following result, a converse to Proposition 8, demonstrates that the new notion of distributive Markov category (Def. 2) is a canonical one, and emphasizes the close relationship between semantics with distributive Markov categories and semantics with commutative affine monads.

Proposition 13. Let C be a small distributive Markov category. Then, there is a distributive category A with a commutative affine monad ùëá on it and a full and faithful functor C ‚Üí Kl(ùëá ) that preserves symmetric monoidal structure, comonoids, and sums.

Proof notes. Our proof is essentially a recasting of [[Power 2006b, ¬ß7]](#) to this different situation, as follows.

Let C det be the wide subcategory of C comprising the deterministic morphisms, and write ùêΩ : C det ‚Üí C for the identity-on-objects inclusion functor. Note that C det is a distributive category. We would like to exhibit C as the Kleisli category for a monad on C det , but this might not be possible: intuitively, C det might be too small for the monad to exist. Instead, we first embed C det in a larger category A and construct a monad on A.

The main construction in our proof is the idea that if X is a small distributive monoidal category, then the category FP(X op , Set) of finite-product-preserving functors is such that

‚Ä¢ FP(X op , Set) is cocomplete and moreover total [([Street and Walters 1978]](#)) as a category;

‚Ä¢ FP(X op , Set) admits a distributive monoidal structure;

‚Ä¢ the Yoneda embedding X ‚Üí [X op , Set], which is full and faithful, factors through FP(X op , Set), and this embedding X ‚Üí FP(X op , Set) preserves finite sums and is strongly monoidal; ‚Ä¢ the Yoneda embedding exhibits FP(X op , Set) as a free colimit completion of X as a monoidal category that already has finite coproducts. So we let A = FP(C op det , Set) comprise the finite-product-preserving functors C op det ‚Üí Set. This is a distributive category. To get a monad on A, we note that since FP(C op , Set) has finite coproducts and C det ‚Üí C ‚Üí FP(C op , Set) preserves finite coproducts and is monoidal, the monoidal structure induces a canonical colimit-preserving monoidal functor ùêΩ ! : FP(C op det , Set) ‚Üí FP(C op , Set). Any colimit-preserving functor ùêΩ ! out of a total category has a right adjoint ùêΩ * , and hence a monoidal monad (ùêΩ * ùêΩ ! ) is induced on A.

It remains for us to check that the embedding C ‚Üí FP(C op , Set) factors through the comparison functor Kl(ùêΩ * ùêΩ ! ) ‚Üí FP(C op , Set), which follows from the fact that ùêΩ : C det ‚Üí C is identity on objects.

‚ñ°

As an aside, we note that, although our simple language in Section 2.1 did not include higherorder functions, the category A constructed in the proof of Proposition 13 is cartesian closed, and since the embedding is full and faithful, this shows that higher-order functions would be a conservative extension of our language. Indeed, this kind of conservativity result was part of the motivation of [[Power 2006b](#)]. For the same reason, inductive types (lists, and so on) would also be a conservative extension. We leave conservativity with other language features for future work. Recursion in probabilistic programming is still under investigation [[Ehrhard et al. 2018;](#b25)[Goubault-Larrecq et al. 2021;](#)[Jia et al. 2021;](#b49)[Matache et al. 2022;](#b66)[V√°k√°r et al. 2019]](#b80); there is also the question of conservativity with respect to combining Markov categories, e.g. combining real number distributions ((1)-( [2](#))) with graph programming ((3)-( [4](#))).

## Bernoulli Bases, Numerals and Observation

Although an interface may have different type constants, it will always have the 'numeral' types, sometimes called 'finite' types:

$0 unit bool = unit + unit unit + unit + unit . . .$For probabilistic programming languages, there is a clear expectation of what will happen when we run a program of type bool: it will randomly produce either true or false, each with some probability. Similarly for other numeral types. For type constants, we might not have evident notions of observation or expected outcomes. But for numeral types, it should be routine. We now make this precise via the notion of Bernoulli base.

On the semantic side, distributive Markov categories will always have 'numeral' objects

$0 1 2 def = 1 + 1 3 def = 1 + 1 + 1 . . .$For any type ùê¥ formed without type constants, and any Markov category, we have that ùê¥ ùëõ for some numeral object. Any equational theory for the programming language induces in particular an equational theory for the sub-language without any type constants. Proposition 14. For any distributive Markov category C, let C N be the category whose objects are natural numbers, and where the morphisms are the morphisms in C between the corresponding numeral objects. This is again a distributive Markov category.

Example 15.

(1) FinSet N = Set N is equivalent to FinSet as a category.

(2) For the finite distributions and the Giry monad ( ¬ß2.

$3.2-2.3.3), Kl(D) N ‚âÉ Kl(G) N ‚âÉ FinStoch.$Recall that a functor is faithful if it is injective on hom-sets. Definition 16. A Bernoulli base for a distributive Markov category C is a faithful distributive Markov functor Œ® : C N ‚Ü£ FinStoch.

Thus, for any distributive Markov category with a Bernoulli base, for any closed term ‚ä¢ ùë° : ùê¥ of numeral type ( ùê¥ = ùëõ), we can regard its interpretation ùë° : 1 ‚Üí ùëõ as nothing but a probability distribution Œ®( ùë° ) on ùëõ outcomes. This is the case even if ùë° uses term constants and has intermediate subterms using type constants.

Example 17. All the examples seen so far can be given Bernoulli bases. In fact, for FinStoch, Kl(D) and Kl(G), the functor Œ® : C N ‚Ü£ FinStoch is an isomorphism of distributive Markov categories.

When Œ® is an isomorphism of categories, that means that all the finite probabilities are present in C. This is slightly stronger than we need in general. For instance, when C = FinSet, there is a unique Bernoulli base Œ® : FinSet N ‚Ü£ FinStoch, taking a function to a 0/1-valued matrix, but it is not full. We could also consider variations on FinStoch. For example, consider the subcategory FinQStoch of FinStoch where the matrices are rational-valued; this has a Bernoulli base that is not an isomorphism.

## Quotients of Distributive Markov Categories

We provide a new, general method for constructing a Bernoulli-based Markov category out of a distributive Markov category. Our construction is a categorical formulation of the notion of contextual equivalence.

Recall that, in general, contextual equivalence for a programming language starts with a notion of basic observation for closed programs at ground types. We then say that programs Œì ‚ä¢ ùë°, ùë¢ : ùê¥ at other types are contextually equivalent if for every context C with ‚ä¢ C [ùë°], C [ùë¢] : ùëõ, for some ground type ùëõ, we have that C [ùë°] and C [ùë¢] satisfy the same observations. In the categorical setting, the notion of observation is given by a distributive Markov functor C N ‚Üí FinStoch, and the notion of context C is replaced by suitable morphisms (‚Ñé, ùëò below). We now introduce a quotient construction that will be key in showing that every graphon arises from a distributive Markov category (Corollary 26), via Theorem 23. We note that this is a general new method for building Markov categories.

Proposition 18. Let C be a distributive Markov category, and let Œ® : C N ‚Üí FinStoch be a distributive Markov functor. Suppose that for every object ùëã ‚àà C, either ùëã = 0 or there exists a morphism 1 ‚Üí ùëã . Then, there is a distributive Markov category C/ Œ® with a Bernoulli base, equipped with a distributive Markov functor C ‚Üí C/ Œ® and a factorization of distributive Markov functors

$Œ® = C N ‚Üí (C/ Œ® ) N ‚Ü£ FinStoch. Proof. Define an equivalence relation ‚àº on each hom-set C(ùëã, ùëå ), by ùëì ‚àº ùëî : ùëã ‚Üí ùëå if ‚àÄùëç, ùëõ. ‚àÄ‚Ñé : 1 ‚Üí ùëã ‚äó ùëç . ‚àÄùëò : ùëå ‚äó ùëç ‚Üí ùëõ. Œ®(ùëò ‚Ä¢ (ùëì ‚äó ùëç ) ‚Ä¢ ‚Ñé) = Œ®(ùëò ‚Ä¢ (ùëî ‚äó ùëç ) ‚Ä¢ ‚Ñé) in FinStoch(1, ùëõ).$Informally, our equivalence relation considers all ways of generating ùëã 's via precomposition (‚Ñé), all ways for testing ùëå 's via postcomposition (ùëò), and all ways of combining with some ancillary data (ùëç ). It is essential that we consider all these kinds of composition in order for the quotient category to have the categorical structure.

It is immediate that composition of morphisms respects ‚àº, and hence we have a category: the objects are the same as C, and the morphisms are ‚àº-equivalence classes. This is our category C/ Œ® .

It is also immediate that if ùëì ‚àº ùëî and ùëì ‚Ä≤ ‚àº ùëî ‚Ä≤ then (ùëì ‚äó ùëì ‚Ä≤ ) ‚àº (ùëî ‚äó ùëî ‚Ä≤ ). Thus, C/ Œ® is a monoidal category.

For the coproduct structure, we must show that if ùëì ‚àº ùëî : ùëã ‚Üí ùëå and ùëì ‚Ä≤ ‚àº ùëî ‚Ä≤ : ùëã ‚Ä≤ ‚Üí ùëå ‚Ä≤ then (ùëì + ùëì ‚Ä≤ ) ‚àº (ùëî + ùëî ‚Ä≤ ) : ùëã + ùëã ‚Ä≤ ‚Üí ùëå + ùëå ‚Ä≤ . We proceed by noting that since we have morphisms ùë• : 1 ‚Üí ùëã and ùë• ‚Ä≤ : 1 ‚Üí ùëã ‚Ä≤ , as well as terminal morphisms ùëã ‚Üí 1 and ùëã ‚Ä≤ ‚Üí 1, we have that ùëã + ùëã ‚Ä≤ is a retract of ùëã ‚äó ùëã ‚Ä≤ ‚äó 2, with the section and retraction given by:

$ùëã + ùëã ‚Ä≤ ùëã ‚äóùë• ‚Ä≤ +ùë• ‚äóùëã ---------‚Üí ùëã ‚äó ùëã ‚Ä≤ + ùëã ‚äó ùëã ‚Ä≤ ùëã ‚äó ùëã ‚Ä≤ ‚äó 2 ùëã ‚äó ùëã ‚Ä≤ ‚äó 2 ùëã ‚äó ùëã ‚Ä≤ + ùëã ‚äó ùëã ‚Ä≤ ùëã ‚äó!+!‚äóùëã -------‚Üí ùëã + ùëã ‚Ä≤$Thus, by composing with this retract, it suffices to check that (ùëì ‚äó ùëì ‚Ä≤ ‚äó 2) ‚àº (ùëî ‚äó ùëî ‚Ä≤ ‚äó 2), which we have already shown.

The functor Œ® : C N ‚Üí FinStoch clearly factors through (C/ Œ® ) N , but it remains to check that the functor (C/ Œ® ) N ‚Üí FinStoch is now faithful (Bernoulli base). So suppose that Œ®(ùëì ) = Œ®(ùëî). To show that ùëì ‚àº ùëî : 1 ‚Üí ùëö, we consider ‚Ñé : 1 ‚Üí 1 ‚äó ùëç , and ùëò : ùëö ‚äó ùëç ‚Üí ùëõ. We must show that

$Œ®(ùëò ‚Ä¢ (ùëì ‚äó ùëç ) ‚Ä¢ ‚Ñé) = Œ®(ùëò ‚Ä¢ (ùëî ‚äó ùëç ) ‚Ä¢ ‚Ñé). Since ‚Ñé = 1 ‚äó ‚Ñé ‚Ä≤ , for some ‚Ñé ‚Ä≤ : 1 ‚Üí ùëç , we have Œ®(ùëò ‚Ä¢ (ùëì ‚äó ùëç ) ‚Ä¢ ‚Ñé) = Œ®(ùëò ‚Ä¢ (ùëö ‚äó ‚Ñé ‚Ä≤ ) ‚Ä¢ ùëì ) = Œ®(ùëò ‚Ä¢ (ùëö ‚äó ‚Ñé ‚Ä≤ )) ‚Ä¢ Œ®(ùëì ) = Œ®(ùëò ‚Ä¢ (ùëö ‚äó ‚Ñé ‚Ä≤ )) ‚Ä¢ Œ®(ùëî) = Œ®(ùëò ‚Ä¢ (ùëö ‚äó ‚Ñé ‚Ä≤ ) ‚Ä¢ ùëî) = Œ®(ùëò ‚Ä¢ (ùëî ‚äó ùëç ) ‚Ä¢ ‚Ñé). ‚ñ° 3 FROM PROGRAM EQUATIONS TO GRAPHONS$The graph interface for the probabilistic programming language (Ex. 1(3)) does not have one fixed equational theory. Rather, we want to consider different equational theories for the language, corresponding to different implementations of the interface for the graph (see also ¬ß1.2). We now show how the different equational theories for the graph language each give rise to a graphon, by building adjacency matrices for finite graphs (shown in ( [18](#formula_30))). To do this, we set up the well-behaved equational theories ( ¬ß2.4), recall the connection between graphons and finite random graphs ( ¬ß3.1), and then show the main result ( ¬ß3.2, Theorem 23).

## Graphons as Consistent and Local Random Graph Models

For all ùëõ ‚â• 1, let [ùëõ] be the set {1, . . . , ùëõ}. (We sometimes omit the square brackets, when it is clear.) A simple undirected graph ùëî with ùëõ nodes can be represented by its adjacency matrix ùê¥ ùëî ‚àà 2 [ùëõ] 2 such that ùê¥ ùëî (ùëñ, ùëñ) = 0 and ùê¥ ùëî (ùëñ, ùëó) = ùê¥ ùëî ( ùëó, ùëñ). Henceforth, we will assume that finite graphs are simple and undirected, unless otherwise stated. A random finite graph, then, has a probability distribution in D 2 [ùëõ] 2 that only assigns non-zero probability to adjacency matrices.

Definition 19 (e.g. [[Lov√°sz 2012, ¬ß11.2.1]](#)). A random graph model is a sequence of distributions of random finite graphs of the form:

$ùëù 1 ‚àà D 2 [1] 2 , ùëù 2 ‚àà D 2 [2] 2 , . . . , ùëù ùëõ ‚àà D 2 [ùëõ] 2 , . . .$We say such a sequence is

‚Ä¢ exchangeable if each of its elements is invariant under permuting nodes: for every ùëõ and bijection ùúé : ùëõ] 2 is the function that permutes the rows and columns according to ùúé; we are regarding D as a covariant functor, Def. 9, and 2 (-) as a contravariant functor); ‚Ä¢ consistent if the sequence is related by marginals: for every ùëõ and for the inclusion function

$[ùëõ] ‚Üí [ùëõ], we have D 2 (ùúé 2 ) (ùëù ùëõ ) = ùëù ùëõ (where 2 (ùúé 2 ) : 2 [ùëõ] 2 ‚Üí 2 [$$ùúÑ : [ùëõ] ‚Ü©‚Üí [ùëõ + 1], D 2 (ùúÑ 2 ) (ùëù ùëõ+1 ) = ùëù ùëõ ($where 2 (ùúÑ 2 ) : 2 ( [ùëõ+1] 2 ) ‚Üí 2 [ùëõ] 2 is the evident projection); ‚Ä¢ local if the subgraphs are independent: if ùê¥ ‚äÜ [ùëõ] and ùêµ ‚äÜ [ùëõ] are disjoint, then we have an injective function ùö• :

$ùê¥ 2 + ùêµ 2 ‚Ü©‚Üí [ùëõ] 2 , and D 2 ùö• (ùëù ùëõ ) ‚àà D 2 (ùê¥ 2 ) √ó 2 (ùêµ 2 ) is a product measure ùëù ùê¥ ‚äó ùëù ùêµ (where 2 ùö• : 2 [ùëõ] 2 ‚Üí 2 (ùê¥ 2 ) √ó 2 (ùêµ 2 )$is the evident pairing of projections).

Definition 20 (e.g. [[Lov√°sz 2012])](#b62). A graphon ùëä is a symmetric measurable function ùëä :

$[0, 1] 2 ‚Üí [0, 1].$Given a graphon ùëä , we can generate a finite simple undirected graph ùëî with vertex set [ùëõ] by sampling ùëõ points ùë• 1 , . . . , ùë• ùëõ uniformly from [0, 1] and, then, including the edge (ùëñ, ùëó) with probability ùëä (ùë• ùëñ , ùë• ùëó ) for all 1 ‚â§ ùëñ, ùëó ‚â§ ùëõ. This sampling procedure defines a distribution over finite graphs: the probability ùëù ùëä ,ùëõ (ùê¥ ùëî ) of the graph ùëî = ( [ùëõ], ùê∏) is:

$‚à´ [0,1] ùëõ (ùëñ,ùëó ) ‚ààùê∏ ùëä (ùë• ùëñ , ùë• ùëó ) (ùëñ,ùëó )‚àâùê∏ 1 -ùëä (ùë• ùëñ , ùë• ùëó ) d(ùë• 1 . . . ùë• ùëõ )(16)$Proposition 21 ( [[Lov√°sz and Szegedy 2006]](#), [[Lov√°sz 2012, ¬ß11.2]](#)). Every graphon generates an exchangeable, consistent, and local random graph model, by the sampling procedure of (16). Conversely, every exchangeable, consistent, and local random graph model is of the form ùëù ùëä ,ùëõ for some graphon ùëä .

Note. There are various methods for constructing ùëä from an exchangeable, consistent and local random graph model, however all are highly non-trivial. A general idea is that ùëä is a kind of limit object. For examples see e.g. [[Lov√°sz and Szegedy 2006, ¬ß11.3]](#) or [[Tao 2013](#b79)]. Fortunately though, we will not need explicit constructions in this paper. ‚ñ°

## Theories of Program Equivalence Induce Graphons

In this section we consider the instance of the generic language with the graph interface (Ex. 1(3)):

$vertex new : unit ‚Üí vertex edge : vertex * vertex ‚Üí bool$We consider a theory of program equivalence, i.e. a distributive Markov category with a distinguished object vertex and morphisms new : 1 ‚Üí vertex and edge : vertex ‚äó vertex ‚Üí 1 + 1. We make two assumptions about the theory:

‚Ä¢ The graphs are simple and undirected:

ùë• : vertex ‚ä¢ edge(ùë•, ùë•) ‚â° false ùë•, ùë¶ : vertex ‚ä¢ edge(ùë•, ùë¶) ‚â° edge(ùë¶, ùë•)

and edge is deterministic. ‚Ä¢ The theory is Bernoulli based ( ¬ß2.4).

For each ùëõ ‚àà N, we can build a random graph with ùëõ vertices as follows. We consider the following program ùë° ùëõ :

$‚ä¢ let ùë• 1 = new() in . . . let ùë• ùëõ = new() in edge(ùë• 1 , ùë• 1 ) . . . edge(ùë• 1 , ùë• ùëõ ) . . . . . . edge(ùë• ùëõ , ùë• 1 ) . . . edge(ùë• ùëõ , ùë• ùëõ ) : bool (ùëõ 2 )(18)$(Here we use syntactic sugar, writing a matrix instead of iteratively using pairs.) Because the equational theory is Bernoulli-based, the interpretation ùë° ùëõ induces a probability distribution Œ® ùë° ùëõ on 2 (ùëõ 2 ) . For clarity, we elide Œ® in what follows, since it is faithful. Proposition 22. Each random matrix in (18) is a random adjacency matrix, i.e. a random graph.

Proof note. This follows from (17). ‚ñ° Theorem 23. For any Bernoulli-based equational theory, the random graph model ( ùë° ùëõ ) ùëõ in (18) is exchangeable, consistent, and local. Thus, the equational theory induces a graphon.

Proof. We denote the matrix in ( [18](#formula_30)) by (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ] .

Exchangeability. We show that the distribution ùë° ùëõ is invariant under relabeling the nodes. By commutativity of the let construct (9), the program

$ùë° ùúé ùëõ def = let ùë• ùúé -1 (1) = new() in . . . let ùë• ùúé -1 (ùëõ) = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ]$satisfies ùë° ùúé ùëõ = ùë° ùëõ . Hence, D (2 ùúé 2 ) ( ùë° ùëõ ) = ùë° ùúé ùëõ = ùë° ùëõ , for every ùëõ and bijection ùúé : [ùëõ] ‚Üí [ùëõ]. Consistency. We define a macro subm ùêº in the graph programming language to extract a submatrix at the index set ùêº ‚äÜ [ùëõ]: we have the (definitional) equality

$subm ùêº ((ùëé ùëñ,ùëó ) ùëñ,ùëó ‚àà [ùëõ] ) def = (ùëé ùëñ,ùëó ) ùëñ,ùëó ‚ààùêº for ùêº ‚äÜ [ùëõ].$We need to show that, if we delete the last node from a graph sampled from ùë° ùëõ+1 , the resulting graph has distribution ùë° ùëõ . This amounts to the affineness property (10), as follows. Let ùëî ‚àº ùë° ùëõ+1 be a random graph, and let ùëî ‚Ä≤ def = ùëî | [ùëõ] be the graph obtained by deleting the last node from ùëî. Then clearly, the adjacency matrix of ùëî ‚Ä≤ is the adjacency matrix of ùëî where the last row and column have been removed, i.e. ùëî ‚Ä≤ is sampled from the interpretation of the program:

$ùë° ‚Ä≤ def = let ùë• 1 = new() in . . . let ùë• ùëõ = new() in let ùë• ùëõ+1 = new() in subm [ùëõ] (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ+1] ‚â° let ùë• 1 = new() in . . . let ùë• ùëõ = new() in let ùë• ùëõ+1 = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ] ‚â° let ùë• 1 = new() in . . . let ùë• ùëõ = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ]$(by ( [10](#formula_2))) ‚â° ùë° ùëõ .

Locality. Without loss of generality (by exchangeability and consistency), we need to show that for every random graph ùëî ‚àº ùë° ùëõ and 1 < ùëò < ùëõ, the subgraphs ùëî ùê¥ ùëò , ùëî ùêµ ùëò respectively induced by the sets ùê¥ ùëò def = [ùëò] and ùêµ ùëò def = {ùëò + 1, . . . , ùëõ} are independent as random variables. Let ùö• be the injection ùö• : ùê¥ 2 ùëò + ùêµ 2 ùëò ‚Ü©‚Üí ùëõ 2 , and

$ùëî ‚Ä≤ ‚àº D (2 ùö• ) ( ùë° ùëõ ) ‚àà D (2 (ùê¥ 2 ùëò ) √ó 2 (ùêµ 2 ùëò )$). We want to show that ùëî ‚Ä≤ and (ùëî ùê¥ ùëò , ùëî ùêµ ùëò ) ‚àº ùë° ùëò ‚äó ùë° ùëõ-ùëò (by consistency) are equal in distribution. Modulo ùõº-renaming, (ùëî ùê¥ ùëò , ùëî ùêµ ùëò ) is sampled from the interpretation of the program:

$ùë° ‚Ä≤ def = let ùë• 1 = new() in . . . let ùë• ùëò = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëò ] , let ùë• ùëò+1 = new() in . . . let ùë• ùëõ = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëò+1‚â§ùëñ,ùëó ‚â§ùëõ ‚â° let ùë¢ 1 = (let ùë• 1 = new() in . . . let ùë• ùëò = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚ààùê¥ ùëò ) in let ùë¢ 2 = (let ùë• ùëò+1 = new() in . . . let ùë• ùëõ = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚ààùêµ ùëò ) in (ùë¢ 1 , ùë¢ 2 ) (by (8)) ‚â° let ùë• 1 = new() in . . . let ùë• ùëò = new() in let ùë• ùëò+1 = new() in . . . let ùë• ùëõ = new() in ((7),(9)) let ùë¢ 1 = subm ùê¥ ùëò (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ] in let ùë¢ 2 = subm ùêµ ùëò (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ] in (ùë¢ 1 , ùë¢ 2 ) ‚â° let ùë• 1 = new() in . . . let ùë• ùëõ = new() in let ùë° = (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ] in let ùë¢ 1 = subm ùê¥ ùëò (ùë°) in let ùë¢ 2 = subm ùêµ ùëò (ùë°) in (ùë¢ 1 , ùë¢ 2 ) (by (11)) ‚â° let ùë• 1 = new() in . . . let ùë• ùëõ = new() in let ùë° = (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ] in subm ùê¥ ùëò (ùë°), subm ùêµ ùëò (ùë°) (by (8)) ‚â° let ùë° = let ùë• 1 = new() in . . . let ùë• ùëõ = new() in (edge(ùë• ùëñ , ùë• ùëó )) ùëñ,ùëó ‚àà [ùëõ] in subm ùê¥ ùëò (ùë°), subm ùêµ ùëò (ùë°))$(by ( [7](#)))

and ùëî ‚Ä≤ ‚àº D (2 ùö• ) ( ùë° ùëõ ) is indeed sampled from the interpretation of the latter program, which yields the result. ‚ñ°

## FROM GRAPHONS TO PROGRAM EQUATIONS

In Section 3, we showed how a distributive Markov category modelling the graph interface (Ex. 1(3)) gives rise to a graphon. In this section, we establish a converse: every graphon arises in this way (Corollary 26). Theorem 25 will establish slightly more: there is a 'generic' distributive Markov category ( ¬ß4.1) modelling the graph interface whose Bernoulli-based quotients are in precise correspondence with graphons ( ¬ß4.2). This approach also suggests an operational way of implementing the graph interface for any graphon ( ¬ß4.3).

## A Generic Distributive Markov Category for the Graph Interface

We construct this generic category in two steps. We first create a distributive Markov category, actually a distributive category, Fam(G op ), that supports (vertex, edge). We then add new using the monoidal indeterminates method of [[Hermida and Tennent 2012]](#b39).

## 4.1.1

Step 1: A Distributive Category with edge. We first define a distributive category that supports (vertex, edge). Let G be the category of finite graphs and functions that preserve and reflect the edge relation. That is, a morphism ùëì : ùëî ‚Üí ùëî ‚Ä≤ is a function ùëì : ùëâ ùëî ‚Üí ùëâ ‚Ä≤ ùëî such that for all ùë£, ùë§ ‚àà ùëâ ùëî we have ùê∏ ùëî (ùë£, ùë§) if and only if ùê∏ ùëî (ùëì (ùë£), ùëì (ùë§)).

Recall (e.g. [[Hu and Tholen 1995]](#b41)) that the free finite coproduct completion of a category C, Fam(C) is given as follows. The objects of Fam(C) are sequences (ùëã 1 . . . ùëã ùëõ ) of objects of C, and the morphisms (ùëã 1 . . . ùëã ùëö ) ‚Üí (ùëå 1 . . . ùëå ùëõ ) are pairs (ùëì , {ùëì ùëñ } ùëö ùëñ=1 ) of a function ùëì : ùëö ‚Üí ùëõ and a sequence of morphisms ùëì 1 : ùëã 1 ‚Üí ùëå ùëì (1) , . . . , ùëì ùëö : ùëã ùëö ‚Üí ùëå ùëì (ùëö) in C.

We consider the category Fam(G op ). Let vertex = (1), the singleton sequence comprising the one-vertex graph.

Proposition 24.

(1) The free coproduct completion Fam(G op ) is a distributive category, with the product vertex ùëõ being the sequence of all graphs with ùëõ vertices. In particular, vertex 2 is a sequence with two components, the complete graph and the edgeless graph with two vertices.

(2) Let edge : vertex √ó vertex ‚Üí 1 + 1 be the morphism (id, {!, !}), intuitively returning true for the edge, and false for the edgeless graph. Here the terminal object 1 of Fam(G op ) is the singleton tuple of the empty graph. This interpretation satisfies (17).

Proof notes. Item (1) follows from [[Hu and Tholen 1995]](#b41), which shows that limits in Fam(G op ) amount to "multi-colimits" in G. For example, the family of all graphs with ùëõ vertices is a multicoproduct of the one-vertex graph in G, hence forms a product in Fam(G op ). Item ( [2](#)) is then a quick calculation. All morphisms in Fam(G op ) are deterministic. ‚ñ°

## 4.1.2

Step 2: Adjoining new. In Section 4.1.1, we introduced a distributive category that interprets the interface (vertex, edge). But it does not support new, and indeed there are no morphisms 1 ‚Üí vertex . To additionally interpret (new), we freely adjoin it. We essentially use the 'monoidal indeterminates' method of Hermida and Tennent [[Hermida and Tennent 2012]](#b39) to do this. Their work was motivated by semantics of dynamic memory allocation, but has also been related to quantum phenomena [[Andr√©s-Mart√≠nez et al. 2022;](#b8)[Huot and Staton 2018]](#b42) and to categorical gradient/probabilistic methods [[Cruttwell et al. 2021;](#b22)[Fong et al. 2021;](#b29)[Shiebler 2021]](#b75), where it is known as the 'para construction'. It is connected to earlier methods for the action calculus [[Pavloviƒá 1997](#b69)].

Let FinSetInj be the category of finite sets and injections. It is a monoidal category with the disjoint union monoidal structure (e.g. [[Fiore 2005;](#b28)[Power 2006a]](#)). Consider the functor ùêΩ : FinSetInj op ‚Üí Fam(G op ), with ùêΩ (ùëõ) = vertex ùëõ , and where the functorial action is by exchange and projection. This is a strong monoidal functor. (Indeed, it is the unique monoidal functor with ùêΩ (1) = vertex .) For any monoidal functor, Hermida and Tennent [[Hermida and Tennent 2012]](#b39) provide monoidal indeterminates by introducing a 'polynomial category', by analogy with a polynomial ring. Unfortunately, a general version for distributive monoidal categories is not yet known, so we focus on the specific case of ùêΩ : FinSetInj op ‚Üí Fam(G op ). We build a new category Fam(G op ) [ùúà : ùêΩ FinSetInj op ], which we abbreviate Fam(G op ) [ùúà]. It has the same objects as Fam(G op ), but the morphisms √¨ ùëã ‚Üí √¨ ùëå are equivalence classes of morphisms [ùëò, ùëì ] : vertex ùëò √ó √¨ ùëã ‚Üí √¨ ùëå in Fam(G op ), modulo reindexing. The reindexing equivalence relation is generated by putting [ùëò, ùëì ] ‚àº [ùëô, ùëî] when there exist injections ùúÑ 1 . . . ùúÑ ùëö : ùëò ‚Üí ùëô such that

$ùëî = vertex ùëô √ó √¨ ùëã ùëö ùëó=1 vertex ùëô √ó ùëã ùëó vertex (ùúÑ ùëó ) √óùëã ùëó ------------‚Üí ùëö ùëó=1 vertex ùëò √ó ùëã ùëó vertex ùëò √ó √¨ ùëã ùëì - ‚Üí √¨ ùëå$where √¨ ùëã = (ùëã 1 , . . . , ùëã ùëö ). In particular, when ùëö = 1, i.e. √¨ ùëã = ùëã is a singleton sequence, we have

$Fam(G op ) [ùúà] (ùëã, √¨ ùëå ) colim ùëò ‚ààFinSetInj Fam(G op ) ( vertex ùëò √ó ùëã, √¨ ùëå ). (19$$)$Composition and monoidal structure accumulate in vertex ùëò , as usual in the monoidal indeterminates ('para') construction, e.g. ‚Ä¢ Fam(G op ) [ùúà] is a distributive Markov category.

$√¨ ùëã [ùëò,ùëì ] ----‚Üí √¨ ùëå [ùëô,ùëî] ---‚Üí √¨ ùëç = √¨ ùëã [ùëô+ùëò,ùëî‚Ä¢( vertex ùëô √óùëì ) ] -----------------‚Üí √¨ ùëç$‚Ä¢ Fam(G op ) [ùúà] supports the graph interface, via the interpretation of (vertex, edge) in Fam(G op ), but also with the interpretation new = ùúà : 1 ‚Üí vertex .

## Bernoulli Bases for Random Graph Models

The following gives a precise characterization of graphons in terms of the numerals of Fam(G op ) [ùúà].

Theorem 25. To give a distributive Markov functor Fam(G op ) [ùúà] N ‚Üí FinStoch is to give a graphon.

Proof outline. We begin by showing a related characterization: that graphons correspond to certain natural transformations. Observe that any distributive Markov category C gives rise to a symmetric monoidal functor C(1, -) : FinSet N ‚Üí Set, regarding the numerals of FinSet N as objects of C ( ¬ß2.4). Let ùê∫ ùëò = 2 ùëò (ùëò -1)/2 be the set of ùëò-vertex graphs. We can characterize the natural

$transformations ùõº : Fam(G op ) [ùúà] (1, -) ‚Üí FinStoch(1, -) as follows. Nat(Fam(G op ) [ùúà] (1, -) , FinStoch(1, -)) Nat colim ùëò ‚ààFinSetInj FinSet(ùê∫ ùëò , -) , D (-)$(Ex. 15(2), Prop. 24( [1](#)) and ( [19](#formula_37))) lim ùëò ‚ààFinSetInj op Nat(FinSet(ùê∫ ùëò , -) , D (-))

(universal property of colimits) lim ùëò ‚ààFinSetInj op D (ùê∫ ùëò ) (Yoneda lemma) An element of this limit of sets is by definition a sequence of distributions ùëù ùëò on ùê∫ ùëò that is invariant under reindexing by FinSetInj op . Since injections are generated by inclusions and permutations, this is then a sequence that is consistent and exchangeable (Def. 19), respectively. Such a natural transformation ùõº is monoidal if and only if the sequence is also local. Hence a monoidal natural transformation is the same thing as a random graph model.

In fact, every monoidal natural transformation ùõº : Fam(G op ) [ùúà] (1, -) ‚Üí FinStoch(1, -) arises uniquely by restricting a distributive Markov functor ùêπ : Fam(G op ) [ùúà] N ‚Üí FinStoch. We now show this, to conclude our proof. Given ùõº, let ùêπ ùëö,ùëõ : Fam(G op ) [ùúà] N (ùëö, ùëõ) ‚Üí FinStoch(ùëö, ùëõ) be:

$Fam(G op ) [ùúà] N (ùëö, ùëõ) Fam(G op ) [ùúà] N (1, ùëõ) ùëö ùõº ùëö ùëõ --‚Üí FinStoch(1, ùëõ) ùëö FinStoch(ùëö, ùëõ).$It is immediate that this ùêπ preserves the symmetric monoidal structure and coproduct structure, but not that ùêπ is a functor. However, the naturality of ùõº in FinSet N gives us that ùêπ preserves postcomposition by morphisms of FinSet N . All of this implies that general categorical composition is preserved as well, since, in any distributive Markov category of the form C N , for ùëì : ùëô ‚Üí ùëö and ùëî : ùëö ‚Üí ùëõ, the composite ùëî ‚Ä¢ ùëì : ùëô ‚Üí ùëõ is equal to

$ùëô = ùëô ‚äó 1 ‚äóùëö ùëì ‚äóùëî 1 ‚äó...‚äóùëî ùëö ----------‚Üí ùëö ‚äó ùëõ ‚äóùëö eval ---‚Üí ùëõ$where ùëî ùëñ = ùëî ‚Ä¢ ùúÑ ùëñ for ùëñ = 1, . . . , ùëö and eval is just the evaluation map ùëö √ó ùëõ ùëö ‚Üí ùëõ in FinSet. ‚ñ° Corollary 26. Every graphon arises from a distributive Markov category via the random graph model in (18). Proof summary. Given a graphon, we consider the distributive Markov functor that corresponds to it, Œ® : Fam(G op ) [ùúà] N ‚Üí FinStoch, by Theorem 25. Using the quotient construction of Proposition 18, we get a distributive Markov category with a Bernoulli base. It is straightforward to verify that the random graph model induced by ( [18](#formula_30)) is the original graphon. ‚ñ°

## Remark on Operational Semantics

The interpretation in this section suggests a general purpose operational semantics for closed programs at ground type, ‚ä¢ ùë° : ùëõ, along the following lines:

(1) Calculate the interpretation ùë° : 1 ‚Üí ùëõ in Fam(G op ) [[ùúà]](#). There are no probabilistic choices in this step, it is a symbolic manipulation, because the morphisms of the Markov category Fam(G op ) [ùúà] are built from tuples of finite graph homomorphisms. In effect, this interpretation pulls all the new's to the front of the term. (2) Apply the Markov functor Œ®( ùë° ) to obtain a probability distribution on ùëõ, and sample from this distribution to return a result.

## INTERPRETATION: BLACK-AND-WHITE GRAPHONS VIA MEASURE-THEORETIC PROBABILITY

In Section 4, we gave a general syntactic construction for building an equational theory from a graphon. Since that definition is based on free constructions and quotients, a priori, it does not 'explain' what the type vertex stands for. Like contextual equivalence of programs, a priori, it does not give useful compositional reasoning methods. To prove two programs are equal, according to the construction of Prop. 18, one needs to quantify over all ùëç , ‚Ñé, and ùëò, in general.

In this section, we show that one class of graphons, black-and-white graphons (Def. 27), admits a straightforward measure-theoretic semantics, and we can thus use the equational theory induced by this semantics, rather than the method of Section 4. This measure-theoretic semantics is close to previous measure-theoretic work on probabilistic programming languages (e.g. [[Kozen 1981;](#b60)[Staton 2017]](#)).

After recapping measure-theoretic probability ( ¬ß2.3.3), in Section 5.1, we show that every blackand-white graphon arises from a measure-theoretic interpretation (Prop. 28). In Section 5.2, by defining 'measure-theoretic interpretation' more generally, we show that, conversely, this measuretheoretic approach can only cater for black-and-white graphons (Prop. 29).

## Black-and-White Graphons from Equational Theories

Definition 27. [e.g. [[Janson 2013](#b47)

$]] A graphon ùëä : [0, 1] 2 ‚Üí [0, 1] is black-and-white if there exists ùê∏ : [0, 1] 2 ‚Üí {0, 1} such that ùëä (ùë•, ùë¶) = ùê∏ (ùë•, ùë¶) for almost all ùë•, ùë¶.$Recall that the Giry monad (Def. 11) gives rise to a Bernoulli-based distributive Markov category ( ¬ß2.3.3, Ex. 15). For any black-and-white graphon ùëä , we define an interpretation of the graph interface for the probabilistic programming language using G, as follows.

‚Ä¢ vertex ùëä = [0, 1]; bool ùëä = 2, the discrete two element space;

‚Ä¢ new() ùëä = Uniform(0, 1), the uniform distribution on [0, 1];

‚Ä¢ edge ùëä (ùë•, ùë¶) = ùúÇ (ùê∏ (ùë•, ùë¶)).

Proposition 28. Let ùëä be a black-and-white graphon. The equational theory induced by -ùëä induces the graphon ùëä according to the construction in Section 3.2.

Proof. Suppose thatùëä corresponds to the sequence of random graphs ùëù 1 , ùëù 2 , . . . as in Section 3.1. Consider the term ùë° ùëõ in (18), and directly calculate its interpretation. Then, we get ùë° ùëõ ùëä = ùëù ùëõ , via ( [16](#formula_27)), as required.

The choice of ùê∏ does not matter in the interpretation of these terms, because ùëä = ùê∏ almost everywhere. ‚ñ°

## All Measure-Theoretic Interpretations are Black-and-White

Although the model in Section 5.1 is fairly canonical, there are sometimes other enlightening interpretations using the Giry monad. These also correspond to black-and-white graphons. For example, consider the geometric-graph example from Figure [1](#fig_1). We interpret this using the Giry monad, putting

‚Ä¢ vertex = ùëÜ 2 , the sphere; bool = 2;

‚Ä¢ new() = Uniform(ùëÜ 2 ), the uniform distribution on the sphere;

‚Ä¢ edge (ùë•, ùë¶) = ùúÇ (ùëë (ùë•, ùë¶) < ùúÉ ), i.e. an edge if their distance is less than ùúÉ .

This will again induce a graphon, via (18). We briefly look at theories that arise in this more flexible way:

Proposition 29. Consider any interpretation of the graph interface in the Giry monad: a measurable space vertex , a measurable set edge ‚äÜ vertex 2 , and a probability measure new() on vertex . The induced graphon is black-and-white.

Proof notes. If vertex is standard Borel, the randomization lemma [[Kallenberg 2010, Lem. 3.22]](#) gives a function ùëì : [0, 1] ‚Üí vertex that pushes the uniform distribution on [0, 1] onto the probability measure new() . We define a black-and-white graphon ùëä by ùëä (ùë•, ùë¶) = 1 if (ùëì (ùë•), ùëì (ùë¶)) ‚àà edge , and ùëä (ùë•, ùë¶) = 0 otherwise. This graphon interpretation -ùëä gives the same sequence of graphs in (18), just by reparameterizing the integrals.

If vertex is not standard Borel, we note that there is an equivalent interpretation where it is, because there exists a measure-preserving map vertex ‚Üí Œ© to a standard Borel space Œ© and a measurable set ùê∏ ‚äÜ Œ© 2 that pulls back to edge , giving rise to the same graphon (e.g. [[Janson 2013, Lemma 7.3]](#)). ‚ñ°

Discussion. Proposition 29 demonstrates that this measure-theoretic interpretation has limitations.

Definition 30. For ùõº ‚àà (0, 1), the Erd≈ës-R√©nyi graphon

$ùëä ùõº : [0, 1] 2 ‚Üí [0, 1] is given by ùëä ùõº (ùë•, ùë¶) = ùõº.$The Erd≈ës-R√©nyi graphons cannot arise from measure-theoretic interpretations of the graph interface, because they are not black-and-white. In Section 6, we give an alternative interpretation for the Erd≈ës-R√©nyi graphons.

The reader might be tempted to interpret an Erd≈ës-R√©nyi graphon by defining edge ùëä ùõº (ùë•, ùë¶) = bernoulli(ùõº).

However, this interpretation does not provide a model for the basic equations of the language, because this edge is not deterministic, and derivable equations such as (6) will fail. Intuitively, once an edge has been sampled between two given nodes, its presence (or absence) remains unchanged in the rest of the program, i.e. the edge is not resampled again, it is memoized (see also [[Kaddar and Staton 2023;](#b52)[Roy et al. 2008]](#b74)).

Although not all graphons are black-and-white, these are still a widely studied and useful class. They are often called 'random-free'. For example, an alternative characterization is that the random graph model of Prop. 21 has subquadratic entropy function [[Janson 2013, ¬ß10.6](#)].

## INTERPRETATION: ERD≈êS-R√âNYI GRAPHONS VIA RADO-NOMINAL SETS

In Section 4, we gave a general construction to show that every graphon arises from a Bernoullibased equational theory. In Section 5, we gave a more concrete interpretation, based on measuretheory, for black-and-white graphons. We now consider the Erd≈ës-R√©nyi graphons (Def. 30), which are not black-and-white.

Our interpretation is based on Rado-nominal sets. These are also studied elsewhere, but for different purposes (e.g. [[Boja≈Ñczyk et al. 2014;](#b12)[Boja≈Ñczyk and Place 2012;](#b13)[Klin et al. 2016](#b57)], [Pitts 2013, ¬ß1.9]).

Rado-nominal sets ( ¬ß6.1) are sets that are equipped with an action of the automorphisms of the Rado graph, which is an infinite graph that contains every finite graph. There is a particular Rado-nominal set V of the vertices of the Rado graph. The type vertex will be interpreted as V; edge is interpreted using the edge relation ùê∏ on V. The equational theory induced by this interpretation gives rise to the Erd≈ës-R√©nyi graphons (Def. 30).

Since Rado-nominal sets form a model of ZFA set theory (Prop. 36), we revisit probability theory internal to this setting. We consider internal probability measures on Rado-nominal sets ( ¬ß6.3), and we show that there are internal probability measures on V that give rise to Erd≈ës-R√©nyi graphons ( ¬ß6.3). The key starting point here is that, internal to Rado-nominal sets, the only functions V ‚Üí 2 are the sets of vertices that are definable in the language of graphs ( ¬ß6.2).

We organize the probability measures (Def. 37) into a probability monad on Rado-nominal sets ( ¬ß6.4), analogous to the Giry monad. Fubini does not routinely hold in this setting ( ¬ß6.4.4), but we use a standard technique to cut down to a commutative affine monad ( ¬ß6.4.5). This gives rise to a Bernoulli-based equational theory, and in fact, this theory corresponds to Erd≈ës-R√©nyi graphons (via (18): Corollary 45).

## Definition and First Examples

The Rado graph (V, ùê∏) ( [[Ackermann 1937;](#b6)[Rado 1964]](#b73), also known as the 'random graph' [[Erd≈ës and R√©nyi 1959]](#b27)) is the unique graph, up to isomorphism, with a countably infinite set of vertices that has the extension property: if ùê¥, ùêµ are disjoint finite subsets of V, then there is a vertex ùëé ‚àà V \ (ùê¥ ‚à™ ùêµ) with an edge to all the vertices in ùê¥ but none of the vertices in ùêµ.

The Rado graph embeds every finite graph, which can be shown by using the extension property inductively.

An automorphism of the Rado graph is a graph isomorphism V ‚Üí V. The automorphisms of the Rado graph relate to isomorphisms between finite graphs, as follows. First, if ùê¥ is a finite graph regarded as a subset of V, then any automorphism ùúé induces an isomorphism of finite graphs ùê¥ ùúé [[ùê¥]](#). Conversely, if ùëì : ùê¥ ùêµ is an isomorphism of finite graphs, and we regard ùê¥ and ùêµ as disjoint subsets of V, then there exists an automorphism ùúé of V that restricts to ùëì (i.e. ùëì = ùúé | ùê¥ ).

We write Aut [(Rado)](#) for the group of automorphisms of (V, ùê∏). (This has been extensively studied in model theory and descriptive set theory, e.g. [[Angel et al. 2014;](#b9)[Kechris et al. 2005](#b55) An element ùë• ‚àà ùëã is defined to have finite support if there is a finite set ùê¥ ‚äÜ V such that for all automorphisms ùúé, if ùúé fixes ùê¥ (i.e. ùúé | ùê¥ = id ùê¥ ), it also fixes ùë• (i.e. ùúé ‚Ä¢ ùë• = ùë•).

Equivariant functions between Rado-nominal sets are functions that preserve the group action (i.e. ùëì (ùúé ‚Ä¢ ùë•) = ùúé ‚Ä¢ (ùëì (ùë•))).

Proposition 32 [([Pitts 2013]](#b71)). If finite sets ùê¥, ùêµ ‚äÜ V both support ùë•, so does ùê¥ ‚à© ùêµ. Hence every element has a least support.

Example 33.

(1) The set V of vertices is a Rado-nominal set, with ùúé ‚Ä¢ ùëé = ùúé (ùëé). The support of vertex ùëé is {ùëé}.

(2) The set V √ó V of pairs of vertices is a Rado-nominal set, with ùúé ‚Ä¢ (ùëé, ùëè) = (ùúé (ùëé), ùúé (ùëè)).

The support of (ùëé, ùëè) is {ùëé, ùëè}. More generally, a finite product of Rado-nominal sets has a coordinate-wise group action.

(3) The edge relation ùê∏ ‚äÜ V √ó V is a Rado-nominal subset (which is formally defined in ¬ß6.2) because automorphisms preserve the edge relation. (4) Any set ùëã can be regarded with the discrete action, ùúé ‚Ä¢ ùë• = ùë•, and then every element has empty support. We regard these sets with the discrete action: 1 = {‚òÖ}; 2 = {0, 1}; N; and the unit interval [0, 1].

## Powersets and Definable Sets

For any subset ùëÜ ‚äÜ ùëã of a Rado-nominal set, we can define

$ùúé ‚Ä¢ ùëÜ = ùúé [ùëÜ] = {ùúé ‚Ä¢ ùë• | ùë• ‚àà ùëÜ }. We let 2 ùëã = {ùëÜ ‚äÜ ùëã | ùëÜ has finite support}. (20$$)$This is a Rado-nominal set.

Example 34. We give some concrete examples of subsets.

(1) For vertices ùëè and ùëê in V with no edge between them, the set {ùëé ‚àà V | ùê∏ (ùëé, ùëè) ‚àß ùê∏ (ùëé, ùëê)} is the set of ways of forming a horn. It has support {ùëè, ùëê}.

(2) {(ùëè, ùëê) ‚àà V 2 | ùê∏ (ùëé, ùëè) ‚àß ùê∏ (ùëé, ùëê) ‚àß ¬¨ùê∏ (ùëè, ùëê)} is the set of horns with apex ùëé; it has support {ùëé}.

(3) {(ùëé, ùëè, ùëê) ‚àà V 3 | ùê∏ (ùëé, ùëè) ‚àß ùê∏ (ùëé, ùëê) ‚àß ¬¨ùê∏ (ùëè, ùëê)} is the set of all oriented horns; it has empty support. (4) (Non-example) There is a countable totally disconnected subgraph of V; it does not have finite support as a subset of V.

In fact, the finitely supported subsets correspond exactly to the definable sets in first-order logic over the theory of graphs. The following results may be folklore.

Proposition 35. Let ùëÜ ‚äÜ V ùëõ , and ùê¥ ‚äÜ V be finite. The following are equivalent:

‚Ä¢ ùëÜ = {(ùë† 1 , . . . ùë† ùëõ ) | ùúô (ùë† 1 . . . ùë† ùëõ )}, for a first-order formula ùúô over the theory of graphs, with parameters in ùê¥; ‚Ä¢ ùëÜ has support ùê¥.

Proof. (‚áí) For all isomorphisms ùëì : V ‚Üí V that fix ùê¥, and for all elements ùëé 1 . . . ùëé ùëò ‚àà ùê¥ and subsets ùëÜ = {(ùë† 1 , . . . , ùë† ùëõ ) | ùúô (ùë† 1 . . . ùë† ùëõ , ùëé 1 . . . ùëé ùëò )}, we have ùúô (ùëì (ùë† 1 ) . . . ùëì (ùë† ùëõ ), ùëé 1 . . . ùëé ùëò ) = ùúô (ùëì (ùë† 1 ) . . . ùëì (ùë† ùëõ ), ùëì (ùëé 1 ) . . . ùëì (ùëé ùëò )).

Furthermore, ùúô is invariant with respect to ùëì . Thus, the image ùëì (ùëÜ) ‚äÜ ùëÜ. By a similar argument, we have ùëì -1 (ùëÜ) ‚äÜ ùëÜ, so that ùëÜ ‚äÜ ùëì (ùëÜ). Thus, ùëì (ùëÜ) = ùëÜ ( [[Marker 2002, Prop. 1.3.5]](#)).

(‚áê) This is a consequence of the Ryll-Nardzewski theorem for the theory of the Rado graph (which can be shown to be ùúî-categorical by a back-and-forth argument, using the extension property of the Rado graph). But we give here a more direct proof, assuming ùëõ = 1 for simplicity. Suppose ùê¥ ‚äÜ V is a finite support for ùëÜ. Then, for any ùë£, ùë£ ‚Ä≤ ‚àà V\ùê¥, if ùë£ and ùë£ ‚Ä≤ have the same connectivity to ùê¥, then they are either both in or not in ùëÜ since, by the extension property, we can find an automorphism fixing ùê¥ and sending ùë£ to ùë£ ‚Ä≤ . The set of vertices with the same connectivity to ùê¥ as ùë£ is definable, and there are only 2 |ùê¥| such sets. Hence, ùëÜ\ùê¥ is a union of finitely many definable sets, and as ùëÜ ‚à© ùê¥ is definable (being finite), so is ùëÜ = (ùëÜ\ùê¥) ‚à™ (ùëÜ ‚à© ùê¥). ‚ñ°

We note that 2 ùëã in ( [20](#formula_45)) is a canonical notion of internal powerset, from a categorical perspective.

Proposition 36. RadoNom is a Boolean Grothendieck topos, with powerobject 2 ùëã in (20).

Proof notes. RadoNom can be regarded as continuous actions of Aut [(Rado)](#), regarded as a topological group with the product topology, and then we invoke standard methods [[Johnstone 2002, Ex. A2.1.6]](#). It is also equivalent to the category of sheaves over finite graphs and embeddings with the atomic topology. See [[Caramello 2013](#b16)[[Caramello , 2014] ]](#b17) for general discussion. ‚ñ°

## Probability Measures on Rado-Nominal Sets

The finitely supported sets ùëÜ ‚äÜ V can be regarded as 'events' to which we would assign a probability. For example, if we already have vertices ùëè and ùëê, we may want to know the chance of picking a vertex that forms a horn, and this would be the probability of the set in Ex. 34(a).

Definition 37. A sequence ùëÜ 1 , ùëÜ 2 ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚äÜ ùëã is said to be support-bounded if there is one finite set ùê¥ ‚äÜ V that supports all the sets ùëÜ ùëñ .

A function ùúá : 2 ùëã ‚Üí [0, 1] is (internally) countably additive if for any support-bounded sequence

$ùëÜ 1 , ùëÜ 2 ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚äÜ ùëã of disjoint sets, ùúá ( ‚àû ùëñ=1 ùëÜ ùëñ ) = ‚àû ùëñ=1 ùúá (ùëÜ ùëñ ).$A probability measure on a Rado-nominal set ùëã is an equivariant function ùúá : 2 ùëã ‚Üí [0, 1] that is internally countably additive, such that ùúá (ùëã ) = 1.

We remark that there are two subtleties here. First, we restrict to support-bounded sequences. These are the correctly internalized notion of sequence in Rado-nominal sets, since they correspond precisely to finitely-supported functions N ‚Üí 2 ùëã . Second, we consider a Rado-nominal set to be equipped with its internal powerset 2 ùëã , rather than considering sub-ùúé-algebras.

Measures on the space of vertices. We define an internal probability measure (Def. 37) on the space V of vertices, which, we will show, corresponds to the Erd≈ës-R√©nyi graphon. Fix ùõº ‚àà [0, 1], the chance of an edge.

We define the measure ùúà ùõº of a definable set ùëÜ ‚àà 2 V as follows. Suppose that ùëÜ has support {ùëé 1 , . . . , ùëé ùëõ }. We choose an enumeration of vertices (ùë£ 1 , . . . , ùë£ 2 ùëõ ) in V (disjoint from {ùëé 1 , . . . , ùëé ùëõ }) that covers all the 2 ùëõ possible edge relationships that a vertex could have with the ùëé ùëñ 's. (For example, ùë£ 1 has no edges to any ùëé ùëñ , and ùë£ 2 ùëõ has an edge to every ùëé ùëñ , and the other ùë£ ùëó 's have the other possible edge relationships.) Let:

$ùúà ùõº (ùëÜ) = 2 ùëõ ‚àëÔ∏Å ùëó=1 [ùë£ ùëó ‚àà ùëÜ] ùëõ ùëñ=1 ùõºùê∏ (ùë£ ùëó , ùëé ùëñ ) + (1 -ùõº) (1 -ùê∏ (ùë£ ùëó , ùëé ùëñ )) . (21$$)$Proposition 38. The assignment given in ( [21](#formula_48)) is an internal probability measure (Def. 37) on V.

Proof. The function ùúà ùõº is well-defined: it does not depend on the choice of ùë£ ùëó 's (by Prop. 35), nor on the choice of support (by direct calculation). It is equivariant, since for ùúé ‚Ä¢ ùëÜ, a valid enumeration of vertices is given by ùúé

$‚Ä¢ ùë£ 1 , . . . ùúé ‚Ä¢ ùë£ 2 ùëõ . Also, ùúà (V) = 1, since V has empty support. Internal countable additivity follows from the identity ùë£ ùëó ‚àà ‚àû ùëñ=1 ùëÜ ùëñ = ‚àû ùëñ=1 [ùë£ ùëó ‚àà ùëÜ ùëñ ]. ‚ñ° Remark.$The definitions and results of this section appear to be novel. However, the general idea of considering measures on formulas which are invariant to substitutions that permute the variables goes back to work of Gaifman [[Gaifman 1964](#b35)]. The paper [[Ackerman et al. 2016a](#)] characterizes those countably infinite graphs that can arise with probability 1 in that framework; see [[Ackerman et al. 2017b](#)] for a discussion of how Gaifman's work connects to Prop. 21.

## Nominal Probability Monads

Since RadoNom is a Boolean topos with natural numbers object (Prop. 36), we can interpret measure-theoretic notions in the internal language of the topos, as long as they do not require the axiom of choice. We now spell out the resulting development, without assuming familiarity with topos theory. By doing this, we build new probability monads on RadoNom.

6.4.1 Finitely Supported Functions and Measures. Let ùëã and ùëå be Rado-nominal sets. The set of all functions ùëã ‚Üí ùëå has an action of Aut [(Rado)](#), given by (ùúé ‚Ä¢ ùëì ) (ùë•) = ùúé -1 ‚Ä¢ (ùëì (ùúé ‚Ä¢ ùë•)). The function space [ùëã ‚áí ùëå ] comprises those functions that have finite support under this action. Categorically, this structure is uniquely determined by the 'currying' bijection, natural in ùëç :

RadoNom(ùëç √ó ùëã, ùëå ) RadoNom(ùëç, ùëã ‚áí ùëå ).

(For example, the powerobject 2 ùëã ( ¬ß6.2) can be regarded as [ùëã ‚áí 2], if we regard a set as its characteristic function.)

In Def. 37, we focused on equivariant probability measures. We generalize this to finitely supported measures. For example, pick a vertex ùëé ‚àà V. Then, the Dirac measure on V (i.e. ùõø ùëé (ùëÜ) = 1 if ùëé ‚àà ùëÜ, and ùõø ùëé (ùëÜ) = 0 if ùëé ‚àâ ùëÜ) has support {ùëé}.

Definition 39. For a Rado-nominal set ùëã , let P (ùëã ) comprise the finitely supported functions ùúá : 2 ùëã ‚Üí [0, 1] that are internally countably additive, and satisfy ùúá (ùëã ) = 1. This is a Rado-nominal set, as a subset of [2 ùëã ‚áí [0, 1]]. Functions in P (ùëã ) are called finitely supported probability measures. 6.4.2 Internal Integration. We revisit some basic integration theory in this nominal setting. In traditional measure theory, one can define the Lebesgue integral of a measurable function ùëì : ùëã ‚Üí [0, 1] by ‚à´ ùëì (ùë•)ùúá (dùë•) = sup ùëõ ùëñ=1 ùëü ùëñ ùúá (ùëà ùëñ ) where the supremum ranges over simple functions ùëñ ùëü ùëñ [-‚àà ùëà ùëñ ] with ùëà ùëñ measurable in ùëã and bounded above by ùëì ( ¬ß2.3.3). The same construction works in the internal logic of RadoNom.

Note that the following does not mention ùëì being measurable: since ùëã is considered to have its internal powerset ùúé-algebra, finite-supportedness implies 'measurability' here.

Proposition 40. Let ùúá ‚àà P (ùëã ) be a finitely supported probability measure on ùëã . For any finitely supported function ùëì : ùëã ‚Üí [0, 1], the internally-constructed Lebesgue integral ‚à´ ùëì (ùë•) ùúá (dùë•) ‚àà [0, 1] exists. Moreover, integration is an equivariant map

$‚à´ : P (ùëã ) √ó [ùëã ‚áí [0, 1]] ‚Üí [0, 1]$which preserves suprema of internally countable monotone sequences in its second argument.

Proof. If ùëà 1 , . . . , ùëà ùëõ ‚äÜ ùëã are finitely supported, ùëü 1 , . . . , ùëü ùëõ ‚àà [0, 1], and ùëñ ùëü ùëñ [-‚àà ùëà ùëñ ] ‚â§ ùëì , then by ordinary additivity of ùúá, we have ùëü ùëñ ùúá (ùëà ùëñ ) ‚àà [0, 1]. By ordinary real analysis, the supremum of all such values exists and is in [0, 1]. For equivariance, recall that [0, 1] is equipped with the trivial action of Aut [(Rado)](#). Use the fact that

$ùëñ ùëü ùëñ [-‚àà ùëà ùëñ ] ‚â§ ùëì if and only if ùëñ ùëü ùëñ [-‚àà ùúé ‚Ä¢ ùëà ùëñ ] ‚â§ ùúé ‚Ä¢ ùëì .$The last claim is the monotone convergence theorem internalized to RadoNom. ‚ñ° 6.4.3 Kernels and a Monad. We can regard a 'probability kernel' as a finitely supported function ùëò : ùëã ‚Üí P (ùëå ). Equivalently, ùëò is a finitely supported function ùëò : ùëã √ó 2 ùëå ‚Üí [0, 1] that is countably additive and has mass 1 in its second argument. (In traditional measure theory, one would explicitly ask that ùëò is measurable in its first argument, but as we observed, finite-supportedness already implies it.)

As usual, probability kernels compose, and this allows us to regard them as Kleisli morphisms for a monad (Def. 6), defined as follows.

Definition 41. We define the strong monad P on RadoNom as follows.

‚Ä¢ For a Rado-nominal set ùëã , let P (ùëã ) comprise the finitely supported probability measures (Def. 39). ‚Ä¢ The unit of the monad ùúÇ ùëã : ùëã ‚Üí P (ùëã ) is the Dirac measure, ùúÇ ùëã (ùë•) (ùëÜ) = [ùë• ‚àà ùëÜ].

‚Ä¢ The bind (>>=) : P (ùëã ) √ó (ùëã ‚áí P (ùëå )) ‚Üí P (ùëå ) is given by

$(ùúá >>= ùëò) (ùëÜ) = ‚à´ ùëã ùëò (ùë•, ùëÜ) ùúá (dùë•).$We note that this is similar to the 'expectations monad' [[Jacobs and Mandemaker 2012, Thm. 4](#)].

## Commuting Integrals (Fubini).

For measures ùúá 1 ‚àà P (ùëã ) and ùúá 2 ‚àà P (ùëå ), the monad structure allows us to define a product measure

$ùúá 1 ‚äó ùúá 2 = ùúá 1 >>= (ùúÜùë• . ùúá 2 >>= ùúÜùë¶. ùúÇ (ùë•, ùë¶)) ‚à´ ùëì (ùë•, ùë¶) (ùúá 1 ‚äó ùúá 2 ) (d(ùë•, ùë¶)) = ‚à´ ‚à´ ùëì (ùë•, ùë¶) ùúá 2 (dùë¶) ùúá 1 (dùë•).(22)$Although this iterated integration is reminiscent of the traditional approach, in general we cannot reorder integrals ('Fubini does not hold'). For example, given two measures ùúà ùõº and ùúà ùõΩ for ùõº ‚â† ùõΩ and ùëì being the characteristic function of the set {(ùë•, ùë¶) :

$ùê∏ (ùë•, ùë¶)} ‚äÜ V 2 , we have ‚à´ ‚à´ [ùê∏ (ùë•, ùë¶)] ùúà ùõº (dùë¶) ùúà ùõΩ (dùë•) = ‚à´ ùõº ùúà ùõΩ (dùë•) = ùõº ‚â† ùõΩ = ‚à´ ùõΩ ùúà ùõº (dùë¶) = ‚à´ ‚à´ [ùê∏ (ùë•, ùë¶)] ùúà ùõΩ (dùë•) ùúà ùõº (dùë¶).(23)$However, it does hold when we consider only copies of the same measure.

Proposition 42. For ùúà ùõº ‚àà P (V) as in ( [21](#formula_48)), ùúà ùõº commutes with ùúà ùõº . That is, for any finitely supported

$ùëì : V √ó V ‚Üí [0, 1], ‚à´ ‚à´ ùëì (ùë•, ùë¶) ùúà ùõº (dùë¶) ùúà ùõº (dùë•) = ‚à´ ‚à´ ùëì (ùë•, ùë¶) ùúà ùõº (dùë•) ùúà ùõº (dùë¶).$Proof notes. By Prop. 35 and 40, it suffices to check on the indicator functions of definable subsets of V 2 . The indicators of sets {(ùë•, ùë¶) | Œ¶(ùë•, ùë¶)} where Œ¶(ùë•, ùë¶) is a disjunction of ùë• = ùë¶, ùë• = ùëé, or ùë¶ = ùëé for some ùëé ‚àà V are seen to have integral 0 on both sides. The remaining possibilities can be reduced to the case where Œ¶ ùê¥,ùúô,ùúì,ùúñ (ùë•, ùë¶) is (ùë•, ùë¶ ‚àâ ùê¥) ‚àß (ùë• ‚â† ùë¶) ‚àß (ùê∏ (ùë•, ùë¶) ‚Üî ùúñ) ‚àß ùëé‚ààùê¥ (ùê∏ (ùëé, ùë•) ‚Üî ùúô ùëé ) ‚àß (ùê∏ (ùëé, ùë¶) ‚Üî ùúì ùëé ) where ùê¥ ‚äÜ V is a finite set, ùúñ ‚àà {‚ä•, ‚ä§}, and ùúô,ùúì ‚àà {‚ä•, ‚ä§} ùê¥ . This formula corresponds to choosing a two-vertex extension of the finite graph spanned by ùê¥ ‚äÜ V. Intuitively, the two double integrals correspond to the two alternative two-step computations of the conditional probability of extending the graph ùê¥ to this extension according to which of the two vertices is sampled first, and indeed both evaluate to ùõº ùëò (1 -ùõº) 2|ùê¥|+1-ùëò where ùëò = [ùúñ] + ùëé‚ààùê¥ ( [ùúô ùëé ] + [ùúì ùëé ]). ‚ñ° Remark. In traditional measure theory, iterated integrals are defined using product ùúé-algebras.

Here we have not constructed product ùúé-algebras, but rather always take the internal powerset as the ùúé-algebra. This allows us to view all the definable sets as measurable on V ùëõ (Prop. 35), which is very useful. We remark that alternative product spaces also arise in non-standard approaches to graphons (see [[Tao 2013, ¬ß6]](#) for an overview), and also in quasi-Borel spaces [[Heunen et al. 2017]](#b40) for different reasons.

6.4.5 A Commutative Monad. We now use Prop. 42 to build a commutative affine submonad P ùõº of the monad P, which we will use to model the graph interface for the probabilistic programming language. With Prop. 36, we use the following general result. Proposition 43. Let T be a strong monad on a Grothendieck topos. Consider a family of morphisms {ùëì ùëñ : ùëã ùëñ ‚Üí T (ùëå ùëñ )} ùëñ ‚ààùêº .

‚Ä¢ There is a least strong submonad T ùëì ‚äÜ T through which all ùëì ùëñ factor.

‚Ä¢ If the morphisms ùëì ùëñ all commute with each other, then T ùëì is a commutative monad (Def. 7).

Proof notes. Our argument is close to [[Kammar and McDermott 2018, ¬ß2.3]](#) and also [[Kammar 2014, Thms. 7.5 & 12.8]](#).

We let T ùëì be the least subfunctor of T that contains the images of the ùëì ùëñ 's and ùúÇ, and is closed under the image of monadic bind (>>=). To show that this exists, we proceed as follows. First, fix a regular cardinal ùúÜ > ùêº such that ùëå ùëñ 's are all ùúÜ-presentable, such that the topos is locally ùúÜ-presentable (e.g. [[Ad√°mek and Rosick√Ω 1994]](#b7)). Consider the poset Sub ùúÜ (T ) of ùúÜ-accessible subfunctors of T . The cardinality bound ùúÜ ensures it is small. Ordered by pointwise inclusion, this is a complete lattice: the non-empty meets are immediate, and the empty meet requires us to consider the ùúÜ-accessible coreflection of T . We defined T ùëì by a monotone property which we can regard as a monotone operator on this complete lattice Sub ùúÜ (T ), and so the least ùúÜ-accessible subfunctor exists. This is T ùëì . Concretely, it is a least upper bound of an ordinal indexed chain. The chain starts with the functor ùêπ 0 (ùëç ) = ùëñ ‚ààùêº,ùëî:ùëå ùëñ ‚Üíùëç image(T (ùëî) ‚Ä¢ ùëì ùëñ ) ‚äÜ T (ùëç ) which is ùúÜ-accessible because the ùëå ùëñ 's are ùúÜ-presentable. The chain iteratively closes under the image of monadic bind, until we reach a subfunctor that is a submonad of T .

To see that T ùëì is commutative, we appeal to (transfinite) induction. Say that a subfunctor ùêπ of T is commutative if all morphisms that factor through ùêπ commute (Def. 7), and then note that the property of being commutative is preserved along the ordinal indexed chain. ‚ñ°

With this in mind, fixing a measure ùúà ùõº as in ( [21](#formula_48)), we form the least submonad P ùõº of P induced by the morphisms ùúà ùõº : 1 ‚Üí P (V) bernoulli : [0, 1] ‚Üí P (2) (24) where bernoulli(ùëü ) = ùëü ‚Ä¢ ùúÇ (0) + (1 -ùëü ) ‚Ä¢ ùúÇ (1).

Corollary 44. The least submonad P ùõº of the probability monad P induced by the morphisms in (24) is a commutative affine monad (Def. 7).

Proof notes. It is easy to show that bernoulli commutes with every morphism ùëã ‚Üí P (ùëå ). Moreover, ùúà ùõº commutes with itself (Prop. 42). Finally, P ùõº is affine since P is. ‚ñ°

## Summary and Interpretation

Fix ùõº ‚àà [0, 1]. We induce an internal measure ùúà ùõº on the vertices of the Rado graph as explained in (21); and build a commutative submonad P ùõº of P. We can then interpret the graph probabilistic programming language. We interpret types as Rado-nominal sets:

$bool = 2 vertex = V unit = 1 ùê¥ 1 * ùê¥ 2 = ùê¥ 1 √ó ùê¥ 2 . (25$$)$We interpret typed programs Œì ‚ä¢ ùë° : ùê¥ as Kleisli morphisms Œì ‚Üí P ùõº ( ùê¥ )

i.e. internal probability kernels Œì √ó 2 ùê¥ ‚Üí [0, 1]. Sequencing (let) is interpreted using the monad structure, with new : 1 ‚Üí P ùõº (V) and edge : V √ó V ‚Üí P ùõº (2) as new() = ùúà ùõº edge (ùë£, ùë§) = ùúÇ (ùê∏ (ùë£, ùë§))

Corollary 45. Consider the interpretation in Rado-nominal sets (( [25](#formula_57))-( [26](#formula_59))). If we form the sequence of random graphs in (18), then these correspond to the Erd≈ës-R√©nyi graphon.

Proof notes. The semantics interprets ground types as finite sets with discrete Aut [(Rado)](#) action -in which case internal probability kernels correspond to stochastic matrices, agreeing with FinStoch. Thus, the theory is Bernoulli-based. To see that the graphon arises, consider for instance when ùëõ = 2, we have: for ùë° 2 as in (18), and therefore ùë° 2 = ùõø 0 , bernoulli(ùõº) bernoulli(ùõº), ùõø 0 : P (2 4 )

For general ùëõ, this corresponds to the random graph model ùëù ùëä ùõº ,ùëõ for the Erd≈ës-R√©nyi graphon ùëä ùõº . ‚ñ°

## CONCLUSION

Summary. We have shown that equational theories for the graph interface to the probabilistic programming language (Ex. 1) give rise to graphons (Theorem 23). Conversely, every graphon arises in this way. We showed this generally using an abstract construction based on Markov categories (Corollary 26) and methods from category theory [[Hermida and Tennent 2012;](#b39)[Hu and Tholen 1995]](#b41). Since this is an abstract method, we also considered two concrete styles of semantic interpretation that give rise to classes of graphons: traditional measure-theoretic interpretations give rise to black-and-white graphons (Prop. 28), and an interpretation using the internal probability theory of Rado-nominal sets gives rise to Erd≈ës-R√©nyi graphons (Corollary 45).

Further context, and future work. The idea of studying exchangeable structures through program equations is perhaps first discussed in the abstract [[Staton et al. 2017](#b77)], whose ¬ß3.2 ends with an open question about semantics of languages with graphs that the present paper addresses. Subsequent work addressed the simpler setting of exchangeable sequences and beta-bernoulli conjugacy through program equations [[Staton et al. 2018]](#b76), and stochastic memoization [[Kaddar and Staton 2023]](#b52); the latter uses a category similar to RadoNom, although the monad is different. Beyond sequences [[Staton et al. 2018](#b76)] and graphs (this paper), a natural question is how to generalize to arbitrary exchangeable interfaces (see e.g. [[Orbanz and Roy 2015]](#b68)). For example, we could consider exchangeable random boolean arrays via the interface new-row : unit ‚Üí row, new-column() : unit ‚Üí column, entry : row * column ‚Üí bool and random hypergraphs with the interface new : unit ‚Üí vertex, hyperedge ùëõ : vertex ùëõ ‚Üí bool.

We could also consider interfaces for hierarchical structures, such as arrays where every entry contains a graph. Diverse exchangeable random structures have been considered from the modeltheoretic viewpoint [[Ackerman 2015;](#b0)[Crane and Towsner 2018]](#b21) and from the perspective of probability theory (e.g. [[Campbell et al. 2023;](#b15)[Jung et al. 2021;](#b51)[Kallenberg 2010]](#b53)), but it remains to be seen whether the programming perspective here can provide a unifying view. Another point is that graphons correspond to dense graphs, and so a question is how to accommodate sparse graphs from a programming perspective (e.g. [[Caron and Fox 2017;](#b19)[Veitch and Roy 2019]](#b82)).

This paper has focused on a very simple programming language ( ¬ß2.1). As mentioned in Section 1.5, several implementations of probabilistic programming languages do support various Bayesian nonparametric primitives based on exchangeable sequences, partitions, and relations (e.g. [[Dash et al. 2023;](#b24)[Goodman et al. 2008;](#b37)[Kiselyov and Shan 2010;](#b56)[Mansinghka et al. 2014;](#b64)[Roy et al. 2008;](#b74)[Wood et al. 2014]](#b84)). In particular, the 'exchangeable random primitive' (XRP) interface [[Ackerman et al. 2016b;](#)[Wu 2013](#b85)] provides a built-in abstract data type for representing exchangeable sequences. This aids model design by its abstraction, but also aids inference performance by clarifying the independence relationships.

Aside from practical inference performance, we can ask whether representation and inference are computable. For the simpler setting of exchangeable sequences, this is dealt with positively by [[Freer and](#)[Roy 2010, 2012]](#). The question of computability for graphons and exchangeable graphs is considerably subtler, and some standard representations are noncomputable [[Ackerman et al. 2019](#b4)] (see also [[Ackerman et al. 2017a]](#)). This suggests several natural questions about whether certain natural classes of computable exchangeable graphs can be identified by program analyses in the present context.

![For a simple example, we can write a program over the interface to calculate the probability of three random vertices forming a triangle: the program let ùëé = new() in let ùëè = new() in let ùëê = new() in edge(ùëé, ùëè) & edge(ùëè, ùëê) & edge(ùëé, ùëê) : bool (5)]()

![Fig. 1. (a) A graph; (b) an inferred geometric realization of it (ùúÉ ‚âà ùúã/3); (c) a generated sample for ùúÉ = ùúã/6.]()

![]. (Similar examples are implemented in[Goodman and Tenenbaum 2023, Ch. 12], albeit untyped.) Then our interface is captured by a Haskell type class: 1 class RandomGraph p vertex | p ‚Üí vertex where new :: p ‚Üí Prob vertex edge :: p ‚Üí vertex ‚Üí vertex ‚Üí Bool Here p is a parameter type, and we write Prob for a probability monad. A spherical implementation of the interface (following ¬ß1.1) is parameterized by the dimension ùëë and the distance ùúÉ , as follows: data SphGrph = SG Int Double --parameters for a sphere graph data SphVertex = SV [ Double ] --vertices are Euclidean coordinates instance RandomGraph SphGrph SphVertex where new :: SphGrph ‚Üí Prob SphVertex new ( SG d theta ) = ... --sample a random unit d -vector uniformly edge :: SphGrph ‚Üí SphVertex ‚Üí SphVertex ‚Üí Bool edge ( SG d theta ) v w = ... --check whether arccos (v.w) < theta]()

![and although our equivalence relation is slightly coarser, it still respects the symmetric monoidal category structure, and there is a monoidal functor Fam(G op ) ‚Üí Fam(G op ) [ùúà], regarding each morphism ùëì : √¨ ùëã ‚Üí √¨ ùëå in Fam(G op ) as a morphism [0, ùëì ] in Fam(G op ) [ùúà]. But there is also now an adjoined morphism ùúà = [1, id] : 1 ‚Üí vertex . This monoidal category Fam(G op ) [ùúà] moreover inherits the distributive coproduct structure from Fam(G op ), and the functor Fam(G op ) ‚Üí Fam(G op ) [ùúà] is a distributive Markov functor. To define copairing of [ùëò, ùëì ] : √¨ ùëã ‚Üí √¨ ùëç and [ùëô, ùëî] : √¨ ùëå ‚Üí √¨ ùëç we use the reindexing equivalence relation to assume ùëò = ùëô and then define the copairing as ‚ü®[ùëò, ùëì ], [ùëò, ùëî]‚ü© = [ùëò, ‚ü®ùëì , ùëî‚ü©] : √¨ ùëã + √¨ ùëå ‚Üí √¨ ùëç . In summary:]()

![].) Definition 31. A Rado-nominal set is a set ùëã equipped with an action ‚Ä¢ : Aut(Rado) √ó ùëã ‚Üí ùëã (i.e. id ‚Ä¢ ùë• = ùë•; (ùúé 2 ‚Ä¢ ùúé 1 ) ‚Ä¢ ùë• = ùúé 2 ‚Ä¢ ùúé 1 ‚Ä¢ ùë•) such that every element has finite support.]()

![ùë• 1 , ùë• 1 )], [ùê∏ (ùë• 1 , ùë• 2 )] [ùê∏ (ùë• 2 , ùë• 1 )], [ùê∏ (ùë• 2 , ùë• 2 )] (ùúà ùõº ‚äó ùúà ùõº ) (d(ùë• 1 , ùë• 2 ))]()

See https://lazyppl-team.github.io/GraphDemo.html for full details in literate Haskell.

ùê¥, ùê¥ 1 , ùê¥ 2 , ùêµ ::= unit | 0 | ùê¥ 1 * ùê¥ 2 | ùê¥ 1 + ùê¥ 2 | . . . and terms, including the typical constructors and destructors but also explicit sequencing (let in)ùë°, ùë° 1 , ùë° 2 , ùë¢ ::= ùë• | () | (ùë° 1 , ùë° 2 ) | ùúã 1 ùë° | ùúã 2 ùë° | in 1 ùë° | in 2 ùë° | let ùë• = ùë° 1 in ùë° 2 | case ùë° of {} | case ùë° of {in 1 (ùë• 1 ) ‚áí ùë¢ 1 ; in 2 (ùë• 2 ) ‚áí ùë¢ 2 } | . . .We consider the standard typing rules (where ùëñ ‚àà {1, 2}):Œì, ùë• : ùê¥, Œì ‚Ä≤ ‚ä¢ ùë• : ùê¥ Œì ‚ä¢ () : unit Œì ‚ä¢ ùë° 1 : ùê¥ 1 Œì ‚ä¢ ùë° 2 : ùê¥ 2 Œì ‚ä¢ (ùë° 1 , ùë° 2 ) : ùê¥ 1 * ùê¥ 2 Œì ‚ä¢ ùë° : ùê¥ 1 * ùê¥ 2 Œì ‚ä¢ ùúã ùëñ ùë° : ùê¥ ùëñ Œì ‚ä¢ ùë° : ùê¥ ùëñ Œì ‚ä¢ in ùëñ ùë° : ùê¥ 1 + ùê¥ 2 Œì ‚ä¢ ùë° : ùê¥ Œì, ùë• : ùê¥ ‚ä¢ ùë¢ : ùêµ Œì ‚ä¢ let ùë• = ùë° in ùë¢ : ùêµ

Œì ‚Üí ùê¥ . (See e.g.[[Pitts 2001](#b71)] for a general discussion of terms as morphisms.)In more detail, to give such an interpretation, type constants must first be given chosen interpretations as objects of C. We can then interpret types and contexts using the monoidal and coproduct structure of C. Following this, term constants ùëì : ùê¥ ‚Üí ùêµ must be given chosen interpretations as morphisms ùëì : ùê¥ ‚Üí ùêµ in C. The interpretation of other terms is made by induction on the structure of typing derivations in a standard manner, using the structure of the distributive Markov category (e.g.[[Benton et al. 1992](#b11)],[Stein 2021,  ¬ß7.2]). For example,Œì, ùë• : ùê¥, Œì ‚Ä≤ ‚ä¢ ùë• : ùê¥ = Œì, ùë• : ùê¥, Œì ‚Ä≤ Œì ‚äó ùê¥ ‚äó Œì ‚Ä≤ !‚äó ùê¥ ‚äó! ------‚Üí 1 ‚äó ùê¥ ‚äó 1 ùê¥ Œì ‚ä¢ let ùë• = ùë° in ùë¢ : ùêµ = Œì Œî Œì ---‚Üí Œì ‚äó Œì Œì ‚äó ùë° ------‚Üí Œì ‚äó ùê¥ = Œì, ùë• : ùê¥ ùë¢ --‚Üí ùêµŒì ‚ä¢ case ùë° of {in 1 (ùë• 1 ) ‚áí ùë¢ 1 ; in 2 (ùë• 2 ) ‚áí ùë¢ 2 } : ùêµ =

