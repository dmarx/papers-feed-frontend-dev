<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Probabilistic Programming Interfaces for Random Graphs: Markov Categories, Graphons, and Nominal Sets</title>
				<funder>
					<orgName type="full">Royal Society University Research Fellowship</orgName>
				</funder>
				<funder>
					<orgName type="full">CoCoSys</orgName>
				</funder>
				<funder ref="#_BQbAS84">
					<orgName type="full">Korean government (MSIT)</orgName>
				</funder>
				<funder ref="#_ckBZgzt">
					<orgName type="full">AFOSR</orgName>
				</funder>
				<funder>
					<orgName type="full">DARPA</orgName>
				</funder>
				<funder ref="#_35zU3NQ">
					<orgName type="full">Korea government (MSIT)</orgName>
				</funder>
				<funder>
					<orgName type="full">National Research Foundation of Korea</orgName>
					<orgName type="abbreviated">NRF</orgName>
				</funder>
				<funder ref="#_GfBQgTw">
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2023-12-28">28 Dec 2023</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Nate</forename><surname>Ackerman</surname></persName>
							<idno type="ORCID">0000-0002-8059-7497</idno>
						</author>
						<author>
							<persName><forename type="first">Cameron</forename><forename type="middle">E</forename><surname>Freer</surname></persName>
							<email>freer@mit.edu</email>
							<idno type="ORCID">0000-0003-1791-6843</idno>
						</author>
						<author>
							<persName><forename type="first">Sean</forename><surname>Moss</surname></persName>
							<email>s.k.moss@bham.ac.uk</email>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Roy</surname></persName>
							<email>daniel.roy@utoronto.ca</email>
							<idno type="ORCID">0000-0001-8930-0058</idno>
						</author>
						<author>
							<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
							<email>sam.staton@cs.ox.ac.uk</email>
							<idno type="ORCID">0000-0002-0141-8922</idno>
						</author>
						<author>
							<persName><roleName>KAIST</roleName><forename type="first">Hongseok</forename><surname>Yang</surname></persName>
							<email>hongseok00@gmail.com</email>
						</author>
						<author>
							<persName><forename type="first">South</forename><surname>Korea</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Harvard University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">YOUNESSE KADDAR</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">JACEK KARWOWSKI</orgName>
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">University of Birmingham</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">University of Toronto</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff7">
								<orgName type="institution">Harvard University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="department">Younesse Kaddar</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff9">
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff10">
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff11">
								<orgName type="institution">University of Birmingham</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff12">
								<orgName type="institution">University of Toronto</orgName>
								<address>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff13">
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff14">
								<orgName type="department">School of Computing</orgName>
								<orgName type="institution">KAIST</orgName>
								<address>
									<country key="KR">South Korea</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Probabilistic Programming Interfaces for Random Graphs: Markov Categories, Graphons, and Nominal Sets</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2023-12-28">28 Dec 2023</date>
						</imprint>
					</monogr>
					<idno type="MD5">ECA63E3145E3D7A381824BA44C4A7D53</idno>
					<idno type="arXiv">arXiv:2312.17127v1[cs.PL]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2-SNAPSHOT" ident="GROBID" when="2025-02-21T16:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>probability monads</term>
					<term>exchangeable processes</term>
					<term>graphons</term>
					<term>nominal sets</term>
					<term>Markov categories</term>
					<term>probabilistic programming</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We study semantic models of probabilistic programming languages over graphs, and establish a connection to graphons from graph theory and combinatorics. We show that every well-behaved equational theory for our graph probabilistic programming language corresponds to a graphon, and conversely, every graphon arises in this way.</p><p>We provide three constructions for showing that every graphon arises from an equational theory. The first is an abstract construction, using Markov categories and monoidal indeterminates. The second and third are more concrete. The second is in terms of traditional measure theoretic probability, which covers 'black-and-white' graphons. The third is in terms of probability monads on the nominal sets of Gabbay and Pitts. Specifically, we use a variation of nominal sets induced by the theory of graphs, which covers Erdős-Rényi graphons. In this way, we build new models of graph probabilistic programming from graphons.</p><p>CCS Concepts: • Theory of computation → Semantics and reasoning; Probabilistic computation.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>This paper is about the semantic structures underlying probabilistic programming with random graphs. Random graphs have applications in statistical modelling across biology, chemistry, epidemiology, and so on, as well as theoretical interest in graph theory and combinatorics (e.g. <ref type="bibr">[Bornholdt and Schuster 2002]</ref>). Probabilistic programming, i.e. programming for statistical modelling [van de <ref type="bibr" target="#b81">Meent et al. 2018]</ref>, is useful for building the statistical models for the applications. Moreover, as we show (Theorem 23 and Corollary 26), the semantic aspects of programming languages for random graphs correspond to graphons <ref type="bibr" target="#b62">[Lovász 2012</ref>], a core structure in graph theory and combinatorics.</p><p>To set the scene more precisely, we recall the setting of probabilistic programming with realvalued distributions, and contrast it with the setting with graphs. Many probabilistic programming languages provide a type of real numbers (real) and distributions such as the normal distribution normal : real * real → real</p><p>(1)</p><p>together with arithmetic operations such as (+) : real * real → real.</p><p>(2)</p><p>Even if we encounter an unfamiliar distribution over (real) in a library, we have a rough idea of how to explain what it could be, in terms of probability densities and measures.</p><p>In this paper, we consider the setting of probabilistic programming with graphs, where the probabilistic programming language or library provides a type (vertex) and some distribution new : unit → vertex</p><p>(3) together with a test edge : vertex * vertex → bool.</p><p>(4)</p><p>Our goal is to analyze the interface (vertex, new, edge) for graphs semantically, and answer, for instance, what they could be and what they could do. We give one example analysis in Section 1.1 first, and the general one later in Theorem 23 and Corollary 26, which says that to give an implementation of (vertex, new, edge), satisfying the laws of probabilistic programming, is to give a graphon. In doing so, we connect the theory of probabilistic programming with graph theory and combinatorics.</p><p>Probabilistic programming is generally used for statistical inference, in which we describe a generative model by writing a program using primitives such as (1)-( <ref type="formula">4</ref>) above, and then infer a distribution on certain parameters, given particular observed data. This paper is focused on the generative model aspect, and not inference (although for simple examples, generic inference methods apply immediately, see §1.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Example of an Implementation of a Random Graph: Geometric Random Graphs</head><p>To illustrate the interface (vertex, new, edge) of ( <ref type="formula">3</ref>)-( <ref type="formula">4</ref>), we consider for illustration a random geometric graph (e.g. <ref type="bibr" target="#b14">[Bubeck et al. 2016;</ref><ref type="bibr" target="#b70">Penrose 2003]</ref>) where the vertices are points on the surface of the unit sphere, chosen uniformly at random, and where there is an edge between two vertices if the angle between them is less than some fixed 𝜃 . This random graph might be used, for instance, to model the connections between people on the earth.</p><p>For example, a simple statistical inference problem might start from the observed connectivity in Figure <ref type="figure" target="#fig_1">1</ref>(a). We might ask for the distribution on 𝜃 given that this graph arose from the spherical random geometric graph. One sample from this posterior distribution on random geometric graphs with 𝜃 = 𝜋/3 is shown in Figure <ref type="figure" target="#fig_1">1(b)</ref>. Another, unconditioned sample from the random geometric graph with 𝜃 = 𝜋/6 is shown in Figure <ref type="figure" target="#fig_1">1(c)</ref>. We can regard this example as an implementation of the interface (vertex, new, edge) as follows: we implement (vertex) as the surface of the sphere (e.g. implemented as Euclidean coordinates).</p><p>• new() : vertex randomly picks a new vertex as a point on the sphere uniformly at random. Figure <ref type="figure" target="#fig_1">1</ref>(c) shows the progress after calling new() 15 times. • edge : vertex * vertex → bool checks whether there is an edge between two vertices; this amounts to checking whether the angle between two points is less than 𝜃 . randomly returns true or false; the probability of true is the probability of a triangle. This implementation using the sphere is only one way to implement (vertex, new, edge). There are implementations using higher-dimensional spheres, or other geometric objects. We can also consider random equivalence relations as graphs, i.e. disjoint unions of complete graphs, or random bipartite graphs, which are triangle-free. We can consider the Erdős-Rényi random graph, where the chance of an edge between two vertices is independent of the other edges, and has a fixed probability. These are all different implementations of the same abstract interface, (vertex, new, edge), and programs such as (5) make sense for all of them. The point of this paper is to characterize all these implementations, as graphons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Implementations Regarded as Equational Theories</head><p>The key method of this paper is to treat implementations of the interface (vertex, new, edge) extensionally, as equational theories. That is, rather than looking at specific implementation details, we look at the equations between programs that a user of the implementation would rely on. (This is analogous to the idea in model theory of studying first-order theories rather than specific models; similar ideas arise in the algebraic theory of computational effects [Plotkin and <ref type="bibr">Power 2002]</ref>.) For example, if an implementation always provides a bipartite random graph, we have the equation <ref type="bibr">Program (5)</ref> ≡ false between programs, because a triangle is never generated. This equation does not hold in the example of Figure <ref type="figure" target="#fig_1">1(b-c</ref>), since triangles are possible. We focus on a class of equational theories that are well behaved, as follows. First, we suppose that they contain basic laws for probabilistic programming (eqns. ( <ref type="formula">7</ref>) -(11), §2.2). This basic structure already appears broadly in different guises, including in Moggi's monadic metalanguage <ref type="bibr" target="#b67">[Moggi 1989</ref>], in linear logic <ref type="bibr" target="#b26">[Ehrhard and Tasson 2019]</ref>, and in synthetic probability theory <ref type="bibr" target="#b32">[Fritz 2020</ref>]. Second, we suppose that the equational theories are equipped with a 'Bernoulli base', which means that although we do not specify an implementation for the type (vertex), each closed program of type (bool) is equated with some ordinary Bernoulli distribution, in such a way as to satisfy the classical laws of traditional finite probability theory ( § 2.4). Finally, we suppose that the edge relation is symmetric (the graphs are undirected) and that it doesn't change when the same question is asked multiple times ('deterministic'), e.g. let 𝑎 = new() in let 𝑏 = new() in edge(𝑎, 𝑏) &amp; ¬edge(𝑎, 𝑏) ≡ false.</p><p>(6)</p><p>A graphon is a symmetric measurable function [0, 1] 2 → [0, 1]. We show that every equational theory for the interface <ref type="bibr">(vertex, new, edge)</ref> gives rise to a graphon (Theorem 23), and conversely that every graphon arises in this way <ref type="bibr">(Corollary 26)</ref>.</p><p>We emphasize that this abstract treatment of implementations, in terms of equational theories, is very open-ended, and permits a diverse range of implementation methods. Indeed, we show in Section 5 that any implementation using traditional measure-theoretic methods will only produce black-and-white graphons, so this abstract treatment is crucial.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">From Equational Theories to Graphons</head><p>In Section 3, we show how an equational theory over programs in the interface <ref type="bibr">(vertex, new, edge)</ref> gives rise to a graphon. The key first step is that graphons (modulo equivalence) can be characterized in terms of sequences of finite random graphs that satisfy three conditions: exchangeability, consistency, and locality.</p><p>To define a graphon, we show how to define programs that describe finite random graphs, by using new and edge to build boolean-valued 𝑛 × 𝑛 adjacency matrices, for all 𝑛 (shown in ( <ref type="formula" target="#formula_30">18</ref>)). Assuming that the equational theory of programs is Bernoulli-based, these programs can be interpreted as probability distributions on the finite spaces of adjacency matrices which, we show, are finite random graphs.</p><p>It remains to show that the induced sequence of random graphs satisfies the three conditions for graphons (exchangeability, consistency, and locality). These can be formulated as equational properties, and so they can be verified by using the equational reasoning in the equational theory. This is Theorem 23. A key part of the proof is the observation that exchangeability for graphons connects to commutativity of let (9): we can permute the order in which vertices are instantiated without changing the distributions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">From Graphons to Equational Theories</head><p>We also show the converse: every graphon arises from a good equational theory for the interface <ref type="bibr">(vertex, new, edge)</ref>. We look at this from three angles: first, we prove this in the general case using an abstract method, and then, we use concrete methods for two special cases.</p><p>Fixing a graphon, we build an equational theory by following a categorical viewpoint. A good equational theory for probabilistic programming amounts to a 'distributive Markov category', which is a monoidal category with coproducts that is well-suited to probability ( §2.2 and <ref type="bibr" target="#b32">[Fritz 2020]</ref>). The idea that distributive categories are a good way to analyze abstract interfaces goes back at least to <ref type="bibr" target="#b83">[Walters 1989</ref>], which used distributive categories to study interfaces for stacks and storage. We can thus use now-standard abstract methods for building monoidal and distributive categories to build an equational theory for the programming language.</p><p>We proceed in two steps. We first use methods such as <ref type="bibr" target="#b39">[Hermida and Tennent 2012;</ref><ref type="bibr" target="#b41">Hu and Tholen 1995]</ref> to build an abstract distributive Markov category that supports the interface (vertex, new, edge) in a generic way. This equational theory is generic and not Bernoulli-based: although it satisfies the equational laws of probabilistic programming, there is no given connection to traditional probability. The second step is to show that (a) it is possible to quotient this generic category to get Bernoulli-based equational theories; (b) the choices of quotient are actually in bijective correspondence with graphons. Thus, we can build an equational theory from which any given graphon arises, via (18): this is Corollary 26. (The framework of Bernoulli-based Markov categories is new here, and the techniques of <ref type="bibr" target="#b39">[Hermida and Tennent 2012;</ref><ref type="bibr" target="#b41">Hu and Tholen 1995]</ref> have not previously been applied in categorical probability, so a challenge for future work is to investigate these ideas in other aspects of categorical probability.)</p><p>Although this is a general method, it is an abstract method involving quotient constructions. The ideal form of denotational semantics is to explain what programs are by regarding them as functions between certain kinds of spaces. Although Corollary 26 demonstrates that every graphon arises from an equational theory, the type (vertex) is interpreted as an object of an abstract category, and programs are equivalence classes of abstract morphisms. In the remainder of the paper, we give two situations where we can interpret (vertex) as a genuine concrete space, and programs are functions or distributions on spaces. Such an interpretation immediately yields an equational theory, where two programs are equal if they have the same interpretation.</p><p>• Section 5: For 'black-and-white graphons', we present measure-theoretic models of the interface, based on a standard measure-theoretic interpretation of probabilistic programming (e.g. <ref type="bibr" target="#b60">[Kozen 1981]</ref>). We interpret (vertex) as a measurable space, and (new) as a probability measure on it, and (edge) in terms of a measurable predicate. Then, the composition of programs is defined in terms of probability kernels and Lebesgue integration. This kind of model exactly captures the black-and-white graphons (Prop. 29). • Section 6: For 'Erdős-Rényi' graphons, which are constantly gray, and not black-and-white, we present a model based on Rado-nominal sets ( §6.1). These are a variant of nominal sets ( <ref type="bibr" target="#b34">[Gabbay and Pitts 1999;</ref><ref type="bibr" target="#b71">Pitts 2013]</ref>) where the atoms are vertices of the Rado graph (following <ref type="bibr" target="#b12">[Bojańczyk et al. 2014]</ref>). We consider a new notion of 'internal probability measure' in this setting, and use this to give a compositional semantics that gives rise to the Erdős-Rényi graphons (Corollary 45).</p><p>Together, these more concrete sections then provide further intuition for the correspondence between equational theories and graphons.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Connection to Practice</head><p>We conclude this introduction with remarks on the connection to practical modelling. In practice, the graph interface might form part of a generative model, on which we perform inference. The structure is clearest in a typed language, and one example is the LazyPPL library for Haskell <ref type="bibr" target="#b24">[Dash et al. 2023</ref> We can use this as a building block for more complex models. For a simple example, we generated Figure <ref type="figure" target="#fig_1">1</ref>(b) by using the generic Metropolis-Hastings inference of the LazyPPL library to infer 𝜃 given a particular graph (Fig. <ref type="figure" target="#fig_1">1</ref>(a)). We have also implemented other random graphs; our implementation of the Erdős-Rényi graph uses stochastic memoization <ref type="bibr" target="#b52">[Kaddar and Staton 2023;</ref><ref type="bibr" target="#b74">Roy et al. 2008</ref>].</p><p>Summary and context. As we have discussed, our main result is that equational theories for the programming interface ( §1.1) give rise to graphons ( §1.3) and every graphon arises in this way ( §1.4). These results open up new ways to study random graphs, by using programming semantics. On the other hand, our results here put the abstractions of practical probabilistic programming on a solid theoretical foundation (see also §7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PROGRAMMING INTERFACES FOR RANDOM GRAPHS: EQUATIONAL THEORIES AND MARKOV CATEGORIES</head><p>In Section 1.1, we considered probabilistic programming over a graph interface. To make this formal, we now recall syntax, types, and equational reasoning for simple probabilistic programming languages. We begin with a general syntax ( §2.1), which can accommodate various interfaces in the form of type and term constants, including the interface for graphs (Ex. 1(3)).</p><p>We study different instantiations of the probabilistic programming language in terms of the equational theories that they satisfy. We consider two equivalent ways of understanding equational theories: as distributive Markov categories ( §2.2) and in terms of affine monads ( §2.3). Markov categories are a categorical formulation of probability theory (e.g. <ref type="bibr" target="#b32">[Fritz 2020]</ref>), and affine monads arise in the categorical analysis of probability (e.g. <ref type="bibr" target="#b33">[Fritz et al. 2023;</ref><ref type="bibr" target="#b45">Jacobs 2018;</ref><ref type="bibr" target="#b59">Kock 2012]</ref>) as well as in the semantics for probabilistic programming (e.g. [Azevedo de <ref type="bibr" target="#b10">Amorim 2023;</ref><ref type="bibr" target="#b23">Dahlqvist et al. 2018;</ref><ref type="bibr" target="#b24">Dash et al. 2023]</ref>). We make a connection with traditional probability via the notion of Bernoulli base ( §2.4).</p><p>Much of this section will be unsurprising to experts: the main purpose is to collect definitions and results. The definition of distributive Markov category appears to be novel, and so we go over that definition and correspondence with monads (Propositions 8 and 13). In Section 2.5, we give a construction for quotienting a distributive Markov category, which we will need in Section 4. We include the result in the section because it may be of independent interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Syntax for a Generic Probabilistic Programming Language</head><p>Our generic probabilistic programming language is, very roughly, an idealized, typed fragment of a typical language like Church <ref type="bibr" target="#b37">[Goodman et al. 2008</ref>]. We start with a simple programming language (following <ref type="bibr" target="#b26">[Ehrhard and Tasson 2019;</ref><ref type="bibr">Staton 2017;</ref><ref type="bibr" target="#b78">Stein 2021]</ref> but also <ref type="bibr" target="#b67">[Moggi 1989</ref>]) with at least the following product and sum type constructors:</p><formula xml:id="formula_0">Γ ⊢ 𝑡 : 0 Γ ⊢ case 𝑡 of {} : 𝐵 Γ ⊢ 𝑡 : 𝐴 1 + 𝐴 2 Γ, 𝑥 𝑖 : 𝐴 𝑖 ⊢ 𝑢 𝑖 : 𝐵 𝑖 ∈ {1,2} Γ ⊢ case 𝑡 of {in 1 (𝑥 1 ) ⇒ 𝑢 1 ; in 2 (𝑥 2 ) ⇒ 𝑢 2 } : 𝐵 (Here, a context Γ is a sequence of assignments of types 𝐴 to variables 𝑥.)</formula><p>In what follows, we use shorthands such as bool = unit + unit, and if-then-else instead of case. This language is intended to be a generic probabilistic programming language, but so far there is nothing specifically probabilistic about this syntax. Different probabilistic programming languages support distributions over different kinds of structures. Thus, our language is extended according to an 'interface' by specifying type constants and typed term constants 𝑓 : 𝐴 → 𝐵. For each term constant 𝑓 : 𝐴 → 𝐵, we include a new typing rule, Γ ⊢ 𝑡 : 𝐴 Γ ⊢ 𝑓 (𝑡) : 𝐵 Example 1. We consider the following examples of interfaces.</p><p>(1) For probabilistic programming over finite domains, we may have term constants such as bernoulli 0.5 : unit → bool, intuitively a fair coin toss.</p><p>(2) For probabilistic programming over real numbers, we may have a type constant real and term constants such as normal : real * real → real, intuitively a parameterized normal distribution, and arithmetic operations such as (+) : real * real → real.</p><p>(3) The main interface of this paper is for random graphs: this has a type constant vertex and term constants new : unit → vertex and edge : vertex * vertex → bool.</p><p>(We have kept this language as simple as possible, to focus on the interesting aspects. A practical probabilistic programming language will include other features, which are largely orthogonal, and indeed within our implementation in Haskell ( §1.5), programming features like higher order functions and recursion are present and useful. See also the discussion in §2.3.4.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Equational Theories and Markov Categories</head><p>Section 2.1 introduced a syntax for various probabilistic programming interfaces. The idea is that this is a generic language which applies to different interfaces with different distributions that are implemented in different ways. Rather than considering various ad hoc operational semantics, we study the instances of interfaces by the program equations that they support.</p><p>Regardless of the specifics of a particular implementation, we expect basic equational reasoning principles for probabilistic programming to hold, such as the following laws:</p><formula xml:id="formula_1">(let 𝑦=(let 𝑥=𝑡 in 𝑢) in 𝑡 ′ ) ≡ (let 𝑥=𝑡 in let 𝑦=𝑢 in 𝑡 ′ ) (where 𝑥 ∉ fv(𝑡 ′ )) (7) (𝑡, 𝑢) ≡ (let 𝑥 = 𝑡 in let 𝑦 = 𝑢 in (𝑥, 𝑦)) (8) (let 𝑥=𝑡 in let 𝑥 ′ =𝑡 ′ in 𝑢) ≡ (let 𝑥 ′ =𝑡 ′ in let 𝑥=𝑡 in 𝑢)</formula><p>(where 𝑥 ∉ fv(𝑡 ′ ) and 𝑥 ′ ∉ fv(𝑡)) (9)</p><formula xml:id="formula_2">(let 𝑥 = 𝑡 ′ in 𝑡) ≡ 𝑡 (where 𝑥 ∉ fv(𝑡))<label>(10)</label></formula><p>The following law does not always hold, but does hold when 𝑣 is 'deterministic'.</p><formula xml:id="formula_3">(let 𝑥 = 𝑣 in 𝑡) ≡ 𝑡 [𝑣/𝑥]<label>(11)</label></formula><p>Equations ( <ref type="formula">9</ref>) and (10) say that parts of programs can be re-ordered and discarded, as long as the dataflow is respected. This is a feature of probabilistic programming. For example, coins do not remember the order nor how many times they have been tossed. But these equations would typically not hold in a language with state.</p><p>The cleanest way to study equational theories of programs is via a categorical semantics, and for Markov categories have arisen as a canonical setting for categorical probability. Informally, a category is a structure for composition, and this matches the composition structure of let in our language. We also have monoidal structure which allows for the type constructor 𝐴 × 𝐵 and for the compound contexts Γ, comonoid structure which allows duplication of variables, and distributive coproduct structure which allows for the sum types. Definition 2. A symmetric monoidal category (C, ⊗, 𝐼 ) is a category C equipped with a functor ⊗ : C × C → C and an object 𝐼 together with associativity, unit and symmetry structure ( <ref type="bibr">[Mac Lane 1998, XI.1.]</ref>). A Markov category ( <ref type="bibr" target="#b32">[Fritz 2020]</ref>) is a symmetric monoidal category in which</p><p>• the monoidal unit 𝐼 is a terminal object (𝐼 = 1), and • every object 𝑋 is equipped with a comonoid Δ 𝑋 : 𝑋 → 𝑋 ⊗ 𝑋 , compatible with the tensor product (Δ 𝑋 ⊗𝑌 = (𝑋 ⊗ swp ⊗ 𝑌 ) • (Δ 𝑋 ⊗ Δ 𝑌 ), where swp is the swap map of C).</p><p>A morphism 𝑓 : 𝑋 → 𝑌 in a Markov category is deterministic if it commutes with the comonoids:</p><formula xml:id="formula_4">(𝑓 ⊗ 𝑓 ) • Δ 𝑋 = Δ 𝑌 • 𝑓 .</formula><p>A distributive symmetric monoidal category (e.g. <ref type="bibr" target="#b48">[Jay 1993;</ref><ref type="bibr" target="#b83">Walters 1989]</ref>) is a symmetric monoidal category equipped with chosen finite coproducts such that the canonical maps 𝑋 ⊗ 𝑍 + 𝑌 ⊗ 𝑍 → (𝑋 + 𝑌 ) ⊗ 𝑍 and 0 → 0 ⊗ 𝑍 are isomorphisms. A distributive Markov category is a Markov category whose underlying monoidal category is also distributive and whose chosen coproduct injections 𝑋 → 𝑋 + 𝑌 ← 𝑌 are deterministic. A distributive category <ref type="bibr" target="#b18">[Carboni et al. 1993;</ref><ref type="bibr" target="#b20">Cockett 1993</ref>] is a distributive Markov category where all morphisms are deterministic.</p><p>A (strict) distributive Markov functor is a functor 𝐹 : C → D between distributive Markov categories which strictly preserves the chosen symmetric monoidal, coproduct, and comonoid structures.</p><p>In this paper we mainly focus on functors between distributive Markov categories that strictly preserve the relevant structure, so we elide 'strict'. (Nonetheless, non-strict functors are important, e.g. <ref type="bibr">[Fritz 2020, §10</ref>.2] and Prop. 13.)</p><p>We interpret the language of Section 2.1 in a distributive Markov category C by interpreting types 𝐴 and type contexts Γ as objects 𝐴 and Γ , and typed terms Γ ⊢ 𝑡 : 𝐴 as morphisms</p><formula xml:id="formula_5">Γ Δ Γ ---→ Γ ⊗ Γ Γ ⊗ 𝑡 ------→ Γ ⊗ 𝐴 1 + 𝐴 2 Γ, 𝑥 : 𝐴 1 + Γ, 𝑥 : 𝐴 2 ⟨ 𝑢 1 , 𝑢 2 ⟩ --------→ 𝐵 Γ ⊢ 𝑓 (𝑡) : 𝐵 = Γ 𝑡 --→ 𝐴 𝑓 --→ 𝐵</formula><p>An interpretation in a Markov category induces an equational theory between programs: let Γ ⊢ 𝑡 = 𝑢 : 𝐴 if 𝑡 = 𝑢 . Proposition 3 (e.g. <ref type="bibr" target="#b78">[Stein 2021</ref>], §7.1). The equational theory induced by the interpretation in a distributive Markov category, with given interpretations of type and term constants, always includes the equations (7)-( <ref type="formula" target="#formula_2">10</ref>), and also (11) whenever 𝑣 is a deterministic morphism.</p><p>Example 4. The category (FinSet, ×, 1) of finite sets is a distributive Markov category. As in any category with products, each object has a unique comonoid structure, and all morphisms are deterministic. This is a good Markov category for interpreting the plain language with no type or term constants. For example, bool is a set with two elements.</p><p>Example 5. The category FinStoch has natural numbers as objects and the morphisms are stochastic matrices. In more detail, a morphism 𝑚 → 𝑛 is a matrix in (R ≥0 ) 𝑚×𝑛 such that each row sums to 1. Composition is by matrix multiplication. The monoidal structure is given on objects by multiplication of numbers, and on morphisms by Kronecker product of matrices. By choosing an enumeration of each finite set, we get a functor FinSet → FinStoch that converts a function to the corresponding (0/1)-valued matrix. So every object of FinStoch can be regarded with the comonoid structure from FinSet. The deterministic morphisms in FinStoch are exactly the morphisms from FinSet <ref type="bibr">[Fritz 2020, 10.3]</ref>. This is a good Markov category for interpreting the language with Bernoulli distributions (Ex. 1(1)). We interpret the fair coin as the 1 × 2 matrix (0.5, 0.5).</p><p>We can also give some interpretations for the graph interface (Ex. 1(3)) in FinStoch. For instance, consider random graphs made of two disjoint complete subgraphs, as is typical in a clustering model. We can interpret this by putting vertex = 2, edge = ( 1 0 0 1 0 1 1 0 ) ⊤ , and new = (0.5, 0.5).</p><p>We look at other examples of distributive Markov categories and interpretations of these interfaces in <ref type="table">Sections 2.3.2</ref> and <ref type="table">2.3.3,</ref> and <ref type="table">then in Sections 4-6.</ref> 2.3 Equational Theories and Affine Monads 2.3.1 Distributive Markov Categories from Affine Monads. One way to generate equational theories via Markov categories is by considering certain kinds of monads, following Moggi <ref type="bibr" target="#b67">[Moggi 1989</ref>]. Definition 6. A strong monad on a category A with finite products is given by</p><p>• for each object 𝑋 , an object 𝑇 (𝑋 );</p><p>• for each object 𝑋 , a morphism 𝜂 𝑋 : 𝑋 → 𝑇 (𝑋 );</p><p>• for objects 𝑍, 𝑋, 𝑌 , a family of functions natural in 𝑍</p><formula xml:id="formula_6">(&gt;&gt;=) : A(𝑍,𝑇 (𝑋 )) × A(𝑍 × 𝑋,𝑇 (𝑌 )) → A(𝑍,𝑇 (𝑌 ))</formula><p>such that &gt;&gt;= is associative with unit 𝜂.</p><p>(There are various different formulations of this structure. When A is cartesian closed, as in Defs. 9 and 41, then the bind (&gt;&gt;=) is represented by a morphism (&gt;&gt;=) : 𝑇 (𝑋 ) × (𝑋 ⇒ 𝑇 (𝑌 )) → 𝑇 (𝑌 ), by the Yoneda lemma.) Definition 7 ( <ref type="bibr" target="#b43">[Jacobs 1994;</ref><ref type="bibr" target="#b58">Kock 1970;</ref><ref type="bibr" target="#b61">Lindner 1979]</ref>). Given a strong monad 𝑇 , we say that two morphisms 𝑓 :</p><formula xml:id="formula_7">𝑋 1 → 𝑇 (𝑋 2 ), 𝑔 : 𝑋 1 → 𝑇 (𝑋 3 ) commute if 𝑓 &gt;&gt;= ((𝑔 • 𝜋 1 ) &gt;&gt;= (𝜂 • ⟨𝜋 2 • 𝜋 1 , 𝜋 2 ⟩)) = 𝑔 &gt;&gt;= ((𝑓 • 𝜋 1 ) &gt;&gt;= (𝜂 • ⟨𝜋 2 , 𝜋 2 • 𝜋 1 ⟩)) : 𝑋 1 → 𝑇 (𝑋 2 × 𝑋 3 ). A strong monad is commutative if all morphisms commute. It is affine if 𝑇 (1) → 1 is an isomorphism.</formula><p>The Kleisli category Kl(𝑇 ) of a strong monad 𝑇 has the same objects as A, but the morphisms are different: Kl(𝑇 ) (𝐴, 𝐵) = A(𝐴,𝑇 (𝐵)). There is a functor 𝐽 : A → Kl(𝑇 ), given on morphisms by composing with 𝜂 (e.g. <ref type="bibr">[Mac Lane 1998, §VI.5</ref>], <ref type="bibr" target="#b67">[Moggi 1989]</ref>). Proposition 8. Let 𝑇 be a strong monad on a category A. If 𝑇 is commutative and affine and A has finite products, then the Kleisli category Kl(𝑇 ) has a canonical structure of a Markov category. Furthermore, if A is distributive, then Kl(𝑇 ) can be regarded as a distributive Markov category.</p><p>Proof notes. The Markov structure follows <ref type="bibr">[Fritz 2020, §3]</ref>. Since 𝑇 is commutative, the product structure of A extends to a symmetric monoidal structure on Kl(𝑇 ). Since 𝑇 (1) = 1, the monoidal unit (1) is terminal in Kl(𝑇 ). Every object in A has a comonoid structure, and this is extended to Kl(𝑇 ) via 𝐽 . The morphisms in the image of 𝐽 are deterministic, although this need not be a full characterization of determinism.</p><p>For the distributive structure, recall that 𝐽 preserves coproducts and indeed it has a right adjoint. Hence, the coproduct injections will be deterministic. □</p><p>We can thus interpret the language of Section 2.1 using any strong monad, interpreting the types 𝐴 as objects 𝐴 of A, and a term Γ ⊢ 𝑡 : 𝐴 as a morphism 𝑡 : Γ → 𝑇 ( 𝐴 ). This interpretation matches Moggi's interpretation of the language of Section 2.1 in a strong monad.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Example Affine Monad: Distribution Monad.</head><p>Definition 9 (e.g. <ref type="bibr" target="#b44">[Jacobs 2016</ref>], §4.1). The distribution monad D on Set is defined as follows:</p><p>• On objects: each set 𝑋 is mapped to the set of all finitely-supported discrete probability measures on 𝑋 , that is, all functions 𝑝 : 𝑋 → R that are non-zero for only finitely many elements and satisfy 𝑥 ∈𝑋 𝑝 (𝑥) = 1. • The unit 𝜂 𝑋 : 𝑋 → D (𝑋 ) maps 𝑥 ∈ 𝑋 to the indicator function 𝜆𝑦. [𝑦 = 𝑥], i.e. the Dirac distribution 𝛿 𝑥 . • The bind function (&gt;&gt;=) is defined as follows:</p><formula xml:id="formula_8">(𝑓 &gt;&gt;= 𝑔) (𝑧) (𝑦) = 𝑥 ∈𝑋 𝑓 (𝑧) (𝑥) • 𝑔(𝑧, 𝑥) (𝑦)</formula><p>By the standard construction for strong monads, each morphism 𝑓 : 𝑋 → 𝑌 gets mapped to D 𝑓 : D𝑋 → D𝑌 , that is, the pushforward in this case:</p><formula xml:id="formula_9">D 𝑓 (𝑝) (𝑦) = 𝑥 ∈ 𝑓 -1 (𝑦) 𝑝 (𝑥).</formula><p>Consider the language with no type constants, and just the term constant bernoulli 0.5 (Ex. 1( <ref type="formula">1</ref>)). This can be interpreted in the distribution monad. Since every type 𝐴 is interpreted as a finite set 𝐴 , and every context Γ as a finite set Γ , a term Γ ⊢ 𝑡 : 𝐴 is interpreted as a function Γ → D 𝐴 . To give a Kleisli morphism between finite sets is to give a stochastic matrix, and so the induced equational theory is the same as the interpretation in FinStoch (Ex. 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Example Affine</head><p>Monad: Giry Monad. We recall some rudiments of measure-theoretic probability.</p><p>Definition 10. A 𝜎-algebra on a set is a non-empty collection of subsets that contains the empty set and is closed under countable unions and complements. A measurable space is a pair (𝑋, Σ) of a set and a 𝜎-algebra on it. A measurable function</p><formula xml:id="formula_10">(𝑋, Σ 𝑋 ) → (𝑌 , Σ 𝑌 ) is a function 𝑓 : 𝑋 → 𝑌 such that 𝑓 -1 (𝑈 ) ∈ Σ 𝑋 for all 𝑈 ∈ Σ 𝑌 .</formula><p>A probability measure on a measurable space (𝑋, Σ) is a function 𝜇 : Σ → [0, 1] that has total mass 1 (𝜇 (𝑋 ) = 1) and that is 𝜎-additive: 𝜇 ( ∞ 𝑖=1 𝑈 𝑖 ) = ∞ 𝑖=1 𝜇 (𝑈 𝑖 ) for any sequence of disjoint 𝑈 𝑖 . Examples of measurable spaces include: the finite sets 𝑋 equipped with their powerset 𝜎-algebras; the unit interval [0, 1] equipped with its Borel 𝜎-algebra, which is the least 𝜎-algebra containing the open sets. Examples of probability measures include: discrete probability measures (Def. 9); the uniform measure on [0, 1]; the Dirac distribution</p><formula xml:id="formula_11">𝛿 𝑥 (𝑈 ) = [𝑥 ∈ 𝑈 ].</formula><p>The product of two measurable spaces (𝑋, Σ 𝑋 ) × (𝑌 , Σ 𝑌 ) = (𝑋 × 𝑌 , Σ 𝑋 ⊗ Σ 𝑌 ) comprises the product of sets with the least 𝜎-algebra making the projections 𝑋 ← 𝑋 × 𝑌 → 𝑌 measurable. The category of measurable spaces and measurable functions is a distributive category.</p><p>A probability kernel between measurable spaces (𝑋, Σ 𝑋 ) and (𝑌 , Σ 𝑌 ) is a function 𝑘 : 𝑋 × Σ 𝑌 → [0, 1] that is measurable in the first argument and that is 𝜎-additive and has mass 1 in the second argument.</p><p>To compose probability kernels, we briefly recall Lebesgue integration. Consider a measurable space (𝑋, Σ 𝑋 ), a measure 𝜇 : Σ 𝑋 → [0, 1], and a measurable function</p><formula xml:id="formula_12">𝑓 : 𝑋 → [0, 1]. If 𝑓 is a simple function, i.e. 𝑓 (𝑥) = 𝑚 𝑖=1 𝑟 𝑖 • [𝑥 ∈ 𝑈 𝑖 ] for some 𝑚, 𝑟 𝑖 ∈ [0, 1], and 𝑈 𝑖 ∈ Σ 𝑋 , the Lebesgue integral ∫ 𝑓 d𝜇 = ∫ 𝑓 (𝑥) 𝜇 (d𝑥) ∈ [0, 1] is defined to be 𝑚 𝑖=1 𝑟 𝑖 × 𝜇 (𝑈 𝑖 ).</formula><p>If 𝑓 is not a simple function, there exists a sequence of increasing simple functions 𝑓 1 , 𝑓 2 , . . . : 𝑋 → [0, 1] such that sup 𝑘 𝑓 𝑘 (𝑥) = 𝑓 (𝑥) (for example, by taking 𝑓 𝑘 (𝑥) def = ⌊10 𝑘 𝑓 (𝑥)⌋/10 𝑘 ). In that case, the integral is defined to be the limit of the integrals of the 𝑓 𝑘 's (which exists by monotone convergence).</p><p>Probability kernels can be equivalently formulated as morphisms 𝑋 → G(𝑌 ), where G is the Giry monad: Definition 11 ( <ref type="bibr" target="#b36">[Giry 1980]</ref>). The Giry monad G is a strong monad on the category Meas of measurable spaces given by • G(𝑋 ) is the set of probability measures on 𝑋 , with the least 𝜎-algebra making ∫ 𝑓 d(-) : G(𝑋 ) → [0, 1] measurable for all measurable 𝑓 : 𝑋 → [0, 1];</p><p>• the unit 𝜂 maps 𝑥 to the Dirac distribution 𝛿 𝑥 ;</p><p>• the bind is given by composing kernels:</p><formula xml:id="formula_13">(𝑘 &gt;&gt;= 𝑙) (𝑧, 𝑈 ) = ∫ 𝑙 ((𝑧, 𝑥), 𝑈 ) 𝑘 (𝑧, d𝑥). (<label>12</label></formula><formula xml:id="formula_14">)</formula><p>Proposition 12. The monad G is commutative and affine.</p><p>Proof notes. Commutativity boils down to Fubini's theorem for reordering integrals and affineness is marginalization (since probability measures have mass 1). See also <ref type="bibr" target="#b45">[Jacobs 2018</ref>]. □ Consider the real-numbers language (Ex. 1(2)). Let real = R, with the Borel sets, and interpret normal as the normal probability measure on R. The basic arithmetic operations are all measurable.</p><p>Among the following three programs</p><formula xml:id="formula_15">let 𝑥 = normal(0, 1) in 𝑥 + 𝑥 (13) let 𝑥 = normal(0, 1) in let 𝑦 = normal(0, 1) in 𝑥 + 𝑦 (14) normal(0, 1) + normal(0, 1)<label>(15)</label></formula><p>the programs ( <ref type="formula">14</ref>) and ( <ref type="formula" target="#formula_15">15</ref>) denote the same normal distribution with variance 2, whereas (13) denotes a distribution with variance 4. Notice that we cannot use ( <ref type="formula" target="#formula_3">11</ref>) to equate all the programs, because normal is not deterministic. We can also interpret the Bernoulli language (Ex. 1(1)) in the Giry monad; this interpretation gives the same equational theory as the interpretation in FinStoch and in the distribution monad in Section 2.3.2.</p><p>We can also give some interpretations for the graph interface (Ex. 1(3)) in the Giry monad. For an informal example, consider the geometric example from Section 1.1, let vertex = 𝑆 2 (the sphere), and define new to be the uniform distribution on the sphere. (See also Section 5.2.) 2.3.4 Affine Monads from Distributive Markov Categories. The following result, a converse to Proposition 8, demonstrates that the new notion of distributive Markov category (Def. 2) is a canonical one, and emphasizes the close relationship between semantics with distributive Markov categories and semantics with commutative affine monads.</p><p>Proposition 13. Let C be a small distributive Markov category. Then, there is a distributive category A with a commutative affine monad 𝑇 on it and a full and faithful functor C → Kl(𝑇 ) that preserves symmetric monoidal structure, comonoids, and sums.</p><p>Proof notes. Our proof is essentially a recasting of <ref type="bibr">[Power 2006b, §7]</ref> to this different situation, as follows.</p><p>Let C det be the wide subcategory of C comprising the deterministic morphisms, and write 𝐽 : C det → C for the identity-on-objects inclusion functor. Note that C det is a distributive category. We would like to exhibit C as the Kleisli category for a monad on C det , but this might not be possible: intuitively, C det might be too small for the monad to exist. Instead, we first embed C det in a larger category A and construct a monad on A.</p><p>The main construction in our proof is the idea that if X is a small distributive monoidal category, then the category FP(X op , Set) of finite-product-preserving functors is such that</p><p>• FP(X op , Set) is cocomplete and moreover total <ref type="bibr">([Street and Walters 1978]</ref>) as a category;</p><p>• FP(X op , Set) admits a distributive monoidal structure;</p><p>• the Yoneda embedding X → [X op , Set], which is full and faithful, factors through FP(X op , Set), and this embedding X → FP(X op , Set) preserves finite sums and is strongly monoidal; • the Yoneda embedding exhibits FP(X op , Set) as a free colimit completion of X as a monoidal category that already has finite coproducts. So we let A = FP(C op det , Set) comprise the finite-product-preserving functors C op det → Set. This is a distributive category. To get a monad on A, we note that since FP(C op , Set) has finite coproducts and C det → C → FP(C op , Set) preserves finite coproducts and is monoidal, the monoidal structure induces a canonical colimit-preserving monoidal functor 𝐽 ! : FP(C op det , Set) → FP(C op , Set). Any colimit-preserving functor 𝐽 ! out of a total category has a right adjoint 𝐽 * , and hence a monoidal monad (𝐽 * 𝐽 ! ) is induced on A.</p><p>It remains for us to check that the embedding C → FP(C op , Set) factors through the comparison functor Kl(𝐽 * 𝐽 ! ) → FP(C op , Set), which follows from the fact that 𝐽 : C det → C is identity on objects.</p><p>□</p><p>As an aside, we note that, although our simple language in Section 2.1 did not include higherorder functions, the category A constructed in the proof of Proposition 13 is cartesian closed, and since the embedding is full and faithful, this shows that higher-order functions would be a conservative extension of our language. Indeed, this kind of conservativity result was part of the motivation of <ref type="bibr">[Power 2006b</ref>]. For the same reason, inductive types (lists, and so on) would also be a conservative extension. We leave conservativity with other language features for future work. Recursion in probabilistic programming is still under investigation <ref type="bibr" target="#b25">[Ehrhard et al. 2018;</ref><ref type="bibr">Goubault-Larrecq et al. 2021;</ref><ref type="bibr" target="#b49">Jia et al. 2021;</ref><ref type="bibr" target="#b66">Matache et al. 2022;</ref><ref type="bibr" target="#b80">Vákár et al. 2019]</ref>; there is also the question of conservativity with respect to combining Markov categories, e.g. combining real number distributions ((1)-( <ref type="formula">2</ref>)) with graph programming ((3)-( <ref type="formula">4</ref>)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Bernoulli Bases, Numerals and Observation</head><p>Although an interface may have different type constants, it will always have the 'numeral' types, sometimes called 'finite' types:</p><formula xml:id="formula_16">0 unit bool = unit + unit unit + unit + unit . . .</formula><p>For probabilistic programming languages, there is a clear expectation of what will happen when we run a program of type bool: it will randomly produce either true or false, each with some probability. Similarly for other numeral types. For type constants, we might not have evident notions of observation or expected outcomes. But for numeral types, it should be routine. We now make this precise via the notion of Bernoulli base.</p><p>On the semantic side, distributive Markov categories will always have 'numeral' objects</p><formula xml:id="formula_17">0 1 2 def = 1 + 1 3 def = 1 + 1 + 1 . . .</formula><p>For any type 𝐴 formed without type constants, and any Markov category, we have that 𝐴 𝑛 for some numeral object. Any equational theory for the programming language induces in particular an equational theory for the sub-language without any type constants. Proposition 14. For any distributive Markov category C, let C N be the category whose objects are natural numbers, and where the morphisms are the morphisms in C between the corresponding numeral objects. This is again a distributive Markov category.</p><p>Example 15.</p><p>(1) FinSet N = Set N is equivalent to FinSet as a category.</p><p>(2) For the finite distributions and the Giry monad ( §2.</p><formula xml:id="formula_18">3.2-2.3.3), Kl(D) N ≃ Kl(G) N ≃ FinStoch.</formula><p>Recall that a functor is faithful if it is injective on hom-sets. Definition 16. A Bernoulli base for a distributive Markov category C is a faithful distributive Markov functor Ψ : C N ↣ FinStoch.</p><p>Thus, for any distributive Markov category with a Bernoulli base, for any closed term ⊢ 𝑡 : 𝐴 of numeral type ( 𝐴 = 𝑛), we can regard its interpretation 𝑡 : 1 → 𝑛 as nothing but a probability distribution Ψ( 𝑡 ) on 𝑛 outcomes. This is the case even if 𝑡 uses term constants and has intermediate subterms using type constants.</p><p>Example 17. All the examples seen so far can be given Bernoulli bases. In fact, for FinStoch, Kl(D) and Kl(G), the functor Ψ : C N ↣ FinStoch is an isomorphism of distributive Markov categories.</p><p>When Ψ is an isomorphism of categories, that means that all the finite probabilities are present in C. This is slightly stronger than we need in general. For instance, when C = FinSet, there is a unique Bernoulli base Ψ : FinSet N ↣ FinStoch, taking a function to a 0/1-valued matrix, but it is not full. We could also consider variations on FinStoch. For example, consider the subcategory FinQStoch of FinStoch where the matrices are rational-valued; this has a Bernoulli base that is not an isomorphism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Quotients of Distributive Markov Categories</head><p>We provide a new, general method for constructing a Bernoulli-based Markov category out of a distributive Markov category. Our construction is a categorical formulation of the notion of contextual equivalence.</p><p>Recall that, in general, contextual equivalence for a programming language starts with a notion of basic observation for closed programs at ground types. We then say that programs Γ ⊢ 𝑡, 𝑢 : 𝐴 at other types are contextually equivalent if for every context C with ⊢ C [𝑡], C [𝑢] : 𝑛, for some ground type 𝑛, we have that C [𝑡] and C [𝑢] satisfy the same observations. In the categorical setting, the notion of observation is given by a distributive Markov functor C N → FinStoch, and the notion of context C is replaced by suitable morphisms (ℎ, 𝑘 below). We now introduce a quotient construction that will be key in showing that every graphon arises from a distributive Markov category (Corollary 26), via Theorem 23. We note that this is a general new method for building Markov categories.</p><p>Proposition 18. Let C be a distributive Markov category, and let Ψ : C N → FinStoch be a distributive Markov functor. Suppose that for every object 𝑋 ∈ C, either 𝑋 = 0 or there exists a morphism 1 → 𝑋 . Then, there is a distributive Markov category C/ Ψ with a Bernoulli base, equipped with a distributive Markov functor C → C/ Ψ and a factorization of distributive Markov functors</p><formula xml:id="formula_19">Ψ = C N → (C/ Ψ ) N ↣ FinStoch. Proof. Define an equivalence relation ∼ on each hom-set C(𝑋, 𝑌 ), by 𝑓 ∼ 𝑔 : 𝑋 → 𝑌 if ∀𝑍, 𝑛. ∀ℎ : 1 → 𝑋 ⊗ 𝑍 . ∀𝑘 : 𝑌 ⊗ 𝑍 → 𝑛. Ψ(𝑘 • (𝑓 ⊗ 𝑍 ) • ℎ) = Ψ(𝑘 • (𝑔 ⊗ 𝑍 ) • ℎ) in FinStoch(1, 𝑛).</formula><p>Informally, our equivalence relation considers all ways of generating 𝑋 's via precomposition (ℎ), all ways for testing 𝑌 's via postcomposition (𝑘), and all ways of combining with some ancillary data (𝑍 ). It is essential that we consider all these kinds of composition in order for the quotient category to have the categorical structure.</p><p>It is immediate that composition of morphisms respects ∼, and hence we have a category: the objects are the same as C, and the morphisms are ∼-equivalence classes. This is our category C/ Ψ .</p><p>It is also immediate that if 𝑓 ∼ 𝑔 and 𝑓 ′ ∼ 𝑔 ′ then (𝑓 ⊗ 𝑓 ′ ) ∼ (𝑔 ⊗ 𝑔 ′ ). Thus, C/ Ψ is a monoidal category.</p><p>For the coproduct structure, we must show that if 𝑓 ∼ 𝑔 : 𝑋 → 𝑌 and 𝑓 ′ ∼ 𝑔 ′ : 𝑋 ′ → 𝑌 ′ then (𝑓 + 𝑓 ′ ) ∼ (𝑔 + 𝑔 ′ ) : 𝑋 + 𝑋 ′ → 𝑌 + 𝑌 ′ . We proceed by noting that since we have morphisms 𝑥 : 1 → 𝑋 and 𝑥 ′ : 1 → 𝑋 ′ , as well as terminal morphisms 𝑋 → 1 and 𝑋 ′ → 1, we have that 𝑋 + 𝑋 ′ is a retract of 𝑋 ⊗ 𝑋 ′ ⊗ 2, with the section and retraction given by:</p><formula xml:id="formula_20">𝑋 + 𝑋 ′ 𝑋 ⊗𝑥 ′ +𝑥 ⊗𝑋 ---------→ 𝑋 ⊗ 𝑋 ′ + 𝑋 ⊗ 𝑋 ′ 𝑋 ⊗ 𝑋 ′ ⊗ 2 𝑋 ⊗ 𝑋 ′ ⊗ 2 𝑋 ⊗ 𝑋 ′ + 𝑋 ⊗ 𝑋 ′ 𝑋 ⊗!+!⊗𝑋 -------→ 𝑋 + 𝑋 ′</formula><p>Thus, by composing with this retract, it suffices to check that (𝑓 ⊗ 𝑓 ′ ⊗ 2) ∼ (𝑔 ⊗ 𝑔 ′ ⊗ 2), which we have already shown.</p><p>The functor Ψ : C N → FinStoch clearly factors through (C/ Ψ ) N , but it remains to check that the functor (C/ Ψ ) N → FinStoch is now faithful (Bernoulli base). So suppose that Ψ(𝑓 ) = Ψ(𝑔). To show that 𝑓 ∼ 𝑔 : 1 → 𝑚, we consider ℎ : 1 → 1 ⊗ 𝑍 , and 𝑘 : 𝑚 ⊗ 𝑍 → 𝑛. We must show that</p><formula xml:id="formula_21">Ψ(𝑘 • (𝑓 ⊗ 𝑍 ) • ℎ) = Ψ(𝑘 • (𝑔 ⊗ 𝑍 ) • ℎ). Since ℎ = 1 ⊗ ℎ ′ , for some ℎ ′ : 1 → 𝑍 , we have Ψ(𝑘 • (𝑓 ⊗ 𝑍 ) • ℎ) = Ψ(𝑘 • (𝑚 ⊗ ℎ ′ ) • 𝑓 ) = Ψ(𝑘 • (𝑚 ⊗ ℎ ′ )) • Ψ(𝑓 ) = Ψ(𝑘 • (𝑚 ⊗ ℎ ′ )) • Ψ(𝑔) = Ψ(𝑘 • (𝑚 ⊗ ℎ ′ ) • 𝑔) = Ψ(𝑘 • (𝑔 ⊗ 𝑍 ) • ℎ). □ 3 FROM PROGRAM EQUATIONS TO GRAPHONS</formula><p>The graph interface for the probabilistic programming language (Ex. 1(3)) does not have one fixed equational theory. Rather, we want to consider different equational theories for the language, corresponding to different implementations of the interface for the graph (see also §1.2). We now show how the different equational theories for the graph language each give rise to a graphon, by building adjacency matrices for finite graphs (shown in ( <ref type="formula" target="#formula_30">18</ref>)). To do this, we set up the well-behaved equational theories ( §2.4), recall the connection between graphons and finite random graphs ( §3.1), and then show the main result ( §3.2, Theorem 23).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Graphons as Consistent and Local Random Graph Models</head><p>For all 𝑛 ≥ 1, let [𝑛] be the set {1, . . . , 𝑛}. (We sometimes omit the square brackets, when it is clear.) A simple undirected graph 𝑔 with 𝑛 nodes can be represented by its adjacency matrix 𝐴 𝑔 ∈ 2 [𝑛] 2 such that 𝐴 𝑔 (𝑖, 𝑖) = 0 and 𝐴 𝑔 (𝑖, 𝑗) = 𝐴 𝑔 ( 𝑗, 𝑖). Henceforth, we will assume that finite graphs are simple and undirected, unless otherwise stated. A random finite graph, then, has a probability distribution in D 2 [𝑛] 2 that only assigns non-zero probability to adjacency matrices.</p><p>Definition 19 (e.g. <ref type="bibr">[Lovász 2012, §11.2.1]</ref>). A random graph model is a sequence of distributions of random finite graphs of the form:</p><formula xml:id="formula_22">𝑝 1 ∈ D 2 [1] 2 , 𝑝 2 ∈ D 2 [2] 2 , . . . , 𝑝 𝑛 ∈ D 2 [𝑛] 2 , . . .</formula><p>We say such a sequence is</p><p>• exchangeable if each of its elements is invariant under permuting nodes: for every 𝑛 and bijection 𝜎 : 𝑛] 2 is the function that permutes the rows and columns according to 𝜎; we are regarding D as a covariant functor, Def. 9, and 2 (-) as a contravariant functor); • consistent if the sequence is related by marginals: for every 𝑛 and for the inclusion function</p><formula xml:id="formula_23">[𝑛] → [𝑛], we have D 2 (𝜎 2 ) (𝑝 𝑛 ) = 𝑝 𝑛 (where 2 (𝜎 2 ) : 2 [𝑛] 2 → 2 [</formula><formula xml:id="formula_24">𝜄 : [𝑛] ↩→ [𝑛 + 1], D 2 (𝜄 2 ) (𝑝 𝑛+1 ) = 𝑝 𝑛 (</formula><p>where 2 (𝜄 2 ) : 2 ( [𝑛+1] 2 ) → 2 [𝑛] 2 is the evident projection); • local if the subgraphs are independent: if 𝐴 ⊆ [𝑛] and 𝐵 ⊆ [𝑛] are disjoint, then we have an injective function 𝚥 :</p><formula xml:id="formula_25">𝐴 2 + 𝐵 2 ↩→ [𝑛] 2 , and D 2 𝚥 (𝑝 𝑛 ) ∈ D 2 (𝐴 2 ) × 2 (𝐵 2 ) is a product measure 𝑝 𝐴 ⊗ 𝑝 𝐵 (where 2 𝚥 : 2 [𝑛] 2 → 2 (𝐴 2 ) × 2 (𝐵 2 )</formula><p>is the evident pairing of projections).</p><p>Definition 20 (e.g. <ref type="bibr" target="#b62">[Lovász 2012])</ref>. A graphon 𝑊 is a symmetric measurable function 𝑊 :</p><formula xml:id="formula_26">[0, 1] 2 → [0, 1].</formula><p>Given a graphon 𝑊 , we can generate a finite simple undirected graph 𝑔 with vertex set [𝑛] by sampling 𝑛 points 𝑥 1 , . . . , 𝑥 𝑛 uniformly from [0, 1] and, then, including the edge (𝑖, 𝑗) with probability 𝑊 (𝑥 𝑖 , 𝑥 𝑗 ) for all 1 ≤ 𝑖, 𝑗 ≤ 𝑛. This sampling procedure defines a distribution over finite graphs: the probability 𝑝 𝑊 ,𝑛 (𝐴 𝑔 ) of the graph 𝑔 = ( [𝑛], 𝐸) is:</p><formula xml:id="formula_27">∫ [0,1] 𝑛 (𝑖,𝑗 ) ∈𝐸 𝑊 (𝑥 𝑖 , 𝑥 𝑗 ) (𝑖,𝑗 )∉𝐸 1 -𝑊 (𝑥 𝑖 , 𝑥 𝑗 ) d(𝑥 1 . . . 𝑥 𝑛 )<label>(16)</label></formula><p>Proposition 21 ( <ref type="bibr">[Lovász and Szegedy 2006]</ref>, <ref type="bibr">[Lovász 2012, §11.2]</ref>). Every graphon generates an exchangeable, consistent, and local random graph model, by the sampling procedure of (16). Conversely, every exchangeable, consistent, and local random graph model is of the form 𝑝 𝑊 ,𝑛 for some graphon 𝑊 .</p><p>Note. There are various methods for constructing 𝑊 from an exchangeable, consistent and local random graph model, however all are highly non-trivial. A general idea is that 𝑊 is a kind of limit object. For examples see e.g. <ref type="bibr">[Lovász and Szegedy 2006, §11.3]</ref> or <ref type="bibr" target="#b79">[Tao 2013</ref>]. Fortunately though, we will not need explicit constructions in this paper. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Theories of Program Equivalence Induce Graphons</head><p>In this section we consider the instance of the generic language with the graph interface (Ex. 1(3)):</p><formula xml:id="formula_28">vertex new : unit → vertex edge : vertex * vertex → bool</formula><p>We consider a theory of program equivalence, i.e. a distributive Markov category with a distinguished object vertex and morphisms new : 1 → vertex and edge : vertex ⊗ vertex → 1 + 1. We make two assumptions about the theory:</p><p>• The graphs are simple and undirected:</p><p>𝑥 : vertex ⊢ edge(𝑥, 𝑥) ≡ false 𝑥, 𝑦 : vertex ⊢ edge(𝑥, 𝑦) ≡ edge(𝑦, 𝑥)</p><p>and edge is deterministic. • The theory is Bernoulli based ( §2.4).</p><p>For each 𝑛 ∈ N, we can build a random graph with 𝑛 vertices as follows. We consider the following program 𝑡 𝑛 :</p><formula xml:id="formula_30">⊢ let 𝑥 1 = new() in . . . let 𝑥 𝑛 = new() in edge(𝑥 1 , 𝑥 1 ) . . . edge(𝑥 1 , 𝑥 𝑛 ) . . . . . . edge(𝑥 𝑛 , 𝑥 1 ) . . . edge(𝑥 𝑛 , 𝑥 𝑛 ) : bool (𝑛 2 )<label>(18)</label></formula><p>(Here we use syntactic sugar, writing a matrix instead of iteratively using pairs.) Because the equational theory is Bernoulli-based, the interpretation 𝑡 𝑛 induces a probability distribution Ψ 𝑡 𝑛 on 2 (𝑛 2 ) . For clarity, we elide Ψ in what follows, since it is faithful. Proposition 22. Each random matrix in (18) is a random adjacency matrix, i.e. a random graph.</p><p>Proof note. This follows from (17). □ Theorem 23. For any Bernoulli-based equational theory, the random graph model ( 𝑡 𝑛 ) 𝑛 in (18) is exchangeable, consistent, and local. Thus, the equational theory induces a graphon.</p><p>Proof. We denote the matrix in ( <ref type="formula" target="#formula_30">18</ref>) by (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛] .</p><p>Exchangeability. We show that the distribution 𝑡 𝑛 is invariant under relabeling the nodes. By commutativity of the let construct (9), the program</p><formula xml:id="formula_31">𝑡 𝜎 𝑛 def = let 𝑥 𝜎 -1 (1) = new() in . . . let 𝑥 𝜎 -1 (𝑛) = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛]</formula><p>satisfies 𝑡 𝜎 𝑛 = 𝑡 𝑛 . Hence, D (2 𝜎 2 ) ( 𝑡 𝑛 ) = 𝑡 𝜎 𝑛 = 𝑡 𝑛 , for every 𝑛 and bijection 𝜎 : [𝑛] → [𝑛]. Consistency. We define a macro subm 𝐼 in the graph programming language to extract a submatrix at the index set 𝐼 ⊆ [𝑛]: we have the (definitional) equality</p><formula xml:id="formula_32">subm 𝐼 ((𝑎 𝑖,𝑗 ) 𝑖,𝑗 ∈ [𝑛] ) def = (𝑎 𝑖,𝑗 ) 𝑖,𝑗 ∈𝐼 for 𝐼 ⊆ [𝑛].</formula><p>We need to show that, if we delete the last node from a graph sampled from 𝑡 𝑛+1 , the resulting graph has distribution 𝑡 𝑛 . This amounts to the affineness property (10), as follows. Let 𝑔 ∼ 𝑡 𝑛+1 be a random graph, and let 𝑔 ′ def = 𝑔 | [𝑛] be the graph obtained by deleting the last node from 𝑔. Then clearly, the adjacency matrix of 𝑔 ′ is the adjacency matrix of 𝑔 where the last row and column have been removed, i.e. 𝑔 ′ is sampled from the interpretation of the program:</p><formula xml:id="formula_33">𝑡 ′ def = let 𝑥 1 = new() in . . . let 𝑥 𝑛 = new() in let 𝑥 𝑛+1 = new() in subm [𝑛] (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛+1] ≡ let 𝑥 1 = new() in . . . let 𝑥 𝑛 = new() in let 𝑥 𝑛+1 = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛] ≡ let 𝑥 1 = new() in . . . let 𝑥 𝑛 = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛]</formula><p>(by ( <ref type="formula" target="#formula_2">10</ref>)) ≡ 𝑡 𝑛 .</p><p>Locality. Without loss of generality (by exchangeability and consistency), we need to show that for every random graph 𝑔 ∼ 𝑡 𝑛 and 1 &lt; 𝑘 &lt; 𝑛, the subgraphs 𝑔 𝐴 𝑘 , 𝑔 𝐵 𝑘 respectively induced by the sets 𝐴 𝑘 def = [𝑘] and 𝐵 𝑘 def = {𝑘 + 1, . . . , 𝑛} are independent as random variables. Let 𝚥 be the injection 𝚥 : 𝐴 2 𝑘 + 𝐵 2 𝑘 ↩→ 𝑛 2 , and</p><formula xml:id="formula_34">𝑔 ′ ∼ D (2 𝚥 ) ( 𝑡 𝑛 ) ∈ D (2 (𝐴 2 𝑘 ) × 2 (𝐵 2 𝑘 )</formula><p>). We want to show that 𝑔 ′ and (𝑔 𝐴 𝑘 , 𝑔 𝐵 𝑘 ) ∼ 𝑡 𝑘 ⊗ 𝑡 𝑛-𝑘 (by consistency) are equal in distribution. Modulo 𝛼-renaming, (𝑔 𝐴 𝑘 , 𝑔 𝐵 𝑘 ) is sampled from the interpretation of the program:</p><formula xml:id="formula_35">𝑡 ′ def = let 𝑥 1 = new() in . . . let 𝑥 𝑘 = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑘 ] , let 𝑥 𝑘+1 = new() in . . . let 𝑥 𝑛 = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑘+1≤𝑖,𝑗 ≤𝑛 ≡ let 𝑢 1 = (let 𝑥 1 = new() in . . . let 𝑥 𝑘 = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈𝐴 𝑘 ) in let 𝑢 2 = (let 𝑥 𝑘+1 = new() in . . . let 𝑥 𝑛 = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈𝐵 𝑘 ) in (𝑢 1 , 𝑢 2 ) (by (8)) ≡ let 𝑥 1 = new() in . . . let 𝑥 𝑘 = new() in let 𝑥 𝑘+1 = new() in . . . let 𝑥 𝑛 = new() in ((7),(9)) let 𝑢 1 = subm 𝐴 𝑘 (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛] in let 𝑢 2 = subm 𝐵 𝑘 (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛] in (𝑢 1 , 𝑢 2 ) ≡ let 𝑥 1 = new() in . . . let 𝑥 𝑛 = new() in let 𝑡 = (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛] in let 𝑢 1 = subm 𝐴 𝑘 (𝑡) in let 𝑢 2 = subm 𝐵 𝑘 (𝑡) in (𝑢 1 , 𝑢 2 ) (by (11)) ≡ let 𝑥 1 = new() in . . . let 𝑥 𝑛 = new() in let 𝑡 = (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛] in subm 𝐴 𝑘 (𝑡), subm 𝐵 𝑘 (𝑡) (by (8)) ≡ let 𝑡 = let 𝑥 1 = new() in . . . let 𝑥 𝑛 = new() in (edge(𝑥 𝑖 , 𝑥 𝑗 )) 𝑖,𝑗 ∈ [𝑛] in subm 𝐴 𝑘 (𝑡), subm 𝐵 𝑘 (𝑡))</formula><p>(by ( <ref type="formula">7</ref>))</p><p>and 𝑔 ′ ∼ D (2 𝚥 ) ( 𝑡 𝑛 ) is indeed sampled from the interpretation of the latter program, which yields the result. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FROM GRAPHONS TO PROGRAM EQUATIONS</head><p>In Section 3, we showed how a distributive Markov category modelling the graph interface (Ex. 1(3)) gives rise to a graphon. In this section, we establish a converse: every graphon arises in this way (Corollary 26). Theorem 25 will establish slightly more: there is a 'generic' distributive Markov category ( §4.1) modelling the graph interface whose Bernoulli-based quotients are in precise correspondence with graphons ( §4.2). This approach also suggests an operational way of implementing the graph interface for any graphon ( §4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Generic Distributive Markov Category for the Graph Interface</head><p>We construct this generic category in two steps. We first create a distributive Markov category, actually a distributive category, Fam(G op ), that supports (vertex, edge). We then add new using the monoidal indeterminates method of <ref type="bibr" target="#b39">[Hermida and Tennent 2012]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.1.1</head><p>Step 1: A Distributive Category with edge. We first define a distributive category that supports (vertex, edge). Let G be the category of finite graphs and functions that preserve and reflect the edge relation. That is, a morphism 𝑓 : 𝑔 → 𝑔 ′ is a function 𝑓 : 𝑉 𝑔 → 𝑉 ′ 𝑔 such that for all 𝑣, 𝑤 ∈ 𝑉 𝑔 we have 𝐸 𝑔 (𝑣, 𝑤) if and only if 𝐸 𝑔 (𝑓 (𝑣), 𝑓 (𝑤)).</p><p>Recall (e.g. <ref type="bibr" target="#b41">[Hu and Tholen 1995]</ref>) that the free finite coproduct completion of a category C, Fam(C) is given as follows. The objects of Fam(C) are sequences (𝑋 1 . . . 𝑋 𝑛 ) of objects of C, and the morphisms (𝑋 1 . . . 𝑋 𝑚 ) → (𝑌 1 . . . 𝑌 𝑛 ) are pairs (𝑓 , {𝑓 𝑖 } 𝑚 𝑖=1 ) of a function 𝑓 : 𝑚 → 𝑛 and a sequence of morphisms 𝑓 1 : 𝑋 1 → 𝑌 𝑓 (1) , . . . , 𝑓 𝑚 : 𝑋 𝑚 → 𝑌 𝑓 (𝑚) in C.</p><p>We consider the category Fam(G op ). Let vertex = (1), the singleton sequence comprising the one-vertex graph.</p><p>Proposition 24.</p><p>(1) The free coproduct completion Fam(G op ) is a distributive category, with the product vertex 𝑛 being the sequence of all graphs with 𝑛 vertices. In particular, vertex 2 is a sequence with two components, the complete graph and the edgeless graph with two vertices.</p><p>(2) Let edge : vertex × vertex → 1 + 1 be the morphism (id, {!, !}), intuitively returning true for the edge, and false for the edgeless graph. Here the terminal object 1 of Fam(G op ) is the singleton tuple of the empty graph. This interpretation satisfies (17).</p><p>Proof notes. Item (1) follows from <ref type="bibr" target="#b41">[Hu and Tholen 1995]</ref>, which shows that limits in Fam(G op ) amount to "multi-colimits" in G. For example, the family of all graphs with 𝑛 vertices is a multicoproduct of the one-vertex graph in G, hence forms a product in Fam(G op ). Item ( <ref type="formula">2</ref>) is then a quick calculation. All morphisms in Fam(G op ) are deterministic. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.1.2</head><p>Step 2: Adjoining new. In Section 4.1.1, we introduced a distributive category that interprets the interface (vertex, edge). But it does not support new, and indeed there are no morphisms 1 → vertex . To additionally interpret (new), we freely adjoin it. We essentially use the 'monoidal indeterminates' method of Hermida and Tennent <ref type="bibr" target="#b39">[Hermida and Tennent 2012]</ref> to do this. Their work was motivated by semantics of dynamic memory allocation, but has also been related to quantum phenomena <ref type="bibr" target="#b8">[Andrés-Martínez et al. 2022;</ref><ref type="bibr" target="#b42">Huot and Staton 2018]</ref> and to categorical gradient/probabilistic methods <ref type="bibr" target="#b22">[Cruttwell et al. 2021;</ref><ref type="bibr" target="#b29">Fong et al. 2021;</ref><ref type="bibr" target="#b75">Shiebler 2021]</ref>, where it is known as the 'para construction'. It is connected to earlier methods for the action calculus <ref type="bibr" target="#b69">[Pavlović 1997</ref>].</p><p>Let FinSetInj be the category of finite sets and injections. It is a monoidal category with the disjoint union monoidal structure (e.g. <ref type="bibr" target="#b28">[Fiore 2005;</ref><ref type="bibr">Power 2006a]</ref>). Consider the functor 𝐽 : FinSetInj op → Fam(G op ), with 𝐽 (𝑛) = vertex 𝑛 , and where the functorial action is by exchange and projection. This is a strong monoidal functor. (Indeed, it is the unique monoidal functor with 𝐽 (1) = vertex .) For any monoidal functor, Hermida and Tennent <ref type="bibr" target="#b39">[Hermida and Tennent 2012]</ref> provide monoidal indeterminates by introducing a 'polynomial category', by analogy with a polynomial ring. Unfortunately, a general version for distributive monoidal categories is not yet known, so we focus on the specific case of 𝐽 : FinSetInj op → Fam(G op ). We build a new category Fam(G op ) [𝜈 : 𝐽 FinSetInj op ], which we abbreviate Fam(G op ) [𝜈]. It has the same objects as Fam(G op ), but the morphisms ì 𝑋 → ì 𝑌 are equivalence classes of morphisms [𝑘, 𝑓 ] : vertex 𝑘 × ì 𝑋 → ì 𝑌 in Fam(G op ), modulo reindexing. The reindexing equivalence relation is generated by putting [𝑘, 𝑓 ] ∼ [𝑙, 𝑔] when there exist injections 𝜄 1 . . . 𝜄 𝑚 : 𝑘 → 𝑙 such that</p><formula xml:id="formula_36">𝑔 = vertex 𝑙 × ì 𝑋 𝑚 𝑗=1 vertex 𝑙 × 𝑋 𝑗 vertex (𝜄 𝑗 ) ×𝑋 𝑗 ------------→ 𝑚 𝑗=1 vertex 𝑘 × 𝑋 𝑗 vertex 𝑘 × ì 𝑋 𝑓 - → ì 𝑌</formula><p>where ì 𝑋 = (𝑋 1 , . . . , 𝑋 𝑚 ). In particular, when 𝑚 = 1, i.e. ì 𝑋 = 𝑋 is a singleton sequence, we have</p><formula xml:id="formula_37">Fam(G op ) [𝜈] (𝑋, ì 𝑌 ) colim 𝑘 ∈FinSetInj Fam(G op ) ( vertex 𝑘 × 𝑋, ì 𝑌 ). (<label>19</label></formula><formula xml:id="formula_38">)</formula><p>Composition and monoidal structure accumulate in vertex 𝑘 , as usual in the monoidal indeterminates ('para') construction, e.g. • Fam(G op ) [𝜈] is a distributive Markov category.</p><formula xml:id="formula_39">ì 𝑋 [𝑘,𝑓 ] ----→ ì 𝑌 [𝑙,𝑔] ---→ ì 𝑍 = ì 𝑋 [𝑙+𝑘,𝑔•( vertex 𝑙 ×𝑓 ) ] -----------------→ ì 𝑍</formula><p>• Fam(G op ) [𝜈] supports the graph interface, via the interpretation of (vertex, edge) in Fam(G op ), but also with the interpretation new = 𝜈 : 1 → vertex .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Bernoulli Bases for Random Graph Models</head><p>The following gives a precise characterization of graphons in terms of the numerals of Fam(G op ) [𝜈].</p><p>Theorem 25. To give a distributive Markov functor Fam(G op ) [𝜈] N → FinStoch is to give a graphon.</p><p>Proof outline. We begin by showing a related characterization: that graphons correspond to certain natural transformations. Observe that any distributive Markov category C gives rise to a symmetric monoidal functor C(1, -) : FinSet N → Set, regarding the numerals of FinSet N as objects of C ( §2.4). Let 𝐺 𝑘 = 2 𝑘 (𝑘 -1)/2 be the set of 𝑘-vertex graphs. We can characterize the natural</p><formula xml:id="formula_40">transformations 𝛼 : Fam(G op ) [𝜈] (1, -) → FinStoch(1, -) as follows. Nat(Fam(G op ) [𝜈] (1, -) , FinStoch(1, -)) Nat colim 𝑘 ∈FinSetInj FinSet(𝐺 𝑘 , -) , D (-)</formula><p>(Ex. 15(2), Prop. 24( <ref type="formula">1</ref>) and ( <ref type="formula" target="#formula_37">19</ref>)) lim 𝑘 ∈FinSetInj op Nat(FinSet(𝐺 𝑘 , -) , D (-))</p><p>(universal property of colimits) lim 𝑘 ∈FinSetInj op D (𝐺 𝑘 ) (Yoneda lemma) An element of this limit of sets is by definition a sequence of distributions 𝑝 𝑘 on 𝐺 𝑘 that is invariant under reindexing by FinSetInj op . Since injections are generated by inclusions and permutations, this is then a sequence that is consistent and exchangeable (Def. 19), respectively. Such a natural transformation 𝛼 is monoidal if and only if the sequence is also local. Hence a monoidal natural transformation is the same thing as a random graph model.</p><p>In fact, every monoidal natural transformation 𝛼 : Fam(G op ) [𝜈] (1, -) → FinStoch(1, -) arises uniquely by restricting a distributive Markov functor 𝐹 : Fam(G op ) [𝜈] N → FinStoch. We now show this, to conclude our proof. Given 𝛼, let 𝐹 𝑚,𝑛 : Fam(G op ) [𝜈] N (𝑚, 𝑛) → FinStoch(𝑚, 𝑛) be:</p><formula xml:id="formula_41">Fam(G op ) [𝜈] N (𝑚, 𝑛) Fam(G op ) [𝜈] N (1, 𝑛) 𝑚 𝛼 𝑚 𝑛 --→ FinStoch(1, 𝑛) 𝑚 FinStoch(𝑚, 𝑛).</formula><p>It is immediate that this 𝐹 preserves the symmetric monoidal structure and coproduct structure, but not that 𝐹 is a functor. However, the naturality of 𝛼 in FinSet N gives us that 𝐹 preserves postcomposition by morphisms of FinSet N . All of this implies that general categorical composition is preserved as well, since, in any distributive Markov category of the form C N , for 𝑓 : 𝑙 → 𝑚 and 𝑔 : 𝑚 → 𝑛, the composite 𝑔 • 𝑓 : 𝑙 → 𝑛 is equal to</p><formula xml:id="formula_42">𝑙 = 𝑙 ⊗ 1 ⊗𝑚 𝑓 ⊗𝑔 1 ⊗...⊗𝑔 𝑚 ----------→ 𝑚 ⊗ 𝑛 ⊗𝑚 eval ---→ 𝑛</formula><p>where 𝑔 𝑖 = 𝑔 • 𝜄 𝑖 for 𝑖 = 1, . . . , 𝑚 and eval is just the evaluation map 𝑚 × 𝑛 𝑚 → 𝑛 in FinSet. □ Corollary 26. Every graphon arises from a distributive Markov category via the random graph model in (18). Proof summary. Given a graphon, we consider the distributive Markov functor that corresponds to it, Ψ : Fam(G op ) [𝜈] N → FinStoch, by Theorem 25. Using the quotient construction of Proposition 18, we get a distributive Markov category with a Bernoulli base. It is straightforward to verify that the random graph model induced by ( <ref type="formula" target="#formula_30">18</ref>) is the original graphon. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Remark on Operational Semantics</head><p>The interpretation in this section suggests a general purpose operational semantics for closed programs at ground type, ⊢ 𝑡 : 𝑛, along the following lines:</p><p>(1) Calculate the interpretation 𝑡 : 1 → 𝑛 in Fam(G op ) <ref type="bibr">[𝜈]</ref>. There are no probabilistic choices in this step, it is a symbolic manipulation, because the morphisms of the Markov category Fam(G op ) [𝜈] are built from tuples of finite graph homomorphisms. In effect, this interpretation pulls all the new's to the front of the term. (2) Apply the Markov functor Ψ( 𝑡 ) to obtain a probability distribution on 𝑛, and sample from this distribution to return a result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">INTERPRETATION: BLACK-AND-WHITE GRAPHONS VIA MEASURE-THEORETIC PROBABILITY</head><p>In Section 4, we gave a general syntactic construction for building an equational theory from a graphon. Since that definition is based on free constructions and quotients, a priori, it does not 'explain' what the type vertex stands for. Like contextual equivalence of programs, a priori, it does not give useful compositional reasoning methods. To prove two programs are equal, according to the construction of Prop. 18, one needs to quantify over all 𝑍 , ℎ, and 𝑘, in general.</p><p>In this section, we show that one class of graphons, black-and-white graphons (Def. 27), admits a straightforward measure-theoretic semantics, and we can thus use the equational theory induced by this semantics, rather than the method of Section 4. This measure-theoretic semantics is close to previous measure-theoretic work on probabilistic programming languages (e.g. <ref type="bibr" target="#b60">[Kozen 1981;</ref><ref type="bibr">Staton 2017]</ref>).</p><p>After recapping measure-theoretic probability ( §2.3.3), in Section 5.1, we show that every blackand-white graphon arises from a measure-theoretic interpretation (Prop. 28). In Section 5.2, by defining 'measure-theoretic interpretation' more generally, we show that, conversely, this measuretheoretic approach can only cater for black-and-white graphons (Prop. 29).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Black-and-White Graphons from Equational Theories</head><p>Definition 27. [e.g. <ref type="bibr" target="#b47">[Janson 2013</ref></p><formula xml:id="formula_43">]] A graphon 𝑊 : [0, 1] 2 → [0, 1] is black-and-white if there exists 𝐸 : [0, 1] 2 → {0, 1} such that 𝑊 (𝑥, 𝑦) = 𝐸 (𝑥, 𝑦) for almost all 𝑥, 𝑦.</formula><p>Recall that the Giry monad (Def. 11) gives rise to a Bernoulli-based distributive Markov category ( §2.3.3, Ex. 15). For any black-and-white graphon 𝑊 , we define an interpretation of the graph interface for the probabilistic programming language using G, as follows.</p><p>• vertex 𝑊 = [0, 1]; bool 𝑊 = 2, the discrete two element space;</p><p>• new() 𝑊 = Uniform(0, 1), the uniform distribution on [0, 1];</p><p>• edge 𝑊 (𝑥, 𝑦) = 𝜂 (𝐸 (𝑥, 𝑦)).</p><p>Proposition 28. Let 𝑊 be a black-and-white graphon. The equational theory induced by -𝑊 induces the graphon 𝑊 according to the construction in Section 3.2.</p><p>Proof. Suppose that𝑊 corresponds to the sequence of random graphs 𝑝 1 , 𝑝 2 , . . . as in Section 3.1. Consider the term 𝑡 𝑛 in (18), and directly calculate its interpretation. Then, we get 𝑡 𝑛 𝑊 = 𝑝 𝑛 , via ( <ref type="formula" target="#formula_27">16</ref>), as required.</p><p>The choice of 𝐸 does not matter in the interpretation of these terms, because 𝑊 = 𝐸 almost everywhere. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">All Measure-Theoretic Interpretations are Black-and-White</head><p>Although the model in Section 5.1 is fairly canonical, there are sometimes other enlightening interpretations using the Giry monad. These also correspond to black-and-white graphons. For example, consider the geometric-graph example from Figure <ref type="figure" target="#fig_1">1</ref>. We interpret this using the Giry monad, putting</p><p>• vertex = 𝑆 2 , the sphere; bool = 2;</p><p>• new() = Uniform(𝑆 2 ), the uniform distribution on the sphere;</p><p>• edge (𝑥, 𝑦) = 𝜂 (𝑑 (𝑥, 𝑦) &lt; 𝜃 ), i.e. an edge if their distance is less than 𝜃 .</p><p>This will again induce a graphon, via (18). We briefly look at theories that arise in this more flexible way:</p><p>Proposition 29. Consider any interpretation of the graph interface in the Giry monad: a measurable space vertex , a measurable set edge ⊆ vertex 2 , and a probability measure new() on vertex . The induced graphon is black-and-white.</p><p>Proof notes. If vertex is standard Borel, the randomization lemma <ref type="bibr">[Kallenberg 2010, Lem. 3.22]</ref> gives a function 𝑓 : [0, 1] → vertex that pushes the uniform distribution on [0, 1] onto the probability measure new() . We define a black-and-white graphon 𝑊 by 𝑊 (𝑥, 𝑦) = 1 if (𝑓 (𝑥), 𝑓 (𝑦)) ∈ edge , and 𝑊 (𝑥, 𝑦) = 0 otherwise. This graphon interpretation -𝑊 gives the same sequence of graphs in (18), just by reparameterizing the integrals.</p><p>If vertex is not standard Borel, we note that there is an equivalent interpretation where it is, because there exists a measure-preserving map vertex → Ω to a standard Borel space Ω and a measurable set 𝐸 ⊆ Ω 2 that pulls back to edge , giving rise to the same graphon (e.g. <ref type="bibr">[Janson 2013, Lemma 7.3]</ref>). □</p><p>Discussion. Proposition 29 demonstrates that this measure-theoretic interpretation has limitations.</p><p>Definition 30. For 𝛼 ∈ (0, 1), the Erdős-Rényi graphon</p><formula xml:id="formula_44">𝑊 𝛼 : [0, 1] 2 → [0, 1] is given by 𝑊 𝛼 (𝑥, 𝑦) = 𝛼.</formula><p>The Erdős-Rényi graphons cannot arise from measure-theoretic interpretations of the graph interface, because they are not black-and-white. In Section 6, we give an alternative interpretation for the Erdős-Rényi graphons.</p><p>The reader might be tempted to interpret an Erdős-Rényi graphon by defining edge 𝑊 𝛼 (𝑥, 𝑦) = bernoulli(𝛼).</p><p>However, this interpretation does not provide a model for the basic equations of the language, because this edge is not deterministic, and derivable equations such as (6) will fail. Intuitively, once an edge has been sampled between two given nodes, its presence (or absence) remains unchanged in the rest of the program, i.e. the edge is not resampled again, it is memoized (see also <ref type="bibr" target="#b52">[Kaddar and Staton 2023;</ref><ref type="bibr" target="#b74">Roy et al. 2008]</ref>).</p><p>Although not all graphons are black-and-white, these are still a widely studied and useful class. They are often called 'random-free'. For example, an alternative characterization is that the random graph model of Prop. 21 has subquadratic entropy function <ref type="bibr">[Janson 2013, §10.6</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">INTERPRETATION: ERDŐS-RÉNYI GRAPHONS VIA RADO-NOMINAL SETS</head><p>In Section 4, we gave a general construction to show that every graphon arises from a Bernoullibased equational theory. In Section 5, we gave a more concrete interpretation, based on measuretheory, for black-and-white graphons. We now consider the Erdős-Rényi graphons (Def. 30), which are not black-and-white.</p><p>Our interpretation is based on Rado-nominal sets. These are also studied elsewhere, but for different purposes (e.g. <ref type="bibr" target="#b12">[Bojańczyk et al. 2014;</ref><ref type="bibr" target="#b13">Bojańczyk and Place 2012;</ref><ref type="bibr" target="#b57">Klin et al. 2016</ref>], [Pitts 2013, §1.9]).</p><p>Rado-nominal sets ( §6.1) are sets that are equipped with an action of the automorphisms of the Rado graph, which is an infinite graph that contains every finite graph. There is a particular Rado-nominal set V of the vertices of the Rado graph. The type vertex will be interpreted as V; edge is interpreted using the edge relation 𝐸 on V. The equational theory induced by this interpretation gives rise to the Erdős-Rényi graphons (Def. 30).</p><p>Since Rado-nominal sets form a model of ZFA set theory (Prop. 36), we revisit probability theory internal to this setting. We consider internal probability measures on Rado-nominal sets ( §6.3), and we show that there are internal probability measures on V that give rise to Erdős-Rényi graphons ( §6.3). The key starting point here is that, internal to Rado-nominal sets, the only functions V → 2 are the sets of vertices that are definable in the language of graphs ( §6.2).</p><p>We organize the probability measures (Def. 37) into a probability monad on Rado-nominal sets ( §6.4), analogous to the Giry monad. Fubini does not routinely hold in this setting ( §6.4.4), but we use a standard technique to cut down to a commutative affine monad ( §6.4.5). This gives rise to a Bernoulli-based equational theory, and in fact, this theory corresponds to Erdős-Rényi graphons (via (18): Corollary 45).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Definition and First Examples</head><p>The Rado graph (V, 𝐸) ( <ref type="bibr" target="#b6">[Ackermann 1937;</ref><ref type="bibr" target="#b73">Rado 1964]</ref>, also known as the 'random graph' <ref type="bibr" target="#b27">[Erdős and Rényi 1959]</ref>) is the unique graph, up to isomorphism, with a countably infinite set of vertices that has the extension property: if 𝐴, 𝐵 are disjoint finite subsets of V, then there is a vertex 𝑎 ∈ V \ (𝐴 ∪ 𝐵) with an edge to all the vertices in 𝐴 but none of the vertices in 𝐵.</p><p>The Rado graph embeds every finite graph, which can be shown by using the extension property inductively.</p><p>An automorphism of the Rado graph is a graph isomorphism V → V. The automorphisms of the Rado graph relate to isomorphisms between finite graphs, as follows. First, if 𝐴 is a finite graph regarded as a subset of V, then any automorphism 𝜎 induces an isomorphism of finite graphs 𝐴 𝜎 <ref type="bibr">[𝐴]</ref>. Conversely, if 𝑓 : 𝐴 𝐵 is an isomorphism of finite graphs, and we regard 𝐴 and 𝐵 as disjoint subsets of V, then there exists an automorphism 𝜎 of V that restricts to 𝑓 (i.e. 𝑓 = 𝜎 | 𝐴 ).</p><p>We write Aut <ref type="bibr">(Rado)</ref> for the group of automorphisms of (V, 𝐸). (This has been extensively studied in model theory and descriptive set theory, e.g. <ref type="bibr" target="#b9">[Angel et al. 2014;</ref><ref type="bibr" target="#b55">Kechris et al. 2005</ref> An element 𝑥 ∈ 𝑋 is defined to have finite support if there is a finite set 𝐴 ⊆ V such that for all automorphisms 𝜎, if 𝜎 fixes 𝐴 (i.e. 𝜎 | 𝐴 = id 𝐴 ), it also fixes 𝑥 (i.e. 𝜎 • 𝑥 = 𝑥).</p><p>Equivariant functions between Rado-nominal sets are functions that preserve the group action (i.e. 𝑓 (𝜎 • 𝑥) = 𝜎 • (𝑓 (𝑥))).</p><p>Proposition 32 <ref type="bibr" target="#b71">([Pitts 2013]</ref>). If finite sets 𝐴, 𝐵 ⊆ V both support 𝑥, so does 𝐴 ∩ 𝐵. Hence every element has a least support.</p><p>Example 33.</p><p>(1) The set V of vertices is a Rado-nominal set, with 𝜎 • 𝑎 = 𝜎 (𝑎). The support of vertex 𝑎 is {𝑎}.</p><p>(2) The set V × V of pairs of vertices is a Rado-nominal set, with 𝜎 • (𝑎, 𝑏) = (𝜎 (𝑎), 𝜎 (𝑏)).</p><p>The support of (𝑎, 𝑏) is {𝑎, 𝑏}. More generally, a finite product of Rado-nominal sets has a coordinate-wise group action.</p><p>(3) The edge relation 𝐸 ⊆ V × V is a Rado-nominal subset (which is formally defined in §6.2) because automorphisms preserve the edge relation. (4) Any set 𝑋 can be regarded with the discrete action, 𝜎 • 𝑥 = 𝑥, and then every element has empty support. We regard these sets with the discrete action: 1 = {★}; 2 = {0, 1}; N; and the unit interval [0, 1].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Powersets and Definable Sets</head><p>For any subset 𝑆 ⊆ 𝑋 of a Rado-nominal set, we can define</p><formula xml:id="formula_45">𝜎 • 𝑆 = 𝜎 [𝑆] = {𝜎 • 𝑥 | 𝑥 ∈ 𝑆 }. We let 2 𝑋 = {𝑆 ⊆ 𝑋 | 𝑆 has finite support}. (<label>20</label></formula><formula xml:id="formula_46">)</formula><p>This is a Rado-nominal set.</p><p>Example 34. We give some concrete examples of subsets.</p><p>(1) For vertices 𝑏 and 𝑐 in V with no edge between them, the set {𝑎 ∈ V | 𝐸 (𝑎, 𝑏) ∧ 𝐸 (𝑎, 𝑐)} is the set of ways of forming a horn. It has support {𝑏, 𝑐}.</p><p>(2) {(𝑏, 𝑐) ∈ V 2 | 𝐸 (𝑎, 𝑏) ∧ 𝐸 (𝑎, 𝑐) ∧ ¬𝐸 (𝑏, 𝑐)} is the set of horns with apex 𝑎; it has support {𝑎}.</p><p>(3) {(𝑎, 𝑏, 𝑐) ∈ V 3 | 𝐸 (𝑎, 𝑏) ∧ 𝐸 (𝑎, 𝑐) ∧ ¬𝐸 (𝑏, 𝑐)} is the set of all oriented horns; it has empty support. (4) (Non-example) There is a countable totally disconnected subgraph of V; it does not have finite support as a subset of V.</p><p>In fact, the finitely supported subsets correspond exactly to the definable sets in first-order logic over the theory of graphs. The following results may be folklore.</p><p>Proposition 35. Let 𝑆 ⊆ V 𝑛 , and 𝐴 ⊆ V be finite. The following are equivalent:</p><p>• 𝑆 = {(𝑠 1 , . . . 𝑠 𝑛 ) | 𝜙 (𝑠 1 . . . 𝑠 𝑛 )}, for a first-order formula 𝜙 over the theory of graphs, with parameters in 𝐴; • 𝑆 has support 𝐴.</p><p>Proof. (⇒) For all isomorphisms 𝑓 : V → V that fix 𝐴, and for all elements 𝑎 1 . . . 𝑎 𝑘 ∈ 𝐴 and subsets 𝑆 = {(𝑠 1 , . . . , 𝑠 𝑛 ) | 𝜙 (𝑠 1 . . . 𝑠 𝑛 , 𝑎 1 . . . 𝑎 𝑘 )}, we have 𝜙 (𝑓 (𝑠 1 ) . . . 𝑓 (𝑠 𝑛 ), 𝑎 1 . . . 𝑎 𝑘 ) = 𝜙 (𝑓 (𝑠 1 ) . . . 𝑓 (𝑠 𝑛 ), 𝑓 (𝑎 1 ) . . . 𝑓 (𝑎 𝑘 )).</p><p>Furthermore, 𝜙 is invariant with respect to 𝑓 . Thus, the image 𝑓 (𝑆) ⊆ 𝑆. By a similar argument, we have 𝑓 -1 (𝑆) ⊆ 𝑆, so that 𝑆 ⊆ 𝑓 (𝑆). Thus, 𝑓 (𝑆) = 𝑆 ( <ref type="bibr">[Marker 2002, Prop. 1.3.5]</ref>).</p><p>(⇐) This is a consequence of the Ryll-Nardzewski theorem for the theory of the Rado graph (which can be shown to be 𝜔-categorical by a back-and-forth argument, using the extension property of the Rado graph). But we give here a more direct proof, assuming 𝑛 = 1 for simplicity. Suppose 𝐴 ⊆ V is a finite support for 𝑆. Then, for any 𝑣, 𝑣 ′ ∈ V\𝐴, if 𝑣 and 𝑣 ′ have the same connectivity to 𝐴, then they are either both in or not in 𝑆 since, by the extension property, we can find an automorphism fixing 𝐴 and sending 𝑣 to 𝑣 ′ . The set of vertices with the same connectivity to 𝐴 as 𝑣 is definable, and there are only 2 |𝐴| such sets. Hence, 𝑆\𝐴 is a union of finitely many definable sets, and as 𝑆 ∩ 𝐴 is definable (being finite), so is 𝑆 = (𝑆\𝐴) ∪ (𝑆 ∩ 𝐴). □</p><p>We note that 2 𝑋 in ( <ref type="formula" target="#formula_45">20</ref>) is a canonical notion of internal powerset, from a categorical perspective.</p><p>Proposition 36. RadoNom is a Boolean Grothendieck topos, with powerobject 2 𝑋 in (20).</p><p>Proof notes. RadoNom can be regarded as continuous actions of Aut <ref type="bibr">(Rado)</ref>, regarded as a topological group with the product topology, and then we invoke standard methods <ref type="bibr">[Johnstone 2002, Ex. A2.1.6]</ref>. It is also equivalent to the category of sheaves over finite graphs and embeddings with the atomic topology. See <ref type="bibr" target="#b16">[Caramello 2013</ref><ref type="bibr" target="#b17">[Caramello , 2014] ]</ref> for general discussion. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Probability Measures on Rado-Nominal Sets</head><p>The finitely supported sets 𝑆 ⊆ V can be regarded as 'events' to which we would assign a probability. For example, if we already have vertices 𝑏 and 𝑐, we may want to know the chance of picking a vertex that forms a horn, and this would be the probability of the set in Ex. 34(a).</p><p>Definition 37. A sequence 𝑆 1 , 𝑆 2 • • • ⊆ 𝑋 is said to be support-bounded if there is one finite set 𝐴 ⊆ V that supports all the sets 𝑆 𝑖 .</p><p>A function 𝜇 : 2 𝑋 → [0, 1] is (internally) countably additive if for any support-bounded sequence</p><formula xml:id="formula_47">𝑆 1 , 𝑆 2 • • • ⊆ 𝑋 of disjoint sets, 𝜇 ( ∞ 𝑖=1 𝑆 𝑖 ) = ∞ 𝑖=1 𝜇 (𝑆 𝑖 ).</formula><p>A probability measure on a Rado-nominal set 𝑋 is an equivariant function 𝜇 : 2 𝑋 → [0, 1] that is internally countably additive, such that 𝜇 (𝑋 ) = 1.</p><p>We remark that there are two subtleties here. First, we restrict to support-bounded sequences. These are the correctly internalized notion of sequence in Rado-nominal sets, since they correspond precisely to finitely-supported functions N → 2 𝑋 . Second, we consider a Rado-nominal set to be equipped with its internal powerset 2 𝑋 , rather than considering sub-𝜎-algebras.</p><p>Measures on the space of vertices. We define an internal probability measure (Def. 37) on the space V of vertices, which, we will show, corresponds to the Erdős-Rényi graphon. Fix 𝛼 ∈ [0, 1], the chance of an edge.</p><p>We define the measure 𝜈 𝛼 of a definable set 𝑆 ∈ 2 V as follows. Suppose that 𝑆 has support {𝑎 1 , . . . , 𝑎 𝑛 }. We choose an enumeration of vertices (𝑣 1 , . . . , 𝑣 2 𝑛 ) in V (disjoint from {𝑎 1 , . . . , 𝑎 𝑛 }) that covers all the 2 𝑛 possible edge relationships that a vertex could have with the 𝑎 𝑖 's. (For example, 𝑣 1 has no edges to any 𝑎 𝑖 , and 𝑣 2 𝑛 has an edge to every 𝑎 𝑖 , and the other 𝑣 𝑗 's have the other possible edge relationships.) Let:</p><formula xml:id="formula_48">𝜈 𝛼 (𝑆) = 2 𝑛 ∑︁ 𝑗=1 [𝑣 𝑗 ∈ 𝑆] 𝑛 𝑖=1 𝛼𝐸 (𝑣 𝑗 , 𝑎 𝑖 ) + (1 -𝛼) (1 -𝐸 (𝑣 𝑗 , 𝑎 𝑖 )) . (<label>21</label></formula><formula xml:id="formula_49">)</formula><p>Proposition 38. The assignment given in ( <ref type="formula" target="#formula_48">21</ref>) is an internal probability measure (Def. 37) on V.</p><p>Proof. The function 𝜈 𝛼 is well-defined: it does not depend on the choice of 𝑣 𝑗 's (by Prop. 35), nor on the choice of support (by direct calculation). It is equivariant, since for 𝜎 • 𝑆, a valid enumeration of vertices is given by 𝜎</p><formula xml:id="formula_50">• 𝑣 1 , . . . 𝜎 • 𝑣 2 𝑛 . Also, 𝜈 (V) = 1, since V has empty support. Internal countable additivity follows from the identity 𝑣 𝑗 ∈ ∞ 𝑖=1 𝑆 𝑖 = ∞ 𝑖=1 [𝑣 𝑗 ∈ 𝑆 𝑖 ]. □ Remark.</formula><p>The definitions and results of this section appear to be novel. However, the general idea of considering measures on formulas which are invariant to substitutions that permute the variables goes back to work of Gaifman <ref type="bibr" target="#b35">[Gaifman 1964</ref>]. The paper <ref type="bibr">[Ackerman et al. 2016a</ref>] characterizes those countably infinite graphs that can arise with probability 1 in that framework; see <ref type="bibr">[Ackerman et al. 2017b</ref>] for a discussion of how Gaifman's work connects to Prop. 21.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Nominal Probability Monads</head><p>Since RadoNom is a Boolean topos with natural numbers object (Prop. 36), we can interpret measure-theoretic notions in the internal language of the topos, as long as they do not require the axiom of choice. We now spell out the resulting development, without assuming familiarity with topos theory. By doing this, we build new probability monads on RadoNom.</p><p>6.4.1 Finitely Supported Functions and Measures. Let 𝑋 and 𝑌 be Rado-nominal sets. The set of all functions 𝑋 → 𝑌 has an action of Aut <ref type="bibr">(Rado)</ref>, given by (𝜎 • 𝑓 ) (𝑥) = 𝜎 -1 • (𝑓 (𝜎 • 𝑥)). The function space [𝑋 ⇒ 𝑌 ] comprises those functions that have finite support under this action. Categorically, this structure is uniquely determined by the 'currying' bijection, natural in 𝑍 :</p><p>RadoNom(𝑍 × 𝑋, 𝑌 ) RadoNom(𝑍, 𝑋 ⇒ 𝑌 ).</p><p>(For example, the powerobject 2 𝑋 ( §6.2) can be regarded as [𝑋 ⇒ 2], if we regard a set as its characteristic function.)</p><p>In Def. 37, we focused on equivariant probability measures. We generalize this to finitely supported measures. For example, pick a vertex 𝑎 ∈ V. Then, the Dirac measure on V (i.e. 𝛿 𝑎 (𝑆) = 1 if 𝑎 ∈ 𝑆, and 𝛿 𝑎 (𝑆) = 0 if 𝑎 ∉ 𝑆) has support {𝑎}.</p><p>Definition 39. For a Rado-nominal set 𝑋 , let P (𝑋 ) comprise the finitely supported functions 𝜇 : 2 𝑋 → [0, 1] that are internally countably additive, and satisfy 𝜇 (𝑋 ) = 1. This is a Rado-nominal set, as a subset of [2 𝑋 ⇒ [0, 1]]. Functions in P (𝑋 ) are called finitely supported probability measures. 6.4.2 Internal Integration. We revisit some basic integration theory in this nominal setting. In traditional measure theory, one can define the Lebesgue integral of a measurable function 𝑓 : 𝑋 → [0, 1] by ∫ 𝑓 (𝑥)𝜇 (d𝑥) = sup 𝑛 𝑖=1 𝑟 𝑖 𝜇 (𝑈 𝑖 ) where the supremum ranges over simple functions 𝑖 𝑟 𝑖 [-∈ 𝑈 𝑖 ] with 𝑈 𝑖 measurable in 𝑋 and bounded above by 𝑓 ( §2.3.3). The same construction works in the internal logic of RadoNom.</p><p>Note that the following does not mention 𝑓 being measurable: since 𝑋 is considered to have its internal powerset 𝜎-algebra, finite-supportedness implies 'measurability' here.</p><p>Proposition 40. Let 𝜇 ∈ P (𝑋 ) be a finitely supported probability measure on 𝑋 . For any finitely supported function 𝑓 : 𝑋 → [0, 1], the internally-constructed Lebesgue integral ∫ 𝑓 (𝑥) 𝜇 (d𝑥) ∈ [0, 1] exists. Moreover, integration is an equivariant map</p><formula xml:id="formula_51">∫ : P (𝑋 ) × [𝑋 ⇒ [0, 1]] → [0, 1]</formula><p>which preserves suprema of internally countable monotone sequences in its second argument.</p><p>Proof. If 𝑈 1 , . . . , 𝑈 𝑛 ⊆ 𝑋 are finitely supported, 𝑟 1 , . . . , 𝑟 𝑛 ∈ [0, 1], and 𝑖 𝑟 𝑖 [-∈ 𝑈 𝑖 ] ≤ 𝑓 , then by ordinary additivity of 𝜇, we have 𝑟 𝑖 𝜇 (𝑈 𝑖 ) ∈ [0, 1]. By ordinary real analysis, the supremum of all such values exists and is in [0, 1]. For equivariance, recall that [0, 1] is equipped with the trivial action of Aut <ref type="bibr">(Rado)</ref>. Use the fact that</p><formula xml:id="formula_52">𝑖 𝑟 𝑖 [-∈ 𝑈 𝑖 ] ≤ 𝑓 if and only if 𝑖 𝑟 𝑖 [-∈ 𝜎 • 𝑈 𝑖 ] ≤ 𝜎 • 𝑓 .</formula><p>The last claim is the monotone convergence theorem internalized to RadoNom. □ 6.4.3 Kernels and a Monad. We can regard a 'probability kernel' as a finitely supported function 𝑘 : 𝑋 → P (𝑌 ). Equivalently, 𝑘 is a finitely supported function 𝑘 : 𝑋 × 2 𝑌 → [0, 1] that is countably additive and has mass 1 in its second argument. (In traditional measure theory, one would explicitly ask that 𝑘 is measurable in its first argument, but as we observed, finite-supportedness already implies it.)</p><p>As usual, probability kernels compose, and this allows us to regard them as Kleisli morphisms for a monad (Def. 6), defined as follows.</p><p>Definition 41. We define the strong monad P on RadoNom as follows.</p><p>• For a Rado-nominal set 𝑋 , let P (𝑋 ) comprise the finitely supported probability measures (Def. 39). • The unit of the monad 𝜂 𝑋 : 𝑋 → P (𝑋 ) is the Dirac measure, 𝜂 𝑋 (𝑥) (𝑆) = [𝑥 ∈ 𝑆].</p><p>• The bind (&gt;&gt;=) : P (𝑋 ) × (𝑋 ⇒ P (𝑌 )) → P (𝑌 ) is given by</p><formula xml:id="formula_53">(𝜇 &gt;&gt;= 𝑘) (𝑆) = ∫ 𝑋 𝑘 (𝑥, 𝑆) 𝜇 (d𝑥).</formula><p>We note that this is similar to the 'expectations monad' <ref type="bibr">[Jacobs and Mandemaker 2012, Thm. 4</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.4">Commuting Integrals (Fubini).</head><p>For measures 𝜇 1 ∈ P (𝑋 ) and 𝜇 2 ∈ P (𝑌 ), the monad structure allows us to define a product measure</p><formula xml:id="formula_54">𝜇 1 ⊗ 𝜇 2 = 𝜇 1 &gt;&gt;= (𝜆𝑥 . 𝜇 2 &gt;&gt;= 𝜆𝑦. 𝜂 (𝑥, 𝑦)) ∫ 𝑓 (𝑥, 𝑦) (𝜇 1 ⊗ 𝜇 2 ) (d(𝑥, 𝑦)) = ∫ ∫ 𝑓 (𝑥, 𝑦) 𝜇 2 (d𝑦) 𝜇 1 (d𝑥).<label>(22)</label></formula><p>Although this iterated integration is reminiscent of the traditional approach, in general we cannot reorder integrals ('Fubini does not hold'). For example, given two measures 𝜈 𝛼 and 𝜈 𝛽 for 𝛼 ≠ 𝛽 and 𝑓 being the characteristic function of the set {(𝑥, 𝑦) :</p><formula xml:id="formula_55">𝐸 (𝑥, 𝑦)} ⊆ V 2 , we have ∫ ∫ [𝐸 (𝑥, 𝑦)] 𝜈 𝛼 (d𝑦) 𝜈 𝛽 (d𝑥) = ∫ 𝛼 𝜈 𝛽 (d𝑥) = 𝛼 ≠ 𝛽 = ∫ 𝛽 𝜈 𝛼 (d𝑦) = ∫ ∫ [𝐸 (𝑥, 𝑦)] 𝜈 𝛽 (d𝑥) 𝜈 𝛼 (d𝑦).<label>(23)</label></formula><p>However, it does hold when we consider only copies of the same measure.</p><p>Proposition 42. For 𝜈 𝛼 ∈ P (V) as in ( <ref type="formula" target="#formula_48">21</ref>), 𝜈 𝛼 commutes with 𝜈 𝛼 . That is, for any finitely supported</p><formula xml:id="formula_56">𝑓 : V × V → [0, 1], ∫ ∫ 𝑓 (𝑥, 𝑦) 𝜈 𝛼 (d𝑦) 𝜈 𝛼 (d𝑥) = ∫ ∫ 𝑓 (𝑥, 𝑦) 𝜈 𝛼 (d𝑥) 𝜈 𝛼 (d𝑦).</formula><p>Proof notes. By Prop. 35 and 40, it suffices to check on the indicator functions of definable subsets of V 2 . The indicators of sets {(𝑥, 𝑦) | Φ(𝑥, 𝑦)} where Φ(𝑥, 𝑦) is a disjunction of 𝑥 = 𝑦, 𝑥 = 𝑎, or 𝑦 = 𝑎 for some 𝑎 ∈ V are seen to have integral 0 on both sides. The remaining possibilities can be reduced to the case where Φ 𝐴,𝜙,𝜓,𝜖 (𝑥, 𝑦) is (𝑥, 𝑦 ∉ 𝐴) ∧ (𝑥 ≠ 𝑦) ∧ (𝐸 (𝑥, 𝑦) ↔ 𝜖) ∧ 𝑎∈𝐴 (𝐸 (𝑎, 𝑥) ↔ 𝜙 𝑎 ) ∧ (𝐸 (𝑎, 𝑦) ↔ 𝜓 𝑎 ) where 𝐴 ⊆ V is a finite set, 𝜖 ∈ {⊥, ⊤}, and 𝜙,𝜓 ∈ {⊥, ⊤} 𝐴 . This formula corresponds to choosing a two-vertex extension of the finite graph spanned by 𝐴 ⊆ V. Intuitively, the two double integrals correspond to the two alternative two-step computations of the conditional probability of extending the graph 𝐴 to this extension according to which of the two vertices is sampled first, and indeed both evaluate to 𝛼 𝑘 (1 -𝛼) 2|𝐴|+1-𝑘 where 𝑘 = [𝜖] + 𝑎∈𝐴 ( [𝜙 𝑎 ] + [𝜓 𝑎 ]). □ Remark. In traditional measure theory, iterated integrals are defined using product 𝜎-algebras.</p><p>Here we have not constructed product 𝜎-algebras, but rather always take the internal powerset as the 𝜎-algebra. This allows us to view all the definable sets as measurable on V 𝑛 (Prop. 35), which is very useful. We remark that alternative product spaces also arise in non-standard approaches to graphons (see <ref type="bibr">[Tao 2013, §6]</ref> for an overview), and also in quasi-Borel spaces <ref type="bibr" target="#b40">[Heunen et al. 2017]</ref> for different reasons.</p><p>6.4.5 A Commutative Monad. We now use Prop. 42 to build a commutative affine submonad P 𝛼 of the monad P, which we will use to model the graph interface for the probabilistic programming language. With Prop. 36, we use the following general result. Proposition 43. Let T be a strong monad on a Grothendieck topos. Consider a family of morphisms {𝑓 𝑖 : 𝑋 𝑖 → T (𝑌 𝑖 )} 𝑖 ∈𝐼 .</p><p>• There is a least strong submonad T 𝑓 ⊆ T through which all 𝑓 𝑖 factor.</p><p>• If the morphisms 𝑓 𝑖 all commute with each other, then T 𝑓 is a commutative monad (Def. 7).</p><p>Proof notes. Our argument is close to <ref type="bibr">[Kammar and McDermott 2018, §2.3]</ref> and also <ref type="bibr">[Kammar 2014, Thms. 7.5 &amp; 12.8]</ref>.</p><p>We let T 𝑓 be the least subfunctor of T that contains the images of the 𝑓 𝑖 's and 𝜂, and is closed under the image of monadic bind (&gt;&gt;=). To show that this exists, we proceed as follows. First, fix a regular cardinal 𝜆 &gt; 𝐼 such that 𝑌 𝑖 's are all 𝜆-presentable, such that the topos is locally 𝜆-presentable (e.g. <ref type="bibr" target="#b7">[Adámek and Rosický 1994]</ref>). Consider the poset Sub 𝜆 (T ) of 𝜆-accessible subfunctors of T . The cardinality bound 𝜆 ensures it is small. Ordered by pointwise inclusion, this is a complete lattice: the non-empty meets are immediate, and the empty meet requires us to consider the 𝜆-accessible coreflection of T . We defined T 𝑓 by a monotone property which we can regard as a monotone operator on this complete lattice Sub 𝜆 (T ), and so the least 𝜆-accessible subfunctor exists. This is T 𝑓 . Concretely, it is a least upper bound of an ordinal indexed chain. The chain starts with the functor 𝐹 0 (𝑍 ) = 𝑖 ∈𝐼,𝑔:𝑌 𝑖 →𝑍 image(T (𝑔) • 𝑓 𝑖 ) ⊆ T (𝑍 ) which is 𝜆-accessible because the 𝑌 𝑖 's are 𝜆-presentable. The chain iteratively closes under the image of monadic bind, until we reach a subfunctor that is a submonad of T .</p><p>To see that T 𝑓 is commutative, we appeal to (transfinite) induction. Say that a subfunctor 𝐹 of T is commutative if all morphisms that factor through 𝐹 commute (Def. 7), and then note that the property of being commutative is preserved along the ordinal indexed chain. □</p><p>With this in mind, fixing a measure 𝜈 𝛼 as in ( <ref type="formula" target="#formula_48">21</ref>), we form the least submonad P 𝛼 of P induced by the morphisms 𝜈 𝛼 : 1 → P (V) bernoulli : [0, 1] → P (2) (24) where bernoulli(𝑟 ) = 𝑟 • 𝜂 (0) + (1 -𝑟 ) • 𝜂 (1).</p><p>Corollary 44. The least submonad P 𝛼 of the probability monad P induced by the morphisms in (24) is a commutative affine monad (Def. 7).</p><p>Proof notes. It is easy to show that bernoulli commutes with every morphism 𝑋 → P (𝑌 ). Moreover, 𝜈 𝛼 commutes with itself (Prop. 42). Finally, P 𝛼 is affine since P is. □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Summary and Interpretation</head><p>Fix 𝛼 ∈ [0, 1]. We induce an internal measure 𝜈 𝛼 on the vertices of the Rado graph as explained in (21); and build a commutative submonad P 𝛼 of P. We can then interpret the graph probabilistic programming language. We interpret types as Rado-nominal sets:</p><formula xml:id="formula_57">bool = 2 vertex = V unit = 1 𝐴 1 * 𝐴 2 = 𝐴 1 × 𝐴 2 . (<label>25</label></formula><formula xml:id="formula_58">)</formula><p>We interpret typed programs Γ ⊢ 𝑡 : 𝐴 as Kleisli morphisms Γ → P 𝛼 ( 𝐴 )</p><p>i.e. internal probability kernels Γ × 2 𝐴 → [0, 1]. Sequencing (let) is interpreted using the monad structure, with new : 1 → P 𝛼 (V) and edge : V × V → P 𝛼 (2) as new() = 𝜈 𝛼 edge (𝑣, 𝑤) = 𝜂 (𝐸 (𝑣, 𝑤))</p><p>Corollary 45. Consider the interpretation in Rado-nominal sets (( <ref type="formula" target="#formula_57">25</ref>)-( <ref type="formula" target="#formula_59">26</ref>)). If we form the sequence of random graphs in (18), then these correspond to the Erdős-Rényi graphon.</p><p>Proof notes. The semantics interprets ground types as finite sets with discrete Aut <ref type="bibr">(Rado)</ref> action -in which case internal probability kernels correspond to stochastic matrices, agreeing with FinStoch. Thus, the theory is Bernoulli-based. To see that the graphon arises, consider for instance when 𝑛 = 2, we have: for 𝑡 2 as in (18), and therefore 𝑡 2 = 𝛿 0 , bernoulli(𝛼) bernoulli(𝛼), 𝛿 0 : P (2 4 )</p><p>For general 𝑛, this corresponds to the random graph model 𝑝 𝑊 𝛼 ,𝑛 for the Erdős-Rényi graphon 𝑊 𝛼 . □</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>Summary. We have shown that equational theories for the graph interface to the probabilistic programming language (Ex. 1) give rise to graphons (Theorem 23). Conversely, every graphon arises in this way. We showed this generally using an abstract construction based on Markov categories (Corollary 26) and methods from category theory <ref type="bibr" target="#b39">[Hermida and Tennent 2012;</ref><ref type="bibr" target="#b41">Hu and Tholen 1995]</ref>. Since this is an abstract method, we also considered two concrete styles of semantic interpretation that give rise to classes of graphons: traditional measure-theoretic interpretations give rise to black-and-white graphons (Prop. 28), and an interpretation using the internal probability theory of Rado-nominal sets gives rise to Erdős-Rényi graphons (Corollary 45).</p><p>Further context, and future work. The idea of studying exchangeable structures through program equations is perhaps first discussed in the abstract <ref type="bibr" target="#b77">[Staton et al. 2017</ref>], whose §3.2 ends with an open question about semantics of languages with graphs that the present paper addresses. Subsequent work addressed the simpler setting of exchangeable sequences and beta-bernoulli conjugacy through program equations <ref type="bibr" target="#b76">[Staton et al. 2018]</ref>, and stochastic memoization <ref type="bibr" target="#b52">[Kaddar and Staton 2023]</ref>; the latter uses a category similar to RadoNom, although the monad is different. Beyond sequences <ref type="bibr" target="#b76">[Staton et al. 2018</ref>] and graphs (this paper), a natural question is how to generalize to arbitrary exchangeable interfaces (see e.g. <ref type="bibr" target="#b68">[Orbanz and Roy 2015]</ref>). For example, we could consider exchangeable random boolean arrays via the interface new-row : unit → row, new-column() : unit → column, entry : row * column → bool and random hypergraphs with the interface new : unit → vertex, hyperedge 𝑛 : vertex 𝑛 → bool.</p><p>We could also consider interfaces for hierarchical structures, such as arrays where every entry contains a graph. Diverse exchangeable random structures have been considered from the modeltheoretic viewpoint <ref type="bibr" target="#b0">[Ackerman 2015;</ref><ref type="bibr" target="#b21">Crane and Towsner 2018]</ref> and from the perspective of probability theory (e.g. <ref type="bibr" target="#b15">[Campbell et al. 2023;</ref><ref type="bibr" target="#b51">Jung et al. 2021;</ref><ref type="bibr" target="#b53">Kallenberg 2010]</ref>), but it remains to be seen whether the programming perspective here can provide a unifying view. Another point is that graphons correspond to dense graphs, and so a question is how to accommodate sparse graphs from a programming perspective (e.g. <ref type="bibr" target="#b19">[Caron and Fox 2017;</ref><ref type="bibr" target="#b82">Veitch and Roy 2019]</ref>).</p><p>This paper has focused on a very simple programming language ( §2.1). As mentioned in Section 1.5, several implementations of probabilistic programming languages do support various Bayesian nonparametric primitives based on exchangeable sequences, partitions, and relations (e.g. <ref type="bibr" target="#b24">[Dash et al. 2023;</ref><ref type="bibr" target="#b37">Goodman et al. 2008;</ref><ref type="bibr" target="#b56">Kiselyov and Shan 2010;</ref><ref type="bibr" target="#b64">Mansinghka et al. 2014;</ref><ref type="bibr" target="#b74">Roy et al. 2008;</ref><ref type="bibr" target="#b84">Wood et al. 2014]</ref>). In particular, the 'exchangeable random primitive' (XRP) interface <ref type="bibr">[Ackerman et al. 2016b;</ref><ref type="bibr" target="#b85">Wu 2013</ref>] provides a built-in abstract data type for representing exchangeable sequences. This aids model design by its abstraction, but also aids inference performance by clarifying the independence relationships.</p><p>Aside from practical inference performance, we can ask whether representation and inference are computable. For the simpler setting of exchangeable sequences, this is dealt with positively by <ref type="bibr">[Freer and</ref><ref type="bibr">Roy 2010, 2012]</ref>. The question of computability for graphons and exchangeable graphs is considerably subtler, and some standard representations are noncomputable <ref type="bibr" target="#b4">[Ackerman et al. 2019</ref>] (see also <ref type="bibr">[Ackerman et al. 2017a]</ref>). This suggests several natural questions about whether certain natural classes of computable exchangeable graphs can be identified by program analyses in the present context.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><figDesc>For a simple example, we can write a program over the interface to calculate the probability of three random vertices forming a triangle: the program let 𝑎 = new() in let 𝑏 = new() in let 𝑐 = new() in edge(𝑎, 𝑏) &amp; edge(𝑏, 𝑐) &amp; edge(𝑎, 𝑐) : bool (5)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. (a) A graph; (b) an inferred geometric realization of it (𝜃 ≈ 𝜋/3); (c) a generated sample for 𝜃 = 𝜋/6.</figDesc><graphic coords="3,120.32,43.14,261.75,186.75" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><figDesc>]. (Similar examples are implemented in[Goodman and Tenenbaum 2023, Ch. 12], albeit untyped.) Then our interface is captured by a Haskell type class: 1 class RandomGraph p vertex | p → vertex where new :: p → Prob vertex edge :: p → vertex → vertex → Bool Here p is a parameter type, and we write Prob for a probability monad. A spherical implementation of the interface (following §1.1) is parameterized by the dimension 𝑑 and the distance 𝜃 , as follows: data SphGrph = SG Int Double --parameters for a sphere graph data SphVertex = SV [ Double ] --vertices are Euclidean coordinates instance RandomGraph SphGrph SphVertex where new :: SphGrph → Prob SphVertex new ( SG d theta ) = ... --sample a random unit d -vector uniformly edge :: SphGrph → SphVertex → SphVertex → Bool edge ( SG d theta ) v w = ... --check whether arccos (v.w) &lt; theta</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><figDesc>and although our equivalence relation is slightly coarser, it still respects the symmetric monoidal category structure, and there is a monoidal functor Fam(G op ) → Fam(G op ) [𝜈], regarding each morphism 𝑓 : ì 𝑋 → ì 𝑌 in Fam(G op ) as a morphism [0, 𝑓 ] in Fam(G op ) [𝜈]. But there is also now an adjoined morphism 𝜈 = [1, id] : 1 → vertex . This monoidal category Fam(G op ) [𝜈] moreover inherits the distributive coproduct structure from Fam(G op ), and the functor Fam(G op ) → Fam(G op ) [𝜈] is a distributive Markov functor. To define copairing of [𝑘, 𝑓 ] : ì 𝑋 → ì 𝑍 and [𝑙, 𝑔] : ì 𝑌 → ì 𝑍 we use the reindexing equivalence relation to assume 𝑘 = 𝑙 and then define the copairing as ⟨[𝑘, 𝑓 ], [𝑘, 𝑔]⟩ = [𝑘, ⟨𝑓 , 𝑔⟩] : ì 𝑋 + ì 𝑌 → ì 𝑍 . In summary:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><figDesc>].) Definition 31. A Rado-nominal set is a set 𝑋 equipped with an action • : Aut(Rado) × 𝑋 → 𝑋 (i.e. id • 𝑥 = 𝑥; (𝜎 2 • 𝜎 1 ) • 𝑥 = 𝜎 2 • 𝜎 1 • 𝑥) such that every element has finite support.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><figDesc>𝑥 1 , 𝑥 1 )], [𝐸 (𝑥 1 , 𝑥 2 )] [𝐸 (𝑥 2 , 𝑥 1 )], [𝐸 (𝑥 2 , 𝑥 2 )] (𝜈 𝛼 ⊗ 𝜈 𝛼 ) (d(𝑥 1 , 𝑥 2 ))</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>See https://lazyppl-team.github.io/GraphDemo.html for full details in literate Haskell.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>𝐴, 𝐴 1 , 𝐴 2 , 𝐵 ::= unit | 0 | 𝐴 1 * 𝐴 2 | 𝐴 1 + 𝐴 2 | . . . and terms, including the typical constructors and destructors but also explicit sequencing (let in)𝑡, 𝑡 1 , 𝑡 2 , 𝑢 ::= 𝑥 | () | (𝑡 1 , 𝑡 2 ) | 𝜋 1 𝑡 | 𝜋 2 𝑡 | in 1 𝑡 | in 2 𝑡 | let 𝑥 = 𝑡 1 in 𝑡 2 | case 𝑡 of {} | case 𝑡 of {in 1 (𝑥 1 ) ⇒ 𝑢 1 ; in 2 (𝑥 2 ) ⇒ 𝑢 2 } | . . .We consider the standard typing rules (where 𝑖 ∈ {1, 2}):Γ, 𝑥 : 𝐴, Γ ′ ⊢ 𝑥 : 𝐴 Γ ⊢ () : unit Γ ⊢ 𝑡 1 : 𝐴 1 Γ ⊢ 𝑡 2 : 𝐴 2 Γ ⊢ (𝑡 1 , 𝑡 2 ) : 𝐴 1 * 𝐴 2 Γ ⊢ 𝑡 : 𝐴 1 * 𝐴 2 Γ ⊢ 𝜋 𝑖 𝑡 : 𝐴 𝑖 Γ ⊢ 𝑡 : 𝐴 𝑖 Γ ⊢ in 𝑖 𝑡 : 𝐴 1 + 𝐴 2 Γ ⊢ 𝑡 : 𝐴 Γ, 𝑥 : 𝐴 ⊢ 𝑢 : 𝐵 Γ ⊢ let 𝑥 = 𝑡 in 𝑢 : 𝐵</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Γ → 𝐴 . (See e.g.<ref type="bibr" target="#b71">[Pitts 2001</ref>] for a general discussion of terms as morphisms.)In more detail, to give such an interpretation, type constants must first be given chosen interpretations as objects of C. We can then interpret types and contexts using the monoidal and coproduct structure of C. Following this, term constants 𝑓 : 𝐴 → 𝐵 must be given chosen interpretations as morphisms 𝑓 : 𝐴 → 𝐵 in C. The interpretation of other terms is made by induction on the structure of typing derivations in a standard manner, using the structure of the distributive Markov category (e.g.<ref type="bibr" target="#b11">[Benton et al. 1992</ref>],[Stein 2021,  §7.2]). For example,Γ, 𝑥 : 𝐴, Γ ′ ⊢ 𝑥 : 𝐴 = Γ, 𝑥 : 𝐴, Γ ′ Γ ⊗ 𝐴 ⊗ Γ ′ !⊗ 𝐴 ⊗! ------→ 1 ⊗ 𝐴 ⊗ 1 𝐴 Γ ⊢ let 𝑥 = 𝑡 in 𝑢 : 𝐵 = Γ Δ Γ ---→ Γ ⊗ Γ Γ ⊗ 𝑡 ------→ Γ ⊗ 𝐴 = Γ, 𝑥 : 𝐴 𝑢 --→ 𝐵Γ ⊢ case 𝑡 of {in 1 (𝑥 1 ) ⇒ 𝑢 1 ; in 2 (𝑥 2 ) ⇒ 𝑢 2 } : 𝐵 =</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This material is based on work supported by a <rs type="funder">Royal Society University Research Fellowship</rs>, <rs type="funder">ERC</rs> Project <rs type="projectName">BLAST</rs> and <rs type="funder">AFOSR</rs> Award No. <rs type="grantNumber">FA9550-21-1-003</rs>. This work was supported in part by <rs type="funder">CoCoSys</rs>, one of seven centers in JUMP 2.0, a <rs type="institution">Semiconductor Research Corporation (SRC)</rs> program sponsored by <rs type="funder">DARPA</rs>. HY was supported by the <rs type="funder">National Research Foundation of Korea (NRF)</rs> grant funded by the <rs type="funder">Korea government (MSIT)</rs> (No. <rs type="grantNumber">RS-2023-00279680</rs>), and also by the <rs type="programName">Engineering Research Center Program</rs> through the <rs type="funder">National Research Foundation of Korea (NRF)</rs> grant funded by the <rs type="funder">Korean government (MSIT)</rs> (No. <rs type="grantNumber">NRF-2018R1A5A1059921</rs>).</p><p>It has been helpful to discuss developments in this work with many people over the years, and we are also grateful to our anonymous reviewers for helpful suggestions.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_GfBQgTw">
					<orgName type="project" subtype="full">BLAST</orgName>
				</org>
				<org type="funding" xml:id="_ckBZgzt">
					<idno type="grant-number">FA9550-21-1-003</idno>
				</org>
				<org type="funding" xml:id="_35zU3NQ">
					<idno type="grant-number">RS-2023-00279680</idno>
					<orgName type="program" subtype="full">Engineering Research Center Program</orgName>
				</org>
				<org type="funding" xml:id="_BQbAS84">
					<idno type="grant-number">NRF-2018R1A5A1059921</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">Nathanael</forename><surname>Ackerman</surname></persName>
		</author>
		<idno>1509.06170</idno>
		<title level="m">Representations of Aut(M)-Invariant Measures</title>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv e-print</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Nathanael</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cameron</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Kruckman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rehana</forename><surname>Patel</surname></persName>
		</author>
		<idno>1710.09336</idno>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
	<note type="report_type">Properly ergodic structures. arXiv e-print</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Nathanael</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cameron</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rehana</forename><surname>Patel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Forum Math. Sigma</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">17</biblScope>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
	<note>Invariant measures concentrated on countable structures</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName><forename type="first">Nathanael</forename><forename type="middle">L</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Avigad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cameron</forename><forename type="middle">E</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><forename type="middle">M</forename><surname>Rute</surname></persName>
		</author>
		<ptr target="https://pps2017.luddy.indiana.edu/files/2016/12/compAH.pdf" />
		<title level="m">On computable representations of exchangeable data. Workshop on Probabilistic Programming Semantics</title>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Algorithmic barriers to representing conditional independence</title>
		<author>
			<persName><forename type="first">Nathanael</forename><forename type="middle">L</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Avigad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cameron</forename><forename type="middle">E</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jason</forename><forename type="middle">M</forename><surname>Rute</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 34th ACM/IEEE Symp. Logic in Comp. Sci. (LICS</title>
		<meeting>34th ACM/IEEE Symp. Logic in Comp. Sci. (LICS</meeting>
		<imprint>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">Nathanael</forename><forename type="middle">L</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cameron</forename><forename type="middle">E</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<ptr target="http://pps2016.luddy.indiana.edu/files/2015/12/xrp.pdf" />
		<title level="m">Exchangeable Random Primitives. Workshop on Probabilistic Programming Semantics (PPS 2016)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Die Widerspruchsfreiheit der allgemeinen Mengenlehre</title>
		<author>
			<persName><forename type="first">Wilhelm</forename><surname>Ackermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Ann</title>
		<imprint>
			<biblScope unit="volume">114</biblScope>
			<biblScope unit="page" from="305" to="315" />
			<date type="published" when="1937">1937. 1937</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Adámek</surname></persName>
		</author>
		<author>
			<persName><surname>Rosický</surname></persName>
		</author>
		<title level="m">Locally presentable and accessible categories</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Universal Properties of Partial Quantum Maps</title>
		<author>
			<persName><forename type="first">Pablo</forename><surname>Andrés-Martínez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chris</forename><surname>Heunen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robin</forename><surname>Kaarsgaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc QPL 2022</title>
		<meeting>QPL 2022</meeting>
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Random orderings and unique ergodicity of automorphism groups</title>
		<author>
			<persName><forename type="first">Omer</forename><surname>Angel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">S</forename><surname>Kechris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Russell</forename><surname>Lyons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Eur. Math. Soc. (JEMS)</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="2059" to="2095" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Higher-Order Language for Markov Kernels and Linear Operators</title>
		<author>
			<persName><forename type="first">Pedro Henrique Azevedo De</forename><surname>Amorim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FOSSACS 2023</title>
		<meeting>FOSSACS 2023</meeting>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Linear 𝜆-calculus and categorical models revisited</title>
		<author>
			<persName><forename type="first">Nick</forename><surname>Benton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gavin</forename><surname>Bierman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valeria</forename><surname>De Paiva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Hyland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CSL</title>
		<meeting>CSL</meeting>
		<imprint>
			<date type="published" when="1992">1992. 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automata theory in nominal sets</title>
		<author>
			<persName><forename type="first">Mikołaj</forename><surname>Bojańczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bartek</forename><surname>Klin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sławomir</forename><surname>Lasota</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Towards model theory with data values</title>
		<author>
			<persName><forename type="first">M</forename><surname>Bojańczyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Place</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Graphs and Networks</title>
		<editor>
			<persName><forename type="first">Stefan</forename><surname>Bornholdt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Georg</forename><surname>Hans</surname></persName>
		</editor>
		<editor>
			<persName><surname>Schuster</surname></persName>
		</editor>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="2002">2012. 2002</date>
		</imprint>
	</monogr>
	<note>Proc. ICALP 2012</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Testing for high-dimensional geometry in random graphs</title>
		<author>
			<persName><forename type="first">Sébastien</forename><surname>Bubeck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jian</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ronen</forename><surname>Eldan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miklós</forename><forename type="middle">Z</forename><surname>Rácz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Random Structures &amp; Algorithms</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="503" to="532" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Trevor</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Saifuddin</forename><surname>Syed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chiao-Yu</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tamara</forename><surname>Broderick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Local exchangeability. Bernoulli</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="2084" to="2100" />
			<date type="published" when="2023">2023. 2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<author>
			<persName><forename type="first">Olivia</forename><surname>Caramello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topological Galois Theory</title>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page">291</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fraïssé&apos;s Construction from a Topos-Theoretic Perspective</title>
		<author>
			<persName><forename type="first">Olivia</forename><surname>Caramello</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logica Universalis</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="261" to="281" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Introduction to extensive and distributive categories</title>
		<author>
			<persName><forename type="first">Aurelio</forename><surname>Carboni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephen</forename><surname>Lack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R F C</forename><surname>Walters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Pure Appl. Algebra</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="145" to="158" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Sparse Graphs Using Exchangeable Random Measures</title>
		<author>
			<persName><forename type="first">François</forename><surname>Caron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emily</forename><forename type="middle">B</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Statistical Society Series B: Statistical Methodology</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="issue">09</biblScope>
			<biblScope unit="page" from="1295" to="1366" />
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Introduction to distributive categories</title>
		<author>
			<persName><forename type="first">J R B</forename><surname>Cockett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Struct. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="277" to="307" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Relatively exchangeable structures</title>
		<author>
			<persName><forename type="first">Harry</forename><surname>Crane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henry</forename><surname>Towsner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="416" to="442" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Categorical Foundations of Gradient-Based Learning</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">H</forename><surname>Geoffrey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bruno</forename><surname>Cruttwell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neil</forename><surname>Gavranović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Ghani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabio</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName><surname>Zanasi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESOP 2021</title>
		<meeting>ESOP 2021</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Layer by layer: composing monads</title>
		<author>
			<persName><forename type="first">Fredrik</forename><surname>Dahlqvist</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Louis</forename><surname>Parlant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alexandra</forename><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICTAC</title>
		<meeting>ICTAC</meeting>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Affine monads and lazy structures for Bayesian programming</title>
		<author>
			<persName><forename type="first">S</forename><surname>Dash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kaddar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Paquet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL 2023</title>
		<meeting>POPL 2023</meeting>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Measurable cones and stable, measurable functions: a model for probabilistic higher-order programming</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ehrhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michele</forename><surname>Pagani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christine</forename><surname>Tasson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM Program. Lang</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">28</biblScope>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Probabilistic call by push value</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Ehrhard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christine</forename><surname>Tasson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logical Methods in Computer Science</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On Random Graphs I</title>
		<author>
			<persName><forename type="first">P</forename><surname>Erdős</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rényi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Publicationes Mathematicae Debrecen</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">290</biblScope>
			<date type="published" when="1959">1959. 1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Mathematical models of computational and combinatorial structures</title>
		<author>
			<persName><forename type="first">M P</forename><surname>Fiore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FOSSACS</title>
		<meeting>FOSSACS</meeting>
		<imprint>
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Backprop as Functor: A Compositional Perspective on Supervised Learning</title>
		<author>
			<persName><forename type="first">Brendan</forename><surname>Fong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Spivak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rémy</forename><surname>Tuyéras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual ACM/IEEE Symposium on Logic in Computer Science</title>
		<title level="s">LICS &apos;19</title>
		<meeting>the 34th Annual ACM/IEEE Symposium on Logic in Computer Science<address><addrLine>Vancouver, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Posterior distributions are computable from predictive distributions</title>
		<author>
			<persName><forename type="first">Cameron</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 13th Int. Conf. Artificial Intelligence and Statistics</title>
		<meeting>13th Int. Conf. Artificial Intelligence and Statistics</meeting>
		<imprint>
			<publisher>AISTATS</publisher>
			<date type="published" when="2010">2010. 2010</date>
			<biblScope unit="page" from="233" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Computable de Finetti measures</title>
		<author>
			<persName><forename type="first">Cameron</forename><forename type="middle">E</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Pure and Applied Logic</title>
		<imprint>
			<biblScope unit="volume">163</biblScope>
			<biblScope unit="page" from="530" to="546" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A synthetic approach to Markov kernels, conditional independence and theorems on sufficient statistics</title>
		<author>
			<persName><forename type="first">T</forename><surname>Fritz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Math</title>
		<imprint>
			<biblScope unit="volume">370</biblScope>
			<date type="published" when="2020">2020. 2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabio</forename><surname>Gadducci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Perrone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Davide</forename><surname>Trotta</surname></persName>
		</author>
		<idno>2303.14049</idno>
		<title level="m">Weakly affine monads</title>
		<imprint>
			<date type="published" when="2023">2023. 2023</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv e-print</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A New Approach to Abstract Syntax Involving Binders</title>
		<author>
			<persName><forename type="first">Murdoch</forename><surname>Gabbay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">M</forename><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LICS 1999</title>
		<meeting>LICS 1999</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="214" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Concerning measures in first order calculi</title>
		<author>
			<persName><forename type="first">Haim</forename><surname>Gaifman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Israel J. Math</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1" to="18" />
			<date type="published" when="1964">1964. 1964</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A categorical approach to probability theory</title>
		<author>
			<persName><forename type="first">Michèle</forename><surname>Giry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Categorical aspects of topology and analysis</title>
		<title level="s">Lecture Notes in Math.</title>
		<imprint>
			<date type="published" when="1980">1980</date>
			<biblScope unit="volume">915</biblScope>
			<biblScope unit="page" from="68" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Church: A universal language for generative models</title>
		<author>
			<persName><forename type="first">Noah</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vikash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Mansinghka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Keith</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">B</forename><surname>Bonawitz</surname></persName>
		</author>
		<author>
			<persName><surname>Tenenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 24th Conf. Uncertainty in Artificial Intelligence (UAI 2008)</title>
		<meeting>24th Conf. Uncertainty in Artificial Intelligence (UAI 2008)</meeting>
		<imprint>
			<publisher>AUAI Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="220" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">D</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
		<idno>arXiv e-print 2106.16190</idno>
		<ptr target="http://v1.probmods.org" />
		<title level="m">Jean Goubault-Larrecq, Xiaodong Jia, and Clément Théron. 2021. A Domain-Theoretic Approach to Statistical Programming Languages</title>
		<imprint>
			<date type="published" when="2021">2023. 2021</date>
		</imprint>
	</monogr>
	<note>Probabilistic Models of Cognition</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Monoidal indeterminates and categories of possible worlds</title>
		<author>
			<persName><forename type="first">Claudio</forename><surname>Hermida</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Tennent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="page">430</biblScope>
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A convenient category for higher-order probability theory</title>
		<author>
			<persName><forename type="first">Chris</forename><surname>Heunen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ohad</forename><surname>Kammar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongseok</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LICS</title>
		<meeting>LICS</meeting>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Limits in free coproduct completions</title>
		<author>
			<persName><forename type="first">Hongde</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Walter</forename><surname>Tholen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Pure and Applied Algebra</title>
		<imprint>
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="277" to="291" />
			<date type="published" when="1995">1995. 1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Universal Properties in Quantum Theory</title>
		<author>
			<persName><forename type="first">Mathieu</forename><surname>Huot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. QPL</title>
		<meeting>QPL</meeting>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Semantics of weakening and contraction</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Pure &amp; Appl. Logic</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="page" from="73" to="106" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Introduction to coalgebra: Towards mathematics of states and observations</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CUP</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">From probability monads to commutative effectuses</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Log. Algebr. Methods Program</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="page" from="200" to="237" />
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">The Expectation Monad in Quantum Foundations</title>
		<author>
			<persName><forename type="first">Bart</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jorik</forename><surname>Mandemaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 8th International Workshop on Quantum Physics and Logic</title>
		<title level="s">Electronic Proceedings in Theoretical Computer Science</title>
		<meeting>8th International Workshop on Quantum Physics and Logic</meeting>
		<imprint>
			<publisher>Open Publishing Association</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="143" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Graphons, cut norm and distance, couplings and rearrangements</title>
		<author>
			<persName><forename type="first">Svante</forename><surname>Janson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New York Journal of Mathematics Monographs</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Tail recursion through universal invariants</title>
		<author>
			<persName><forename type="first">Jay</forename><surname>Barry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoret. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="151" to="189" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Commutative Monads for Probabilistic Programming Languages</title>
		<author>
			<persName><forename type="first">Xiaodong</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bert</forename><surname>Lindenhovius</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">W</forename><surname>Mislove</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vladimir</forename><surname>Zamdzhiev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">36th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2021</title>
		<meeting><address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2021-06-29">2021. June 29 -July 2, 2021</date>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<author>
			<persName><forename type="first">T</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName><surname>Johnstone</surname></persName>
		</author>
		<title level="m">Sketches of an Elephant -A Topos Theory Compendium</title>
		<imprint>
			<publisher>OUP</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">A generalization of hierarchical exchangeability on trees to directed acyclic graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Staton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annales Henri Lebesgue</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2021">2021. 2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A model of stochastic memoization and name generation in probabilistic programming: categorical semantics via monads on presheaf categories</title>
		<author>
			<persName><forename type="first">Younesse</forename><surname>Kaddar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MFPS 2023</title>
		<meeting>MFPS 2023</meeting>
		<imprint>
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<author>
			<persName><forename type="first">Olav</forename><surname>Kallenberg</surname></persName>
		</author>
		<title level="m">Foundations of Modern Probability</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Factorisation Systems for Logical Relations and Monadic Lifting in Type-andeffect System Semantics</title>
		<author>
			<persName><forename type="first">Ohad</forename><surname>Kammar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MFPS 2018</title>
		<meeting>MFPS 2018</meeting>
		<imprint>
			<date type="published" when="2014">2014. 2018</date>
			<biblScope unit="page" from="239" to="260" />
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh. Ohad Kammar and Dylan McDermott</orgName>
		</respStmt>
	</monogr>
	<note>Ph. D. Dissertation An algebraic theory of type-and-effect systems</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Fraïssé limits, Ramsey theory, and topological dynamics of automorphism groups</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">S</forename><surname>Kechris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">G</forename><surname>Pestov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Todorčević</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Geom. Funct. Anal</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="106" to="189" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Probabilistic programming using first-class stores and first-class continuations</title>
		<author>
			<persName><forename type="first">Oleg</forename><surname>Kiselyov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chung-Chieh</forename><surname>Shan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 2010 ACM SIGPLAN Workshop on ML</title>
		<meeting>2010 ACM SIGPLAN Workshop on ML</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Homomorphism Problems for First-Order Definable Structures</title>
		<author>
			<persName><forename type="first">Sławomir</forename><surname>Bartek Klin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joanna</forename><surname>Lasota</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Szymon</forename><surname>Ochremiak</surname></persName>
		</author>
		<author>
			<persName><surname>Toruńczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FSTTCS</title>
		<meeting>FSTTCS</meeting>
		<imprint>
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Monads on symmetric monoidal closed categories</title>
		<author>
			<persName><forename type="first">Anders</forename><surname>Kock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Arch. Math</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="1970">1970. 1970</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Commutative monads as a theory of distributions</title>
		<author>
			<persName><forename type="first">Anders</forename><surname>Kock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Appl. Categ</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="97" to="131" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Semantics of probabilistic programs</title>
		<author>
			<persName><forename type="first">Dexter</forename><surname>Kozen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. System Sci</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="328" to="350" />
			<date type="published" when="1981">1981. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">H</forename><surname>Lindner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Affine parts of monads. Arch. Math.</title>
		<imprint>
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Providence, RI. xiv+475 pages. László Lovász and Balázs Szegedy</title>
		<author>
			<persName><forename type="first">László</forename><surname>Lovász</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Combinatorial Theory, Series B</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="933" to="957" />
			<date type="published" when="2006">2012. 2006. 2006</date>
			<publisher>Amer. Math. Soc</publisher>
		</imprint>
	</monogr>
	<note>Large networks and graph limits Limits of dense graph sequences</note>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<author>
			<persName><forename type="first">Saunders</forename><surname>Mac</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lane</forename></persName>
		</author>
		<title level="m">Categories for the Working Mathematician</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Venture: a higher-order probabilistic programming platform with programmable inference</title>
		<author>
			<persName><forename type="first">Vikash</forename><surname>Mansinghka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Selsam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yura</forename><surname>Perov</surname></persName>
		</author>
		<idno>1404.0099</idno>
		<imprint>
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv e-print</note>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Model Theory : An Introduction</title>
		<author>
			<persName><forename type="first">David</forename><surname>Marker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer Science &amp; Business Media</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Concrete categories and higher-order recursion: With applications including probability, differentiability, and full abstraction</title>
		<author>
			<persName><forename type="first">Cristina</forename><surname>Matache</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sean</forename><forename type="middle">K</forename><surname>Moss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LICS &apos;22: 37th Annual ACM/IEEE Symposium on Logic in Computer Science</title>
		<editor>
			<persName><forename type="first">Christel</forename><surname>Baier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dana</forename><surname>Fisman</surname></persName>
		</editor>
		<meeting><address><addrLine>Haifa, Israel</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2022-08-02">2022. August 2 -5, 2022</date>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Computational Lambda-Calculus and Monads</title>
		<author>
			<persName><forename type="first">E</forename><surname>Moggi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth Annual Symposium on Logic in Computer Science</title>
		<meeting>the Fourth Annual Symposium on Logic in Computer Science<address><addrLine>Pacific Grove, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Bayesian Models of Graphs, Arrays and Other Exchangeable Random Structures</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Orbanz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="437" to="461" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Categorical logic of names and abstraction in action calculi</title>
		<author>
			<persName><forename type="first">Duško</forename><surname>Pavlović</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="619" to="637" />
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Random geometric graphs</title>
		<author>
			<persName><forename type="first">Mathew</forename><surname>Penrose</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Oxford University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Nominal Sets: names and symmetry in computer science</title>
		<author>
			<persName><forename type="first">M</forename><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName><surname>Pitts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Logic in Computer Science</title>
		<editor>
			<persName><forename type="first">Gordon</forename><forename type="middle">D</forename><surname>Cup</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">John</forename><surname>Plotkin</surname></persName>
		</editor>
		<editor>
			<persName><surname>Power</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2001">2001. 2013. 2002. 2002</date>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
	<note>Categorical logic Notions of Computation Determine Monads Proc. FOSSACS</note>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Semantics for local computational effects</title>
		<author>
			<persName><forename type="first">A J</forename><surname>Power</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MFPS 2006. John Power. 2006b</title>
		<meeting>MFPS 2006. John Power. 2006b</meeting>
		<imprint>
			<date type="published" when="2006">2006. 2006</date>
			<biblScope unit="volume">364</biblScope>
			<biblScope unit="page" from="254" to="269" />
		</imprint>
	</monogr>
	<note>Generic models for computational effects</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Universal Graphs and Universal Functions</title>
		<author>
			<persName><forename type="first">R</forename><surname>Rado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Arithmetica</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="331" to="340" />
			<date type="published" when="1964">1964. 1964</date>
		</imprint>
	</monogr>
	<note>Issue 4</note>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">A stochastic programming perspective on nonparametric Bayes</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Vikash</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Noah</forename><surname>Mansinghka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joshua</forename><forename type="middle">B</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName><surname>Tenenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Nonparametric Bayes</title>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Issue 1. Sam Staton. 2017. Commutative Semantics for Probabilistic Programming</title>
		<author>
			<persName><forename type="first">Dan</forename><surname>Shiebler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ESOP</title>
		<meeting>ESOP</meeting>
		<imprint>
			<date type="published" when="2017">2021. April 2021. 2017</date>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="855" to="879" />
		</imprint>
	</monogr>
	<note>Categorical Stochastic Processes and Likelihood</note>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">The Beta-Bernoulli Process and Algebraic Effects</title>
		<author>
			<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dario</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongseok</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathanael</forename><forename type="middle">L</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cameron</forename><forename type="middle">E</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.09598</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. ICALP 2018. Appendix at</title>
		<meeting>ICALP 2018. Appendix at</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<author>
			<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongseok</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nathanael</forename><surname>Ackerman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cameron</forename><surname>Freer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<ptr target="https://pps2017.luddy.indiana.edu/files/2017/01/staton-yang-ackerman-freer-roy.pdf" />
		<title level="m">Exchangeable Random Processes and Data Abstraction. Workshop on Probabilistic Programming Semantics</title>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">University of Oxford. Ross Street and Robert Walters</title>
		<author>
			<persName><forename type="first">Dario</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Structural Foundations for Probabilistic Programming Languages</title>
		<imprint>
			<date type="published" when="1978">2021. 1978. 1978</date>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="350" to="379" />
		</imprint>
	</monogr>
	<note>Ph. D. Dissertation Yoneda structures on 2-categories</note>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<author>
			<persName><forename type="first">Terence</forename><surname>Tao</surname></persName>
		</author>
		<ptr target="https://terrytao.wordpress.com/2013/12/07/" />
		<title level="m">Ultraproducts as a Bridge Between Discrete and Continuous Analysis</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">A domain theory for statistical probabilistic programming</title>
		<author>
			<persName><forename type="first">Matthijs</forename><surname>Vákár</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ohad</forename><surname>Kammar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sam</forename><surname>Staton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM Program. Lang</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">29</biblScope>
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<author>
			<persName><forename type="first">Jan-Willem</forename><surname>Van De Meent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brooks</forename><surname>Paige</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongseok</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wood</surname></persName>
		</author>
		<idno>1809.10756</idno>
		<title level="m">An Introduction to Probabilistic Programming</title>
		<imprint>
			<date type="published" when="2018">2018. 2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv e-print</note>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Sampling and estimation for (sparse) exchangeable graphs</title>
		<author>
			<persName><forename type="first">Victor</forename><surname>Veitch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="3274" to="3299" />
			<date type="published" when="2019">2019. 2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Data types in distributive categories</title>
		<author>
			<persName><forename type="first">R F C</forename><surname>Walters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bulletin of the Australian Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="79" to="82" />
			<date type="published" when="1989">1989. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">A New Approach to Probabilistic Programming Inference</title>
		<author>
			<persName><forename type="first">Frank</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Willem Van De Meent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vikash</forename><surname>Mansinghka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 17th Int. Conf. on Artificial Intelligence and Statistics</title>
		<meeting>17th Int. Conf. on Artificial Intelligence and Statistics</meeting>
		<imprint>
			<publisher>AISTATS</publisher>
			<date type="published" when="2014">2014. 2014</date>
			<biblScope unit="page" from="1024" to="1032" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Reduced Traces and JITing in Church. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">Jeff</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mass. Inst. of Tech</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
