# Language models scale reliably with over-training and on downstream tasks

## Abstract

## 

Scaling laws are useful guides for derisking expensive training runs, as they predict performance of large models using cheaper, small-scale experiments. However, there remain gaps between current scaling studies and how language models are ultimately trained and evaluated. For instance, scaling is usually studied in the compute-optimal training regime (i.e., "Chinchilla optimal" regime). In contrast, models are often over-trained to reduce inference costs. Moreover, scaling laws mostly predict loss on next-token prediction, but models are usually compared on downstream task performance. To address both shortcomings, we create a testbed of 104 models with 0.011B to 6.9B parameters trained with various numbers of tokens on three data distributions. First, we fit scaling laws that extrapolate in both the amount of over-training and the number of model parameters. This enables us to predict the validation loss of a 1.4B parameter, 900B token run (i.e., 32× over-trained) and a 6.9B parameter, 138B token run (i.e., a compute-optimal run)-each from experiments that take 300× less compute. Second, we relate the perplexity of a language model to its downstream task performance by proposing a power law. We use this law to predict top-1 error averaged over downstream tasks for the two aforementioned models, using experiments that take 20× less compute. Our experiments are available at [https://github.com/mlfoundations/scaling](https://github.com/mlfoundations/scaling).

## Introduction

Training large language models is expensive. Furthermore, training high-quality models requires a complex recipe of algorithmic techniques and training data. To reduce the cost of finding successful training recipes, researchers first evaluate ideas with small experiments and then extrapolate their efficacy to larger model and data regimes via scaling laws. With reliable extrapolation, it is possible to quickly iterate at small scale and still pick the method that will perform best for the final large training run. Indeed, this workflow has become commonplace for training state-of-the-art language models like Chinchilla 70B [[45]](#b44), PaLM 540B [[19]](#b18), GPT-4 [[76]](#b75), and many others.  We fit a scaling law for model validation loss, parameterized by (i) a token multiplier M = N/D, which is the ratio of training tokens D to parameters N and (ii) the compute C in FLOPs used to train a model, approximated by C = 6N D. Larger values of M specify more over-training. We are able to extrapolate, in both N and M , the validation performance of models requiring more than 300× the training compute used to construct the scaling law. (right) We also fit a scaling law to predict average downstream top-1 error as a function of validation loss. We find that fitting scaling laws for downstream error benefits from using more expensive models when compared to fitting for loss prediction. We predict the average error over 17 downstream tasks for models trained with over 20× the compute. For this figure, we train all models on RedPajama [[112]](#b111).

Despite their importance for model development, published scaling laws differ from the goals of training state-of-the-art models in important ways. For instance, scaling studies usually focus on the compute-optimal training regime ("Chinchilla optimality" [[45]](#b44)), where model and dataset size are set to yield minimum loss for a given compute budget. However, this setting ignores inference costs. As larger models are more expensive at inference, it is now common practice to over-train smaller models [[113]](#b112). Another potential mismatch is that most scaling laws quantify model performance by perplexity in next-token prediction instead of accuracy on widely used benchmark datasets. However, practitioners usually turn to benchmark performance, not loss, to compare models.

In this paper, we conduct an extensive set of experiments to address both scaling in the over-trained regime and benchmark performance prediction.

Motivated by the practice of training beyond compute-optimality, we first investigate whether scaling follows reliable trends in the over-trained regime. We notice, as implied by Hoffmann et al. [[45]](#b44), for a set of models of different sizes trained with a constant ratio of tokens to parameters, models' reducible loss L ′ [[43,](#b42)[45]](#b44) follows a power law (L ′ = λ • C -η ) in the amount of training compute C. We find that as one increases the ratio of tokens to parameters, corresponding to more over-training, the scaling exponent η remains about the same, while the scalar λ changes. We explain our observations by reparameterizing existing scaling laws in relation to the amount of over-training.

To establish empirically that scaling extrapolates in the over-trained regime, we further experiment

## Preliminaries

Scaling laws for loss. Typically, scaling laws predict model loss L as a function of the compute C in FLOPs used for training. If one increases the number of parameters N in a model or the number of tokens D that a model is trained on, compute requirements naturally increase. Hence, we assume C is a function of N, D. Following Kaplan et al. [[51]](#b50), we use the approximation C = 6N D, which Hoffmann et al. [[45]](#b44) independently verify. We consider,

$L(C) = E + L ′ (C),(1)$where E is an irreducible loss and L ′ is the reducible loss. E captures the Bayes error or minimum possible loss achievable on the validation domain. The L ′ (C) term captures what can possibly be learned about the validation domain by training on a source domain. L ′ (C) should approach zero with increased training data and model capacity. L ′ (C) is often assumed to follow a power law: L ′ (C) = λ • C -η (i.a., Hestness et al. [[43]](#b42), OpenAI [[76]](#b75)). It is also often helpful to consider a power law in a log-log plot, where it appears as a line with slope -η and y-intercept log (λ). 

$L ′ (C) = λ • C -η$, the exponent η remains relatively constant resulting in lines with approximately fixed slope (Figure [17](#fig_25)). The scalar λ that determines the y-intercept, however, shifts with different token multipliers. This suggests λ is a function of the token multiplier, while η is not.

Token multipliers. We define a token multiplier M = D/N as the ratio of training tokens to model parameters for notational convenience. M allows us to consider fixed relationships between D and N even as a model gets bigger (i.e., as N becomes larger).

Compute-optimal training. Hoffmann et al. [[45]](#b44) establish compute-optimal training, where, for any compute budget H, the allocation of parameters and tokens is given by, arg min

$N,D L(N, D) s.t. C(N, D) = H.(2)$To solve for the optimal N * , D * , one can sweep N, D for each compute budget, retaining the best configurations. Hoffmann et al. [[45]](#b44) find that as the compute budget increases, N * and D * scale roughly evenly. Assuming equal scaling, there is a fixed compute-optimal token multiplier M * = D * /N * per training distribution.

Over-training. We define over-training as the practice of allocating compute sub-optimally, so smaller models train on a disproportionately large number of tokens (i.e., M > M * ). While loss should be higher than in the compute-optimal allocation for a given training budget, the resulting models have fewer parameters and thus incur less inference cost.

## Scaling laws for over-training

To propose a scaling law for over-trained models, we first turn to empirical observation. We train four model configurations with parameter counts between 0.011B and 0.411B for token multipliers M between 20 and 640, where M = 20 points lie roughly on the compute-optimal frontier, and larger M corresponds to more over-training. We defer experimental details to Section 3 to focus on our observations first. In Figure [2](#fig_2), we show loss against compute in a log-log plot for the models trained on three datasets and evaluated on the C4 eval set. We notice parallel lines when fitting power laws to We plot models trained on three datasets and notice an exponential decay of average top-1 error as C4 eval loss, on the x-axis, decreases. We consider on the y-axes average error on 17 evaluations where performance is at least 10 points above random chance for at least one 0.154B scale model. These observations suggest that average top-1 error should be predictable with reliable loss estimates.

the reducible loss, which suggests a near-constant scaling exponent even with increased over-training. This indicates that scaling behavior should be describable in the amount of over-training.

In search of an analytic expression for the observations in Figure [2](#fig_2), we consider existing scaling literature. A common functional form for the risk of a model, as proposed in prior work [[45,](#b44)[93]](#b92) is,

$L(N, D) = E + AN -α + BD -β .(3)$Recall from Section 2.1, N is the number of parameters and D the number of training tokens.

The constants E, A, α, B, β are fit from data. By fitting this parametric form, Hoffmann et al. [[45]](#b44) find that scaling exponents α and β are roughly equal, suggesting that one should scale N and D equally as compute increases. Hence, we assume α = β. With this assumption, we reparameterize Equation (3) in terms of compute C = 6N D and a token multiplier M = D/N . We get,

$L(C, M ) = E + aM η + bM -η C -η ,(4)$where η = α/2, a = A(1/6) -η , b = B(1/6) -η gives the relation to Equation [(3)](#b2). For a complete derivation, see Appendix B.

Equation ( [4](#formula_4)) has the following interpretation: (i) The scaling exponent η is not dependent on M . Thus, we always expect lines with the same slope in the log-log plot-as in Figure [2](#fig_2). (ii) The term aM η + bM -η determines the offsets between curves with different token multipliers. Hence, we expect non-overlapping, parallel lines in the log-log plot for the range of M we consider-also consistent with Figure [2](#fig_2).

Recall that we make the assumption α = β, which implies equal scaling of parameters and tokens as more compute is available. However, as explained in Appendix B, even if α ̸ = β, we get a parameterization that implies the power-law exponent remains constant with over-training.

## Scaling laws for downstream error

Scaling is typically studied in the context of loss [[45,](#b44)[51,](#b50)[72]](#b71), which Schaeffer et al. [[100]](#b99) note is smoother than metrics like accuracy. However, practitioners often use downstream benchmark accuracy as a proxy for model quality and not loss on perplexity evaluation sets. To better connect scaling laws and over-training to task prediction, we revisit the suite of models plotted in Figure [2](#fig_2). In Figure [3](#fig_3), we plot average downstream top-1 errors over evaluations sourced from LLM-Foundry [[69]](#b68) against the C4 eval loss. We defer details of the setup to Section 3 to focus here on a key observation: average error appears to follow exponential decay as loss decreases.

Based on the exponential decay we observe in Figure [3](#fig_3), we propose the following relationship between downstream average top-1 error Err and loss L,

$Err(L) = ϵ -k • exp (-γL),(5)$where ϵ, k, γ are fit from data. Equation ( [5](#formula_5)) also has an interpretation in terms of model perplexity PP(L) = exp (L),

$Err(PP) = ϵ -k • PP -γ .(6)$Namely, Err follows a power law in PP that is bounded from above by ϵ signifying arbitrarily high error and from below by ϵ -k • exp(-γE), where E is the Bayes error from Equation (4).

Equation ( [5](#formula_5)) in conjunction with Equation (4) suggests a three-step method to predict Err as a function of compute and the amount of over-training. For choices of training and validation distributions, (i) fit a scaling law to Equation (4) using triplets of compute C, token multiplier M , and measured loss L on a validation set to yield (C, M ) → L. (ii) Fit a scaling law to Equation (5) using pairs of loss L and downstream error Err for models to get L → Err. (iii) Chain predictions to get (C, M ) → Err.

## Constructing a scaling testbed

In this section, we discuss our experimental setup to test the predictions suggested by Equations ( [4](#formula_4)) and [(5)](#b4). We first present our general language modeling setup (Section 3.1). Next, we discuss our strategy for determining model configurations for our scaling investigation (Section 3.2) and fitting scaling laws (Section 3.3). We then present metrics to validate how well scaling laws predict loss and downstream performance (Section 3.4).

## Training setup

We train transformers [[116]](#b115) for next token prediction, based on architectures like GPT-2 [[85]](#b84) and LLaMA [[113]](#b112). We employ GPT-NeoX [[15]](#b14) as a standardized tokenizer for all data. See Appendix C for architecture, optimization, and hyperparameter details.

## Model configurations

To get final configurations for the 0.011B to 0.411B parameter models plotted in Figures [2](#fig_2) and [3](#fig_3), we first conduct a wide grid search over a total of 435 models, trained from scratch, from 0.01B to 0.5B

10 17 10 19 10 21 Compute (6ND) [FLOPs] 2 3 4 5 6 Loss: OpenLM eval Search 10 17 10 19 10 21 Compute (6ND) [FLOPs] Filter 10 17 10 19 10 21 Compute (6ND) [FLOPs] Fit Grid search models Selected models Target 1.4B model Target 6.9B model Interpolation Extrapolation 10 22 1.9 1.8 1.7 Figure 4: Search, filter, fit: A recipe for selecting configurations for scaling. (left) To generate the final configurations presented in Table 3, we run a 435 model grid search over model width, hidden dimension, number of attention heads, batch size, and warmup steps. All models are trained near compute-optimally. (center) We plot the efficient frontier of models, which appear to follow a trend, excluding models from 5.2 × 10 16 to 5.2 × 10 17 , which fall below the trend. (right)

We fit a power law with irreducible error to the remaining configurations, picking four configurations that closely track the full model suite ("Selected models"). These models extrapolate the performance of 1.4B, 6.9B target models. Shaded regions represent bootstrap 95% confidence intervals. parameters (Figure [4](#) (left)). We train on the original OpenLM data mix [[39]](#b38), which largely consists of RedPajama [[112]](#b111) and The Pile [[31]](#b30). While we eventually plan to over-train models, at this step we search for base configurations near compute-optimality. We train on 20 tokens per parameter (M = 20), which, in early experiments, gives models near the compute-optimal frontier. This is similar to findings in Hoffmann et al. [[45]](#b44)'s Table [3](#tab_6), which suggests that M = 20 is near-optimal for the Chinchilla experimental setup.

To find maximally performant small-scale models on validation data, we tune model width, number of layers, number of attention heads, warmup steps, and batch size. Our validation set, OpenLM eval, contains tokens from recent arXiv papers, the OpenLM codebase itself, and news articles. We find in early experiments that qk-LayerNorm makes models less sensitive to learning rate, which is a phenomenon Wortsman et al. [[123]](#b122) report in their Figure [1](#fig_1). Hence, we fix the learning rate (3e-3) for our sweeps. We also perform smaller grid searches over 1.4B and 6.9B parameter model configurations at M = 20, retaining the best configurations.

At this point, we have many models, several of which give poor performance; following prior work [[45,](#b44)[51]](#b50), we want to keep only models that give best performance. Hence, in Figure [4](#) (center), we filter out models that do not lie on the Pareto frontier. While there appears to be a general trend, configurations between 5.2 × 10 16 and 5.2 × 10 17 FLOPs lie below the frontier established by other models. We hypothesize these models over-perform as they are trained for more optimization steps than their neighbors based on our power-of-two batch sizes. We provide support for this hypothesis in Appendix F, but opt to remove these models from our investigation.

To ensure tractable compute requirements for our scaling experiments, we require a subset of models that follows the trend of the entire Pareto frontier. In Figure [4](#) (right), we fit trends to the Pareto models and to a subset of four models. We notice that the trends closely predict both the performance Table [1](#): Default number of parameters N and token multiplier M to fit our scaling laws. We invest ∼100 A100 hours to fit Equation ( [4](#formula_4)) and ∼1,000 A100 hours to fit Equation [(5)](#b4).

## N M

Used to fit Equation ( [4](#formula_4)) Used to fit Equation ( [5](#formula_5))

$0.011B 20 ✓ ✓ 0.079B 20 ✓ ✓ 0.154B 20 ✓ ✓ 0.411B 20 ✓ ✓ 0.011B 320 ✓ ✓ 1.4B 20 ✗ ✓ Total compute C [FLOPs] 2.4e19 2.7e20$of the 1.4B and 6.9B models, suggesting that our small-scale configurations reliably extrapolate in the compute-optimal setting.

Moving forward, we do not tune hyperparameters for other token multipliers (i.e., M ̸ = 20), on other training or evaluation distributions, or on validation sets for downstream tasks. For more details including specific hyperparameters, see Appendix D.

To create our scaling testbed, we start with the four small-scale, base configurations from our grid search: N ∈ {0.011B, 0.079B, 0.154B, 0.411B}. To ensure our conclusions are not particular to a single training distribution, we train models on each of C4 [[27,](#b26)[88]](#b87), RedPajama [[112]](#b111), and RefinedWeb [[82]](#b81), which have 138B, 1.15T, and 600B tokens, respectively, for different token multipliers M ∈ {5, 10, 20, 40, 80, 160, 320, 640}. We omit runs that require more tokens than are present in a dataset (i.e., N = 0.411B, M = 640 for C4). We additionally train N = 1.4B models at M = 20 and at the largest token multiplier possible without repeating tokens (i.e., 80 for C4, 640 for RedPajama, and 320 for RefinedWeb). We train N = 6.9B, M = 20 models on each dataset given the relevance of 7B parameter models [[49,](#b48)[113]](#b112). In total this results in a testbed of 104 models.

## Fitting scaling laws

We fit Equation (4) to approximate E, a, b, η using curve-fitting in SciPy [[117]](#b116) (i.e., Levenberg-Marquardt to minimize non-linear least squares). We repeat this process to fit Equation (5) to approximate ϵ, k, γ. We invest ∼100 A100 hours to train the models required to fit a scaling law for loss and ∼1,000 A100 hours for a corresponding law for downstream error. Unless otherwise specified, we fit to the N, M pairs in Table [1](#), which are a subset of our full testbed. Our configurations allow us to test for extrapolation to the N = 1.4B, M = 640 (900B token) and the N = 6.9B, M = 20 (138B token) regimes.

## Evaluation setup

Evaluation datasets. Unless otherwise stated, our default validation loss dataset is C4 eval. For downstream tasks, we adopt a subset from 46 tasks from LLM-foundry [[69]](#b68), which includes standard tasks with both zero-shot and few-shot evaluations. Specifically, we consider a 17-task subset where, for each evaluation, at least one 0.154B scale model-trained with as many as 99B tokens-gets 10 percentage points above chance accuracy: ARC-Easy [[23]](#b22), BIG-bench: CS algorithms [[11]](#b10), BIG-bench: Dyck languages [[11]](#b10), BIG-bench: Novel Concepts [[11]](#b10), BIG-bench: Operators [[11]](#b10), BIG- 1.1% 0.0% 0.2% 0.7% 0.9% 0.0% 0.6% 2.6% 0.3% 0.2% 0.4% 0.1% 0.7% 0.8% 1.5% 0.5% 1.1% 1.1% 3.3% 2.8% 0.6% 0.5% 0.2% 0.0% 2.8% 0.2% 2.0% 0.8% 1.5%

## 4.3%

Train: C4 Eval: C4 eval 0.3% 0.0% 0.3% 1.7% 1.1% 0.0% 1.0% 2.2% 0.3% 0.2% 0.7% 1.4% 2.1% 2.3% 0.8% 0.5% 0.6% 0.0% 0.4% 0.4% 0.3% 0.4% 0.2% 0.1% 0.3% 0.3%

1.4% 1.1% 0.1% 0.7% 0.7% Train: RedPajama Eval: C4 eval 10 20 40 80 160 320 640 M

0.9% 0.0% 0.9% 1.9% 1.0% 0.0% 1.1% 2.4% 0.1% 0.0% 0.5% 1.2% 2.0% 0.9% 0.9% 0.2% 0.6% 2.8% 2.2% 0.8% 0.9% 0.2% 0.1% 0.5% 0.8% 0.9% 0.9% 0.3% 0.6% 0.0%

1.6% Train: RefinedWeb Eval: C4 eval 0.0% 2.0% 4.0% 6.0% 8.0% 10.0% Relative error bench: QA WikiData [[11]](#b10), BoolQ [[21]](#b20), Commonsense QA [[107]](#b106), COPA [[92]](#b91), CoQA [[91]](#b90), HellaSwag (zero-shot) [[126]](#b125), HellaSwag (10-shot) [[126]](#b125), LAMBADA [[77]](#b76), PIQA [[14]](#b13), PubMed QA Labeled [[50]](#b49), SQuAD [[90]](#b89), and WinoGrand [[55]](#b54). For more details on evaluation datasets see Appendix E. We focus on this subset to ensure we are measuring signal, not noise. Including downstream tasks like MMLU [[40]](#b39), where performance is close to random chance, however, does not invalidate our results as we show in our evaluation set ablations (Appendix F).

Metrics. We consider three main metrics: Validation loss, which is the cross entropy between a model's output and the one-hot ground truth token, averaged over all tokens in a sequence and over all sequences in a dataset. Average top-1 error, which is a uniform average over the 17 downstream evaluations, as mentioned in the above paragraph.

To measure how good a prediction ζ(C, M ) is, we measure Relative prediction error : |ζ(C, M ) -ζ GT |/ζ GT , where ζ is the predicted loss L or the average top-1 error Err. ζ GT is the ground truth measurement to predict.

## Results: Reliable extrapolation

In this Section, we quantify the extent to which the scaling laws developed in Section 2 extrapolate larger model performance using the scaling testbed from Section 3. By default, we fit Equations ( [4](#formula_4)) and ( [5](#formula_5)) to the configurations in Table [1](#), use C4 eval for loss, and the 17-task split from Section 3.4 for average top-1 error.

Over-trained performance is predictable. We highlight our main over-training results in Figure [1](#fig_1) (left). Namely, we are able to extrapolate both in the number of parameters N and the token multiplier M to closely predict the C4 eval performance of a 1.4B parameter model trained on 900B RedPajama tokens (N = 1.4B, M = 640). Our prediction, which takes 300× less compute to construct than the final 1.4B run, is accurate to within 0.7% relative error. Additionally, for the N = 6.9B, M = 20 run, near compute-optimal, the relative error is also 0.7%.  [4](#formula_4)) is useful in practice for predicting over-trained scaling behavior. (iii) Fitting to Equation ( [4](#formula_4)) gives good prediction accuracy near compute-optimal. More specifically, predictions are accurate both for the 1.4B over-trained model and the 6.7B compute-optimal model using a single scaling fit.

While Figure [1](#fig_1) explores a specific case of making predictions in the over-trained regime, we aim to understand the error profile of our predictions across training datasets, token multipliers, and number of parameters. Hence, Figure [5](#fig_6) shows the relative error between ground truth loss and predicted loss on C4 eval for models in our testbed. We notice uniformly low prediction error suggesting that predictions are accurate in many settings.

Average top-1 error is predictable. Figure [1](#fig_1) (right) presents our main result in estimating scaling laws for downstream error. Concretely, we use the models indicated in Table [1](#) to fit Equations ( [4](#formula_4)) and ( [5](#formula_5)), chaining the scaling fits to predict the average top-1 error as a function of training compute C and the token multiplier M . Our fits allow us to predict, using 20× less compute, the downstream performance of a 6.9B model trained on 138B RedPajama tokens to within 0.05% relative error and a 1.4B model trained on RedPajama 900B tokens to within 3.6% relative error.

Table [2](#tab_4) additionally shows the relative error of our downstream performance predictions for models trained on C4, RedPajama, and RefinedWeb, indicating that our scaling law functional forms are applicable on many training datasets. We note that while average accuracy is predictable, individual downstream task predictions are significantly more noisy. We report relative error for more model predictions in Figures [11](#fig_16) and [12](#fig_2). We also find that if we remove the 1.4B model for the Equation ( [5](#formula_5)) fit, relative error jumps, for instance, from 0.05% to 10.64% on the 17-task split for the 6.9B, 138B token RedPajama prediction. This highlights the importance of investing more compute when constructing scaling laws for downstream task prediction compared to loss prediction.

Under-training, out-of-distribution scaling, compute-reliability trade-offs. In addition to our main results presented above, we include additional results in Appendix F, which we summarize here. First, we notice that when token multipliers become too small (i.e., M = 5) scaling becomes unreliable and lies off the trend. Additionally, multipliers other than 20, such as 10, 40, and 80, garner points that are roughly on the compute optimal frontier (Figure [9](#fig_12)). This observation suggests that the compute-optimal multiplier may lie in a range rather than take a single value. To probe the limits of reliable scaling, we attempt to break our scaling laws in out-of-distribution settings. We find that models trained on C4-English filtered-and evaluated on next token prediction on code domains have a high relative error in many cases. Perhaps surprisingly, evaluating the same models on German next token prediction gives reliable loss scaling (Figure [10](#fig_1)). We additionally examine the compute necessary to create accurate scaling laws, finding that scaling laws can be constructed more cheaply for loss prediction than for downstream error prediction (Figures [15](#fig_22) and [16](#fig_23)).

## Related work

We review the most closely related work in this section. For additional related work, see Appendix G.

Scaling laws. Early works on scaling artificial neural networks observe predictable power-law scaling in the training set size and number of model parameters [[43,](#b42)[44,](#b43)[93]](#b92). Alabdulmohsin et al. [[2]](#b1) stress the importance of looking at the extrapolation regime of a scaling law. Yang et al. [[124]](#b123) prescribe architectural and hyperparameter changes when scaling model width to realize performant models; Yang et al. [[125]](#b124) make analogous recommendations when scaling model depth. Bi et al. [[13]](#b12) propose hyperparameter aware scaling laws. Unlike the aforementioned work, our investigation focuses on over-training and predicting downstream accuracy.

Hoffmann et al. [[45]](#b44) investigate how the number of model parameters N and training tokens D should be chosen to minimize loss L given a compute budget C. Hoffmann et al. [[45]](#b44) find that when scaling up C, both N and D should be scaled equally up to a multiplicative constant (i.e., N ∝ C ∼0.5 and D ∝ C ∼0.5 ) to realize compute-optimality. Appendix C of the Chinchilla paper additionally suggests that these findings hold across three datasets. However, Hoffmann et al. [[45]](#b44) do not verify their scaling laws for training beyond compute-optimality, or for downstream error prediction-both of which are central to our work.

Sardana & Frankle [[98]](#b97) propose modifications to the Chinchilla formulation to incorporate inference costs into the definition of compute-optimality and solve for various fixed inference budgets. Their key finding, which is critical for our work, is that when taking into account a large enough inference budget, it is optimal to train smaller models for longer than the original Chinchilla recommendations.

Our work presupposes that over-training can be beneficial. Instead of solving for inference-optimal schemes, we support empirically a predictive theory of scaling in the over-trained regime. Additionally, we provide experiments across many validation and training sets.

For predicting downstream scaling beyond loss, Isik et al. [[47]](#b46) relate the number of pre-training tokens to downstream cross-entropy and machine translation BLEU score [[78]](#b77) after fine-tuning. In contrast, we take a holistic approach to evaluation by looking at top-1 error over many natural language tasks. Schaeffer et al. [[100]](#b99) argue that emergent abilities [[120]](#b119) are a product of non-linear metrics and propose smoother alternatives. As a warmup for why non-linear metrics may be hard to predict, Schaeffer et al. [[100]](#b99) consider predicting an ℓ length sequence exactly:

$Err(N, ℓ) ≈ 1 -PP(N ) -ℓ ,$where N is the number of parameters in a model and PP is its perplexity. This is a special case of our Equations ( [5](#formula_5)) and [(6)](#b5), where the number of training tokens does not appear, ϵ = 1, k = 1, and γ = ℓ. In contrast, we treat ϵ, k, γ as free parameters for a scaling law fit, finding that average error over downstream tasks can make for a predictable metric.

Over-training in popular models. There has been a rise in over-trained models [[113,](#b112)[114]](#b113) and accompanying massive datasets [[3,](#b2)[82,](#b81)[104,](#b103)[112]](#b111). For example, Chinchilla 70B [[45]](#b44) is trained with a token multiplier of 20, while LLaMA-2 7B [[114]](#b113) uses a token multiplier of 290. In our investigation, we look at token multipliers from 5 to 640 to ensure coverage of popular models and relevance for future models that may be trained on even more tokens.

## Limitations, future work, and conclusion

Limitations and future work. We identify limitations, which provide motivation for future work.

• Hyperparameters. While our configurations are surprisingly amenable to reliable scaling across many training and testing distributions without further tuning, there is a need to develop scaling laws that do not require extensive hyperparameter sweeps.

• Scaling up. Validating the trends in this paper for even larger runs is a valuable direction. Additionally, repeating our setup for models that achieve non-trivial performance on harder evaluations like MMLU is left to future work.

• Scaling down. Actualizing predictable scaling with even cheaper runs is important to make this area of research more accessible, especially for downstream error prediction.

• Failure cases. While we present a preliminary analysis of when scaling is unreliable, future work should investigate conditions under which scaling breaks down.

• Post-training. It is common to employ fine-tuning interventions after pre-training, which we do not consider. Quantifying to what degree over-training the base model provides benefits after post-training is an open area of research.

• Individual downstream task prediction. While we find that averaging over many task error metrics can make for a predictable metric, per-task predictions are left to future work.

• In-the-wild performance. Downstream task performance is a proxy for the in-the-wild user experience. Analyzing scaling trends in the context of this experience is timely.

• Dataset curation. Our work only deals with existing training datasets. Exploring dataset curation for improved model scaling is another promising direction.

## Conclusion.

We show that the loss of over-trained models, trained past compute-optimality, is predictable. Furthermore, we propose and validate a scaling law relating loss to average downstream task performance. We hope our work will inspire others to further examine the relationship between model training and downstream generalization. Our testbed will be made publicly available, and we hope it will make scaling research more accessible to researchers and practitioners alike. 

$L(C, M ) = E + A C 6M -α 2 + B CM 6 -α 2 , = E + A 1 6 -α 2 M α 2 + B 1 6 -α 2 M -α 2 C -α 2 .$This is equal to Equation ( [4](#formula_4)), making the substitutions η = α/2, a = A(1/6) -η , b = B(1/6) -η , as noted in the main body.

Relation to compute-optimal training. Recall that we made the assumption α = β, which implies equal scaling of parameters and tokens to realize compute-optimal models. While this assumption is empirically justified [[45]](#b44), even if α ̸ = β, we get a parameterization that implies the power law exponent in Equation ( [4](#formula_4)) remains constant with over-training, while the power law scalar changes.

To find a compute-optimal training setting, Hoffmann et al. [[45]](#b44) propose to minimize the right-hand side of Equation We now deviate from compute-optimal training by modifying the model size and tokens by multiplication with a constant √ m, according to

$N m = 1 √ m N * , D m = √ mD * .(7)$This modification keeps the compute constant (i.e., 6N m D m = 6N * D * ). The risk, then, becomes

$L(f Nm,Dm ) = E + m α 2 Aγ -α β+α + m -β 2 Bγ β β+α C -αβ α+β . (8$$)$We again expect the same power law exponent and changing power law scalar. Note that m in Equation ( [8](#formula_11)) is similar to M in Equation ( [4](#formula_4)). Specifically, m is a multiple of the Chinchilla-optimal token multiplier M * = D * /N * , which is no longer fixed as a compute budget changes for α ̸ = β.   [4](#formula_4)). Relative error is generally low across interpolation and extrapolation regimes. Relative error is largest for the RedPajama N = 1.4B, M = 640 prediction at 15.4%. In this case, we find that our scaling law predicts the model should perform worse than it does in practice.

Scaling is largely predictable in-distribution (ID). Prior work focuses on understanding scaling using ID loss, often using training loss directly [[45,](#b44)[51]](#b50). Hence, we also consider Paloma [[65]](#b64) loss evaluation sets, which are designed to probe performance in specific domains. We use Paloma's C4 [[27,](#b26)[88]](#b87), RedPajama [[112]](#b111), and Falcon-RefinedWeb [[82]](#b81) splits to probe for ID loss. As seen in Figure [7](#fig_9), relative error is mostly low. Relative error is largest for the N = 1.4B, M = 640 RedPajama run at 15.4%. Examining this case specifically, we find that the model performs better than the scaling law prediction. We hypothesize that as a model sees more tokens there is an increased likelihood of near-duplicate sequences ID, resulting in performance that is better than predicted.

Relative error is stable across many choices of downstream evaluation suites. To understand how sensitive our investigation is to our choices of downstream evaluation sets, we consider several other options as seen in Figure [8](#fig_11). We find that our prediction errors are fairly (i) low and (ii) consistent for many choices of downstream evaluation sets including the whole suite of 46 evaluations. Scaling can break down when under-training. We find that when a token multiple is too small (i.e., under-training regime), scaling appears unreliable. In Figure [9](#fig_12) we see for M = 5 the scaling trend is different. We hypothesize that tuning hyperparameters (e.g., warmup, batch size) directly for smaller multipliers may help mitigate the breakdown in predictability.

Scaling can be unpredictable out-of-distribution (OOD). Our main result shows reliable C4 eval loss predictions with models trained on RedPajama, which is an OOD evaluation setting. However, both C4 and RedPajama both contain tokens sourced from CommonCrawl.

To further probe OOD performance, we measure the relative error of scaling laws fit to models trained on C4 and evaluated on Paloma's 100 programming languages [[65]](#b64), Paloma's Penn Tree Bank (PTB) split [[66]](#b65), and a German version of C4 [[27]](#b26). Recall that the C4 training set we use has been filtered for English text. Hence we expect (i) the proportion of code is minimal, (ii) the "<unk>" substrings in PTB raw text do not appear frequently, and (iii) German is not prevalent. We notice that extrapolation relative error tends to be high for large M, N on programming languages and PTB (Figure [10](#fig_1) (left, center)). In contrast, for German C4, relative error is still low across  Recall that we consider a 17 task evaluation suite created by including only test sets where any 0.154B model we trained (for any token multiplier and training dataset) gets t = 10 percentage points above random chance. We evaluate over this subset to make sure we are measuring signal not noise. Here, we wish to understand how sensitive the relative prediction error is to our choice of t. (left) We see that relative prediction error is fairly low before a threshold of t = 35 (less than 10% relative error). When too many tasks are excluded (i.e., t ≥ 40) relative error spikes. Averaging over all 46 datasets (t = -5 as some evals are worse than random chance) also makes for a predictable metric (less than 3% relative error). (right) A parallel view, showing how many tasks are removed as t increases. 40 out of the 46 tasks can be removed and relative error is still fairly stable. the extrapolation range, with a maximum relative error of 7.6% at the N =1.4B, M = 80 scale (Figure [10](#fig_1) (right)). We hypothesize that further modifications to scaling laws are necessary to predict when scaling should be reliable as a function of the training and evaluation distributions.

Small-scale experiments can predict average downstream top-1 error. To verify that chaining Equations ( [4](#formula_4)) and ( [5](#formula_5)) is effective in practice, we collect C4 eval loss and downstream error pairs for the configurations in Table [1](#). In Figure [11](#fig_16), we look at relative error for our scaling predictions in the context of Average top-1 error over 46 evals and in Figure [12](#fig_2) over the high-signal 17 eval subset. We again notice reliable scaling in interpolation and extrapolation regimes, suggesting the validity of our procedure to predict downstream average top-1 error.

Loss evaluation ablations for downstream trends. Figure [13](#fig_18) presents the correlation between downstream error and loss evaluated on different validation sets (C4, RedPajama, and RefinedWeb). Regardless of the validation set (x-axis), models follow the exponential decay relationship given in Equation ( [5](#formula_5)), suggesting the choice of validation loss is not critical for the appearance of this phenomenon.

Investing more compute in a scaling law makes it more predictive. Thus far we have looked at standard configurations from Table [1](#) to construct our scaling laws, mainly to demonstrate extrapolation to larger N, M . However, for practitioners, the main constraint is often training compute. Hence, we wish to understand the trade-offs between the amount of compute invested in creating a scaling law and the relative error of the resulting law in the over-trained regime. In Figure [14](#fig_20) (left), we see that as one increases the amount of compute, it is possible to get better fits with lower relative error. In Figure [14](#fig_20) (right), we see a similar trend as one increases the number of data points used to fit a scaling law. Blue stars indicate the configurations from Table [1](#), which provide accurate predictions relative to the general trends-hinting at their usefulness for our investigation. In Figures [15](#fig_22) and [16](#fig_23) we repeat the compute analysis comparing trade-offs for loss prediction and error prediction for our RedPajama 1.4B parameter, 900B token and 6.9B parameter, 138B token runs respectively. We find that less compute is generally necessary to construct a loss scaling law that achieves the same relative error as that of an error prediction scaling law.

On compute-optimal token multipliers. We consider 20 tokens per parameter as close to compute-optimal for our experiments. Here we investigate, using different approaches, what the compute-optimal token multipliers are for each dataset-assuming one should scale number of parameter and training tokens equally as Hoffmann et al. [[45]](#b44) suggest.

Turning to Figure [9](#fig_12), we notice that there are many multipliers, between 10 and 80 that yield models close to the frontier. Hence, empirically, it appears choices within this range should be suitable for the optimal token multiplier.

We can also compute an optimal token multiplier using the coefficients in Table [6](#). Based on Hoffmann et al. [[45]](#b44)'s Equation ( [4](#formula_4)) and the assumption that α = β, we write,

$N * (C) = G C 6 1 2 , D * (C) = G -1 C 6 1 2 , G = a b 1 4η .(9)$To compute M * = D * /N * , we then have,

$M * = b a 1 2η . (10$$)$Using the values from Table [6](#) and Equation [(10)](#b9), we find M * C4 = 3.36, M * RedPajama = 7.42, M * RefinedWeb = 5.85, where the subscript gives the dataset name. These values conflict with the 6.9B N 0.3% 0.2% 0.6% 0.9% 0.2% 0.3% 1.3% 1.2% 0.4% 1.0% 0.1% 0.3% 0.3% 0.0% 0.2% 0.7% 0.5% 1.2% 1.7% 1.0% 0.4% 0.6% 0.2% 0.0% 1.6% 0.0% 0.4% 0.1% 0.4% 1.1% 1.3% 0.2% 0.6% 0.4% 0.1% 0.0% 0.3% 0.8% 1.0% 0.6% 1.3% 0.2% 0.2% 0.0% 0.6% 0.9% 0.9% 0.3% 1.3% 0.8% 1.3% 1.5% 1.0% 1.0% 1.0% 0.3% 3.4%

## 2.1%

Train: RedPajama, Downstream: 46-task split 1.2% 0.1% 0.1% 0.7% 0.3% 0.8% 0.6% 0.5% 1.4% 0.4% 0.9% 0.8% 1.0% 1.2% 0.8% 0.1% 0.6% 0.3% 1.1% 0.7% 0.9% 0.5% 1.1% 1.1% 1.7% 1.6% 0.6% 0.9% 0.3% 4.3%  [5](#formula_5)). Using our fits, we accurately predict downstream average top-1 error across interpolation and extrapolation regimes. This result supports that (i) chaining a scaling law and our proposed exponential decay function is a valid procedure and (ii) average top-1 error can be highly predictable.

Scaling beyond language modeling. There is a large body of work on scaling neural networks beyond language modeling, for example in computer vision [[1,](#b0)[2,](#b1)[60,](#b59)[105,](#b104)[127]](#b126), multimodal learning [[18,](#b17)[30,](#b29)[41]](#b40), and image reconstruction [[52]](#b51).

Over-training in existing models. To contextualize the extent to which we over-train, we provide token multipliers for popular models in Table [8](#).

## H Broader impact

Language models have known risks in terms of harmful language, toxicity, and human automation-to name a few [[12,](#b11)[121]](#b120). We include the following for our public release "WARNING: These are base models and not aligned with post-training. They are provided as is and intended as research artifacts only." However, even as research artifacts, we recognize that models can still be misused by malicious actors or can be harmful to benevolent actors. When deciding to release our models and experiments, we considered (i) the benefit to the scientific community and (ii) the benchmark performance relative to other models that have already been released. For (i) we feel that our testbed is of use to others in the community who want to do scaling research, but do not necessarily have the means to train these model artifacts themselves. Hence, we predict (and hope) releasing all models and experiments will be helpful to others wanting to participate in scaling research. For (ii), we note that there are publicly available models [[49,](#b48)[113,](#b112)[114]](#b113), which outperform models from our testbed and that are more likely to be widely adopted. Finally, we recognize that advancing scaling science also has potential for harm. Specifically, while we are concerned with loss and downstream task performance for popular evaluation settings, it is possible that nefarious actors may use scaling laws to help design more harmful models.   [[118,](#b117)[131,](#b130)[132]](#b131) reading comprehension multiple choice 3 510 0.25 AGIEval LSAT RC [[118,](#b117)[131,](#b130)[132]](#b131) reading comprehension multiple choice 3 268 0.25 AGIEval SAT English [[132]](#b131) reading comprehension multiple choice 3 206 0.25 ARC-Challenge [[23]](#b22) world knowledge multiple choice 10 2376 0.25 ARC-Easy [[23]](#b22) world knowledge multiple choice 10 2376 0.25 BBQ [[79]](#b78) safety multiple choice 3 58492 0.50 BIG-bench: CS algorithms [[11]](#b10) symbolic problem solving language modeling 10 1320 0.00 BIG-bench: Conceptual combinations [[11]](#b10) language understanding multiple choice 10 103 0.25 BIG-bench: Conlang translation [[11]](#b10) language understanding language modeling 0 164 0.00 BIG-bench: Dyck languages [[11]](#b10) symbolic problem solving language modeling 10 1000 0.00 BIG-bench: Elementary math QA [[11]](#b10) symbolic problem solving multiple choice 10 38160 0.25 BIG-bench: Language identification [[11]](#b10) language understanding multiple choice 10 10000 0.25 BIG-bench: Logical deduction [[11]](#b10) symbolic problem solving multiple choice 10 1500 0.25 BIG-bench: Misconceptions [[11]](#b10) world knowledge multiple choice 10 219 0.50 BIG-bench: Novel Concepts [[11]](#b10) commonsense reasoning multiple choice 10 32 0.25 BIG-bench: Operators [[11]](#b10) symbolic problem solving language modeling 10 210 0.00 BIG-bench: QA WikiData [[11]](#b10) world knowledge language modeling 10 20321 0.00 BIG-bench: Repeat copy logic [[11]](#b10) symbolic problem solving language modeling 10 32 0.00 BIG-bench: Strange stories [[11]](#b10) commonsense reasoning multiple choice 10 174 0.50 BIG-bench: Strategy QA [[11]](#b10) commonsense reasoning multiple choice 10 2289 0.50 BIG-bench: Understanding fables [[11]](#b10) reading comprehension multiple choice 10 189 0.25 BoolQ [[21]](#b20) reading comprehension multiple choice 10 3270 0.50 COPA [[92]](#b91) commonsense reasoning multiple choice 0 100 0.50 CoQA [[91]](#b90) reading comprehension language modeling 0 7983 0.00 Commonsense QA [[107]](#b106) commonsense reasoning multiple choice 10 1221 0.25 Enterprise PII classification [[81]](#b80) safety multiple choice 10 3395 0.50 HellaSwag (10-shot) [[126]](#b125) language understanding multiple choice 10 10042 0.25 HellaSwag (zero-shot) [[126]](#b125) language understanding multiple choice 0 10042 0.25 Jeopardy [[69]](#b68) world knowledge language modeling 10 2117 0.00 LAMBADA [[77]](#b76) language understanding language modeling 0 5153 0.00 LogiQA [[58]](#b57) symbolic problem solving multiple choice 10 651 0.25 MMLU (5-shot) [[40]](#b39) world knowledge multiple choice 5 14042 0.25 MMLU (zero-shot) [[40]](#b39) world knowledge multiple choice 0 14042 0.25 MathQA [[5]](#b4) symbolic problem solving multiple choice 10 2983 0.25 OpenBook QA [[68]](#b67) commonsense reasoning multiple choice 0 500 0.25 PIQA [[14]](#b13) commonsense reasoning multiple choice 10 1838 0.50 PubMed QA Labeled [[50]](#b49) reading comprehension language modeling 10 1000 0.00 SIQA [[97]](#b96) commonsense reasoning multiple choice 10 1954 0.50 SQuAD [[90]](#b89) reading comprehension language modeling 10 10570 0.00 Simple Arithmetic: NoSpaces [[69]](#b68) symbolic problem solving language modeling 10 1000 0.00 Simple Arithmetic: WithSpaces [[69]](#b68) symbolic problem solving language modeling 10 1000 0.00 WinoGender MC: Female [[94]](#b93) safety multiple choice 10 60 0.50 WinoGender MC: Male [[94]](#b93) safety multiple choice 10 60 0.50 WinoGrande [[95]](#b94) language understanding schema 0 1267 0.50 WinoGrand [[55]](#b54) language understanding schema 0 273 0.50

Table 6: Scaling law fit parameters. Here we present our scaling coefficients fit to Equations ( [4](#formula_4)) and ( [5](#formula_5)) using configurations from Table [1](#).

Training dataset Fit for Equation (4): L(C, M ) = Fit for Equation (5):

$Err(L) = E + (a • M η + b • M -η )C η ϵ -k • exp (-γL)C4$[27, 88] 1.51 + 141 • M 0.121 + 190 • M -0.121 C -0.121 0.850 -2.08 • exp (-0.756 • L) RedPajama [112] 1.84 + 212 • M 0.136 + 367 • M -0.136 C -0.136 0.857 -2.21 • exp (-0.715 • L) RefinedWeb [82] 1.73 + 157 • M 0.127 + 246 • M -0.127 C -0.127 0.865 -2.21 • exp (-0.707 • L)   We observe that regardless of evaluation loss distribution (x-axis), models tend to follow Equation [(5)](#b4). This suggests that there can be several reasonable choices for the validation loss distribution. Additionally, ID models trained on C4 and evaluated on a C4 validation set, perform best in terms of loss, but these gains don't necessarily translate to lower error downstream (e.g., (left column)). This suggests the need to fit Equation (5) per dataset and also suggests comparing models trained on different data distributions with a single loss evaluation can be misleading.   [4](#formula_4)) with as many as 29 models trained on RedPajama. Specifically, a grid formed by N ∈ {0.011B, 0.079B, 0.154B, 0.411B}, M ∈ {5, 10, 20, 40, 80, 160, 320} gives 28 models and a N = 1.4B, M = 20 run gives the last model. We sort models by training FLOPs in increasing order and sample models uniformly from index windows [1, 2, ..., n] for n ∈ [[5, 6, .., 29]](#) to fit Equation (4). The blue star represents the default configuration presented in Table [1](#). The prediction target is a N = 1.4B, M = 640 (D = 900B) model. As the amount of compute (left) and the number of points (right) used to fit the scaling law increases, relative error trends downwards. Our default configuration keeps compute and number of points low, while still providing low prediction error compared to the trend.  The compute necessary to accurately predict loss is less than that needed to accurately predict (right) average downstream error. This claim is supported by the fact that the slope of the trend for loss is steeper than for top-1 error. These findings corroborate Figure [16](#fig_23). The compute necessary to accurately predict loss is less than that needed to accurately predict (right) average downstream error. This claim is supported by the fact that the slope of the trend for loss is steeper than for top-1 error. These findings corroborate Figure [15](#fig_22).  In Figure [2](#fig_2), we notice roughly parallel lines (i.e., roughly constant scaling exponent η) in the log-log plot of loss vs. compute, even as the token multiplier M changes. Here we plot η vs. M directly, where the shaded region gives a 95% bootstrap confidence interval for the trend. This view supports that η is relatively constant. Table [8](#): Token multipliers of existing models. In our work, we run experiments with token multipliers between 5 and 640 for {GPT-2 [[85]](#b84), LLaMA [[113]](#b112)}-style decoder-only architectures.

Model family Parameters N Training tokens D Token multiplier M T5 [89] 11B 34B 3.1 GPT-3 [16] 175B 300B 1.7 Gopher [86] 280B 300B 1.1 Chinchilla [45] 70B 1.4T 20.0 LLaMA [113] 7B 1T 140.0 LLaMA [113] 70B 1.4T 20.0 LLaMA-2 [114] 7B 2T 290.0 LLaMA-2 [114] 70B 2T 30.0 XGen [74] 7B 1.5T 210.0 MPT [110] 7B 1T 140.0

![Figure 1: Reliable scaling with over-training and on downstream error prediction. (left) We fit a scaling law for model validation loss, parameterized by (i) a token multiplier M = N/D, which is the ratio of training tokens D to parameters N and (ii) the compute C in FLOPs used to train a model, approximated by C = 6N D. Larger values of M specify more over-training.We are able to extrapolate, in both N and M , the validation performance of models requiring more than 300× the training compute used to construct the scaling law. (right) We also fit a scaling law to predict average downstream top-1 error as a function of validation loss. We find that fitting scaling laws for downstream error benefits from using more expensive models when compared to fitting for loss prediction. We predict the average error over 17 downstream tasks for models trained with over 20× the compute. For this figure, we train all models on RedPajama[112].]()

![Figure 2: Scaling in the over-trained regime follows consistent power law exponents. We notice parallel lines in the log-log plots of reducible loss vs. training compute for a range of token multipliers M , which give the ratio of training tokens to model parameters. Larger M corresponds to more over-training. For a power law giving reducible loss as a function of compute: L ′ (C) = λ • C -η , the exponent η remains relatively constant resulting in lines with approximately fixed slope (Figure17). The scalar λ that determines the y-intercept, however, shifts with different token multipliers. This suggests λ is a function of the token multiplier, while η is not.]()

![Figure3: Average top-1 error scales as a function of loss. We plot models trained on three datasets and notice an exponential decay of average top-1 error as C4 eval loss, on the x-axis, decreases. We consider on the y-axes average error on 17 evaluations where performance is at least 10 points above random chance for at least one 0.154B scale model. These observations suggest that average top-1 error should be predictable with reliable loss estimates.]()

![Figure 5: Relative error on C4 eval for different training distributions. Boxes highlighted in yellow correspond to pairs-number of parameters N , token multiplier M -used to fit Equation (4). Larger values of M correspond to more over-training. The prediction error is low in both interpolation and extrapolation ranges. Below N = 1.4B, empty squares correspond to runs that were not possible due to the limited dataset size for single epoch training. At N = 1.4B we run at M = 20 and at the largest possible multiplier. At N = 6.9B, we run at M = 20.]()

![Developing scaling laws for over-training and downstream tasks 3 2.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Scaling laws for over-training . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 Scaling laws for downstream error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Constructing Training setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Model configurations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Fitting scaling laws . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Evaluation setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .Scaling-law derivationsWe first show that reparameterizing Equation (3) in terms of the compute C and token multiplier M for α = β yields Equation (4). Combining C = 6N D and M = D/N yields N = C/(6M ) and D = CM/6. Inserting these into Equation (3) yields,]()

![subject to the compute constraint C = 6N D. This yields, N * = γ γ = αA βB , for notational convenience. The associated risk is, L(N * , D * ) = E + Aγ]()

![Figure 7: In-distribution (ID) settings. Boxes highlighted in yellow correspond to data points used to fit Equation (4). Relative error is generally low across interpolation and extrapolation regimes. Relative error is largest for the RedPajama N = 1.4B, M = 640 prediction at 15.4%. In this case, we find that our scaling law predicts the model should perform worse than it does in practice.]()

![t (i.e., include evals where any model gets t percentage points above random chance at 0.154B scales)]()

![Figure 8: Downstream evaluation set ablation for 6.9B parameter, 138B token runs.Recall that we consider a 17 task evaluation suite created by including only test sets where any 0.154B model we trained (for any token multiplier and training dataset) gets t = 10 percentage points above random chance. We evaluate over this subset to make sure we are measuring signal not noise. Here, we wish to understand how sensitive the relative prediction error is to our choice of t. (left) We see that relative prediction error is fairly low before a threshold of t = 35 (less than 10% relative error). When too many tasks are excluded (i.e., t ≥ 40) relative error spikes. Averaging over all 46 datasets (t = -5 as some evals are worse than random chance) also makes for a predictable metric (less than 3% relative error). (right) A parallel view, showing how many tasks are removed as t increases. 40 out of the 46 tasks can be removed and relative error is still fairly stable.]()

![Figure 9: Scaling with small token multipliers. For smaller multipliers (e.g., M = 5 in cyan), scaling does not follow the same trend as that of larger multipliers. Additionally, many token multipliers (e.g., M ∈ {10, 20, 40, 80}) garner points close to the compute-optimal frontier.]()

![Figure 11: Relative error on average top-1 predictions (46 task split). Boxes highlighted in yellow correspond to data points used to fit Equation (5). Using our fits, we accurately predict downstream average top-1 error across interpolation and extrapolation regimes. This result supports that (i) chaining a scaling law and our proposed exponential decay function is a valid procedure and (ii) average top-1 error can be highly predictable.]()

![Figure 13: Correlation between average top-1 error and evaluation loss. We observe that regardless of evaluation loss distribution (x-axis), models tend to follow Equation (5). This suggests that there can be several reasonable choices for the validation loss distribution. Additionally, ID models trained on C4 and evaluated on a C4 validation set, perform best in terms of loss, but these gains don't necessarily translate to lower error downstream (e.g., (left column)). This suggests the need to fit Equation (5) per dataset and also suggests comparing models trained on different data distributions with a single loss evaluation can be misleading.]()

![Figure 14: Trade-offs between scaling law for loss fitting considerations and reliability. Each red circle represents a scaling law fit to Equation (4) with as many as 29 models trained on RedPajama. Specifically, a grid formed by N ∈ {0.011B, 0.079B, 0.154B, 0.411B}, M ∈ {5, 10, 20, 40, 80, 160, 320} gives 28 models and a N = 1.4B, M = 20 run gives the last model. We sort models by training FLOPs in increasing order and sample models uniformly from index windows [1, 2, ..., n] for n ∈ [5, 6, .., 29] to fit Equation (4). The blue star represents the default configuration presented in Table1. The prediction target is a N = 1.4B, M = 640 (D = 900B) model. As the amount of compute (left) and the number of points (right) used to fit the scaling law increases, relative error trends downwards. Our default configuration keeps compute and number of points low, while still providing low prediction error compared to the trend.]()

![] used for the scaling fit Relative error: 17-task split Trend Default setting from Table2Individual estimates]()

![Figure 15: Compute vs. relative error for the 1.4B, 900B token RedPajama run. (left)The compute necessary to accurately predict loss is less than that needed to accurately predict (right) average downstream error. This claim is supported by the fact that the slope of the trend for loss is steeper than for top-1 error. These findings corroborate Figure16.]()

![Figure 16: Compute vs. relative error for the 6.9B, 138B token RedPajama run. (left)The compute necessary to accurately predict loss is less than that needed to accurately predict (right) average downstream error. This claim is supported by the fact that the slope of the trend for loss is steeper than for top-1 error. These findings corroborate Figure15.]()

![Figure17: Scaling exponent vs. token multiplier. In Figure2, we notice roughly parallel lines (i.e., roughly constant scaling exponent η) in the log-log plot of loss vs. compute, even as the token multiplier M changes. Here we plot η vs. M directly, where the shaded region gives a 95% bootstrap confidence interval for the trend. This view supports that η is relatively constant.]()

![Downstream relative prediction error at 6.9B parameters and 138B tokens. While predicting accuracy on individual zero-shot downstream evaluations can be challenging ("Individual"), predicting averages across downstream datasets is accurate ("Avg.").Scaling can be predictable even when one increases both the model size and the amount of over-training compared to the training runs used to fit a scaling law. (ii) The form presented in Equation (]()

![Main models and hyperparameters used in our investigation. Models have number of parameters N , with number of layers n layers , number of attention heads n heads , model width d model , and width per attention head d head . Batch sizes are global and in units of sequences. Each sequence has 2,048 tokens. A100 GPU hours are at M = 20, which are near compute-optimal runs. For the 1.4B scale, a batch size of 256 performs slightly better than 512.]()

![Topologies for our grid searches. We consider 130 architectures for our grid search. After sweeping over batch size and warmup, we get a total of 435 configurations. For a complete list of hyperparameter configurations, please see: https://github.com/mlfoundations/scaling]()

![46 downstream tasks. All downstream tasks considered in this work, evaluated via LLM-foundry[69]. For more information on each dataset and specifics about the LLM-foundry category and evaluation type, please see: https://www.mosaicml.com/llm-evaluation.]()

![Downstream relative prediction error at 6.9B, 138B tokens, with and without the 1.4B data point. Recall in Table1, we introduce a N = 1.4B, M = 20 run to get better downstream error predictions. Here we compare, prediction errors with and without this model for fitting the scaling law. Note that without the model (i.e., rows with "w/o 1.4B") average top-1 predictions, over the 17 tasks. are less accurate.]()

