# An Introduction to Johnson-Lindenstrauss Transforms

## Abstract

## 

Johnson-Lindenstrauss Transforms are powerful tools for reducing the dimensionality of data while preserving key characteristics of that data, and they have found use in many fields from machine learning to differential privacy and more. This note explains what they are; it gives an overview of their use and their development since they were introduced in the 1980s; and it provides many references should the reader wish to explore these topics more deeply.

The text was previously a main part of the introduction of my PhD thesis [Fre20], but it has been adapted to be self contained and serve as a (hopefully good) starting point for readers interested in the topic.

## 

1 The Why, What, and How

## The Problem

Consider the following scenario: We have some data that we wish to process but the data is too large, e.g. processing the data takes too much time, or storing the data takes too much space. A solution would be to compress the data such that the valuable parts of the data are kept and the other parts discarded. Of course, what is considered valuable is defined by the data processing we wish to apply to our data. To make our scenario more concrete let us say that our data consists of vectors in a high dimensional Euclidean space, R 𝑑 , and we wish to find a transform to embed these vectors into a lower dimensional space, R 𝑚 , where 𝑚 ≪ 𝑑, so that we can apply our data processing in this lower dimensional space and still get meaningful results. The problem in this more concrete scenario is known as dimensionality reduction.

As an example, let us pretend to be a library with a large corpus of texts and whenever a person returns a novel that they liked, we would like to recommend some similar novels for them to read next. Or perhaps we wish to be able to automatically categorise the texts into groups such as fiction/non-fiction or child/young-adult/adult literature. To be able to use the wealth of research on similarity search and classification we need a suitable representation of our texts, and here a common choice is called bag-of-words. For a language or vocabulary with 𝑑 different words, the bag-of-words representation of a text 𝑡 is a vector 𝑥 ∈ R 𝑑 whose 𝑖th entry is the number of times the 𝑖th word occurs in 𝑡. For example, if the language is just ["be", "is", "not", "or", "question", "that", "the", "to"] then the text "to be or not to be" is represented as (2, 0, 1, 1, 0, 0, 0, 2) ᵀ . To capture some of the context of the words, we can instead represent a text as the count of so-called 𝑛-grams1, which are sequences of 𝑛 consecutive words, e.g. the 2-grams of "to be or not to be" are ["to be", "be or", "or not", "not to", "to be"], and we represent such a bag-of-𝑛-grams as a vector in R (𝑑 𝑛 ) . To compare two texts we compute the distance between the vectors of those texts, because the distance between vectors of texts with mostly the same words (or 𝑛-grams) is small2. For a more realistic language such as English with 𝑑 ≈ 171000 words [[SW89]](#) or that of the "English" speaking internet at 𝑑 ≳ 4790000 words [[WZ05]](#b211), the dimension quickly becomes infeasable. While we only need to store the nonzero counts of words (or 𝑛-grams) to represent a vector, many data processing algorithms have a dependency on the vector dimension 𝑑 (or 𝑑 𝑛 ), e.g. using nearest-neighbour search to find similar novels to recommend [[AI17]](#b5) or using neural networks to classify our texts [[Sch18]](#b169). These algorithms would be infeasible for our library use case if we do not first reduce the dimension of our data.

A seemingly simple approach would be to select a subset of the coordinates, say if the data contained redundant or irrelevant coordinates. This is known as feature selection [JS08; HTF17; Jam+13a], and can be seen as projecting3 onto an axis aligned subspace, i.e. a subspace whose basis is a subset of {𝑒 1 , . . . , 𝑒 𝑑 }.

We can build upon feature selection by choosing the basis from a richer set of vectors. For instance, in principal component analysis as dimensionality reduction (PCA) [[Pea01;](#b156)[Hot33]](#b90) we let the basis of the subspace be the 𝑚 first eigenvectors (ordered decreasingly by eigenvalue) of 𝑋 ᵀ 𝑋, where the rows of 𝑋 ∈ R 𝑛×𝑑 are our 𝑛 high dimensional vectors4. This subspace maximises the variance of the data in the sense that the first eigenvector is the axis that maximises variance and subsequent eigenvectors are the axes that maximise variance subject to being orthogonal to all previous eigenvectors [[LRU20b;](#b137)[HTF17;](#b93)[Jam+13b]](#b101).

But what happens if we choose a basis randomly?

## The Johnson-Lindenstrauss Lemma(s)

In 19845 it was discovered that projecting onto a random basis approximately preserves pairwise distances with high probability. In order to prove a theorem regarding Lipschitz extensions of 1 These are sometimes referred to as shingles. 2 We might wish to apply some normalisation to the vectors, e.g. tf-idf [[LRU20a]](#b136), so that rare words are weighted more and text length is less significant. 3 Here we slightly bend the definition of projection in the sense that we represent a projected vector as the coefficients of the of the linear combination of the (chosen) basis of the subspace we project onto, rather than as the result of that linear combination. If 𝐴 ∈ R 𝑚×𝑑 is a matrix with the subspace basis vectors as rows, we represent the projection of a vector 𝑥 ∈ R 𝑑 as the result of 𝐴𝑥 ∈ R 𝑚 rather than 𝐴 ᵀ 𝐴𝑥 ∈ R 𝑑 .

time8 of 𝒪(|𝑋 |𝑑 2 + 𝑑 𝜔 ) [DDH07], compared to Θ(|𝑋 |𝑑 log 𝑑) and9 Θ(∥𝑋 ∥ 0 𝜀 -1 log|𝑋 |) that can be achieved by the JLDs "FJLT" and "Block SparseJL", respectively, which will be introduced in section 1.4. As such, PCA and JLDs are different tools appropriate for different scenarios (see e.g. [[Bre+19]](#b37) where the two techniques are compared empirically in the domain of medicinal imaging; see also [Das00; BM01; FB03; FM03; Tan+05; DB06; Arp+14; Woj+16; Bre+20]). That is not to say the two are mutually exclusive, as one could apply JL to quickly shave off some dimensions followed by PCA to more carefully reduce the remaining dimensions [e.g. RST09; HMT11; Xie+16; Yan+20]. For more on PCA, we refer the interested reader to [[Jol02]](#b104), which provides an excellent in depth treatment of the topic.

One natural question to ask with respect to JLDs and JLTs is if the target dimension is optimal. This is indeed the case as Kane, Meka, and Nelson [[KMN11]](#b115) and Jayram and Woodruff [[JW13]](#b107) independently give a matching lower bound of 𝑚 = Ω(𝜀 -2 log 1 𝛿 ) for any JLD that satisfies lemma 1.2, and Larsen and Nelson [[LN17]](#b134) showed that the bound in lemma 1.1 is optimal up constant factors for almost the entire range of 𝜀 with the following theorem.

## Theorem 1.3 ([LN17]

). For any integers 𝑛, 𝑑 ≥ 2 and lg 0.5001 𝑛/ √︁ min{𝑑, 𝑛} < 𝜀 < 1 there exists a set of points 𝑋 ⊂ R 𝑑 of size 𝑛 such that any function 𝑓 : 𝑋 → R 𝑚 satisfying eq. (1) must have

$𝑚 = Ω (︁ 𝜀 -2 log(𝜀 2 𝑛) )︁ .(3)$Note that if 𝜀 ≤ √︁ lg 𝑛/min{𝑑, 𝑛} then 𝜀 -2 lg 𝑛 ≥ min{𝑑, 𝑛}, and embedding 𝑋 into dimension min{𝑑, |𝑋 |} can be done isometrically by the identity function or by projecting onto span(𝑋), respectively.

Alon and Klartag [[AK17]](#b6) extended the result in [[LN17]](#b134) by providing a lower bound for the gap in the range of 𝜀.

## Theorem 1.4 ([AK17]

). There exists an absolute positive constant 0 < 𝑐 < 1 so that for any 𝑛 ≥ 𝑑 > 𝑐𝑑 ≥ 𝑚 and for all 𝜀 ≥ 2/ √ 𝑛, there exists a set of points 𝑋 ⊂ R 𝑑 of size 𝑛 such that any function 𝑓 : 𝑋 → R 𝑚 satisfying eq. (1) must have

$𝑚 = Ω (︁ 𝜀 -2 log(2 + 𝜀 2 𝑛) )︁ .(4)$It is, however, possible to circumvent these lower bounds by restricting the set of input vectors we apply the JLTs to. For instance, Klartag and Mendelson [[KM05]](#b114), Dirksen [[Dir16]](#b62), and Bourgain, Dirksen, and Nelson [[BDN15b]](#b28) provide target dimension upper bounds for JLTs that are dependent on statistical properties of the input set 𝑋. Similarly, JLTs can be used to approximately preserve pairwise distances simultaneously for an entire subspace using 𝑚 = Θ(𝜀 -2 𝑡 log(𝑡/𝜀)), where 𝑡 denotes the dimension of the subspace [[Sar06]](#b168), which is a great improvement when 𝑡 ≪ |𝑋 |, 𝑑.

Another useful property of JLTs is that they approximately preserve dot products. Corollary 1.5 formalises this property in terms of lemma 1.1, though it is sometimes [Sar06; AV06] stated in terms of lemma 1.2. Corollary 1.5 has a few extra requirements on 𝑓 and 𝑋 compared 8 Here 𝜔 ≲ 2.373 is the exponent from the running time of squared matrix multiplication [Wil12; Le 14]. 9 Here ∥𝑋 ∥ 0 is the total number of nonzero entries in the set of vectors 𝑋, i.e. ∥𝑋 ∥ 0 ≔ ∑︁ 𝑥∈𝑋 ∥𝑥 ∥ 0 where ∥𝑥 ∥ 0 ≔ |{𝑖 | 𝑥 𝑖 ≠ 0}| for a vector 𝑥.

to lemma 1.1, but these are not an issue if the JLT is sampled from a JLD, or if we add the negations of all our vectors to 𝑋, which only slightly increases the target dimension.

Corollary 1.5. Let 𝑑, 𝜀, 𝑋 and 𝑓 be as defined in lemma 1.1, and furthermore let 𝑓 be linear. Then for every 𝑥, 𝑦 ∈ 𝑋, if -𝑦 ∈ 𝑋 then

$|⟨ 𝑓 (𝑥), 𝑓 (𝑦)⟩ -⟨𝑥, 𝑦⟩| ≤ 𝜀∥𝑥 ∥ 2 ∥𝑦 ∥ 2 .$(5)

Proof. If at least one of 𝑥 and 𝑦 is the 0-vector, then eq. ( [5](#)) is trivially satisfied as 𝑓 is linear. If 𝑥 and 𝑦 are both unit vectors then we assume w.l.o.g. that ∥𝑥 + 𝑦∥ 2 ≥ ∥𝑥 -𝑦 ∥ 2 and we proceed as follows, utilising the polarisation identity: 4⟨𝑢,

$𝑣⟩ = ∥𝑢 + 𝑣∥ 2 2 -∥𝑢 -𝑣 ∥ 2 2 . 4 |︁ |︁ ⟨ 𝑓 (𝑥), 𝑓 (𝑦)⟩ -⟨𝑥, 𝑦⟩ |︁ |︁ = |︁ |︁ ∥ 𝑓 (𝑥) + 𝑓 (𝑦)∥ 2 2 -∥ 𝑓 (𝑥) -𝑓 (𝑦)∥ 2 2 -4⟨𝑥, 𝑦⟩ |︁ |︁ ≤ |︁ |︁ (1 + 𝜀)∥𝑥 + 𝑦∥ 2 2 -(1 -𝜀)∥𝑥 -𝑦∥ 2 2 -4⟨𝑥, 𝑦⟩ |︁ |︁ = |︁ |︁ 4⟨𝑥, 𝑦⟩ + 𝜀(∥𝑥 + 𝑦 ∥ 2 2 + ∥𝑥 -𝑦∥ 2 2 ) -4⟨𝑥, 𝑦⟩ |︁ |︁ = 𝜀(2∥𝑥 ∥ 2 2 + 2∥𝑦 ∥ 2 2 ) = 4𝜀.$Otherwise we can reduce to the unit vector case.

$|⟨ 𝑓 (𝑥), 𝑓 (𝑦)⟩ -⟨𝑥, 𝑦⟩| = |︁ |︁ |︁ |︁ ⟨︂ 𝑓 (︁ 𝑥 ∥𝑥 ∥ 2 )︁ , 𝑓 (︁ 𝑦 ∥ 𝑦∥ 2 )︁ ⟩︂ - ⟨︂ 𝑥 ∥𝑥 ∥ 2 , 𝑦 ∥ 𝑦∥ 2 ⟩︂ |︁ |︁ |︁ |︁ ∥𝑥 ∥ 2 ∥ 𝑦∥ 2 ≤ 𝜀∥𝑥 ∥ 2 ∥ 𝑦∥ 2 .$□ F 8 f Before giving an overview of the development of JLDs in section 1.4, let us return to our scenario and example in section 1.1 and show the wide variety of fields where dimensionality reduction via JLTs have found use. Furthermore, to make us more familiar with lemma 1.1 and its related concepts, we will pick a few examples of how the lemma is used.

## The Use(fulness) of Johnson-Lindenstrauss

JLDs and JLTs have found uses and parallels in many fields and tasks, some of which we will list below. Note that there are some overlap between the following categories, as e.g. [[FB03]](#b71) uses a JLD for an ensemble of weak learners to learn a mixture of Gaussians clustering, and [[PW15]](#b159) solves convex optimisation problems in a way that gives differential privacy guarantees.

Nearest-neighbour search have benefited from the Johnson-Lindenstrauss lemmas on multiple occasions, including [Kle97; KOR00], which used JL to randomly partition space rather than reduce the dimension, while others [AC09; HIM12] used the dimensionality reduction properties of JL more directly. Variations on these results include consructing locality sensitive hashing schemes [[Dat+04]](#b57) and finding nearest neighbours without false negatives [[SW17]](#b182).

Clustering with results in various sub-areas such as mixture of Gaussians [Das99; FB03; UDS07], subspace clustering [HTB17], graph clustering [SI09; Guo+20], self-organising maps [RK89; Kas98], and 𝑘-means [Bec+19; Coh+15; Bou+14; Liu+17; SF18], which will be explained in more detail in section 1.3.1. Outlier detection where there have been works for various settings of outliers, including approximate nearest-neighbours [dVCH10; SZK15] and Gaussian vectors [NC20], while [Zha+20] uses JL as a preprocessor for a range of outlier detection algorithms in a distributed computational model, and [AP12] evaluates the use of JLTs for outlier detection of text documents. Ensemble learning where independent JLTs can be used to generate training sets for weak learners for bagging [SR09] and with the voting among the learners weighted by how well a given JLT projects the data [CS17; Can20]. The combination of JLTs with multiple learners have also found use in the regime of learning high-dimensional distributions from few datapoints (i.e. |𝑋 | ≪ 𝑑) [DK13; ZK19; Niy+20].

Adversarial machine learning where Johnson-Lindenstrauss can both be used to defend against adversarial input [Ngu+16; Wee+19; Tar+19] as well as help craft such attacks [[Li+20]](#b128).

Miscellaneous machine learning where, in addition to the more specific machine learning topics mentioned above, Johnson-Lindenstrauss has been used together with support vector machines [CJS09; Pau+14; LL20], Fisher's linear discriminant [[DK10]](#b64), and neural networks [[Sch18]](#b169), while [[KY20]](#b123) uses JL to facilitate stochastic gradient descent in a distributed setting.

## Numerical linear algebra

with work focusing on low rank approximation [Coh+15; MM20], canonical correlation analysis [Avr+14], and regression in a local [THM17; MM09; Kab14; Sla17] and a distributed [HMM16] computational model. Futhermore, as many of these subfields are related some papers tackle multiple numerical linear algebra problems at once, e.g. low rank approximation, regression, and approximate matrix multiplication [Sar06], and a line of work [MM13; CW17; NN13a] have used JLDs to perform subspace embeddings which in turn gives algorithms for ℓ 𝑝 regression, low rank approximation, and leverage scores. For further reading, there are surveys [Mah11; HMT11; Woo14] covering much of JLDs' use in numerical linear algebra. Convex optimisation in which Johnson-Lindenstrauss has been used for (integer) linear programming [VPL15] and to improve a cutting plane method for finding a point in a convex set using a separation oracle [TSC15; Jia+20]. Additionally, [Zha+13] studies how to recover a high-dimensional optimisation solution from a JL dimensionality reduced one. Differential privacy have utilised Johnson-Lindenstrauss to provide sanitised solutions to the linear algebra problems of variance estimation [Blo+12], regression [She19; SKD19; ZLW09], Euclidean distance estimation [Ken+13; LKR06; GLK13; Tur+08; Xu+17], and low-rank factorisation [Upa18], as well as convex optimisation [PW15; KJ16], collaborative filtering [Yan+17] and solutions to graph-cut queries [Blo+12; Upa13]. Furthermore, [Upa15] analysis various JLDs with respect to differential privacy and introduces a novel one designed for this purpose.

Neuroscience where it is used as a tool to process data in computational neuroscience [GS12; ALG13], but also as a way of modelling neurological processes [GS12; ALG13; All+14; PP14]. Interestingly, there is some evidence [MFL08; SA09; Car+13] to suggest that JL-like operations occur in nature, as a large set of olifactory sensory inputs (projection neurons) map onto a smaller set of neurons (Kenyon cells) in the brains of fruit flies, where each Kenyon cell is connected to a small and seemingly random subset of the projection neurons. This is reminiscent of sparse JL constructions, which will be introduced in section 1.4.1, though I am not neuroscientifically adept enough to judge how far these similarities between biological constructs and randomised linear algebra extend.

Other topics where Johnson-Lindenstrauss have found use include graph sparsification [[SS11]](#b181), graph embeddings in Euclidean spaces [[FM88]](#b76), integrated circuit design [[Vem98]](#b200), biometric authentication [[Arp+14]](#b19), and approximating minimum spanning trees [[HI00]](#b86).

For further examples of Johnson-Lindenstrauss use cases, please see [[Ind01;](#b97)[Vem04]](#b199). Now, let us dive deeper into the areas of clustering and streaming algorithms to see how Johnson-Lindenstrauss can be used there.

## Clustering

Clustering can be defined as partitioning a dataset such that elements are similar to elements in the same partition while being dissimilar to elements in other partitions. A classic clustering problem is the so-called 𝑘-means clustering where the dataset 𝑋 ⊂ R 𝑑 consists of points in Euclidean space. The task is to choose 𝑘 cluster centers 𝑐 1 , . . . , 𝑐 𝑘 such that they minimise the sum of squared distances from datapoints to their nearest cluster center, i.e. arg min

$𝑐 1 ,...,𝑐 𝑘 ∑︂ 𝑥∈𝑋 min 𝑖 ∥𝑥 -𝑐 𝑖 ∥ 2 2 .(6)$This creates a Voronoi partition, as each datapoint is assigned to the partition corresponding to its nearest cluster center. We let 𝑋 𝑖 ⊆ 𝑋 denote the set of points that have 𝑐 𝑖 as their closest center. It is well known that for an optimal choice of centers, the centers are the means of their corresponding partitions, and furthermore, the cost of any choice of centers is never lower than the sum of squared distances from datapoints to the mean of their assigned partition, i.e.

$∑︂ 𝑥∈𝑋 min 𝑖 ∥𝑥 -𝑐 𝑖 ∥ 2 2 ≥ 𝑘 ∑︂ 𝑖=1 ∑︂ 𝑥∈𝑋 𝑖 ∥︁ ∥︁ ∥︁𝑥 - 1 |𝑋 𝑖 | ∑︂ 𝑦∈𝑋 𝑖 𝑦 ∥︁ ∥︁ ∥︁ 2 2 . (7$$)$It has been shown that finding the optimal centers, even for 𝑘 = 2, is NP-hard [Alo+09; Das08]; however, various heuristic approaches have found success such as the commonly used Lloyd's algorithm [[Llo82]](#b132). In Lloyd's algorithm, after initialising the centers in some way we iteratively improve the choice of centers by assigning each datapoint to its nearest center and then updating the center to be the mean of the datapoints assigned to it. These two steps can then be repeated until some termination criterion is met, e.g. when the centers have converged. If we let 𝑡 denote the number of iterations, then the running time becomes 𝒪(𝑡 |𝑋 |𝑘𝑑), as we use 𝒪(|𝑋 |𝑘𝑑) time per iteration to assign each data point to its nearest center. We can improve this running time by quickly embedding the datapoints into a lower dimensional space using a JLT and then running Lloyd's algorithm in this smaller space. The Fast Johnson-Lindenstrauss Transform, which we will introduce later, can for many sets of parameters embed a vector in 𝒪(𝑑 log 𝑑) time reducing the total running time to 𝒪(|𝑋 |𝑑 log 𝑑 + 𝑡|𝑋 |𝑘𝜀 -2 log |𝑋 |). However, for this to be useful we need the partitioning of points in the lower dimensional space to correspond to an (almost) equally good partition in the original higher dimensional space.

In order to prove such a result we will use the following lemma, which shows that the cost of a partitioning, with its centers chosen as the means of the partitions, can be written in terms of pairwise distances between datapoints in the partitions.

$Lemma 1.6. Let 𝑘, 𝑑 ∈ N 1 and 𝑋 𝑖 ⊂ R 𝑑 for10 𝑖 ∈ [𝑘]. 𝑘 ∑︂ 𝑖=1 ∑︂ 𝑥∈𝑋 𝑖 ∥︁ ∥︁ ∥︁𝑥 - 1 |𝑋 𝑖 | ∑︂ 𝑦∈𝑋 𝑖 𝑦 ∥︁ ∥︁ ∥︁ 2 2 = 1 2 𝑘 ∑︂ 𝑖=1 1 |𝑋 𝑖 | ∑︂ 𝑥,𝑦∈𝑋 𝑖 ∥𝑥 -𝑦 ∥ 2 2 .(8)$The proof of lemma 1.6 consists of various linear algebra manipulations and can be found in section 2.1. Now we are ready to prove the following proposition, which states that if we find a partitioning whose cost is within (1 + 𝛾) of the optimal cost in low dimensional space, that partitioning when moving back to the high dimensional space is within (1 + 4𝜀)(1 + 𝛾) of the optimal cost there.

$Proposition 1.7. Let 𝑘, 𝑑 ∈ N 1 , 𝑋 ⊂ R 𝑑 , 𝜀 ≤ 1/2, 𝑚 = Θ(𝜀 -2 log |𝑋 |)$, and 𝑓 : 𝑋 → R 𝑚 be a JLT. Let 𝑌 ⊂ R 𝑚 be the embedding of 𝑋. Let 𝜅 * 𝑚 denote the optimal cost of a partitioning of 𝑌, with respect to eq. (6). Let 𝑌 1 , . . . , 𝑌 𝑘 ⊆ 𝑌 be a partitioning of 𝑌 with cost 𝜅 𝑚 such that 𝜅 𝑚 ≤ (1 + 𝛾)𝜅 * 𝑚 for some 𝛾 ∈ R.

Let 𝜅 * 𝑑 be the cost of an optimal partitioning of 𝑋 and 𝜅 𝑑 be the cost of the partitioning 𝑋 1 , . . . , 𝑋 𝑘 ⊆ 𝑋,

$satisfying 𝑌 𝑖 = { 𝑓 (𝑥) | 𝑥 ∈ 𝑋 𝑖 }. Then 𝜅 𝑑 ≤ (1 + 4𝜀)(1 + 𝛾)𝜅 * 𝑑 .(9)$Proof. Due to lemma 1.6 and the fact that 𝑓 is a JLT we know that the cost of our partitioning is approximately preserved when going back to the high dimensional space, i.e. 𝜅 𝑑 ≤ 𝜅 𝑚 /(1 -𝜀). Furthermore, since the cost of 𝑋's optimal partitioning when embedded down to 𝑌 cannot be lower than the optimal cost of partitioning 𝑌, we can conclude

$𝜅 * 𝑚 ≤ (1 + 𝜀)𝜅 * 𝑑 . Since 𝜀 ≤ 1/2, we have 1/(1 -𝜀) = 1 + 𝜀/(1 -𝜀) ≤ 1 + 2𝜀 and also (1 + 𝜀)(1 + 2𝜀) = (1 + 3𝜀 + 2𝜀 2 ) ≤ 1 + 4𝜀.$Combining these inequalities we get

$𝜅 𝑑 ≤ 1 1 -𝜀 𝜅 𝑚 ≤ (1 + 2𝜀)(1 + 𝛾)𝜅 * 𝑚 ≤ (1 + 2𝜀)(1 + 𝛾)(1 + 𝜀)𝜅 * 𝑑 ≤ (1 + 4𝜀)(1 + 𝛾)𝜅 * 𝑑 .$□ By pushing the constant inside the Θ-notation, proposition 1.7 shows that we can achieve a (1 + 𝜀) approximation11 of 𝑘-means with 𝑚 = Θ(𝜀 -2 log|𝑋 |). However, by more carefully analysing which properties are needed, we can improve upon this for the case where 𝑘 ≪ |𝑋 |. Boutsidis et al. [[Bou+14]](#b36) showed that projecting down to a target dimension of 𝑚 = Θ(𝜀 -2 𝑘) suffices for a slightly worse 𝑘-means approximation factor of (2 + 𝜀). This result was expanded upon in two ways by Cohen et al. [[Coh+15]](#b47), who showed that projecting down to 𝑚 = Θ(𝜀 -2 𝑘) achieves a (1 + 𝜀) approximation ratio, while projecting all the way down to 𝑚 = Θ(𝜀 -2 log 𝑘) still suffices for a (9+𝜀) approximation ratio. The (1+𝜀) case has recently been further improved upon by both Becchetti et al. [[Bec+19]](#b29), who have shown that one can achieve the (1 + 𝜀) approximation ratio for 𝑘-means when projecting down to 𝑚 = Θ

$(︁ 𝜀 -6 (log 𝑘 + log log |𝑋 |) log 𝜀 -1 )︁$, and by Makarychev, Makarychev, and Razenshteyn [[MMR19]](#b144), who independently have proven an even better bound of 𝑚 = Θ (︁

$𝜀 -2 log 𝑘/𝜀 )︁$, essentially giving a "best of worlds" result with respect to [[Coh+15]](#b47).

For an overview of the history of 𝑘-means clustering, we refer the interested reader to [[Boc08]](#b34).

## Streaming

The field of streaming algorithms is characterised by problems where we receive a sequence (or stream) of items and are queried on the items received so far. The main constraint is usually that we only have limited access to the sequence, e.g. that we are only allowed one pass over it, and that we have very limited space, e.g. polylogarithmic in the length of the stream. To make up for these constraints we are allowed to give approximate answers to the queries. The subclass of streaming problems we will look at here are those where we are only allowed a single pass over the sequence and the items are updates to a vector and a query is some statistic on that vector, e.g. the ℓ 2 norm of the vector. More formally, and to introduce the notation, let 𝑑 ∈ N 1 be the number of different items and let 𝑇 ∈ N 1 be the length of the stream of updates (𝑖 𝑗 , 𝑣 𝑗 ) ∈ [𝑑] × R for 𝑗 ∈ [𝑇], and define the vector 𝑥 at time 𝑡 as 𝑥 (𝑡) ≔ ∑︁ 𝑡 𝑗=1 𝑣 𝑗 𝑒 𝑖 𝑗 . A query 𝑞 at time 𝑡 is then a function of 𝑥 (𝑡) , and we will omit the (𝑡) superscript when referring to the current time.

There are a few common variations on this model with respect to the updates. In the cash register model or insertion only model 𝑥 is only incremented by bounded integers, i.e. 𝑣 𝑗 ∈ [𝑀],

for some 𝑀 ∈ N 1 . In the turnstile model, 𝑥 can only be incremented or decremented by bounded integers, i.e. 𝑣 𝑗 ∈ {-𝑀, . . . , 𝑀} for some 𝑀 ∈ N 1 , and the strict turnstile model is as the turnstile model with the additional constraint that the entries of 𝑥 are always non-negative, i.e. 𝑥 (𝑡)

$𝑖 ≥ 0, for all 𝑡 ∈ [𝑇] and 𝑖 ∈ [𝑑].$As mentioned above, we are usually space constrained so that we cannot explicitely store 𝑥 and the key idea to overcome this limitation is to store a linear sketch of 𝑥, that is storing 𝑦 ≔ 𝑓 (𝑥), where 𝑓 : R 𝑑 → R 𝑚 is a linear function and 𝑚 ≪ 𝑑, and then answering queries by applying some function on 𝑦 rather than 𝑥. Note that since 𝑓 is linear, we can apply it to each update individually and compute 𝑦 as the sum of the sketched updates. Furthermore, we can aggregate results from different streams by adding the different sketches, allowing us to distribute the computation of the streaming algorithm.

The relevant Johnson-Lindenstrauss lemma in this setting is lemma 1.2 as with a JLD we get linearity and are able to sample a JLT before seeing any data at the cost of introducing some failure probability.

Based on JLDs, the most natural streaming problem to tackle is second frequency moment estimation in the turnstile model, i.e. approximating ∥𝑥 ∥ 2 2 , which has found use in database query optimisation [Alo+02; WDJ91; DeW+92] and network data analysis [Gil+01; CG05] among other areas. Simply letting 𝑓 be a sample from a JLD and returning ∥ 𝑓 (𝑥)∥ 2 2 on queries, gives a factor (1 ± 𝜀) approximation with failure probability 𝛿 using 𝒪(𝜀 -2 log 1 𝛿 + | 𝑓 |) words12 of space, where | 𝑓 | denotes the words of space needed to store and apply 𝑓 . However, the approach taken by the streaming literature is to estimate ∥𝑥 ∥ 2 2 with constant error probability using 𝒪(𝜀 -2 + | 𝑓 |) words of space, and then sampling 𝒪(log 1 𝛿 ) JLTs 𝑓 1 , . . . , 𝑓 𝒪(log 1/𝛿) : R 𝑑 → R 𝒪(𝜀 -2 ) and responding to a query with median 𝑘 ∥ 𝑓 𝑘 (𝑥)∥ 2 2 , which reduces the error probability to 𝛿. This allows for simpler analyses as well more efficient embeddings (in the case of Count Sketch) compared to using a single bigger JLT, but it comes at the cost of not embedding into ℓ 2 , which is needed for some applications outside of streaming. With this setup the task lies in constructing space efficient JLTs and a seminal work here is the AMS Sketch a.k.a. AGMS Sketch a.k.a. Tug-of-War Sketch [AMS99; Alo+02], whose JLTs can be defined as 𝑓 𝑖 ≔ 𝑚 -1/2 𝐴𝑥, where 𝐴 ∈ {-1, 1} 𝑚×𝑑 is a random matrix. The key idea is that each row 𝑟 of 𝐴 can be backed by a hash function 𝜎 𝑟 : [𝑑] → {-1, 1} that need only be 4-wise independent, meaning that for any set of 4 distinct keys {𝑘 1 , . . . 𝑘 4 } ⊂ [𝑑] and 4 (not necessarily distinct) values 𝑣 1 , . . . 𝑣 4 ∈ {-1, 1}, the probability that the keys hash to those values is

$Pr 𝜎 𝑟 [ ⋀︁ 𝑖 𝜎 𝑟 (𝑘 𝑖 ) = 𝑣 𝑖 ] = |︁ |︁ {-1, 1} |︁ |︁ -4$. This can for instance13 be attained by implementing 𝜎 𝑟 as 3rd degree polynomial modulus a sufficiently large prime with random coefficients [[WC81]](#b203), and so such a JLT need only use 𝒪(𝜀 -2 ) words of space. Embedding a scaled standard unit vector with such a JLT takes 𝒪(𝜀 -2 ) time leading to an overall update time of the AMS Sketch of 𝒪(𝜀 -2 log 1 𝛿 ). A later improvement of the AMS Sketch is the so-called Fast-AGMS Sketch [CG05] a.k.a. Count Sketch [CCF04; TZ12], which sparsifies the JLTs such that each column in their matrix representations only has one non-zero entry. Each JLT can be represented by a pairwise independent hash function ℎ : [𝑑] → [𝒪(𝜀 -2 )] to choose the position of each nonzero entry and a 4-wise independent hash function 𝜎 : [𝑑] → {-1, 1} to choose random signs as before.

This reduces the standard unit vector embedding time to 𝒪(1) and so the overall update time becomes 𝒪(log 1 𝛿 ) for Count Sketch. It should be noted that the JLD inside Count Sketch is also known as Feature Hashing, which we will return to in section 1.4.1.

Despite not embedding into ℓ 2 , due to the use of the non-linear median, AMS Sketch and Count Sketch approximately preserve dot products similarly to corollary 1.5 [CG05, Theorem 2.1 and Theorem 3.5]. This allows us to query for the (approximate) frequency of any particular item as median

$𝑘 ⟨ 𝑓 𝑘 (𝑥), 𝑓 𝑘 (𝑒 𝑖 )⟩ = ⟨𝑥, 𝑒 𝑖 ⟩ ± 𝜀∥𝑥∥ 2 ∥𝑒 𝑖 ∥ 2 = 𝑥 𝑖 ± 𝜀∥𝑥∥ 2$with probability at least 1 -𝛿. This can be extended to finding frequent items in an insertion only stream [[CCF04]](#b43). The idea is to use a slightly larger14 Count Sketch instance to maintain a heap of the 𝑘 approximately most frequent items of the stream so far. That is, if we let 𝑖 𝑘 denote the 𝑘th most frequent item (i.e.

## |︁ |︁ {𝑗 | 𝑥 𝑗 ≥ 𝑥 𝑖 𝑘 }

|︁ |︁ = 𝑘), then with probability 1 -𝛿 we have 𝑥 𝑗 > (1 -𝜀)𝑥 𝑖 𝑘 for every item 𝑗 in our heap.

For more on streaming algorithms, we refer the reader to [[Mut05]](#b146) and [[Nel11]](#b148), which also relates streaming to Johnson-Lindenstrauss.

## The Tapestry of Johnson-Lindenstrauss Transforms

Isti mirant stella -Scene 32, The Bayeux Tapestry [[Unk70]](#b195) As mentioned in section 1.2, the original JLD from [[JL84]](#b103) is a distribution over functions 𝑓 : R 𝑑 → R 𝑚 , where15 𝑓 (𝑥) = (𝑑/𝑚) 1/2 𝐴𝑥 and 𝐴 is a random 𝑚 × 𝑑 matrix whose rows form an orthonormal basis of some 𝑚-dimensional subspace of R 𝑑 , i.e. the rows are unit vectors and pairwise orthogonal. While Johnson and Lindenstrauss [[JL84]](#b103) showed that 𝑚 = Θ(𝜀 -2 log |𝑋 |) suffices to prove lemma 1.1, they did not give any bounds on the constant in the big-𝒪 expression. This was remedied in [[FM88]](#b76), which proved that 𝑚 = 

## ⌉︁

. The next thread of JL research worked on simplifying the JLD constructions as Indyk and Motwani [[HIM12]](#b87) showed that sampling each entry in the matrix i.i.d. from a properly scaled Gaussian distribution is a JLD. The rows of such a matrix do not form a basis as they are with high probability not orthogonal; however, the literature still refer to this and most other JLDs as random projections. Shortly thereafter Arriaga and Vempala [AV06] constructed a JLD by sampling i.i.d. from a Rademacher16 distribution, and Achlioptas [[Ach03]](#b3) sparsified 14 Rather than each JLT having a target dimension of 𝒪(𝜀 -2 ), the analysis needs the target dimension to be

$𝒪 (︂ ∥ tail 𝑘 (𝑥)∥ 2 2 (𝜀𝑥 𝑖 𝑘 ) 2 )︂$, where tail 𝑘 (𝑥) denotes 𝑥 with its 𝑘 largest entries zeroed out.

the Rademacher construction such that the entries 𝑎 𝑖𝑗 are sampled i.i.d. with Pr[𝑎 𝑖𝑗 = 0] = 2/3 and Pr[𝑎 𝑖𝑗 = -1] = Pr[𝑎 𝑖𝑗 = 1] = 1/6. We will refer to such sparse i.i.d. Rademacher constructions as Achlioptas constructions. The Gaussian and Rademacher results have later been generalised [Mat08; IN07; KM05] to show that a JLD can be constructed by sampling each entry in a 𝑚 × 𝑑 matrix i.i.d. from any distribution with mean 0, variance 1, and a subgaussian tail17. It should be noted that these developments have a parallel in the streaming literature as the previously mentioned AMS Sketch [AMS99; Alo+02] is identical to the Rademacher construction [[AV06]](#b20), albeit with constant error probability.

As for the target dimension for these constructions, [[HIM12]](#b87) proved that the Gaussian

$construction is a JLD if 𝑚 ≥ 8(𝜀 2 -2𝜀 3 /3) -1 (︁ ln |𝑋 | + 𝒪(log 𝑚)$)︁

, which roughly corresponds to an additional additive 𝒪(𝜀 -2 log log |𝑋 |) term over the original construction. This additive log log term was shaved off by the proof in [[DG02]](#b61), which concerns itself with the original JLD construction but can easily18 be adapted to the Gaussian construction, and the proof in [[AV06]](#b20), which also give the same log log free bound for the dense Rademacher construction. Achlioptas [[Ach03]](#b3) showed that his construction also achieves

$𝑚 = ⌈︁ 8(𝜀 2 -2𝜀 3 /3) -1 ln |𝑋 |$
## ⌉︁

. The constant of 8 has been improved for the Gaussian and dense Rademacher constructions in the sense that Rojo and Nguyen [RN10; Ngu09] have been able to replace the bound with more intricate19 expressions, which yield a 10 to 40 % improvement for many sets of parameters. However, in the distributional setting it has been shown in [[BGK18]](#b30) that 𝑚 ≥ 4𝜀 -2 ln 1 𝛿 (1 -𝑜(1)) is necessary for any JLD to satisfy lemma 1.2, which corresponds to a constant of 8 if we prove lemma 1.1 the usual way by setting 𝛿 = 𝑛 -2 and union bounding over all pairs of vectors.

There seems to have been some confusion in the literature regarding the improvements in target dimension. The main pitfall was that some papers [e.g. Ach03; HIM12; DG02; RN10; BGK18] were only referring to [[FM88]](#b76) when referring to the target dimension bound of the original construction. As such, [Ach03; HIM12] mistakenly claim to improve the constant for the target dimension with their constructions. Furthermore, [[Ach01]](#b2) is sometimes [e.g. in AC09; Mat08; Sch18] the only work credited for the Rademacher construction, despite it being developed independently and published 2 years prior in [[AV99]](#b21).

All the constructions that have been mentioned so far in this section, embed a vector by performing a relatively dense and unstructured matrix-vector multiplication, which takes Θ(𝑚∥𝑥 ∥ 0 ) = 𝒪(𝑚𝑑) time20 to compute. This sparked two distinct but intertwined strands of research seeking to reduce the embedding time, namely the sparsity-based JLDs which dealt with the density of the embedding matrix and the fast Fourier transform-based which introduced more structure to the matrix. 17 A real random variable 𝑋 with mean 0 has a subgaussian tail if there exists constants 𝛼, 𝛽 > 0 such that for all 𝜆 > 0, Pr

$[︁ |𝑋 | > 𝜆 ]︁ ≤ 𝛽𝑒 -𝛼𝜆 2$. 18 The main part of the proof in [[DG02]](#b61) is showing that the ℓ 2 norm of a vector of i.i.d. Gaussians is concentrated around the expected value. A vector projected with the Gaussian construction is distributed as a vector of i.i.d. Gaussians. 19 For example, one of the bounds for the Rademacher construction is 𝑚 ≥ and [Φ](#) -1 is the quantile function of the standard Gaussian random variable.

$2(𝑑-1)𝛼 2 𝑑𝜀 2 , where 𝛼 ≔ 𝑄+ √ 𝑄 2 +5.98 2 , 𝑄 ≔ Φ -1 (1 -1/|𝑋 | 2 ),$20 ∥𝑥 ∥ 0 is the number of nonzero entries in the vector 𝑥.

## Sparse Johnson-Lindenstrauss Transforms

The simple fact underlying the following string of results is that if 𝐴 has 𝑠 nonzero entries per column, then 𝑓 (𝑥) = 𝐴𝑥 can be computed in Θ(𝑠 ∥𝑥∥ 0 ) time. The first result here is the Achlioptas construction [Ach03] mentioned above, whose column sparsity 𝑠 is 𝑚/3 in expectancy, which leads to an embedding time that is a third of the full Rademacher construction21. However, the first superconstant improvement is due to Dasgupta, Kumar, and Sarlós [[DKS10]](#b66), who based on heuristic approaches [Wei+09; Shi+09b; LLS07; GD08] constructed a JLD with 𝑠 = 𝒪(𝜀 -1 log 1 𝛿 log 2 𝑚 𝛿 ). Their construction, which we will refer to as the DKS construction, works by sampling 𝑠 hash functions ℎ 1 , . . . , ℎ 𝑠 : [𝑑] → {-1, 1} × [𝑚] independently, such that each source entry 𝑥 𝑖 will be hashed to 𝑠 random signs 𝜎 𝑖,1 , . . . , 𝜎 𝑖,𝑠 and 𝑠 target coordinates 𝑗 𝑖,1 , . . . , 𝑗 𝑖,𝑠 (with replacement). The embedding can then be defined as 𝑓 (𝑥) ≔ ∑︁ 𝑖 ∑︁ 𝑘 𝑒 𝑗 𝑖,𝑘 𝜎 𝑖,𝑘 𝑥 𝑖 , which is to say that every source coordinate is hashed to 𝑠 output coordinates and randomly added to or subtracted from those output coordinates. The sparsity analysis was later tightened to show that 𝑠 = 𝒪(𝜀 -1 log 1 𝛿 log 𝑚 𝛿 ) suffices [KN10; KN14] and even 𝑠 = 𝒪

$(︂ 𝜀 -1 (︁ log 1 𝛿 log log log 1 𝛿 log log 1 𝛿 )︁ 2 )︂$suffices for the DKS construction assuming 𝜀 < log -2 1 𝛿 [[BOR10]](#b35), while [[KN14]](#b119) showed that 𝑠 = Ω(𝜀 -1 log 2 1 𝛿 /log 2 1 𝜀 ) is neccessary for the DKS construction. Kane and Nelson [[KN14]](#b119) present two constructions that circumvent the DKS lower bound by ensuring that the hash functions do not collide within a column, i.e. 𝑗 𝑖,𝑎 ≠ 𝑗 𝑖,𝑏 for all 𝑖, 𝑎, and 𝑏. The first construction, which we will refer to as the graph construction, simply samples the 𝑠 coordinates without replacement. The second construction, which we will refer to as the block construction, partitions the output vector into 𝑠 consecutive blocks of length 𝑚/𝑠 and samples one output coordinate per block. Note that the block construction is the same as Count Sketch from the streaming literature [CG05; CCF04], though the hash functions differ and the output is interpreted differently. Kane and Nelson [[KN14]](#b119) prove that 𝑠 = Θ(𝜀 -1 log 1 𝛿 ) is both neccessary and sufficient in order for their two constructions to satisfy lemma 1.2. Note that while Count Sketch is even sparser than the lower bound for the block construction, it does not contradict it as Count sketch does not embed into ℓ 𝑚 2 as it computes the median, which is nonlinear. As far as general sparsity lower bounds go, [[DKS10]](#b66) shows that an average column sparsity of

$𝑠 avg = Ω (︁ min{𝜀 -2 , 𝜀 -1 √︁ log 𝑚 𝑑} )︁$is neccessary for a sparse JLD, while Nelson and Nguyê ˜n [[NN13b]](#b153) improves upon this by showing that there exists a set of points 𝑋 ∈ R 𝑑 such that any JLT for that set must have column sparsity 𝑠 = Ω(𝜀 -1 log |𝑋 |/log 1 𝜀 ) in order to satisfy lemma 1.1. And so it seems that we have almost reached the limit of the sparse JL approach, but why should theory be in the way of a good result? Let us massage the definitions so as to get around these lower bounds.

The hard instances used to prove the lower bounds [NN13b; KN14] consist of very sparse vectors, e.g. 𝑥 = (1/ √ 2, 1/ √ 2, 0, . . . , 0) ᵀ , but the vectors we are interested in applying a JLT to might not be so unpleasant, and so by restricting the input vectors to be sufficiently "nice", we can get meaningful result that perform better than what the pessimistic lower bound would indicate. The formal formulation of this niceness is bounding the ℓ ∞ /ℓ 2 ratio of the vectors lemmas 1.1 and 1.2 need apply to. Let us denote this norm ratio as 𝜈 ∈ [1/ √ 𝑑, 1], and revisit some of the sparse JLDs. The Achlioptas construction [[Ach03]](#b3) can be generalised so that the expected number of nonzero entries per column is 𝑞𝑚 rather than 1 3 𝑚 for a parameter 𝑞 ∈ [0, 1]. Ailon and Chazelle [[AC09]](#b1) show that if 𝜈 = 𝒪 (︁ √︂

$log 1 𝛿 / √ 𝑑 )︁ then choosing 𝑞 = Θ (︁ log 2 1/𝛿 𝑑 )︁$and sampling the nonzero entries from a Gaussian distribution suffices. This result is generalised in [[Mat08]](#b139) by proving that for all 𝜈 ∈ [1/ √ 𝑑, 1] choosing 𝑞 = Θ(𝜈 2 log 𝑑 𝜀𝛿 ) and sampling the nonzero entries from a Rademacher distribution is a JLD for the vectors constrained by that 𝜈.

Be aware that sometimes [e.g. in DKS10; BOR10] this bound22 on 𝑞 is misinterpreted as a lower bound stating that 𝑞𝑚 = Ω ˜(𝜀 -2 ) is neccessary for the Achlioptas construction when 𝜈 = 1. However, Matoušek [[Mat08]](#b139) only loosely argues that his bound is tight for 𝜈 ≤ 𝑑 -0.1 , and if it indeed was tight at 𝜈 = 1, the factors hidden by the Ω ˜would lead to the contradiction that 𝑚 ≥ 𝑞𝑚 = Ω(𝜀 -2 log 1 𝛿 log 𝑑 𝜀𝛿 ) = 𝜔(𝑚). The heuristic [Wei+09; Shi+09b; LLS07; GD08] that [DKS10] is based on is called Feature Hashing a.k.a. the hashing trick a.k.a. the hashing kernel and is a sparse JL construction with exactly 1 nonzero entry per column23. The block construction can then be viewed as the concatenation of 𝑠 = Θ(𝜀 -1 log 1 𝛿 ) feature hashing instances, and the DKS construction can be viewed as the sum of 𝑠 = 𝒪(𝜀 -1 log 1 𝛿 log 𝑚 𝛿 ) Feature Hashing instances or alternatively as first duplicating each entry of 𝑥 ∈ R 𝑑 𝑠 times before applying Feature Hashing to the enlarged vector 𝑥 ′ ∈ R 𝑠𝑑 : Let 𝑓 dup : R 𝑑 → R 𝑠𝑑 be a function that duplicates each entry in its input 𝑠 times, i.e.

$𝑓 dup (𝑥) (𝑖-1)𝑠+𝑗 = 𝑥 ′ (𝑖-1)𝑠+𝑗 ≔ 𝑥 𝑖 for 𝑖 ∈ [𝑑], 𝑗 ∈ [𝑠], then 𝑓 DKS = 𝑓 FH • 𝑓 dup .$This duplication is the key to the analysis in [[DKS10]](#b66) as 𝑓 dup is isometric (up to normalisation) and it ensures that the ℓ ∞ /ℓ 2 ratio of 𝑥 ′ is small, i.e. 𝜈 ≤ 1/

## √

𝑠 from the point of view of the Feature Hashing data structure ( 𝑓 FH ). And so, any lower bound on the sparsity of the DKS construction (e.g. the one given in [[KN14]](#b119)) gives an upper bound on the values of 𝜈 for which Feature Hashing is a JLD: If 𝑢 is a unit vector such that a DKS instance with sparsity 𝑠 ˆfails to preserve 𝑢s norm within 1 ± 𝜀 with probability 𝛿, then it must be the case that Feature Hashing fails to preserve the norm of 𝑓 dup (𝑢) within 1 ± 𝜀 with probability 𝛿, and therefore the ℓ ∞ /ℓ 2 ratio for which Feature Hashing can handle all vectors is strictly less than 1/ √ 𝑠 ˆ.

Written more concisely the statement is

$𝑠 DKS = Ω(𝑎) =⇒ 𝜈 FH = 𝒪(1/ √ 𝑎) and by contraposi- tion24 𝜈 FH = Ω(1/ √ 𝑎) =⇒ 𝑠 DKS = 𝒪(𝑎)$, where 𝑠 DKS is the minimum column sparsity of a DKS construction that is a JLD, 𝜈 FH is the maximum ℓ ∞ /ℓ 2 constraint for which Feature Hashing is a JLD, and 𝑎 is any positive expression. Furthermore, if we prove an upper bound on 𝜈 FH using a hard instance that is identical to an 𝑥 ′ that the DKS construction can generate after duplication, we can replace the previous two implications with bi-implications.

[Wei+09] claims to give a bound on 𝜈 FH , but it sadly contains an error in its proof of this bound [DKS10; Wei+10]. Dahlgaard, Knudsen, and Thorup [[DKT17]](#b67) improve the 𝜈 FH lower bound to

$𝜈 FH = Ω (︂ √︃ 𝜀 log(1+ 4 𝜀 ) log 1 𝛿 log 𝑚 𝛿 )︂$, and Freksen, Kamma, and Larsen [[FKL18]](#b72) give an intricate but tight bound for 𝜈 FH shown in theorem 1.8, where the hard instance used to prove the upper 22 Which seems to be the only thing in [[Mat08]](#b139) related to a bound on 𝑞. 23 i.e. the DKS, graph, or block construction with 𝑠 = 1. 24 Contraposition is (𝑃 =⇒ 𝑄) =⇒ (¬𝑄 =⇒ ¬𝑃) and it does not quite prove what was just claimed without some assumptions that 𝑠 DKS , 𝜈 FH , and 𝑎 do not behave too erratically.

bound is identical to an 𝑥 ′ from the DKS construction.

## Theorem 1.8 ([FKL18]

). There exist constants 𝐶 ≥ 𝐷 > 0 such that for every 𝜀, 𝛿 ∈ (0, 1) and 𝑚 ∈ N 1 the following holds. If

$𝐶 lg 1 𝛿 𝜀 2 ≤ 𝑚 < 2 𝜀 2 𝛿 then 𝜈 FH (𝑚, 𝜀, 𝛿) = Θ (︃ √ 𝜀 min {︂ log 𝜀𝑚 log 1 𝛿 log 1 𝛿 , ⌜ ⃓ ⎷ log 𝜀 2 𝑚 log 1 𝛿 log 1 𝛿 }︂ )︃ . Otherwise, if 𝑚 ≥ 2 𝜀 2 𝛿 then 𝜈 FH (𝑚, 𝜀, 𝛿) = 1. Moreover if 𝑚 < 𝐷 lg 1 𝛿 𝜀 2 then 𝜈 FH (𝑚, 𝜀, 𝛿) = 0. Furthermore, if an 𝑥 ∈ {0, 1} 𝑑 satisfies 𝜈 FH < ∥𝑥∥ -1 2 < 1 then Pr 𝑓 ∼FH [︂ |︁ |︁ ∥ 𝑓 (𝑥)∥ 2 2 -∥𝑥∥ 2 2 |︁ |︁ > 𝜀∥𝑥 ∥ 2 2 ]︂ > 𝛿.$This bound gives a tight tradeoff between target dimension 𝑚, distortion 𝜀, error probability 𝛿, and ℓ ∞ /ℓ 2 constraint 𝜈 for Feature Hashing, while showing how to construct hard instances for Feature Hashing: Vectors with the shape 𝑥 = (1, . . . , 1, 0, . . . , 0) ᵀ are hard instances if they contain few 1s, meaning that Feature Hashing cannot preserve their norms within 1 ± 𝜀 with probability 𝛿. Theorem 1.8 is used in corollary 1.9 to provide a tight tradeoff between 𝑚, 𝜀, 𝛿, 𝜈, and column sparsity 𝑠 for the DKS construction.

Corollary 1.9. Let 𝜈 DKS ∈ [1/ √ 𝑑, 1] denote the largest ℓ ∞ /ℓ 2 ratio required, 𝜈 FH denote the ℓ ∞ /ℓ 2 constraint for Feature Hashing as defined in theorem 1.8, and 𝑠 DKS ∈ [𝑚] as the minimum column sparsity such that the DKS construction with that sparsity is a JLD for the subset of vectors 𝑥 ∈ R 𝑑 that satisfy ∥𝑥∥ ∞ /∥𝑥 ∥ 2 ≤ 𝜈 DKS . Then

$𝑠 DKS = Θ (︂ 𝜈 2 DKS 𝜈 2 FH )︂ .$The proof of this corollary is deferred to section 2.2. Jagadeesan [[Jag19]](#b98) generalised the result from [[FKL18]](#b72) to give a lower bound25 on the 𝑚, 𝜀, 𝛿, 𝜈, and 𝑠 tradeoff for any sparse Rademacher construction with a chosen column sparsity, e.g. the block and graph constructions, and gives a matching upper bound for the graph construction.

## Structured Johnson-Lindenstrauss Transforms

As we move away from the sparse JLDs we will slightly change our idea of what an efficient JLD is. In the previous section the JLDs were especially fast when the vectors were sparse, as the running time scaled with ∥𝑥∥ 0 , whereas we in this section will optimise for dense input vectors such that an embedding time of 𝒪(𝑑 log 𝑑) is a satisfying result.

The chronologically first asymptotic improvement over the original JLD construction is due to Ailon and Chazelle [[AC09]](#b1) who introduced the so-called Fast Johnson-Lindenstrauss Transform (FJLT). As mentioned in the previous section, [[AC09]](#b1) showed that we can use a very sparse (and therefore very fast) embedding matrix as long as the vectors have a low ℓ ∞ /ℓ 2 ratio, and furthermore that applying a randomised Walsh-Hadamard transform to a vector results in a low ℓ ∞ /ℓ 2 ratio with high probability. And so, the FJLT is defined as 𝑓 (𝑥) ≔ 𝑃𝐻𝐷𝑥, where 𝑃 ∈ R 𝑚×𝑑 is a sparse Achlioptas matrix with Gaussian entries and 𝑞 = Θ (︁ log 2 1/𝛿 𝑑 )︁

, 𝐻 ∈ {-1, 1} 𝑑×𝑑 is a Walsh-Hadamard matrix26, and 𝐷 ∈ {-1, 0, 1} 𝑑×𝑑 is a random diagonal matrix with i.i.d. Rademachers on the diagonal. As the Walsh-Hadamard transform can be computed using a simple recursive formula, the expected embedding time becomes 𝒪(𝑑 log 𝑑 + 𝑚 log 2 1 𝛿 ). And as mentioned, [[Mat08]](#b139) showed that we can sample from a Rademacher rather than a Gaussian distribution when constructing the matrix 𝑃. The embedding time improvement of FJLT over previous constructions depends on the relationship between 𝑚 and 𝑑. If 𝑚 = Θ(𝜀 -2 log 1 𝛿 ) and 𝑚 = 𝒪(𝜀 -4/3 𝑑 1/3 ), FJLT's embedding time becomes bounded by the Walsh-Hadamard transform at 𝒪(𝑑 log 𝑑), but at 𝑚 = Θ(𝑑 1/2 ) FJLT is only barely faster than the original construction.

Ailon and Liberty [[AL09]](#b8) improved the running time of the FJLT construction to 𝒪(𝑑 log 𝑚) for 𝑚 = 𝒪(𝑑 1/2-𝛾 ) for any fixed 𝛾 > 0. The increased applicable range of 𝑚 was achieved by applying multiple randomised Walsh-Hadamard transformations, i.e. replacing 𝐻𝐷 with ∏︁ 𝑖 𝐻𝐷 (𝑖) , where the 𝐷 (𝑖) s are a constant number of independent diagonal Rademacher matrices, as well as by replacing 𝑃 with 𝐵𝐷 where 𝐷 is yet another diagonal matrix with Rademacher entries and 𝐵 is consecutive blocks of specific partial Walsh-Hadamard matrices (based on so-called binary dual BCH codes [see e.g. MS77]). The reduction in running time comes from altering the transform slightly by partitioning the input into consecutive blocks of length poly(𝑚) and applying the randomised Walsh-Hadamard transforms to each of them independently. We will refer to this variant of FJLT as the BCHJL construction.

The next pattern of results has roots in compressed sensing and approaches the problem from another angle: Rather than being fast only when 𝑚 ≪ 𝑑, they achieve 𝒪(𝑑 log 𝑑) embedding time even when 𝑚 is close to 𝑑, at the cost of 𝑚 being suboptimal. Before describing these constructions, let us set the scene by briefly introducing some concepts from compressed sensing.

Roughly speaking, compressed sensing concerns itself with recovering a sparse signal via a small number of linear measurements and a key concept here is the Restricted Isometry Property [CT05; CT06; CRT06; Don06]. Definition 1.10 (Restricted Isometry Property). Let 𝑑, 𝑚, 𝑘 ∈ N 1 with 𝑚, 𝑘 < 𝑑 and 𝜀 ∈ (0, 1). A linear function 𝑓 : R 𝑑 → R 𝑚 is said to have the Restricted Isometry Property of order 𝑘 and level 𝜀 (which we will denote as

$(𝑘, 𝜀)-RIP) if for all 𝑥 ∈ R 𝑑 with ∥𝑥∥ 0 ≤ 𝑘, |︁ |︁ ∥ 𝑓 (𝑥)∥ 2 2 -∥𝑥 ∥ 2 2 |︁ |︁ ≤ 𝜀∥𝑥 ∥ 2 2 .(10)$In the compressed sensing literature it has been shown [CT06; RV08] that the subsampled Hadamard transform (SHT) defined as 𝑓 (𝑥) ≔ 𝑆𝐻𝑥, has the (𝑘, 𝜀)-RIP with high probability 26 One definition of the Walsh-Hadamard matrices is that the entries are 𝐻 𝑖𝑗 = (-1) ⟨𝑖-1,𝑗-1⟩ for all 𝑖, 𝑗 ∈ [𝑑], where ⟨𝑎, 𝑏⟩ denote the dot product of the (lg 𝑑)-bit vectors corresponding to the binary representation of the numbers 𝑎, 𝑏 ∈ {0, . . . , 𝑑 -1}, and 𝑑 is a power of two. To illustrate its recursive nature, a large Walsh-Hadamard matrix can be described as a Kronecker product of smaller Walsh-Hadamard matrices, i.e. if 𝑑 > 2 and 𝐻 (𝑛) refers to a 𝑛 × 𝑛 Walsh-Hadamard matrix, then

$𝐻 (𝑑) = 𝐻 (2) ⊗ 𝐻 (𝑑/2) = (︃ 𝐻 (𝑑/2) 𝐻 (𝑑/2) 𝐻 (𝑑/2) -𝐻 (𝑑/2) )︃ . ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 𝑡 0 𝑡 1 𝑡 2 • • • 𝑡 𝑑-1 𝑡 -1 𝑡 0 𝑡 1 • • • 𝑡 𝑑-2 𝑡 -2 𝑡 -1 𝑡 0 • • • 𝑡 𝑑-3 . . . . . . . . . . . . . . . 𝑡 -(𝑚-1) 𝑡 -(𝑚-2) 𝑡 -(𝑚-3) • • • 𝑡 𝑑-𝑚 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ Figure 1:$The structure of a Toeplitz matrix.

for

$𝑚 = Ω (︁ 𝜀 -2 𝑘 log 4 𝑑$)︁

while allowing a vector to be embedded in 𝒪(𝑑 log 𝑑) time. Here 𝐻 ∈ {-1, 1} 𝑑×𝑑 is the Walsh-Hadamard matrix and 𝑆 ∈ {0, 1} 𝑚×𝑑 samples 𝑚 entries of 𝐻𝑥 with replacement, i.e. each row in 𝑆 has one non-zero entry per row, which is chosen uniformly and independently, i.e. 𝑆 is a uniformly random feature selection matrix. Inspired by this transform and the FJLT mentioned previously, Ailon and Liberty [[AL13]](#b10) were able to show that the subsampled randomised Hadamard transform (SRHT) defined as 𝑓 (𝑥) ≔ 𝑆𝐻𝐷𝑥, is a JLT if 𝑚 = Θ(𝜀 -4 log |𝑋 | log 4 𝑑). Once again 𝐷 denotes a random diagonal matrix with Rademacher entries, and 𝑆 and 𝐻 is as in the SHT. Some related results include Do et al. [[Do+09]](#b68) who before [[AL13]](#b10) were able to get a bound of 𝑚 = Θ(𝜀 -2 log 3 |𝑋 |) in the large set case where |𝑋 | ≥ 𝑑, [[Tro11]](#b187) which showed how the SRHT construction approximately preserves the norms of a subspace of vectors, and [[LL20]](#b131) which modified the sampling matrix 𝑆 to improve precision when used as a preprocessor for support vector machines (SVMs) by sacrificing input data independence.

This target dimension bound of [[AL13]](#b10) was later tightened by Krahmer and Ward [[KW11]](#b122), who showed that 𝑚 = Θ(𝜀 -2 log |𝑋 | log 4 𝑑) suffices for the SRHT. This was a corollary of a more general result, namely that if 𝜎 : R 𝑑 → R 𝑑 applies random signs equivalently to the 𝐷 matrices mentioned previously and 𝑓 : R 𝑑 → R 𝑚 has the (︁

$Ω(log |𝑋 |), 𝜀/4$)︁

-RIP then 𝑓 • 𝜎 is a JLT with high probability. An earlier result by Baraniuk et al. [[Bar+08]](#b26) showed that a transform sampled from a JLD has the (︁ 𝒪(𝜀 2 𝑚/log 𝑑), 𝜀 )︁ -RIP with high probability. And so, as one might have expected from their appearance, the Johnson-Lindenstrauss Lemma and the Restricted Isometry Property are indeed cut from the same cloth.

Another transform from the compressed sensing literature uses so-called Toeplitz or partial circulant matrices [Baj+07; Rau09; Rom09; Hau+10; RRT12; Baj12; DJR19], which can be defined in the following way. For 𝑚, 𝑑 ∈ N 1 we say that 𝑇 ∈ R 𝑚×𝑑 is a real Toeplitz matrix if there exists 𝑡 -(𝑚-1) , 𝑡 -(𝑚-2) . . . , 𝑡 𝑑-1 ∈ R such that 𝑇 𝑖𝑗 = 𝑡 𝑗-𝑖 . This has the effect that the entries on any one diagonal are the same (see fig. [1](#fig_1)) and computing the matrix-vector product corresponds to computing the convolution with a vector of the 𝑡s. Partial circulant matrices are special cases of Toeplitz matrices where the diagonals "wrap around" the ends of the matrix, i.e. 𝑡 -𝑖 = 𝑡 𝑑-𝑖 for all 𝑖 ∈ [𝑚 -1].

As a JLT, the Toeplitz construction is 𝑓 (𝑥) ≔ 𝑇𝐷𝑥, where 𝑇 ∈ {-1, 1} 𝑚×𝑑 is a Toeplitz matrix with i.i.d. Rademacher entries and 𝐷 ∈ {-1, 0, 1} 𝑑×𝑑 is a diagonal matrix with Rademacher entries as usual. Note that the convolution of two vectors corresponds to the entrywise product in Fourier space, and we can therefore employ fast Fourier transform (FFT) to embed a vector with the Toeplitz construction in time 𝒪(𝑑 log 𝑑). This time can even be reduced to 𝒪(𝑑 log 𝑚) as we realise that by partitioning 𝑇 into 𝑑 𝑚 consecutive blocks of size 𝑚 × 𝑚, each block is also a Toeplitz matrix, and by applying each individually the embedding time becomes 𝒪( 𝑑 𝑚 𝑚 log 𝑚). Combining the result from [[KW11]](#b122) with RIP bounds for Toeplitz matrices [[RRT12]](#b164) gives that 𝑚 = Θ (︁

$𝜀 -1 log 3/2 |𝑋 | log 3/2 𝑑 + 𝜀 -2 log |𝑋 | log 4 𝑑 )︁$is sufficient for the Toeplitz construction to be a JLT with high probability. However, the Toeplitz construction has also been studied directly as a JLD without going via its RIP bounds. Hinrichs and Vybíral [[HV11]](#b94) showed that 𝑚 = Θ(𝜀 -2 log 3 1 𝛿 ) is sufficient for the Toeplitz construction, and this bound was improved shortly thereafter in [[Vyb11]](#b202) to 𝑚 = Θ(𝜀 -2 log 2 1 𝛿 ). The question then is if we can tighten the analysis to shave off the last log factor and get the elusive result of a JLD with optimal target dimension and 𝒪(𝑑 log 𝑑) embedding time even when 𝑚 is close to 𝑑. Sadly, this is not the case as Freksen and Larsen [[FL20]](#b74) showed that there exists vectors27 that necessitates 𝑚 = Ω(𝜀 -2 log 2 1 𝛿 ) for the Toeplitz construction.

Just as JLTs are used as preprocessors to speed up algorithms that solve the problems we actually care about, we can also use a JLT to speed up other JLTs in what one could refer to as compound JLTs. More explicitely if 𝑓 1 : R 𝑑 → R 𝑑 ′ and 𝑓 2 : R 𝑑 ′ → R 𝑚 with 𝑚 ≪ 𝑑 ′ ≪ 𝑑 are two JLTs and computing 𝑓 1 (𝑥) is fast, we could hope that computing ( 𝑓 2 • 𝑓 1 )(𝑥) is fast as well as 𝑓 2 only need to handle 𝑑 ′ dimensional vectors and hope that ( 𝑓 2 • 𝑓 1 ) preserves the norm sufficiently well since both 𝑓 1 and 𝑓 2 approximately preserve norms individually. As presented here, the obvious candidate for 𝑓 1 is one of the RIP-based JLDs, which was succesfully applied in [[BK17]](#b31). In their construction, which we will refer to as GRHD28, 𝑓 1 is the SRHT and 𝑓 2 is the dense Rademacher construction (i.e. 𝑓 (𝑥) ≔ 𝐴 Rad 𝑆𝐻𝐷𝑥), and it can embed a vector in time 𝒪(𝑑 log 𝑚) for 𝑚 = 𝒪(𝑑 1/2-𝛾 ) for any fixed 𝛾 > 0. This is a similar result to the construction of Ailon and Liberty [[AL09]](#b8), but unlike that construction, GRHD handles the remaining range of 𝑚 more gracefully as for any 𝑟 ∈ [1/2, 1] and 𝑚 = 𝒪(𝑑 𝑟 ), the embedding time for GRHD becomes 𝒪(𝑑 2𝑟 log 4 𝑑). However the main selling point of the GRHD construction is that it allows the simultaneous embedding of sufficiently large sets of points 𝑋 to be computed in total time 𝒪(|𝑋 |𝑑 log 𝑚), even when 𝑚 = Θ(𝑑 1-𝛾 ) for any fixed 𝛾 > 0, by utilising fast matrix-matrix multiplication techniques [[LR83]](#b135). Another compound JLD is based on the so-called lean Walsh transforms (LWT) [[LAS11]](#b126),

which are defined based on so-called seed matrices. For 𝑟, 𝑐 ∈ N 1 we say that 𝐴 1 ∈ C 𝑟×𝑐 is a seed matrix if 𝑟 < 𝑐, its columns are of unit length, and its rows are pairwise orthogonal and have the same ℓ 2 norm. As such, partial Walsh-Hadamard matrices and partial Fourier matrices are seed matrices (up to normalisation); however, for simplicity's sake we will keep it real by focusing on partial Walsh-Hadamard matrices. We can then define a LWT of order 𝑙 ∈ N 1 based on this seed as

$𝐴 𝑙 ≔ 𝐴 ⊗𝑙 1 = 𝐴 1 ⊗ • • • ⊗ 𝐴 1 ,$where ⊗ denotes the Kronecker product, which we will quickly define. Let 𝐴 be a 𝑚 × 𝑛 matrix and 𝐵 be a 𝑝 × 𝑞 matrix, then the Kronecker product 27 Curiously, the hard instances for the Toeplitz construction are very similar to the hard instances for Feature Hashing used in [[FKL18]](#b72). 28 Due to the choice of matrix names in [[BK17]](#b31).

𝐴 ⊗ 𝐵 is the 𝑚𝑝 × 𝑛𝑞 block matrix defined as

$𝐴 ⊗ 𝐵 ≔ ⎛ ⎜ ⎜ ⎝ 𝐴 11 𝐵 • • • 𝐴 1𝑛 𝐵 . . . . . . . . . 𝐴 𝑚1 𝐵 • • • 𝐴 𝑚𝑛 𝐵 ⎞ ⎟ ⎟ ⎠ .$Note that 𝐴 𝑙 is a 𝑟 𝑙 × 𝑐 𝑙 matrix and that any Walsh-Hadamard matrix can be written as 𝐴 𝑙 for some 𝑙 and the 2 × 2 Walsh-Hadamard matrix29 as 𝐴 1 . Furthermore, for a constant sized seed the time complexity of applying 𝐴 𝑙 to a vector is 𝑂(𝑐 𝑙 ) by using an algorithm similar to FFT. We can then define the compound transform which we will refer to as LWTJL, as 𝑓 (𝑥) ≔ 𝐺𝐴 𝑙 𝐷𝑥, where 𝐷 ∈ {-1, 1} 𝑑×𝑑 is a diagonal matrix with Rademacher entries, 𝐴 𝑙 ∈ R 𝑟 𝑙 ×𝑑 is a LWT, and 𝐺 ∈ R 𝑚×𝑟 𝑙 is a JLT, and 𝑟 and 𝑐 are constants. One way to view LWTJL is as a variant of GRHD where the subsampling occurs on the seed matrix rather than the final Walsh-Hadamard matrix. If 𝐺 can be applied in 𝒪(𝑟 𝑙 log 𝑟 𝑙 ) time, e.g. if 𝐺 is the BCHJL construction [[AL09]](#b8) and 𝑚 = 𝒪(𝑟 𝑙(1/2-𝛾) ), the total embedding time becomes 𝒪(𝑑), as 𝑟 𝑙 = 𝑑 𝛼 for some 𝛼 < 1. However, in order to prove that LWTJL satisfies lemma 1.2 the analysis of [[LAS11]](#b126) imposes a few requirements on 𝑟, 𝑐, and the vectors we wish to embed, namely that log 𝑟/log 𝑐 ≥ 1 -2𝛿 and 𝜈 = 𝒪(𝑚 -1/2 𝑑 -𝛿 ), where 𝜈 is an upper bound on the ℓ ∞ /ℓ 2 ratio as introduced at the end of section 1.4.1. The bound on 𝜈 is somewhat tight as shown in proposition 1.11.

Proposition 1.11. For any seed matrix define LWT as the LWTJL distribution seeded with that matrix.

Then for all 𝛿 ∈ (0, 1), there exists a vector 𝑥 ∈ C 𝑑 (or 𝑥 ∈ R 𝑑 , if the seed matrix is a real matrix) satisfying ∥𝑥 ∥ ∞ /∥𝑥 ∥ 2 = Θ(log -1/2 1 𝛿 ) such that

$Pr 𝑓 ∼LWT [ 𝑓 (𝑥) = 0] > 𝛿.(11)$The proof of proposition 1.11 can be found in section 2.3, and it is based on constructing 𝑥 as a few copies of a vector that is orthogonal to the rows of the seed matrix.

The last JLD we will cover is based on so-called Kac random walks, and despite Ailon and Chazelle [[AC09]](#b1) conjecturing that such a construction could satisfy lemma 1.1, it was not until Jain et al. [[Jai+20]](#b99) that a proof was finally at hand. As with the lean Walsh transforms above, let us first define Kac random walks before describing how they can be used to construct JLDs. A Kac random walk is a Markov chain of linear transformations, where for each step we choose two coordinates at random and perform a random rotation on the plane spanned by these two coordinates, or more formally: Definition 1.12 (Kac random walk [[Kac56]](#b109)). For a given dimention 𝑑 ∈ N 1 , let 𝐾 (0) ≔ 𝐼 ∈ {0, 1} 𝑑×𝑑 be the identity matrix, and for each 𝑡 > 0 sample (𝑖 𝑡 , 𝑗 𝑡 ) ∈

## (︁ [𝑑]

2 )︁ and 𝜃 𝑡 ∈ [0, 2𝜋) independently and uniformly at random. Then define the Kac random walk of length 𝑡 as 𝐾 (𝑡) ≔ 𝑅 (𝑖 𝑡 ,𝑗 𝑡 ,𝜃 𝑡 ) 𝐾 (𝑡-1) , where 𝑅 (𝑖,𝑗,𝜃) ∈ R 𝑑×𝑑 is the rotation in the (𝑖, 𝑗) plane by 𝜃 and is given by 𝑅 (𝑖,𝑗,𝜃) 𝑒 𝑘 ≔ 𝑒 𝑘 ∀𝑘 ∉ {𝑖, 𝑗}, 𝑅 (𝑖,𝑗,𝜃) (𝑎𝑒 𝑖 + 𝑏𝑒 𝑗 ) ≔ (𝑎 cos 𝜃 -𝑏 sin 𝜃)𝑒 𝑖 + (𝑎 sin 𝜃 + 𝑏 cos 𝜃)𝑒 𝑗 .

The main JLD introduced in [Jai+20], which we will refer to as KacJL, is a compound JLD where both 𝑓 1 and 𝑓 2 consists of a Kac random walk followed by subsampling, which can be defined more formally in the following way. Let 𝑇 1 ≔ Θ(𝑑 log 𝑑) be the length of the first Kac random walk, 𝑑 ′ ≔ min{𝑑, Θ(𝜀 -2 log |𝑋 | log 2 log |𝑋 | log 3 𝑑)} be the intermediate dimension, 𝑇 2 ≔ Θ(𝑑 ′ log |𝑋 |) be the length of the second Kac random walk, and 𝑚 ≔ Θ(𝜀 -2 log |𝑋 |) be the target dimension, and then define the JLT as 𝑓 (𝑥) = ( 𝑓 2 • 𝑓 1 )(𝑥) ≔ 𝑆 (𝑚,𝑑 ′ ) 𝐾 (𝑇 2 ) 𝑆 (𝑑 ′ ,𝑑) 𝐾 (𝑇 1 ) 𝑥, where 𝐾 (𝑇 1 ) ∈ R 𝑑×𝑑 and 𝐾 (𝑇 2 ) ∈ R 𝑑 ′ ×𝑑 ′ are independent Kac random walks of length 𝑇 1 and 𝑇 2 , respectively, and 𝑆 (𝑑 ′ ,𝑑) ∈ {0, 1} 𝑑 ′ ×𝑑 and 𝑆 (𝑚,𝑑 ′ ) ∈ {0, 1} 𝑚×𝑑 ′ projects onto the first 𝑑 ′ and 𝑚 coordinates30, respectively. Since 𝐾 (𝑇) can be applied in time 𝒪(𝑇), the KacJL construction is JLD with embedding time 𝒪(𝑑 log 𝑑 + min{𝑑 log |𝑋 |, 𝜀 -2 log 2 |𝑋 | log 2 log |𝑋 | log 3 𝑑}) with asymptotically optimal target dimension, and by only applying the first part ( 𝑓 1 ), KacJL achieves an embedding time of 𝒪(𝑑 log 𝑑) but with a suboptimal target dimension of 𝒪(𝜀 -2 log |𝑋 | log 2 log |𝑋 | log 3 𝑑). Jain et al. [[Jai+20]](#b99) also proposes a version of their JLD construction that avoids computing trigonometric functions31 by choosing the angles 𝜃 𝑡 uniformly at random from the set {𝜋/4, 3𝜋/4, 5𝜋/4, 7𝜋/4} or even the singleton set {𝜋/4}. This comes at the cost32 of increasing 𝑇 1 by a factor of log log 𝑑 and 𝑇 2 by a factor of log 𝑑, and for the singleton case multiplying with random signs (as we have done with the 𝐷 matrices in many of the previous constructions) and projecting down onto a random subset of coordinates rather than the 𝑑 ′ or 𝑚 first.

F 8 f This concludes the overview of Johnson-Lindenstrauss distributions and transforms, though there are many aspects we did not cover such as space usage, preprocessing time, randomness usage, and norms other than ℓ 2 . However, a summary of the main aspects we did cover (embedding times and target dimensions of the JLDs) can be found in table 1.

## Name

## Embedding time

Target 

$dimension Ref. Constraints Original 𝒪(∥𝑥∥ 0 𝑚) 𝒪(𝜀 -2 log 1 𝛿 ) [JL84] Gaussian 𝒪(∥𝑥∥ 0 𝑚) 𝒪(𝜀 -2 log 1 𝛿 ) [HIM12] Rademacher 𝒪(∥𝑥∥ 0 𝑚) 𝒪(𝜀 -2 log 1 𝛿 ) [AV06] Achlioptas 𝒪( 1 3 ∥𝑥∥ 0 𝑚) 𝒪(𝜀 -2 log 1 𝛿 ) [Ach03] DKS 𝒪(∥𝑥∥ 0 𝜀 -1 log 𝑚 𝛿 log 1 𝛿 ) 𝒪(𝜀 -2 log 1 𝛿 ) [DKS10; KN14] Block JL 𝒪(∥𝑥∥ 0 𝜀 -1 log 1 𝛿 ) 𝒪(𝜀 -2 log 1 𝛿 ) [KN14] Feature Hashing 𝒪(∥𝑥∥ 0 ) 𝒪(𝜀 -2 𝛿 -1 ) [Wei+09; FKL18] Feature Hashing 𝒪(∥𝑥∥ 0 ) 𝒪(𝜀 -2 log 1 𝛿 ) [FKL18] 𝜈 ≪ 1 FJLT 𝒪(𝑑 log 𝑑 + 𝑚 log 2 1 𝛿 ) 𝒪(𝜀 -2 log 1 𝛿 ) [AC09] BCHJL 𝒪(𝑑 log 𝑚) 𝒪(𝜀 -2 log 1 𝛿 ) [AL09] 𝑚 = 𝑜(𝑑 1/2 ) SRHT 𝒪(𝑑 log 𝑑) 𝒪(𝜀 -2 log |𝑋 | log 4 𝑑) [AL13; KW11] SRHT 𝒪(𝑑 log 𝑑) 𝒪(𝜀 -2 log 3 |𝑋 |) [Do+09] |𝑋 | ≥ 𝑑 Toeplitz 𝒪(𝑑 log 𝑚) 𝒪 (︂ 𝜀 -1 log 3/2 |𝑋 | log 3/2 𝑑 + 𝜀 -2 log |𝑋 | log 4 𝑑 )︂ [KW11] Toeplitz 𝒪(𝑑 log 𝑚) 𝒪(𝜀 -2 log 2 1 𝛿 ) [HV11; Vyb11] Toeplitz 𝒪(𝑑 log 𝑚) Ω(𝜀 -2 log 2 1 𝛿 ) [FL20] GRHD 𝒪(𝑑 log 𝑚) 𝒪(𝜀 -2 log 1 𝛿 ) [BK17] 𝑚 = 𝑜(𝑑 1/2 ) GRHD 𝒪(𝑑 2𝑟 log 4 𝑑) 𝒪(𝜀 -2 log 1 𝛿 ) [BK17] 𝑚 = 𝑂(𝑑 𝑟 ) LWTJL 𝒪(𝑑) 𝒪(𝜀 -2 log 1 𝛿 ) [LAS11] 𝜈 = 𝒪(𝑚 -1/2 𝑑 -𝛿 ) KacJL 𝒪 (︃ 𝑑 log 𝑑 +min {︂ 𝑑 log |𝑋 |, 𝜀 -2 log 2 |𝑋 | log 2 log |𝑋 | log 3 𝑑 }︂ )︃ 𝒪(𝜀 -2 log |𝑋 |) [Jai+20] KacJL 𝒪(𝑑 log 𝑑) 𝒪(𝜀 -2 log |𝑋 | log 2 log |𝑋 | log 3 𝑑) [Jai+20]$$∑︂ 𝑖=1 ∑︂ 𝑥∈𝑋 𝑖 ∥︁ ∥︁ ∥︁𝑥 - 1 |𝑋 𝑖 | ∑︂ 𝑦∈𝑋 𝑖 𝑦 ∥︁ ∥︁ ∥︁ 2 2 = 1 2 𝑘 ∑︂ 𝑖=1 1 |𝑋 𝑖 | ∑︂ 𝑥,𝑦∈𝑋 𝑖 ∥𝑥 -𝑦 ∥ 2 2 .$In order to prove lemma 1.6 we will need the following lemma. 

## □

Proof of lemma 1.6. We will first prove an identity for each partition, so let 𝑋 𝑖 ⊆ 𝑋 ⊂ R 𝑑 be any partition of the dataset 𝑋 and define 𝜇 𝑖 ≔ 1

$|𝑋 𝑖 | ∑︁ 𝑥∈𝑋 𝑖 𝑥 as the mean of 𝑋 𝑖 . 1 2|𝑋 𝑖 | ∑︂ 𝑥,𝑦∈𝑋 𝑖 ∥𝑥 -𝑦 ∥ 2 2 = 1 2|𝑋 𝑖 | ∑︂ 𝑥,𝑦∈𝑋 𝑖 ∥(𝑥 -𝜇 𝑖 ) -(𝑦 -𝜇 𝑖 )∥ 2 2 = 1 2|𝑋 𝑖 | ∑︂ 𝑥,𝑦∈𝑋 𝑖 (︁ ∥𝑥 -𝜇 𝑖 ∥ 2 2 + ∥ 𝑦 -𝜇 𝑖 ∥ 2 2 -2⟨𝑥 -𝜇 𝑖 , 𝑦 -𝜇 𝑖 ⟩ )︁ = ∑︂ 𝑥∈𝑋 𝑖 ∥𝑥 -𝜇 𝑖 ∥ 2 2 - 1 2|𝑋 𝑖 | ∑︂ 𝑥,𝑦∈𝑋 𝑖 2⟨𝑥 -𝜇 𝑖 , 𝑦 -𝜇 𝑖 ⟩ = ∑︂ 𝑥∈𝑋 𝑖 ∥𝑥 -𝜇 𝑖 ∥ 2 2 ,$where the last equality holds by lemma 2.1. We now substitute each term in the sum in lemma 1.6 using the just derived identity:

$𝑘 ∑︂ 𝑖=1 ∑︂ 𝑥∈𝑋 𝑖 ∥︁ ∥︁ ∥︁𝑥 - 1 |𝑋 𝑖 | ∑︂ 𝑦∈𝑋 𝑖 𝑦 ∥︁ ∥︁ ∥︁ 2 2 = 1 2 𝑘 ∑︂ 𝑖=1 1 |𝑋 𝑖 | ∑︂ 𝑥,𝑦∈𝑋 𝑖 ∥𝑥 -𝑦 ∥ 2 2 .$□

## Super Sparse DKS

The tight bounds on the performance of feature hashing presented in theorem 1.8 can be extended to tight performance bounds for the DKS construction. Recall that the DKS construction, parameterised by a so-called column sparsity 𝑠 ∈ N 1 , works by first mapping a vector 𝑥 ∈ R 𝑑 to an 𝑥 ′ ∈ R 𝑠𝑑 by duplicating each entry in 𝑥 𝑠 times and then scaling with 1/ √ 𝑠, before applying feature hashing to 𝑥 ′ , as 𝑥 ′ has a more palatable ℓ ∞ /ℓ 2 ratio compared to 𝑥. The setting for the extended result is that if we wish to use the DKS construction but we only need to handle vectors with a small ∥𝑥 ∥ ∞ /∥𝑥 ∥ 2 ratio, we can choose a column sparsity smaller than the usual Θ(𝜀 -1 log 1 𝛿 log 𝑚 𝛿 ) and still get the Johnson-Lindenstrauss guarantees. This is formalised in corollary 1.9. The two pillars of theorem 1.8 we use in the proof of corollary 1.9 is that the feature hashing tradeoff is tight and that we can force the DKS construction to create hard instances for feature hashing. 

The upper bound part of the Θ in corollary 1.9 shows how sparse we can choose the DKS construction to be and still get Johnson-Lindenstrauss guarantees for the data we care about, while the lower bound shows that if we choose a sparsity below this bound, there exists vectors who get distorted too much too often despite having an ℓ ∞ /ℓ 2 ratio of at most 𝜈 DKS .

Proof of corollary 1.9. Let us first prove the upper bound:

$𝑠 DKS = 𝒪 (︁ 𝜈 2 DKS 𝜈 2 FH )︁ . Let 𝑠 ≔ Θ (︁ 𝜈 2 DKS 𝜈 2 FH )︁$∈ [𝑚] be the column sparsity, and let 𝑥 ∈ R 𝑑 be a unit vector with ∥𝑥∥ ∞ ≤ 𝜈 DKS . The goal is now to show that a DKS construction with sparsity 𝑠 can embed 𝑥 while preserving its norm within 1 ± 𝜀 with probability at least 1 -𝛿 (as defined in lemma 1.2).

Let 𝑥 ′ ∈ R 𝑠𝑑 be the unit vector constructed by duplicating each entry in 𝑥 𝑠 times and scaling 

$|︁ |︁ ≤ 𝜀 ]︂ = Pr 𝑔∼FH [︂ |︁ |︁ ∥ 𝑔(𝑥 ′ )∥ 2 2 -1 |︁ |︁ ≤ 𝜀 ]︂ < 1 -𝛿,$where the inequality is implied by eq. ( [14](#)) and theorem 1.8, and the fact that 𝑥 ′ has the shape of an asymptotically worst case instance for feature hashing.

□

## LWTJL Fails for Too Sparse Vectors

Proposition 1.11. For any seed matrix define LWT as the LWTJL distribution seeded with that matrix.

Then for all 𝛿 ∈ (0, 1), there exists a vector 𝑥 ∈ C 𝑑 (or 𝑥 ∈ R 𝑑 , if the seed matrix is a real matrix) satisfying ∥𝑥 ∥ ∞ /∥𝑥 ∥ 2 = Θ(log -1/2 1 𝛿 ) such that

$Pr 𝑓 ∼LWT [ 𝑓 (𝑥) = 0] > 𝛿.$Proof. The main idea is to construct the vector 𝑥 out of segments that are orthogonal to the seed matrix with some probability, and then show that 𝑥 is orthogonal to all copies of the seed matrix simultaneously with probability larger than 𝛿.

Let 𝑟, 𝑐 ∈ N 1 be constants and 𝐴 1 ∈ C 𝑟×𝑐 be a seed matrix. Let 𝑑 be the source dimension of the LWTJL construction, 𝐷 ∈ {-1, 0, 1} 𝑑×𝑑 be the random diagonal matrix with i.i.d. Rademachers, 𝑙 ∈ N 1 such that 𝑐 𝑙 = 𝑑, and 𝐴 𝑙 ∈ C 𝑟 𝑙 ×𝑐 𝑙 be the the LWT, i.e. 𝐴 𝑙 ≔ 𝐴 ⊗𝑙 1 . Since 𝑟 < 𝑐 there exists a nontrivial vector 𝑧 ∈ C 𝑐 \ {0} that is orthogonal to all 𝑟 rows of 𝐴 1 and ∥𝑧 ∥ ∞ = Θ(1). Now define 𝑥 ∈ C 𝑑 as 𝑘 ∈ N 1 copies of 𝑧 followed by a padding of 0s, where 𝑘 = ⌊ 1 𝑐 lg 1 𝛿 -1⌋. Note that if the seed matrix is real, we can choose 𝑧 and therefore 𝑥 to be real as well.

The first thing to note is that ∥𝑥∥ 0 ≤ 𝑐 𝑘 < lg 1 𝛿 , which implies that Pr 𝐷 [𝐷𝑥 = 𝑥] = 2 -∥𝑥∥ 0 > 𝛿.

Secondly, due to the Kronecker structure of 𝐴 𝑙 and the fact that 𝑧 is orthogonal to the rows of 𝐴 1 , we have 𝐴𝑥 = 0.

Taken together, we can conclude 

## □

The following corollary is just a restatement of proposition 1.11 in terms of lemma 1.2, and the proof therefore follows immediately from proposition 1.11.

Corollary 2.2. For every 𝑚, 𝑑, ∈ N 1 , and 𝛿, 𝜀 ∈ (0, 1), and LWTJL distribution LWT over 𝑓 : K 𝑑 → K 𝑚 , where K ∈ {R, C} and 𝑚 < 𝑑 there exists a vector 𝑥 ∈ K 𝑑 with ∥𝑥 ∥ ∞ /∥𝑥∥ 2 = Θ(log -1/2 1 𝛿 ) such that

$Pr 𝑓 ∼LWT [︂ |︁ |︁ ∥ 𝑓 (𝑥)∥ 2 2 -∥𝑥∥ 2 2 |︁ |︁ ≤ 𝜀∥𝑥 ∥ 2 2 ]︂ < 1 -𝛿.$![𝜀 2 -2𝜀 3 /3) -1 ln |𝑋 | ⌉︁ + 1 suffices for the same JLD if 𝑚 < √︁ |𝑋 |. This bound was further improved in [FM90] by removing the 𝑚 < √︁ |𝑋 | restriction and lowering the bound to 𝑚 = ⌈︁ 8(𝜀 2 -2𝜀 3 /3) -1 ln |𝑋 |]()

![Let 𝑑 ∈ N 1 and 𝑋 ⊂ R 𝑑 and define 𝜇 ≔ 1 |𝑋 | ∑︁ 𝑥∈𝑋 𝑥 as the mean of 𝑋, then it holds that ∑︂ 𝑥,𝑦∈𝑋 ⟨𝑥 -𝜇, 𝑦 -𝜇⟩ = 0. Proof of lemma 2.1. The lemma follows from the definition of 𝜇 and the linearity of the real inner product. ∑︂ 𝑥,𝑦∈𝑋 ⟨𝑥 -𝜇, 𝑦 -𝜇⟩ = ∑︂ 𝑥,𝑦∈𝑋 (︁ ⟨𝑥, 𝑦⟩ -⟨𝑥, 𝜇⟩ -⟨𝑦, 𝜇⟩ + ⟨𝜇, 𝜇⟩]()

![Let 𝜈 DKS ∈ [1/ √ 𝑑, 1] denote the largest ℓ ∞ /ℓ 2 ratio required, 𝜈 FH denote the ℓ ∞ /ℓ 2 constraint for feature hashing as defined in theorem 1.8, and 𝑠 DKS ∈ [𝑚] as the minimum column sparsity such that the DKS construction with that sparsity is a JLD for the subset of vectors 𝑥 ∈ R 𝑑 that satisfy ∥𝑥∥ ∞ /∥𝑥∥ 2 ≤ 𝜈 DKS . Then𝑠 DKS = Θ]()

![𝑠 as in the DKS construction. We now have∥𝑥 ′ ∥ ∞ ≤ 𝜈 DKS √ 𝑠 = Θ(𝜈 FH ). (13)Let DKS denote the JLD from the DKS construction with column sparsity 𝑠, and let FH denote the feature hashing JLD. Then we can conclude Pr 𝛿, where the inequality is implied by eq. (13) and theorem 1.8. Now let us prove the lower bound: 𝑠 DKS = Ω 𝑥 = (𝜈 DKS , . . . , 𝜈 DKS , 0, . . . , 0) ᵀ ∈ R 𝑑 be a unit vector. We now wish to show that a DKS construction with sparsity 𝑠 will preserve the norm of 𝑥 to within 1 ± 𝜀 with probability strictly less than 1 -𝛿. As before, define 𝑥 ′ ∈ R 𝑠𝑑 as the unit vector the DKS construction computes when duplicating every entry in 𝑥 𝑠 times and scaling with 1/ √ 𝑠. This gives∥𝑥 ′ ∥ ∞ = 𝜈 DKS √ 𝑠 = 𝜔(𝜈 FH ).(14)Finally, let DKS denote the JLD from the DKS construction with column sparsity 𝑠, and let FH denote the feature hashing JLD. Then we can conclude Pr]()

![𝑓 (𝑥) = 0] ≥ Pr 𝐷 [𝐴 𝑙 𝐷𝑥 = 0] ≥ Pr 𝐷 [𝐷𝑥 = 𝑥] > 𝛿. Now we just need to show that ∥𝑥∥ ∞ /∥𝑥 ∥ 2 = Θ(log -1/2 1 𝛿 ).Since 𝑐 is a constant and 𝑥 is consists of 𝑘 = Θ(log 1 𝛿 ) copies of 𝑧 followed by zeroes,∥𝑥∥ ∞ = ∥𝑧 ∥ ∞ = Θ(1),∥𝑧∥ 2 = Θ(1),]()

![The tapestry tabularised.Let 𝑘, 𝑑 ∈ N 1 and 𝑋 𝑖 ⊂ R 𝑑 for 𝑖 ∈ {1, . . . , 𝑘}, then]()

Here it is assumed that the mean of our vectors is 0, otherwise the mean vector of our vectors should be subtracted from each of the rows of 𝑋.

Or rather in 1982 as that was when a particular "Conference in Modern Analysis and Probability" was held at Yale University, but the proceedings were published in 1984.

We use[𝑘]  to denote the set {1, . . . , 𝑘}.

Here the approximation ratio is between any 𝑘-means algorithm running on the high dimensional original data and on the low dimensional projected data.

Here we assume that a word is large enough to hold a sufficient approximation of any real number we use and to hold a number from the stream, i.e. if 𝑤 denotes the number of bits in a word then 𝑤 = Ω(log 𝑑 + log 𝑀).

See e.g.[[TZ12]](#b193) for other families of 𝑘-wise independent hash functions.

We will usually omit the normalisation or scaling factor (the (𝑑/𝑚) 1/2 for this JLD) when discussing JLDs as they are textually noisy, not that interesting, and independent of randomness and input data.

The Rademacher distribution is the uniform distribution on {-1, 1}.

Here we ignore any overhead that switching to a sparse matrix representation would introduce.

Here a lower bound refers to a lower bound on 𝜈 as a function of 𝑚, 𝜀, 𝛿, and 𝑠.

Here we ignore the 𝑟 < 𝑐 requirement of seed matrices.

The paper lets 𝑑 ′ and 𝑚 be random variables, but with the way the JLD is presented here a deterministic projection suffices, though it may affect constants hiding in the big-𝒪 expressions.

Recall that sin(𝜋/4) = 2 -1/2 and that similar results holds for cosine and for the other angles.

Note that the various Kac walk lengths are only shown to be sufficient, and so tighter analysis might shorten them and perhaps remove the cost of using simpler angles.

