# BitDelta: Your Fine-Tune May Only Be Worth One Bit

## Abstract

## 

Large Language Models (LLMs) are typically trained in two phases: pre-training on large internet-scale datasets, and fine-tuning for downstream tasks. Given the higher computational demand of pre-training, it is intuitive to assume that finetuning adds less new information to the model, and is thus more compressible. We explore this assumption by decomposing the weights of fine-tuned models into their pre-trained components and an additional delta. We introduce a simple postfine-tuning method, BitDelta, which successfully quantizes this delta down to 1 bit without compromising performance. This interesting finding not only highlights the potential redundancy of information added during fine-tuning, but also has significant implications for the multi-tenant serving and multi-tenant storage of fine-tuned models. By enabling the use of a single high-precision base model accompanied by multiple 1-bit deltas, BitDelta dramatically reduces GPU memory requirements by more than 10×, thus reducing per-user generation latency by more than 10× in multi-tenant settings. We validate BitDelta through experiments across Llama-2, Mistral and MPT model families, and on models up to 70B parameters, showcasing minimal performance degradation in all tested settings.

## Introduction

After large-scale pretraining, foundation models are typically fine-tuned for specific downstream tasks [[16,](#b15)[43,](#b42)[44]](#b43). This pretrain-finetune paradigm has revolutionized machine learning; LLMs have not only proven effective for critical tasks such as instruction following and alignment [[39]](#b38), but are also performant on a wide array of niche yet highly impactful applications [[61,](#b60)[42]](#b41). Through fine-tuning, LLMs are adeptly equipped to align with distinct user preferences or specialized task requirements, showcasing an unprecedented level of adaptability. Thus, the prospect of serving millions of uniquely fine-tuned models, each tailored to individual tasks and user needs, presents a promising vision for the future of machine learning.

Realizing this vision is challenging due to two key reasons: 1) Expensive Storage. Each new fine-tuned model is large, even if we have relatively few base models, making them expensive to store and challenging to manage on disk. 2) Expensive Serving. Distinct fine-tuned models each demand significant GPU memory, making it difficult and expensive to concurrently serve such models without noticeable downtime. To tackle these issues, we decompose the fine-tuned model weights into the weights of the base pre-trained model and a delta induced by the fine-tuning process. By compressing this delta while maintaining model performance, we aim to sidestep the prohibitive costs associated with storage and GPU memory demands.

From the delta decomposition point of view, parameter-efficient fine-tuning (PEFT) methods like LoRA [[25,](#b24)[24,](#b23)[46,](#b45)[15,](#b14)[9]](#b8) effectively enforce a highly structured and compressed form of delta during fine-tuning, a powerful insight for model serving of PEFT-based fine-tunes. Sheng et al. [[49]](#b48) and Chen et al. [[7]](#b6) explore multi-tenant serving of LoRA-based fine-tunes.

Figure [1](#): Overview of BitDelta. BitDelta applies 1-bit quantization to the weight delta between fine-tuned and base models. For each weight matrix, we quantize its delta as its sign bits and a trainable high-precision scale factor. The scale factor is initialized to achieve the best approximation error in L 2 norm and further refined with a few distillation steps. BitDelta shows minimal degradation in model performance and reduces memory consumption in multi-tenancy serving by representing multiple fine-tuned models with a single high-precision base model and multiple 1-bit deltas.

Nevertheless, recent work has shown that PEFT methods may not yet match the model quality of full parameter fine-tuning, especially on high resource tasks [[6]](#b5), and are fairly sensitive to hyperparameter choice and prompting methods [[38]](#b37). Biderman et al. [[2]](#b1) show that LoRA's reduced expressivity, although providing desirable regularization, leads to significantly worse performance compared to full fine-tuning in math and programming tasks. As a result, we notice that among the 2307 LLMs (as of time of writing) on the Open LLM Leaderboard [[1]](#b0) with a valid README file, only < 20% indicate that they exclusively use LoRA. Most models are full parameter fine-tunes, model merges [[64,](#b63)[28,](#b27)[59]](#b58) of full parameter fine-tunes, or model merges of LoRA based fine-tunes (which are effectively high-rank). It is also attractive to approximate general deltas with low-rank matrices post-training (in particular, post-fine-tuning). However, experimental results show that this is challenging (Table [1](#tab_0)), as deltas from full parameter fine-tunes tend to be fairly high-rank (Figure [2](#fig_0)). We instead draw from the insight that motivates PEFT methods in general: Given the higher computational demand of pre-training, it is intuitive to assume that fine-tuning adds less new information to the model, and is thus much more compressible. In fact, we find that we can efficiently quantize the delta to merely 1 bit with almost no performance drop. We propose BitDelta, an efficient post-training quantization (PTQ) solution that acts on the weight delta between a finetuned model and its underlying base model. BitDelta consists of two stages: 1) We quantize the delta between a fine-tuned model's weight matrix and base model's weight matrix into a scaling factor multiplied by a binary matrix. Specifically, we BitDelta creates opportunities to efficiently serve multiple fine-tuned models with shared servers: By only storing a single full-precision base model, and (dynamically) loading and performing batched inference over multiple 1-bit deltas, we can efficiently represent multiple fine-tuned models. Compared to naively using full precision fine-tuned models, deltas compressed by BitDelta are more than 10× smaller, and can therefore be loaded faster. This addresses the storage challenge. Moreover, since LLM inference is memory-bound [[32,](#b31)[5,](#b4)[3]](#b2), the latency of each decoding step is proportional to the GPU memory consumption of the model weights. With an efficient CUDA kernel implementation, we can translate this memory reduction into a latency reduction, similar to other quantization methods [[19,](#b18)[33]](#b32). Using the W IN T 1 A F P 16 kernel from BitBLAS [[58]](#b57), we improve the multi-tenant serving latency of full-parameter fine-tuned models by more than 10×.

Finally, we study a few extensions of BitDelta, where we quantize the base model and where we iteratively apply BitDelta. Experimental results show that our method is quite general and can be applied to various use cases.

2 Related Work

## Full Model Compression

Quantization. Quantization techniques are widely used to reduce memory consumption and improve LLMs' generation latency. Xiao et al. [[60]](#b59) implement a technique that rescales between activations and parameters, effectively mitigating outlier activations to facilitate smoother quantization. Dettmers et al. [[14]](#b13) develop an approach that decomposes matrix multiplications into 8-bit computations, with an additional 16-bit process for handling outliers. Exploring further, Frantar et al. [[19]](#b18) introduce a method that iteratively rounds weight columns to 3-4 bits of precision. Similarly, Lin et al. [[33]](#b32) propose an activation-aware quantization scheme that selectively preserves crucial weights while compressing the majority to 3-4 bits. Kim et al. [[29]](#b28) devise a sparse, low-precision pattern focusing on a small yet significant set of weights. Chee et al. [[4]](#b3) utilize incoherence processing to quantize model weights to as low as 2 bits with minimal impact on performance.

Pruning. Pruning also aims to reduce the memory consumption of neural networks. It accomplishes this by pushing certain parameter values to zero, inducing sparsity in the model [[31,](#b30)[21,](#b20)[22,](#b21)[67]](#b66). However, these methods may fail to take advantage of modern hardware like GPUs unless using certain structured sparsity patterns like 2:4 (50%) sparsity [[36]](#b35). Frantar and Alistarh [[18]](#b17) demonstrate a pruning method on LLMs that successfully utilizes the 2:4 sparsity pattern and achieves a 50% sparsity ratio. It is challenging to obtain higher sparsity while being hardware-friendly.

Early work on post-training delta compression. Most related to our work, a few studies explore the idea of post-training delta compression by adopting existing compression techniques like GPTQ, unstructured pruning [[22]](#b21), or even classic lossless compression algorithms. Isik et al. [[26]](#b25) focus on reducing the delta size to save storage. Yu et al. [[64]](#b63) utilize pruning to improve model merging applications. Yadav et al. [[62]](#b61) reduces the size of PEFT modules to save storage. Ryu et al. [[47]](#b46) combines quantization with a low-rank approximation to reduce the delta size. The concurrent and independent work by Yao and Klimovic [[63]](#b62) also explores using delta compression to improve multitenant serving, but focuses more on reducing the model loading time from disk to GPU. Compared to existing work, we offer a much simpler and faster method, BitDelta, achieving a compression ratio of more than 10× while also being friendly to modern accelerators.

3 BitDelta

## Method

BitDelta consists of two stages: 1) We quantize each weight matrix into a scalar multiplied by a binary matrix † . 2) We further calibrate the scalar factors using model distillation. We describe each stage in this section:

1-bit quantization. Let W base , W fine ∈ R n×m be weight matrices from the base model and finetuned model respectively. We define the weight delta as ∆ = W fine -W base , representing the modification in weights post-fine-tuning. For efficient representation of this weight delta, we aim to obtain a binarized estimator by encoding its sign bits, denoted as ∆:

$∆ = α ⊙ Sign(∆),(1)$where

$Sign(W ij ) = +1, if W ij > 0, -1, if W ij ≤ 0,(2)$and α is a high-precision scaling factor for the entire matrix. To minimize the quantization error of ∆ in L 2 norm:

$∆ -∆ 2 2 = ij (|W ij | -α) 2 ,(3)$we initialize α as follows:

$α = 1 nm ij |∆ ij |.(4)$Surprisingly, we find that the above quantization approach already does quite well and retains most of the fine-tuned models' performance.

Scale distillation. The scaling factor α intuitively plays a more significant role in the low-bit regime. Additionally, per-matrix L 2 weight error is not a perfect measure of degradation in overall model quality. We further optimize these scales by performing model distillation to align the output logits of the quantized model to that of the original fine-tuned model. More concretely, we freeze the model weights and optimize for the following objective:

$α * = arg min α E x∼X ∥Z fine (x) -Z bin (x; α)∥ 2(5)$† In our experiments, we only quantize the linear layers in the Transformer blocks as they contribute the majority of the parameters and computation. where X is a calibration dataset, and Z(•) are the logits of the respective models. Scale distillation is fairly robust to choice X, as 1) the process is extremely parameter efficient, and 2) the crucial aspect of the process is to logit match with the fine-tuned model, regardless of the actual text content.

For our experiments, we distill on the C4 dataset [[45]](#b44), consisting of generic internet data, using 800 samples of length 128. We use the same subset of C4 over all models to control for seed-based variations. We use the Adam optimizer [[30]](#b29) with lr = 10 -4 , β = (0.9, 0.999), ϵ = 10 -8 . 1x80 GB A100 GPU is used to distill 7B and 13B models, and 6x80GB A100 GPUs are used to distill 70B models (2x for finetune, 4x for binarized). Scale distillation is fast; we can compress 70B models in roughly 10 minutes.

## Methodology Cost

Compared to full parameter and parameter efficient fine-tuning methods, BitDelta is extremely cheap. While fine-tuning methods require training thousands to millions of parameters, BitDelta only necessitates training a single parameter per weight matrix. Moreover, BitDelta operates efficiently with input sequences of length 128, unlike fine-tuning methods that demand longer sequences to saturate the context window (4k, 8k, etc.). Crucially, BitDelta requires only 200 training steps (assuming a batch size of 4), which is significantly less compared to the 10000-1000000 steps at higher batch sizes needed by fine-tuning methods. Thus, in terms of methodology cost, we liken BitDelta more to post-training quantization (PTQ) schemes like GPTQ [[19]](#b18) and AWQ [[33]](#b32), rather than full parameter or parameter efficient fine-tuning, while being faster than most PTQ schemes.

## Implication

The ability to compress the delta to merely 1-bit opens up multiple opportunities for improving efficiency, enabling more effective model storage [[26]](#b25) -where a single base model can be maintained alongside multiple compressed deltas -and facilitating model hot-swapping [[7,](#b6)[49]](#b48). With hotswapping, the base model remains in GPU memory, and compressed deltas are dynamically loaded in accordance to incoming requests. In both cases, the compression ratio can be directly translated into reductions in storage needs and loading times.

Moreover, BitDelta enables the possibility of a multi-tenant serving system like Punica [[7]](#b6) or S-LoRA [[49]](#b48) but for general fine-tuned models instead of just LoRA models. Concretely, we consider the scenario where multiple models fine-tuned from the same base model are served with the same server. This setting greatly exploits the GPU resource and saves each fine-tuned model's inference cost when their traffic is low or unbalanced. With BitDelta, we can keep one high-precision base model with multiple compressed deltas in the GPU memory. Compared to directly serving multiple fine-tuned models, this approach greatly saves memory consumption.

Since LLM inference follows the memory-bound computation pattern where the generation latency is proportional to the GPU memory used by the model weights, the lower memory consumption also suggests the opportunity to improve the serving latency. For example, Punica and S-LoRA exploit LoRA's structure and memory saving by computing the activation product between the shared base weight, and low-rank fine-tuned delta weights separately. Similarly, we decompose the forward pass of each linear layer as follows:

$X ′ i = W fine,i X i ≈ W base X i + ∆i X i Kernel (6)$where X i and X ′ i represent input and output features to the i-th fine-tuned model, and the base model weight and the 1-bit delta are computed separately. For a batch of requests, W base X i can be computed with the classic batched GEMM kernel. We utilize the BitBLAS [58] W IN T 1 A F P 16 kernel that allows us to calculate ∆i X in a batched setting while keeping the 1-bit deltas quantized until they are transferred to the GPU cache. This kernel fuses the dequantization operation with the GEMM calculation, reducing the data moving overhead by a large factor.

## Experiments

## Setup

Baselines. Our primary baselines are the original fine-tuned models without compression. We also compare with 8-bit RTN, 4-bit GPTQ [[19]](#b18), and 2-bit QuIP# [[54]](#b53) on evaluations where we run BitDelta on quantized base models. Models and datasets. We benchmark fine-tuned models based on the Llama-2 [[53]](#b52), Mistral [[27]](#b26), and MPT [[51]](#b50) model families: Vicuna, Xwin-LM, Solar-70B, Zephyr, OpenChat 3.5, Dolphin 2.2.1, and OpenOrca [[10,](#b9)[52,](#b51)[56,](#b55)[55,](#b54)[57,](#b56)[23,](#b22)[37]](#b36). We evaluate on eight tasks: MT-Bench, 25-shot ARC Challenge, 5-shot BBH, 10-shot HellaSwag, zero-shot TruthfulQA, zero-shot LAMBADA, zero-shot Table [4](#): Comparison of model responses from Zephyr-7B-β for Question 9 in MT-Bench, a concise advertisement task. BitDelta-Initial is unable to follow the instructions, producing an advertisement that is overly formal and makes no attempt to adhere to the word limit. With the addition of scale distillation, BitDelta successfully produces a concise, catchy advertisement slightly over the word limit. *Prompt slightly modified for clarity.

## Prompt

Please create a slogan about bioenergy that satisfies the following: 1. Make the tone sound casual 2. Embed an advertisement for a company called "FlexPower" 3. Fewer than 10 words.

BitDelta "FlexPower's groundbreaking bioenergy solution: Produce fuel without compromising food production!" (10 words) This headline is catchy, casual, and highlights the unique selling point of the... GPT-4 Score: 8 BitDelta-Initial "FlexPower's groundbreaking technology unlocks the key to harnessing the power of renewable bioenergy while minimizing ethical concerns" GPT-4 Score: 4

Winogrande, and 5-shot GSM8K [[66,](#b65)[12,](#b11)[50,](#b49)[65,](#b64)[34,](#b33)[40,](#b39)[48,](#b47)[13]](#b12). We use FastChat [[66]](#b65) to evaluate on MT-Bench, and use lm-evaluation-harness [[20]](#b19) to evaluate on the other tasks. We denote our methodology before scale distillation is applied as BitDelta-Initial.

We primarily focus on high-margin metrics where fine-tuning is significantly impactful and aggregate the other metrics. See Tables 7 to 10 in the Appendix for full results. BitDelta performs quite well on the aggregated metrics, even outperforming the baseline in many cases. However, it's important to contextualize these results with regard to the base model itself, which is also performant on these metrics. It's difficult to attribute performance to our methodology or to the underlying base model in such cases. Because of this, we highlight TruthfulQA, GSM8K, and MT-Bench, which base models tend to struggle on, to show that BitDelta accurately preserves fine-tune information. SVD comparison. We compare BitDelta to a low rank approx. of the weight delta on Vicuna-7B v1.5. For the low rank approx., we decompose ∆ = U ΣV and approximate ∆ = AB where A = U Σ, B = ΣV . During distillation, we treat all entries of the low rank matrices as trainable parameters. We compare against two settings: r = 16 (most commonly used) and r = 128 (memory equivalence with Bit-Delta). We find that the low rank approx. fails to fully capture the fine tune information, and underperforms across the board (Table [1](#tab_0)). In particular, the low rank approx. heavily underperforms on MT-Bench [[10]](#b9), a difficult multi-turn instruction following dataset fairly indicative of real world performance. Interestingly, distillation is not as effective for the low rank approx. compared to BitDelta.

## Accurate Quantization

## Main Results.

BitDelta is performant across various model families, across a wide range of model sizes, and across many fine-tuning techniques. We benchmark on Llama-2, Mistral, and MPT, families, and on models ranging from 7B to 70B parameters. Shown in Table [2](#tab_1), we find that BitDelta is very general and can recover all types of finetune information, including SFT-based methods [[43]](#b42) on Mistral-7B v0.1 Instruct, RLHF-based methods [[11]](#b10) on Llama 2 Chat, and context extension methods (RoPE scaling) [[8,](#b7)[41]](#b40) on Vicuna-7B v1.5 16k.

We note that GSM8K for BitDelta-Initial on Mistral-7B v0.1 Instruct and Zephyr-7B-β is abnormally high; we attribute this to how performant the base model Mistral-7B v0.1 is on this task in comparison. Scale distillation is effective, raising TruthfulQA and GSM8K scores to within 1-2 points of the baseline fine-tune, and generally raising MT-Bench scores to within 0.1-0.2 points. Case Study. We present a sample response from Zephyr-7B-β in Table [4](#), highlighting the efficacy of scale distillation. BitDelta-Initial does not have a casual tone, and makes no attempt to adhere to the word limit. With the introduction of scale distillation, BitDelta exhibits greater instruction following capabilities, producing a catchy response that slightly exceeds the word limit.

Quantized base models. Because 8-bit RTN, GPTQ, and QuIP# work with 16-bit activations, we can keep the fine-tune weights W fine and scaling factors α in high precision in the compression process, only quantizing the base weights W base . As shown in Table [6](#tab_4), we find that BitDelta is still performant when applied to quantized base models. Ablation over fidelity of ∆. By successively applying BitDelta, treating the compressed model from the previous iteration as our base model, we can vary the granularity over the delta, associating it with multiple 1-bit masks. One advantage of doing this is the ability to assign arbitrary scale factors to each 1-bit mask. In contrast, when increasing the bit size, scale factors are implicitly fixed with respect to each other. Figure [3](#fig_1) shows how the TruthfulQA of Llama 2-7B plus an increasingly granular delta approaches that of Vicuna-7B v1.5. Full results are in Table [9](#).

## Latency Improvement

For simplicity, we consider the setting where each model receives one distinct request simultaneously. It would be insightful to develop more sophisticated serving systems, which we leave to future work. Following the decomposition in Eq. ( [6](#)), the W IN T 1 A F P 16 kernel is used to compute the batched matrix multiplication between B binary matrices (N × M ) and B high-precision activations (L × N ) where N, M are intermediate dimensions and L is the sequence length. We focus on decoding latency which dominates runtime, as opposed to prefill latency. Tokens are generated one by one when decoding, meaning L is always 1. For all latency experiments we use a single A100 80GB with power limit set to 500W. Kernel latency. We benchmark the decoding latency of our kernel, a batched linear operation over multiple 1-bit deltas, corresponding to the delta component of Eq. [(6)](#b5). We compare this to the S-LoRA kernel, a batched linear operation over multiple low-rank deltas, and also compare this to the base weight backbone shared over all deltas. We set r = 128 for S-LoRA, to maintain memory equivalence with BitDelta at N = M = 4096.

We profile the latency of the backbone (W base X) and deltas (∆X) separately. Although X's memory footprint scales with batch size, it is negligible compared to W base , which remains constant. For typical low to medium batch settings, which is typical for B × N ≪ N × M . In such settings, the overall memory footprint of the backbone is effectively independent of batch size, as shown in Figure [4](#fig_2) (left). This is in contrast with that of the deltas, which scales with the batch size, as each BitDelta underperforms slightly compared to S-LoRA in large-batch settings as the LoRA kernel is highly optimized for GPU. We emphasize that closing or even surpassing the gap is tractable. For example, Ma et al. [[35]](#b34) point out that W IN T 1 A F P 16 requires no multiplication operations and that new hardware can be co-designed with this in mind to drastically reduce energy/latency costs.  End-to-end latency. We benchmark the end-to-end decoding latency on Llama 2-7B variants with an input length of 128 (we find the decoding latency is less sensitive to the input length), ablated across batch size. For BitDelta and S-LoRA, the forward pass consists of the addition of two components: a single backbone pass (batch independent) and a delta pass (scales with batch size).

We compare BitDelta and S-LoRA with a naive method that computes each W i X i separately in the forward pass. This naive approach scales poorly with batch size as it effectively maintains a separate backbone (W i ) for each client in the batch. Given the substantial memory footprint of the backbone, this leads to significant memory usage as batch size increases. In contrast, BitDelta and S-LoRA share a single backbone across all clients in the batch, with only the 16× smaller deltas scaling with batch size. This allows for more efficient memory utilization and better performance at larger batch sizes.

We find that BitDelta and S-LoRA introduce overhead when the batch size is low. However, BitDelta and S-LoRA scale better and successfully translate the saved GPU memory to improved decoding latency, starting at B = 2. This is exacerbated at larger batch sizes, where the naive approach succumbs to out-of-memory issues and BitDelta and S-LoRA are still performant. In the B ≥ 16 regime, used in modern serving solutions, BitDelta has a >10× lower per-user decoding latency than the naive method.

## Conclusion

We propose BitDelta, a simple but effective approach to efficiently quantifyings the weight delta arising from the fine-tuning of LLMs down to 1 bit. BitDelta encodes the sign bits of the weight delta and a per-weight matrix scaling factor, which is calibrated further through distillation. This allows for representing multiple full-parameter fine-tuned models with one base model and multiple 1-bit deltas, enhancing applications in multi-tenancy serving by reducing GPU memory requirements and improving generation latency. BitDelta is fast and accurate, showcasing minimal performance degradation, and opens new avenues for efficient model deployment and resource utilization in machine learning.

![Figure 2: Cumulative Explained Variance (CEV) plot of a 4096 × 4096 weight delta between Llama 2-7B and Vicuna-7B v1.5. Deltas from full parameter fine-tuning are fairly high rank, making low-rank approximations difficult.]()

![Figure 3: As the fidelity of ∆ increases, the Truth-fulQA scores of Llama 2-7B + ∆ approaches that of Vicuna-7B v1.5.]()

![Figure 4: Decoding latency of a linear layer, as in Eqn. 6. Black: Shared base weight backbone W base X. Blue: Batched activation-product with B 1-bit deltas, as in BitDelta. Red: Batched activation-product with B low-rank deltas, as in S-LoRA. Left: Ablation over hidden size, assuming N = M and B = 1. Right: Ablation over batch size, assuming N = M = 4096.]()

![Figure 5: Memory usage of Llama 2-7B, assuming each sequence in the batch has a length of 128. Blue: Memory usage of the naive method, separately storing B distinct fine-tuned models. Orange: Projected values for the naive method.Green: Memory usage of BitDelta. The naive forward pass succumbs to GPU memory issues at higher batch sizes.]()

![Figure 6: End-to-end decoding latency of Llama 2-7B. Blue: Naive forward pass with B distinct fine-tuned models. Orange: Projected values for the naive forward pass. Green: Batched forward pass with BitDelta. Gray: Batched forward pass with S-LoRA. The naive forward pass succumbs to GPU memory issues at higher batch sizes.]()

![Comparison between BitDelta and a SVD based method, with Llama 2-7B and Llama 2-7B Chat as the base and fine-tuned models. BitDelta is performant across the board, whereas the SVD-based method fails to sufficiently capture the fine-tuned information.]()

![BitDelta works on Llama-2 and Mistral families and on a wide range of model sizes ranging from 7B to 70B parameters. BitDelta works for many types of fine-tuned information, including SFT-based methods, RLHF-based methods, and context extension methods (RoPE scaling). Scale distillation is effective, raising TruthfulQA/GSM8K scores to within 1-2 points of the baseline fine-tune, and MT-Bench scores to within 0.1-0.2 points.]()

![Continuation of Table2.]()

![BitDelta achieves over 10× compression. We can further compress the embedding and LM head layers, but leave this to future work due to inconsistencies in tokenizer vocabularies.]()

![We apply BitDelta to Llama 2-7B Chat (with corresponding base model Llama 2-7B), and find it holds up when the underlying base model is quantized at various levels.]()

