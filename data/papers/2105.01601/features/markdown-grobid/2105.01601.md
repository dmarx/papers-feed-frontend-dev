# MLP-Mixer: An all-MLP Architecture for Vision

## Abstract

## 

Convolutional Neural Networks (CNNs) are the go-to model for computer vision. Recently, attention-based networks, such as the Vision Transformer, have also become popular. In this paper we show that while convolutions and attention are both sufficient for good performance, neither of them are necessary. We present MLP-Mixer, an architecture based exclusively on multi-layer perceptrons (MLPs). MLP-Mixer contains two types of layers: one with MLPs applied independently to image patches (i.e. "mixing" the per-location features), and one with MLPs applied across patches (i.e. "mixing" spatial information). When trained on large datasets, or with modern regularization schemes, MLP-Mixer attains competitive scores on image classification benchmarks, with pre-training and inference cost comparable to state-of-the-art models. We hope that these results spark further research beyond the realms of well established CNNs and Transformers. 1  

## Introduction

As the history of computer vision demonstrates, the availability of larger datasets coupled with increased computational capacity often leads to a paradigm shift. While Convolutional Neural Networks (CNNs) have been the de-facto standard for computer vision, recently Vision Transformers [[14]](#b14) (ViT), an alternative based on self-attention layers, attained state-of-the-art performance. ViT continues the long-lasting trend of removing hand-crafted visual features and inductive biases from models and relies further on learning from raw data.

We propose the MLP-Mixer architecture (or "Mixer" for short), a competitive but conceptually and technically simple alternative, that does not use convolutions or self-attention. Instead, Mixer's architecture is based entirely on multi-layer perceptrons (MLPs) that are repeatedly applied across either spatial locations or feature channels. Mixer relies only on basic matrix multiplication routines, changes to data layout (reshapes and transpositions), and scalar nonlinearities.

Figure [1](#fig_0) depicts the macro-structure of Mixer. It accepts a sequence of linearly projected image patches (also referred to as tokens) shaped as a "patches × channels" table as an input, and maintains this dimensionality. Mixer makes use of two types of MLP layers: channel-mixing MLPs and token-mixing MLPs. The channel-mixing MLPs allow communication between different channels; they operate on each token independently and take individual rows of the table as inputs. The token-mixing MLPs allow communication between different spatial locations (tokens); they operate on each channel independently and take individual columns of the table as inputs. These two types of layers are interleaved to enable interaction of both input dimensions.

In the extreme case, our architecture can be seen as a very special CNN, which uses 1×1 convolutions for channel mixing, and single-channel depth-wise convolutions of a full receptive field and parameter sharing for token mixing. However, the converse is not true as typical CNNs are not special cases of Mixer. Furthermore, a convolution is more complex than the plain matrix multiplication in MLPs as it requires an additional costly reduction to matrix multiplication and/or specialized implementation.

Despite its simplicity, Mixer attains competitive results. When pre-trained on large datasets (i.e., ∼100M images), it reaches near state-of-the-art performance, previously claimed by CNNs and Transformers, in terms of the accuracy/cost trade-off. This includes 87.94% top-1 validation accuracy on ILSVRC2012 "ImageNet" [[13]](#b13). When pre-trained on data of more modest scale (i.e., ∼1-10M images), coupled with modern regularization techniques [[49,](#b49)[54]](#b54), Mixer also achieves strong performance. However, similar to ViT, it falls slightly short of specialized CNN architectures.

## Mixer Architecture

Modern deep vision architectures consist of layers that mix features (i) at a given spatial location, (ii) between different spatial locations, or both at once. In CNNs, (ii) is implemented with N × N convolutions (for N > 1) and pooling. Neurons in deeper layers have a larger receptive field [[1,](#)[28]](#b28). At the same time, 1×1 convolutions also perform (i), and larger kernels perform both (i) and (ii).

In Vision Transformers and other attention-based architectures, self-attention layers allow both (i) and (ii) and the MLP-blocks perform (i). The idea behind the Mixer architecture is to clearly separate the per-location (channel-mixing) operations (i) and cross-location (token-mixing) operations (ii). Both operations are implemented with MLPs. Figure [1](#fig_0) summarizes the architecture.

Mixer takes as input a sequence of S non-overlapping image patches, each one projected to a desired hidden dimension C. This results in a two-dimensional real-valued input table, X ∈ R S×C . If the original input image has resolution (H, W ), and each patch has resolution (P, P ), then the number of patches is S = HW/P 2 . All patches are linearly projected with the same projection matrix. Mixer consists of multiple layers of identical size, and each layer consists of two MLP blocks. The first one is the token-mixing MLP: it acts on columns of X (i.e. it is applied to a transposed input table X ), maps R S → R S , and is shared across all columns. The second one is the channel-mixing MLP: it acts on rows of X, maps R C → R C , and is shared across all rows. Each MLP block contains two fully-connected layers and a nonlinearity applied independently to each row of its input data tensor. Mixer layers can be written as follows (omitting layer indices):

$U * ,i = X * ,i + W 2 σ W 1 LayerNorm(X) * ,i , for i = 1 . . . C,(1)$$Y j, * = U j, * + W 4 σ W 3 LayerNorm(U) j, * , for j = 1 . . . S.$Here σ is an element-wise nonlinearity (GELU [[16]](#b16)). D S and D C are tunable hidden widths in the token-mixing and channel-mixing MLPs, respectively. Note that D S is selected independently of the number of input patches. Therefore, the computational complexity of the network is linear in the number of input patches, unlike ViT whose complexity is quadratic. Since D C is independent of the patch size, the overall complexity is linear in the number of pixels in the image, as for a typical CNN.

As mentioned above, the same channel-mixing MLP (token-mixing MLP) is applied to every row (column) of X. Tying the parameters of the channel-mixing MLPs (within each layer) is a natural choice-it provides positional invariance, a prominent feature of convolutions. However, tying parameters across channels is much less common. For example, separable convolutions [[9,](#b9)[40]](#b40), used in some CNNs, apply convolutions to each channel independently of the other channels. However, in separable convolutions, a different convolutional kernel is applied to each channel unlike the token-mixing MLPs in Mixer that share the same kernel (of full receptive field) for all of the channels. The parameter tying prevents the architecture from growing too fast when increasing the hidden dimension C or the sequence length S and leads to significant memory savings. Surprisingly, this choice does not affect the empirical performance, see Supplementary A.1.

Each layer in Mixer (except for the initial patch projection layer) takes an input of the same size. This "isotropic" design is most similar to Transformers, or deep RNNs in other domains, that also use a fixed width. This is unlike most CNNs, which have a pyramidal structure: deeper layers have a lower resolution input, but more channels. Note that while these are the typical designs, other combinations exist, such as isotropic ResNets [[38]](#b38) and pyramidal ViTs [[52]](#b52).

Aside from the MLP layers, Mixer uses other standard architectural components: skip-connections [[15]](#b15) and layer normalization [[2]](#b2). Unlike ViTs, Mixer does not use position embeddings because the token-mixing MLPs are sensitive to the order of the input tokens. Finally, Mixer uses a standard classification head with the global average pooling layer followed by a linear classifier. Overall, the architecture can be written compactly in JAX/Flax, the code is given in Supplementary E.

## Experiments

We evaluate the performance of MLP-Mixer models, pre-trained with medium-to large-scale datasets, on a range of small and mid-sized downstream classification tasks. We are interested in three primary quantities: (1) Accuracy on the downstream task; [(2)](#b2) Total computational cost of pre-training, which is important when training the model from scratch on the upstream dataset; (3) Test-time throughput, which is important to the practitioner. Our goal is not to demonstrate state-of-the-art results, but to show that, remarkably, a simple MLP-based model is competitive with today's best convolutional and attention-based models. Downstream tasks We use popular downstream tasks such as ILSVRC2012 "ImageNet" (1.3M training examples, 1k classes) with the original validation labels [13] and cleaned-up ReaL labels [5], CIFAR-10/100 (50k examples, 10/100 classes) [23], Oxford-IIIT Pets (3.7k examples, 36 classes) [32], and Oxford Flowers-102 (2k examples, 102 classes) [31]. We also use the Visual Task Adaptation Benchmark (VTAB-1k), which consists of 19 diverse datasets, each with 1k training examples [58].

## Pre-training

We follow the standard transfer learning setup: pre-training followed by fine-tuning on the downstream tasks. We pre-train our models on two public datasets: ILSVRC2021 ImageNet, and ImageNet-21k, a superset of ILSVRC2012 that contains 21k classes and 14M images [[13]](#b13). To assess performance at larger scale, we also train on JFT-300M, a proprietary dataset with 300M examples and 18k classes [[44]](#b44). We de-duplicate all pre-training datasets with respect to the test sets of the downstream tasks as done in Dosovitskiy et al. [[14]](#b14), Kolesnikov et al. [[22]](#b22). We pre-train all models at resolution 224 using Adam with β 1 = 0.9, β 2 = 0.999, linear learning rate warmup of 10k steps and linear decay, batch size 4 096, weight decay, and gradient clipping at global norm 1. For JFT-300M, we pre-process images by applying the cropping technique from Szegedy et al. [[45]](#b45) in addition to random horizontal flipping. For ImageNet and ImageNet-21k, we employ additional data augmentation and regularization techniques. In particular, we use RandAugment [[12]](#b12), mixup [[60]](#b60), dropout [[43]](#b43), and stochastic depth [[19]](#b19). This set of techniques was inspired by the timm library [[54]](#b54) and Touvron et al. [[48]](#b48). More details on these hyperparameters are provided in Supplementary B.

Fine-tuning We fine-tune using momentum SGD, batch size 512, gradient clipping at global norm 1, and a cosine learning rate schedule with a linear warmup. We do not use weight decay when finetuning. Following common practice [[22,](#b22)[48]](#b48), we also fine-tune at higher resolutions with respect to those used during pre-training. Since we keep the patch resolution fixed, this increases the number of input patches (say from S to S ) and thus requires modifying the shape of Mixer's token-mixing MLP blocks. Formally, the input in Eq. ( [1](#formula_0)) is left-multiplied by a weight matrix W 1 ∈ R D S ×S and this operation has to be adjusted when changing the input dimension S. For this, we increase the hidden layer width from D S to D S in proportion to the number of patches and initialize the (now larger) weight matrix W 2 ∈ R D S ×S with a block-diagonal matrix containing copies of W 2 on its diagonal. This particular scheme only allows for S = K 2 S with K ∈ N. See Supplementary C for further details. On the VTAB-1k benchmark we follow the BiT-HyperRule [[22]](#b22) and fine-tune Mixer models at resolution 224 and 448 on the datasets with small and large input images respectively.

Metrics We evaluate the trade-off between the model's computational cost and quality. For the former we compute two metrics: (1) Total pre-training time on TPU-v3 accelerators, which combines three relevant factors: the theoretical FLOPs for each training setup, the computational efficiency on the relevant training hardware, and the data efficiency. (2) Throughput in images/sec/core on TPU-v3.

Since models of different sizes may benefit from different batch sizes, we sweep the batch sizes and report the highest throughput for each model. For model quality, we focus on top-1 downstream accuracy after fine-tuning. On two occasions (Figure [3](#fig_1), right and Figure [4](#fig_2)), where fine-tuning all of the models is too costly, we report the few-shot accuracies obtained by solving the 2 -regularized linear regression problem between the frozen learned representations of images and the labels.

## Models

We compare various configurations of Mixer, summarized in Table [1](#tab_1), to the most recent, state-of-the-art, CNNs and attention-based models. In all the figures and tables, the MLP-based Mixer models are marked with pink ( ), convolution-based models with yellow ( ), and attention-based models with blue ( ). The Vision Transformers (ViTs) have model scales and patch resolutions similar to Mixer. HaloNets are attention-based models that use a ResNet-like structure with local selfattention layers instead of 3×3 convolutions [[51]](#b51). We focus on the particularly efficient "HaloNet-H4 (base 128, Conv-12)" model, which is a hybrid variant of the wider HaloNet-H4 architecture with some of the self-attention layers replaced by convolutions. Note, we mark HaloNets with both attention and convolutions with blue ( ). Big Transfer (BiT) [[22]](#b22) models are ResNets optimized for transfer learning. NFNets [[7]](#b7) are normalizer-free ResNets with several optimizations for ImageNet classification. We consider the NFNet-F4+ model variant. We consider MPL [[34]](#b34) and ALIGN [[21]](#b21) for EfficientNet architectures. MPL is pre-trained at very large-scale on JFT-300M images, using meta-pseudo labelling from ImageNet instead of the original labels. We compare to the EfficientNet-B6-Wide model variant. ALIGN pre-train image encoder and language encoder on noisy web image text pairs in a contrastive way. We compare to their best EfficientNet-L2 image encoder.

## Main results

Table [2](#tab_2) presents comparison of the largest Mixer models to state-of-the-art models from the literature. "ImNet" and "ReaL" columns refer to the original ImageNet validation [[13]](#b13) and cleaned-up ReaL [[5]](#b5)[[42]](#b42) and 86.5% NFNet [[7]](#b7).

When the size of the upstream dataset increases, Mixer's performance improves significantly. In particular, Mixer-H/14 achieves 87.94% top-1 accuracy on ImageNet, which is 0.5% better than BiT-ResNet152x4 and only 0.5% lower than ViT-H/14. Remarkably, Mixer-H/14 runs 2.5 times faster than ViT-H/14 and almost twice as fast as BiT. Overall, Figure [2](#) (left) supports our main claim that in terms of the accuracy-compute trade-off Mixer is competitive with more conventional neural network architectures. The figure also demonstrates a clear correlation between the total pre-training cost and the downstream accuracy, even across architecture classes.

BiT-ResNet152x4 in the table are pre-trained using SGD with momentum and a long schedule. Since Adam tends to converge faster, we complete the picture in Figure [2](#) (left) with the BiT-R200x3 model from Dosovitskiy et al. [[14]](#b14) pre-trained on JFT-300M using Adam. This ResNet has a slightly lower accuracy, but considerably lower pre-training compute. Finally, the results of smaller ViT-L/16 and Mixer-L/16 models are also reported in this figure.

## The role of the model scale

The results outlined in the previous section focus on (large) models at the upper end of the compute spectrum. We now turn our attention to smaller Mixer models.

We may scale the model in two independent ways: (1) Increasing the model size (number of layers, hidden dimension, MLP widths) when pre-training; (2) Increasing the input image resolution when

10 1 10 0 10 1 Total pre-training kilo-TPUv3-core-days 84 86 88 90 92 ImageNet transfer accuracy [%] Mixer (i21k | JFT) ViT (i21k | JFT) HaloNet (i21k) BiT (i21k | JFT) NFNet (JFT) MPL (JFT) ALIGN (web) 10 M 30 M 100 M 300 M Training Size 30 40 50 60 70 Linear 5-shot ImageNet Top-1 [%] ~3B Mixer-B/32 Mixer-L/32 Mixer-L/16 BiT-R152x2 ViT-B/32 ViT-L/32 ViT-L/16 Figure 2: Left: ImageNet accuracy/training cost Pareto frontier (dashed line) for the SOTA models in Table 2. Models are pre-trained on ImageNet-21k, or JFT (labelled, or pseudo-labelled for MPL), or web image text pairs. Mixer is as good as these extremely performant ResNets, ViTs, and hybrid models, and sits on frontier with HaloNet, ViT, NFNet, and MPL. Right: Mixer (solid) catches or exceeds BiT (dotted) and ViT (dashed) as the data size grows. Every point on a curve uses the same pre-training compute; they correspond to pre-training on 3%, 10%, 30%, and 100% of JFT-300M for 233, 70, 23, and 7 epochs, respectively. Additional points at ∼3B correspond to pre-training on an even larger JFT-3B dataset for the same number of total steps. Mixer improves more rapidly with data than ResNets, or even ViT. The gap between large Mixer and ViT models shrinks. fine-tuning. While the former affects both pre-training compute and test-time throughput, the latter only affects the throughput. Unless stated otherwise, we fine-tune at resolution 224.

We compare various configurations of Mixer (see Table [1](#tab_1)) to ViT models of similar scales and BiT models pre-trained with Adam. The results are summarized in Table [3](#tab_5) and Figure 3. When trained from scratch on ImageNet, Mixer-B/16 achieves a reasonable top-1 accuracy of 76.44%. This is 3% behind the ViT-B/16 model. The training curves (not reported) reveal that both models achieve very similar values of the training loss. In other words, Mixer-B/16 overfits more than ViT-B/16. For the Mixer-L/16 and ViT-L/16 models this difference is even more pronounced. As the pre-training dataset grows, Mixer's performance steadily improves. Remarkably, Mixer-H/14 pre-trained on JFT-300M and fine-tuned at 224 resolution is only 0.3% behind ViT-H/14 on ImageNet whilst running 2.2 times faster. Figure [3](#fig_1) clearly demonstrates that although Mixer is slightly below the frontier on the lower end of model scales, it sits confidently on the frontier at the high end.

## The role of the pre-training dataset size

The results presented thus far demonstrate that pre-training on larger datasets significantly improves Mixer's performance. Here, we study this effect in more detail.

To study Mixer's ability to make use of the growing number of training examples we pre-train Mixer-B/32, Mixer-L/32, and Mixer-L/16 models on random subsets of JFT-300M containing 3%, 10%, 30% and 100% of all the training examples for 233, 70, 23, and 7 epochs. Thus, every model is pre-trained for the same number of total steps. We also pre-train Mixer-L/16 model on an even larger JFT-3B dataset [[59]](#b59) containing roughly 3B images with 30k classes for the same number of total steps. While not strictly comparable, this allows us to further extrapolate the effect of scale. We use the linear 5-shot top-1 accuracy on ImageNet as a proxy for transfer quality. For every pre-training run we perform early stopping based on the best upstream validation performance. Results are reported in Figure [2](#) (right), where we also include ViT-B/32, ViT-L/32, ViT-L/16, and BiT-R152x2 models.

When pre-trained on the smallest subset of JFT-300M, all Mixer models strongly overfit. BiT models also overfit, but to a lesser extent, possibly due to the strong inductive biases associated with the convolutions. As the dataset increases, the performance of both Mixer-L/32 and Mixer-L/16 grows faster than BiT; Mixer-L/16 keeps improving, while the BiT model plateaus.

The same conclusions hold for ViT, consistent with Dosovitskiy et al. [[14]](#b14). However, the relative improvement of larger Mixer models are even more pronounced. The performance gap between Mixer-L/16 and ViT-L/16 shrinks with data scale. It appears that Mixer benefits from the growing dataset size even more than ViT. One could speculate and explain it again with the difference in inductive biases: self-attention layers in ViT lead to certain properties of the learned functions that are less compatible with the true underlying distribution than those discovered with Mixer architecture.

## Invariance to input permutations

In this section, we study the difference between inductive biases of Mixer and CNN architectures.  setup described in Section 3 and using one of two different input transformations: (1) Shuffle the order of 16×16 patches and permute pixels within each patch with a shared permutation; (2) Permute the pixels globally in the entire image. Same permutation is used across all images. We report the linear 5-shot top-1 accuracy of the trained models on ImageNet in Figure [4](#fig_2) (bottom). Some original images along with their two transformed versions appear in Figure [4](#fig_2) (top). As could be expected, Mixer is invariant to the order of patches and pixels within the patches (the blue and green curves match perfectly). On the other hand, ResNet's strong inductive bias relies on a particular order of pixels within an image and its performance drops significantly when the patches are permuted. Remarkably, when globally permuting the pixels, Mixer's performance drops much less (∼45% drop) compared to the ResNet (∼75% drop).

## Visualization

It is commonly observed that the first layers of CNNs tend to learn Gabor-like detectors that act on pixels in local regions of the image. In contrast, Mixer allows for global information exchange in the token-mixing MLPs, which begs the question whether it processes information in a similar fashion. Figure [5](#fig_3) shows hidden units of the first three token-mixing MLPs of Mixer trained on JFT-300M.

Recall that the token-mixing MLPs allow global communication between different spatial locations. Some of the learned features operate on the entire image, while others operate on smaller regions. Deeper layers appear to have no clearly identifiable structure. Similar to CNNs, we observe many pairs of feature detectors with opposite phases [[39]](#b39). The structure of learned units depends on the hyperparameters. Plots for the first embedding layer appear in Figure [7](#) of Supplementary D.

## Related work

MLP-Mixer is a new architecture for computer vision that differs from previous successful architectures because it uses neither convolutional nor self-attention layers. Nevertheless, the design choices can be traced back to ideas from the literature on CNNs [[24,](#b24)[25]](#b25) and Transformers [[50]](#b50).

CNNs have been the de-facto standard in computer vision since the AlexNet model [[24]](#b24) surpassed prevailing approaches based on hand-crafted image features [[35]](#b35). Many works focused on improving the design of CNNs. Simonyan and Zisserman [[41]](#b41) demonstrated that one can train state-of-the-art models using only convolutions with small 3×3 kernels. He et al. [[15]](#b15) introduced skip-connections together with the batch normalization [[20]](#b20), which enabled training of very deep neural networks and further improved performance. A prominent line of research has investigated the benefits of using sparse convolutions, such as grouped [[57]](#b57) or depth-wise [[9,](#b9)[17]](#b17) variants. In a similar spirit to our token-mixing MLPs, Wu et al. [[55]](#b55) share parameters in the depth-wise convolutions for natural language processing. Hu et al. [[18]](#b18) and Wang et al. [[53]](#b53) propose to augment convolutional networks with non-local operations to partially alleviate the constraint of local processing from CNNs. Mixer takes the idea of using convolutions with small kernels to the extreme: by reducing the kernel size to 1×1 it turns convolutions into standard dense matrix multiplications applied independently to each spatial location (channel-mixing MLPs). This alone does not allow aggregation of spatial information and to compensate we apply dense matrix multiplications that are applied to every feature across all spatial locations (token-mixing MLPs). In Mixer, matrix multiplications are applied row-wise or column-wise on the "patches×features" input table, which is also closely related to the work on sparse convolutions. Mixer uses skip-connections [[15]](#b15) and normalization layers [[2,](#b2)[20]](#b20).

In computer vision, self-attention based Transformer architectures were initially applied for generative modeling [[8,](#b8)[33]](#b33). Their value for image recognition was demonstrated later, albeit in combination with a convolution-like locality bias [[37]](#b37), or on low-resolution images [[10]](#b10). Dosovitskiy et al. [[14]](#b14) introduced ViT, a pure transformer model that has fewer locality biases, but scales well to large data. ViT achieves state-of-the-art performance on popular vision benchmarks while retaining the robustness of CNNs [[6]](#b6). Touvron et al. [[49]](#b49) trained ViT effectively on smaller datasets using extensive regularization. Mixer borrows design choices from recent transformer-based architectures. The design of Mixer's MLP-blocks originates in Vaswani et al. [[50]](#b50). Converting images to a sequence of patches and directly processing embeddings of these patches originates in Dosovitskiy et al. [[14]](#b14).

Many recent works strive to design more effective architectures for vision. Srinivas et al. [[42]](#b42) replace 3×3 convolutions in ResNets by self-attention layers. Ramachandran et al. [[37]](#b37), Tay et al. [[47]](#b47), Li et al. [[26]](#b26), and Bello [[3]](#b3) design networks with new attention-like mechanisms. Mixer can be seen as a step in an orthogonal direction, without reliance on locality bias and attention mechanisms.

The work of Lin et al. [[27]](#b27) is closely related. It attains reasonable performance on CIFAR-10 using fully connected networks, heavy data augmentation, and pre-training with an auto-encoder. Neyshabur [[30]](#b30) devises custom regularization and optimization algorithms and trains a fully-connected network, attaining impressive performance on small-scale tasks. Instead we rely on token and channel-mixing MLPs, use standard regularization and optimization techniques, and scale to large data effectively.

Traditionally, networks evaluated on ImageNet [[13]](#b13) are trained from random initialization using Inception-style pre-processing [[46]](#b46). For smaller datasets, transfer of ImageNet models is popular. However, modern state-of-the-art models typically use either weights pre-trained on larger datasets, or more recent data-augmentation and training strategies. For example, Dosovitskiy et al. [[14]](#b14), Kolesnikov et al. [[22]](#b22), Mahajan et al. [[29]](#b29), Pham et al. [[34]](#b34), Xie et al. [[56]](#b56) all advance state-of-the-art in image classification using large-scale pre-training. Examples of improvements due to augmentation or regularization changes include Cubuk et al. [[11]](#b11), who attain excellent classification performance with learned data augmentation, and Bello et al. [[4]](#b4), who show that canonical ResNets are still near state-of-the-art, if one uses recent training and augmentation strategies.

## Conclusions

We describe a very simple architecture for vision. Our experiments demonstrate that it is as good as existing state-of-the-art methods in terms of the trade-off between accuracy and computational resources required for training and inference. We believe these results open many questions. On the practical side, it may be useful to study the features learned by the model and identify the main differences (if any) from those learned by CNNs and Transformers. On the theoretical side, we would like to understand the inductive biases hidden in these various features and eventually their role in generalization. Most of all, we hope that our results spark further research, beyond the realms of established models based on convolutions and self-attention. It would be particularly interesting to see whether such a design works in NLP or other domains. Pyramids All layers in Mixer retain the same, isotropic design. Recent improvements on the ViT architecture hint that this might not be ideal [[52]](#b52). We tried using the token-mixing MLP to reduce the number of tokens by mapping from S input tokens to S < S output tokens. While first experiments showed that on JFT-300M such models significantly reduced training time without losing much performance, we were unable to transfer these findings to ImageNet or ImageNet-21k. However, since pyramids are a popular design, exploring this design for other vision tasks may still be promising.

## A.2 Fine-tuning

Following ideas from BiT [[22]](#b22) and ViT [[14]](#b14), we also tried using mixup [[60]](#b60) and Polyak averaging [[36]](#b36) during fine-tuning. However, these did not lead to consistent improvements, so we dropped them. We also experimented with using inception cropping [[45]](#b45) during fine-tuning, which also did not lead to any improvements. We did these experiments for JFT-300M pre-trained Mixer models of all scales.

## B Pre-training: hyperparameters, data augmentation and regularization

In Table [4](#tab_6) we describe optimal hyperparameter settings that were used for pre-training Mixer models.

For pre-training on ImageNet and ImageNet-21k we used additional augmentation and regularization.

For RandAugment [[12]](#b12) we always use two augmentations layers and sweep magnitude, m, parameter in a set {0, 10, 15, 20}. For mixup [[60]](#b60) we sweep mixing strength, p, in a set {0.0, 0.2, 0.5, 0.8}. For dropout [[43]](#b43) we try dropping rates, d of 0.0 and 0.1. For stochastic depth, following the original paper [[19]](#b19), we linearly increase the probability of dropping a layer from 0.0 (for the first MLP) to s (for the last MLP), where we try s ∈ {0.0, 0.1}. Finally, we sweep learning rate, lr, and weight decay, wd, from {0.003, 0.001} and {0.1, 0.01} respectively.

C Fine-tuning: hyperparameters and higher image resolution Models are fine-tuned at resolution 224 unless mentioned otherwise. We follow the setup of [[14]](#b14). The only differences are: (1) We exclude lr = 0.001 from the grid search and instead include lr = 0.06 for CIFAR-10, CIFAR-100, Flowers, and Pets. (2) We perform a grid search over lr ∈ {0.003, 0.01, 0.03} for VTAB-1k. (3) We try two different ways of pre-processing during evaluation: (i) "resize-crop": first resize the image to 256 × 256 pixels and then take a 224 × 224 pixel sized central crop. (ii) "resmall-crop": first resize the shorter side of the image to 256 pixels and then take a 224 × 224 pixel sized central crop. For the Mixer and ViT models reported in Table [3](#tab_5) of the main text we used (ii) on ImageNet, Pets, Flowers, CIFAR-10 and CIFAR-100. We used the same setup for the BiT models reported in Table [3](#tab_5) of the main text, with the only exception of using (i) on ImageNet. For the Mixer models reported in Table [2](#tab_2) of the main text we used (i) for all 5 downstream datasets.

Fine-tuning at higher resolution than the one used at pre-training time has been shown to substantially improve the transfer performance of existing vision models [[48,](#b48)[22,](#b22)[14]](#b14). We therefore apply this technique to Mixer as well. When feeding images of higher resolution to the model, we do not change the patch size, which results in a longer sequence of tokens. The token-mixing MLPs have to be adjusted to handle these longer sequences. We experimented with several options and describe the most successful one below.

For simplicity we assume that the image resolution is increased by an integer factor K. The length S of the token sequence increases by a factor of K 2 . We increase the hidden width D S of the token-mixing MLP by a factor of K 2 as well. Now we need to initialize the parameters of this new (larger) MLP with the parameters of the pre-trained MLP. To this end we split the input sequence into K 2 equal parts, each one of the original length S, and initialize the new MLP so that it processes all these parts independently in parallel with the pre-trained MLP.

Formally, the pre-trained weight matrix W 1 ∈ R D S ×S of the original MLP in Eq. 1 of the main text will be now replaced with a larger matrix W 1 ∈ R (K 2 •D S )×(K 2 •S) . Assume the token sequence for the resized input image is a concatenation of K 2 token sequences of length S each, computed by splitting the input into K × K equal parts spatially. We then initialize W 1 with a block-diagonal matrix that has copies of W 1 on its main diagonal. Other parameters of the MLP are handled analogously.

## D Weight visualizations

For better visualization, we sort all hidden units according to a heuristic that tries to show low frequency filters first. For each unit, we also try to identify the unit that is closest to its inverse. Figure [6](#) shows each unit followed by its closest inverse. Note that the models pre-trained on ImageNet and ImageNet-21k used heavy data augmentation. We found that this strongly influences the structure of the learned units.

We also visualize the linear projection units in the embedding layer learned by different models in Figure [7](#). Interestingly, it appears that their properties strongly depend on the patch resolution used by the models. Across all Mixer model scales, using patches of higher resolution 32×32 leads to Gabor-like low-frequency linear projection units, while for the 16×16 resolution the units show no such structure.

![Figure 1: MLP-Mixer consists of per-patch linear embeddings, Mixer layers, and a classifier head. Mixer layers contain one token-mixing MLP and one channel-mixing MLP, each consisting of two fully-connected layers and a GELU nonlinearity. Other components include: skip-connections, dropout, and layer norm on the channels.]()

![Figure 3: The role of the model scale. ImageNet validation top-1 accuracy vs. total pre-training compute (left) and throughput (right) of ViT, BiT, and Mixer models at various scales. All models are pre-trained on JFT-300M and fine-tuned at resolution 224, which is lower than in Figure 2 (left).]()

![Figure 4: Top: Input examples from ImageNet before permuting the contents (left); after shuffling the 16 × 16 patches and pixels within the patches (center); after shuffling pixels globally (right). Bottom: Mixer-B/16 (left) and ResNet50x1 (right) trained with three corresponding input pipelines.]()

![Figure 5: Hidden units in the first (left), second (center), and third (right) token-mixing MLPs of a Mixer-B/16 model trained on JFT-300M. Each unit has 196 weights, one for each of the 14 × 14 incoming patches. We pair the units to highlight the emergence of kernels of opposing phase. Pairs are sorted by filter frequency. In contrast to the kernels of convolutional filters, where each weight corresponds to one pixel in the input image, one weight in any plot from the left column corresponds to a particular 16 × 16 patch of the input image. Complete plots in Supplementary D.]()

![Specifications of the Mixer architectures. The "B", "L", and "H" (base, large, and huge) model scales follow Dosovitskiy et al.[14]. A brief notation "B/16" means the model of base scale with patches of resolution 16×16. The number of parameters is reported for an input resolution of 224 and does not include the weights of the classifier head.]()

![Transfer performance, inference throughput, and training cost. The rows are sorted by inference throughput (fifth column). Mixer has comparable transfer accuracy to state-of-the-art models with similar cost. The Mixer models are fine-tuned at resolution 448. Mixer performance numbers are averaged over three fine-tuning runs and standard deviations are smaller than 0.1.]()

![Performance of Mixer and other models from the literature across various model and pre-training dataset scales. "Avg. 5" denotes the average performance across five downstream tasks. Mixer and ViT models are averaged over three fine-tuning runs, standard deviations are smaller than 0.15. ( ‡) Extrapolated from the numbers reported for the same models pre-trained on JFT-300M without extra regularization. ( ) Numbers provided by authors of Dosovitskiy et al.[14] through personal communication. Rows are sorted by throughput.]()

![Hyperparameter settings used for pre-training Mixer models.Grouping the channels together Token-mixing MLPs take S-dimensional vectors as inputs. Every such vector contains values of a single feature across S different spatial locations. In other words, token-mixing MLPs operate by looking at only one channel at once. One could instead group channels together by concatenating G neighbouring columns in X ∈ R S×C , reshaping it to a matrix of dimension (S • G) × (C/G). This increases the MLP's input dimensionality from S to G • S and reduces the number of vectors to be processed from C to C/G. Now the MLPs look at several channels at once when mixing the tokens. This concatenation of the column-vectors improved linear 5-shot top-1 accuracy on ImageNet by less than 1-2%.]()

MLP-Mixer code will be available at https://github.com/google-research/vision_transformer Preprint. Under review.

In Table2we consider the highest accuracy models in each class for each pre-training dataset. These all use the large resolutions (448 and above). However, fine-tuning at smaller resolution can lead to substantial improvements in the test-time throughput, with often only a small accuracy penalty. For instance, when pretraining on ImageNet-21k, the Mixer-L/16 model fine-tuned at 224 resolution achieves 82.84% ImageNet top-1 accuracy at throughput 420 img/sec/core; the ViT-L/16 model fine-tuned at

resolution achieves 85.15% at 80 img/sec/core[[14]](#b14); and HaloNet fine-tuned at 384 resolution achieves 85.5% at 258 img/sec/core[[51]](#b51).

Pre-trained on ImageNet (with extra regularization)

