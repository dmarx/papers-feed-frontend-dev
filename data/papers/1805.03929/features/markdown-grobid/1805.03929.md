# Resource-Bounded Kolmogorov Complexity Provides an Obstacle to Soficness of Multidimensional Shifts

## Abstract

## 

We suggest necessary conditions for soficness of multidimensional shifts formulated in terms of resource-bounded Kolmogorov complexity. Using this technique we provide examples of effective and non-sofic shifts on Z 2 with very low block complexity: the number of globally admissible patterns of size n × n grows only as a polynomial in n. We also show that more conventional proofs of non-soficness for multi-dimensional effective shifts, including the techniques of Pavlov [

## Introduction

Symbolic dynamics originally appeared in mathematics as a branch of the theory of dynamical systems that studies smooth or topological dynamical systems by discretizing the underlying space. Since the late 1930s, symbolic dynamics became an independent field of research, see [[10,](#b9)[11]](#b10). A classical dynamical system is a space (of states) S with a function F acting on this space; this function represents the "evolution rule," i.e., the time dependence of a configuration in the space. The central notion of the theory of dynamical systems is a trajectory -a sequence of configurations obtained by iterating the evolution rules,

x, F (x), F (F (x)), . . . , F (n) (x), . . .

In symbolic dynamics the space of states reduces to a finite set (an alphabet). The trajectories are represented by infinite (or bi-infinite) sequences of letters over this alphabet, and the "evolution rule" is the shift operator acting on these sequences. Symbolic dynamics focuses on the shift spaces -the sets of bi-infinite sequences of letters (over a finite alphabet) that are defined by a shift-invariant constraint on the factors of finite length. More precisely, a shift space (also called a shift) over an alphabet Σ is a non-empty subset of bi-infinite sequences over Σ that is translation invariant and closed in the standard topology of the Cantor space. Every shift can be defined in terms of forbidden finite patterns: we fix a set of (finite) words F and say that a configuration (a bi-infinite sequence) belongs to the corresponding shift S F if and only if it does not contain any factor from F. We bear in mind that different sets of forbidden patterns can induce the same shift.

Obviously, the properties of shifts heavily depend on the corresponding set of forbidden patterns. The following three large classes of shifts play an important role in symbolic dynamics and computability theory:

• shifts of finite type (SFT), which can be defined by a finite set of forbidden finite patterns;

• sofic shifts (introduced in [[20]](#b19)), where the set of forbidden finite patterns is a regular language;

• effective (or effectively closed shifts), which can be defined by a computable[foot_0](#foot_0) set of forbidden finite patterns.

The class of effective shifts is often understood as a class of "explicitly constructible" shifts, so it is of considerable interest beyond the scope of computability theory. These three classes are distinct:

[the SFTs] [the sofic shifts] [the effective shifts].

The sofic shifts can be equivalently defined as the coordinate-wise projections of configurations from an SFT: Definition 1. A shift S over an alphabet Σ is sofic if there is an SFT S over an alphabet Σ and a mapping π : Σ → Σ, such that S consists of the coordinate-wise projections (. . . π(y -1 )π(y 0 )π(y 1 )π(y 2 ) . . .) of all configurations (. . . y -1 y 0 y 1 y 2 . . .) from S .

There is a simple characterization of soficness. Let us say that two words w 1 , w 2 are equivalent in a shift S, if they have the same follower sets, i.e., if exactly the same half-infinite configurations occur in S immediately to the right of w 1 and to the right of w 2 . A shift is sofic if and only if the finite patterns in this shift are subdivided in a finite number of equivalence classes (see [[9,](#b8)[Theorem 3.2.10]](#)). Loosely speaking, this criterion guarantees that when we read a configuration from the left to the right and verify that it belongs to a sofic shift, we need to keep in mind only finite information.

The SFTs and even the sofic shifts are rather restrictive classes of shifts with several very special properties. Not surprisingly, many important examples of effective shifts are not sofic. Non-soficness of a shift is usually proved with some version of the pumping lemma from automata theory.

Multidimensional shifts. The formalism of shifts can be naturally extended to the grids Z d for d > 1. A shift on Z d (over a finite alphabet Σ) is defined as a set of d-dimensional configurations f : Z d → Σ that are (i) translation-invariant (under translations in all directions) and (ii) closed in Cantor's topology. Similar to the one-dimensional case, the shifts can be defined in terms of forbidden finite patterns.

The definitions of the effective shifts (the set of forbidden patterns is computable) and of the SFTs (the set of forbidden patterns is finite) apply to the multidimensional shift spaces directly, without any revision. The sofic shifts on Z d are defined as in Definition 1 above (as the coordinate-wise projections of SFTs). We refer the reader to [[4]](#b3) for an extensive discussion of the relations between SFT, sofic, and effective shifts on Z d .

For multidimensional shifts spaces, the classes of the effective shifts, the sofic shifts, and the SFTs remain distinct, though the difference between these classes is more elusive than in the one-dimensional case. In this paper we discuss the tools that help to reveal the reasons why one or another effective multidimensional shift is not sofic.

The class of sofic shifts in dimension d ≥ 2 is surprisingly wide. Besides many simple and natural examples, there are shifts whose soficness follow from rather subtle considerations. For instance, S. Mozes showed that the shifts generated by (a natural class of) non deterministic multidimensional substitutions systems are sofic [[12]](#b11). L. B. Westrick proved that the two-dimensional shift on the alphabet {0, 1} whose configurations consist of squares of 1s of pairwise different sizes on a background of 0s, is sofic; moreover, any effectively closed subshift of this shift is also sofic [[21]](#b20).

On the other hand, there are several examples of effective multidimensional shifts that are known to be non-sofic. In what follows we briefly discuss two of them.

Example 1 (the mirror shift). One of the standard examples of a non-sofic shift is the shift of mirrorsymmetric configurations on Z 2 . Let Σ be the alphabet with three letters (e.g., black, white, and red ), and the configurations of the shift are all black-and-white configurations (without any red letter) and the configurations with an infinite horizontal line of red letters and symmetric black-and-white half-planes above and below this line, see Fig. [1](#). We denote this shift by S mirror .

It is easy to see that this shift is effective (the forbidden patterns are those where the red letters are not aligned, and those where the areas above and below the horizontal red line are not symmetric). At the same time, this shift is not sofic. The intuitive explanation of this fact is as follows. Let us focus on a pair of symmetric patterns of size n × n in black and white, above and below the horizontal red line (see the blue squares in Fig. [1](#)). To make sure that the configuration belongs to the shift, we must "compare" these two patterns with each other. To this end, we need to transmit the information about a pattern of size n 2 through its border line (of length O(n)). However, in a sofic shift, the "information flow" across a Figure [1:](#) A configuration with mirror symmetry with respect to the horizontal red line. The blue squares select two symmetric black-and-white patterns. contour of length O(n) is bounded by O(n) bits, and this contradiction implies non-soficness. For a more formal argument see, e.g. [[1]](#b0) and [[5]](#b4), or a similar example [[6,](#b5)[Example 2.4](#)]. We revisit this example in Section 4.1 and use it as a simple illustration of our technique.

Example 2 (the high complexity shift). Let S be the set of all binary configurations on Z 2 where for each n × n pattern P its Kolmogorov complexity is quadratic, C(P ) = Ω(n 2 ). Technically, this means that no globally admissible pattern can be produced by a program of size below cn 2 , for some factor c > 0 (see the formal definition of Kolmogorov complexity below).

This shift is not sofic. This follows from two facts (proven in [[2]](#b1)):

(i) For some c < 1, the shift defined above is not empty.

(ii) In every non-empty sofic shift on Z 2 , there is a configuration where the Kolmogorov complexity of each n × n pattern is bounded by O(n).

At the same time, this shift is obviously effective: we can algorithmically enumerate the patterns whose Kolmogorov complexity is below the specified threshold. In Section 3 we study a similar construction based on a less conventional version of Kolmogorov complexity.

Note that the non-sofic shifts in the two examples above have positive entropy (the number of globally admissible patterns of size n × n grows as 2 Ω(n 2 ) ). This is not surprising: the proofs of non-soficness of these shifts use the intuition about the information flows (super-linear amount of information cannot flow through a linear contour ). This type of argument can be adapted for some shifts where the number of globally admissible patterns of size n × n grows slower than 2 Ω(n 2 ) but still faster than 2 O(n) (see, e.g. [[18,](#b17)[Proposition 15]](#)). As it was noticed in [[21]](#b20), "all examples known to the author of effectively closed shifts which are not sofic were obtained by in some sense allowing elements to pack too much important information into a small area."

This type of argument was formalized as rather general sufficient conditions of non-soficness in [[15]](#b14) and [[6]](#b5). The theorems by Kass and Madden ([6, Theorem 3.2.10]) and Pavlov ([15, Theorem 1.1]) apply only to the two-dimensional shifts where the number of globally admissible n × n patterns is greater than 2 O(n) . However, there is no reason to think that this condition is necessary for non-soficness (see, e.g. the discussion in [5, Section 1.2.2]). It is instructive to observe that non-effective non-sofic shifts can have very low block complexity, see [[6,](#b5)[14]](#b13).

In this paper we propose a new approach to the proof of non-soficness. Our technique uses algorithmic descriptive complexity [(Kolmogorov complexity)](#). Though the definition of the sofic shifts does not involve explicitly any resource bounded computations, we show that a suitable tool to deal with soficness is the time-bounded version of Kolmogorov complexity. We argue that a shift on Z 2 cannot be sofic if the essential information contained in an n × n pattern cannot be compressed to the size O(n) in bounded time.

The ideas behind our argument are similar to those used in [[2]](#b1) and [[6]](#b5), and there is no surprise that Kolmogorov complexity helps to formalize the intuition of "information flows." The main new element of our approach is the idea of information compression with bounded computational resources.

This technique applies to several shifts with very low block complexity: we cannot "communicate" the essential information about a pattern across its contour not because this information is too large, but since we do not have enough time and space to compress it. In particular, we provide examples of non-sofic effective shifts with only polynomial block complexity (and thus zero entropy).

Remark 1. A more straightforward approach to the measure of the "information flow through the border line of a pattern" might use the notion of extender sets introduced in [[6]](#b5). Extender sets are a natural generalization of follower sets to multi-dimensional shifts. Let S be a shift and P be a globally admissible finite pattern in this shift. The extender set of P in S is the set of all (co-finite) patterns Q completing P to a valid configuration of S (the support of Q should be the complement of the support of P ).

Let S be a shift on Z 2 ; denote by N k the number of different extender sets for the globally admissible patterns with a support of size k × k. (Several patterns can share one and the same extender set, so the number of extender sets might be much less than the number of all globally admissible patterns of this size). It seems natural to interpret log N k as the "information flow" crossing the border line of a k × k pattern and imposing the consistency between the pattern and its complement. As the length of the contour around a k × k pattern is O(k), the naive intuition suggests that "a super-linear flow of information cannot cross a contour of linear length." This is indeed true for shifts of finite type: for every SFT on Z 2 , the number N k is not bigger than 2 O(k) . However, in case of sofic shifts, this approach fails. For a sofic shift on Z 2 , the value of log N k can grow much faster than the length of the border line of the pattern ( [[6]](#b5) attributes this observation to unpublished works of C. Hoffman, A. Quas, and R. Pavlov). In fact, for a sofic shift on Z 2 , the value of log N k can grow even as Ω(k 2 ) (we mention such an example in Section 4.2). Therefore, we cannot use the asymptotic of log N k to prove non-soficness of a multi-dimensional shift. This is why we need a subtler refinement of the intuition of "information flows" in sofic shifts.

Though the cardinality of the family of extender sets is not enough to distinguish between sofic and non-sofic shifts, some finer properties of extender sets can be helpful. Kass and Madden proposed in [[6]](#b5) an approach to the proof of non-soficness based on the structure of these sets. Technically, they focus on the length of union-increasing chains of extender sets, which is a more appropriate parameter than the total number of these sets. We discuss this method in Section 4.3 and show that it is can be interpreted as a special case of our approach.

The rest of the paper is organized as follows. After recalling the necessary definitions from symbolic dynamics and the theory of Kolmogorov complexity in Section 2, we prove in Section 3 our main technical results and construct a non-sofic effective shift with very low block complexity. In Section 4 we extend our technique to more general settings; we discuss several examples and show that every proof of nonsoficness using the argument from [[6]](#b5) (the method of union-increasing chains of extender sets) can be reformulated in terms of our technique with the resource-unbounded Kolmogorov complexity. For the sake of self-containedness, in Appendix we prove Theorem 3 (implicitly proven in [[2]](#b1)) and Lemma 1 (formulated and proven in different terms in [[6]](#b5)). We also prove in Appendix Theorem 4, which is a stronger version of Theorem 4 (though the simpler Theorem 4 proven in the main text of the paper is strong enough for all applications where we use it to construct effective non-sofic shifts).

## Preliminaries

Shift spaces In the introduction we have defined the notion of shift spaces (also called shifts). More specifically, we study shifts of finite type, sofic shifts, and effective shifts. In this paper we focus on two-dimensional shifts, though all arguments can be extended to the shifts on Z d for all d ≥ 2.

A (finite) pattern on Z 2 over a finite alphabet Σ is a mapping from a (finite) subset of Z 2 to Σ; the domain of this mapping is the support of the pattern. Sometimes a pattern P with a support A is called a coloring of A (the "colors" are letter from Σ).

For a shift S, we say that a pattern P is globally admissible, if P is a restriction of a configuration from S onto some finite support. For a shift of finite type determined by a set of forbidden patterns F, we say that a pattern is locally admissible if it contains no forbidden patterns from F. Similarly, two patterns with disjoint domains are locally compatible if the union of these patterns is locally admissible.

The block complexity of a shift is a function that gives for each integer n > 0 the number of globally admissible patterns of size n × n (patterns with support {1, . . . , n} 2 ) in this shift.

If a sofic shift S is a coordinate-wise projection of configurations from Ŝ, we say that Ŝ is a covering of S. Every sofic shift has a covering SFT that can be defined by a set of forbidden patterns F , where every pattern in F is a pair of neighboring letters (see, e.g. [[9]](#b8)).

## Computability and Kolmogorov complexity

In this section we recall the main definitions of the theory of Kolmogorov complexity. In the way that is usual in computability theory (see, e.g., [[13,](#b12)[16]](#b15)), we identify algorithms with Turing machines. A partial function f : {0, 1} * → {0, 1} * is called computable, if there is an algorithm (a Turing machine) M that computes this function in the following sense: given as the input a string x from the domain of f , machine M prints the value f (x) and stops; given as the input a string x such that f (x) is not defined, machine M never stops. It is known that the class of computable functions does not change if we vary minor details of the definition of a Turing machine (we may admit machine with only one tape or with any number of tapes, the tapes can be bi-infinite or only infinite to the right, and so on). It is generally agreed that this definition is an adequate formalization of the intuitive idea of computability. In this paper we discuss several simple algorithms; we give only an informal description of these algorithms and do not construct explicitly the corresponding Turing machines.

Let U be a (partial) computable function. The complexity of x with respect to the description method U is defined as

$C U (x) := min{ |p| : U (p) = x },$where |p| stands for the length of the binary string p. If there is no p such that U (p) = x, we assume that C U (x) = ∞. Here U is understood as a programming language; p is a program that prints x; the complexity of x is the length of (one of) the shortest programs p that generate x.

The obvious problem with this definition is its dependence on U . The theory of Kolmogorov complexity becomes possible due to the following invariance theorem.

Theorem 1 (Kolmogorov, [[7]](#b6)). There exists a computable function U such that for any other computable function V there is a constant d such that

$C U (x) ≤ C V (x) + d for all x.$Notation 1. This U is called an optimal description method. We fix an optimal U and in what follows omit the subscript in C U (x) and use the notation C(x). The value C(x) is called the (plain) Kolmogorov complexity of x.

In a similar way, we define Kolmogorov complexity in terms of programs with bounded resources (the time of computation). Let U be a Turing machine; we define the Kolmogorov complexity C t U (x) as the length of the shortest p such that U (p) produces x in at most t steps. There exists an optimal description method U in the following sense: for every Turing machine V

$C poly(t) U (x) ≤ C t V (x) + O(1).$For multi-tape Turing machines a slightly stronger statement can be proven:

Theorem 2 (see [[8]](#b7); the proof uses the simulation technique from [[3]](#b2)). There exists an optimal description method (multi-tape Turing machine) U m in the following sense: for every multi-tape Turing machine V (with any number of tapes) there exists a constant d such that

$C ct log t Um (x) ≤ C t V (x) + d for all strings x.$Notation 2. We fix such a machine U m , and in the sequel use for the resource-bounded version of Kolmogorov complexity the notation C t (x) instead of C t Um (x). Without loss of generality we may assume that C(x) ≤ C t (x) for all x and for all t.

It is easy to show that there exists a constant d such that for all bit strings x = (x 1 . . . x n ) ∈ {0, 1} n we have C(x) ≤ n + d (roughly speaking, this is true because there always exists a trivial algorithm of type "print(x 1 . . . x n )" where the bits x i are listed explicitly; such an algorithm can be expressed in any natural programming language, including Turing machines). At the same time, for every n there exists a string x ∈ {0, 1} n such that C(x) ≥ n, because the total number of descriptions p that are shorter than n bits, is less than 2 n . (Such a string x is usually called incompressible.) More generally, in every set of 2 n strings there is at least one string x such that C(x) ≥ n.

We fix a computable enumeration of finite patterns (over a finite alphabet) that assigns a binary string (a code) to each pattern in dimension two. In the sequel we take the liberty of talking about Kolmogorov complexity of finite patterns in dimension two (assuming the Kolmogorov complexity of the codes of these patterns). Similarly, we can talk about Kolmogorov complexity of natural numbers (assuming the Kolmogorov complexity of the binary expansion of these numbers).

In computability theory it is common to study relativized computations, i.e., computations with an oracle. Let O be an infinite binary sequence. A Turing machine with oracle O is a Turing machine with an extra read-only tape where the bits of O are written; the machine can read bits of the oracle when necessary and then use them in the computation on the usual read/write working tape. Though the access to an oracle can extend the power of a Turing machine, many fundamental properties of Turing machines remain valid with any oracle (in particular, the arguments based on diagonalization apply to Turing machines with an oracle). We refer the reader to the textbooks [[13,](#b12)[16]](#b15) for a detailed discussion of relativized computations. Notation 3. Having fixed an infinite sequence O, we can define the relativized version of Kolmogorov complexity for machines with oracle O (in exactly the same way as above but with Turing machines having the access to the chosen oracle). We use the notation C O (x) for Kolmogorov complexity with oracle O; similarly, C t,O (x) denotes Kolmogorov complexity with oracle O and time bound t.

A systematic introduction to the theory of Kolmogorov can be found in [[8,](#b7)[19]](#b18). In what follows we use only rather simple properties of Kolmogorov complexity. Throughout the paper, the claims of the form C t (x) = m can be understood as an informal statement there is a program of length m that prints x in t steps; we avoid statements where subtle details of the formal definition of Kolmogorov complexity become significant.

## High resource-bounded Kolmogorov complexity is compatible with low block complexity

The following theorem was proven implicitly in [[2]](#b1):

Theorem 3. In every non-empty sofic shift S on Z 2 there exists a configuration x such that for all n × n-patterns P in x, we have

$C T (n) (P ) = O(n) for a time threshold T (n) = 2 O(n 2 ) .$In [[2]](#b1) a weaker version of this theorem is stated: it is claimed only that the plain complexity of n × n patterns is O(n). However, the argument from [[2]](#b1) implies a bound for a resource-bounded version of Kolmogorov complexity. For the sake of self-containedness, in what follows we provide a proof of this theorem in A.

Theorem 3 guarantees that a shift is non-sofic, if in every configuration we can find a sequence of growing size patterns with super-linear Kolmogorov complexity. In the next theorem we prove the existence of such effective shifts. Theorem 4. For every > 0 and for every computable T (n) there exists an effective shift on Z 2 such that for every n and for every globally admissible pattern P of size n × n, we have that (i) C(P ) = O(log n), and

$(ii) C T (n) (P ) = Ω(n 2-).$We defer the proof of Theorem 4 to B. In what follows we prove a slightly weaker version of this theorem, which is nevertheless strong enough for our main applications: Theorem 4 . For every computable T (n) there exists an effective shift on Z[foot_1](#foot_1) such that (i) for every n and for every globally admissible pattern P of size n × n, we have C(P ) = O(log n), and

(ii) for infinitely many n and for every globally admissible pattern P of size n × n, we have that C T (n) (P ) = Ω(n 1.5 ).

From Theorem 3 and Theorem 4 we deduce the following corollary:

Corollary 1. There exists an effective non-sofic shift on Z 2 with block complexity poly(n), i.e., with ≤ poly(n) globally admissible blocks of size n × n.

Proof. We take the shift from Theorem 4 assuming that the threshold T (n) is much greater than 2 Ω(n 2 ) (e.g., we can let T (n) = 2 n 3 ). On the one hand, property (ii) of Theorem 4 and Theorem 3 guarantee that this shift is not sofic. On the other hand, property (i) of Theorem 4 implies that the number of globally admissible blocks of size n × n is not greater than 2 O(log n) .

Remark 2. Our proof of Theorem 4 implies a stronger bound than property (i). In fact, instead of the bound C(P ) = O(log n) we can prove for some (large enough) computable function T (n) that for every globally admissible n × n pattern P in this shift we have

$C T (n) (P ) = O(log n).$Now we introduce some notation.

Notation 4. For any function T (n) and for any number λ > 0, let S λ,T denote the following shift over the alphabet {0, 1}: a configuration x belongs to S λ,T if and only if C T (n) (P ) ≤ λ log n for every n × n pattern P in x.

Obviously, for an integer λ and a computable T (n), the shift introduced in Notation 4 is effective. Remark 2 can be rephrased as follows: there are an integer number λ and a computable function T (n) such that for the corresponding shift S λ, T there exists a sequence of globally admissible patterns

$P n of size n × n (n = 1, 2, . . .) such that C 2 n 3 (P n ) = Ω(n 1.5 );$the same time, for every globally admissible pattern of size n × n we have C(P ) ≤ C T (n) (P ) = O(log n).

Notation 5. Let S 0 denote the shift defined above.

The shift constructed in Theorem 4 is a proper subshift of S 0 . Indeed, besides all configurations of the shift from Theorem 4 (those configuration must have only patterns with high resource-bounded Kolmogorov complexity), S 0 admits also patterns with a very low time bounded complexity (e.g., the configuration with all 0s and the configuration with all 1s). In the next section we use S 0 to construct some other examples of effective non-sofic shifts.

(Proof of Theorem 4 ). In this proof we provide a construction of a required shift assuming that we have fixed in advance a universal Turing machine in the definition of Kolmogorov complexity. The choice of a universal Turing machine is not unique (and quite arbitrary), and the final choice of parameters in our construction depends on this arbitrariness.

Let us fix a sequence (n i ) where n 0 is a large enough integer number 2 , and

$n i+1 := (n 0 • . . . • n i ) c for i = 0, 1, 2, . . . ,(1)$where c ≥ 3 is a constant. We set

$N i := n 0 • . . . • n i .$In what follows we construct for each i a pair of standard binary patterns

$Q 0 i and Q 1 i of size N i × N i such that$• the plain Kolmogorov complexities of the standard patterns C(Q 0 i ) and C(Q 1 i ) are not greater than O(log N i ), and

$• the resource-bounded Kolmogorov complexities C T (Ni) (Q 0 i ) and C T (Ni) (Q 1 i ) are not less than Ω(N 1.5 i ).$The construction is hierarchical: both Q 0 i and Q 1 i are defined as n i × n i matrices composed of patterns

$Q 0 i-1 and Q 1 i-1 ;$for each i the blocks Q 0 i and Q 1 i are bitwise inversions of each other. When the standard patterns Q 0 i and Q 1 i are constructed for all i, we define the shift as the closure of these patterns: we say that a finite pattern is globally admissible if and only if it appears in some standard pattern Q j i or at least in a 2 × 2-block composed of Q 0 i and Q 1 i (for some i). Remark 3. Due to the hierarchical structure of the standard patterns, we can guarantee that every globally admissible pattern P of size

$N i × N i appears in a 2 × 2-block composed of Q 0 i and Q 1 i (no need to try the blocks Q j s for s > i).$Since the construction of Q j i is explicit, the resulting shift is effective. Properties (i) and (ii) of the theorem will follow from the properties of the standard patterns.

In what follows we explain an inductive construction of Q 0 i and Q 1 i . Let Q 0 0 and Q 0 1 be the squares composed of only 0s and only 1s respectively. Further, for every i we take the lexicographically first binary matrix R i of size

$n i × n i such that C ti (R i ) ≥ n 2 i (2)$(the time bound t i is fixed in the sequel). We claim that such a matrix exists. Indeed, there exists a matrix of size n i × n i that is incompressible in the sense of the plain Kolmogorov complexity. The resource-bounded Kolmogorov complexity of a matrix can be only greater than the plain complexity. Therefore, there exists at least one matrix satisfying (2). If t i is a computable function of i, then given i we can find R i algorithmically. Now we substitute in R i instead of each zero and one entry the copies of

$Q 0 i-1 and Q 1 i-1 respectively, e.g., R i =       0 0 0 0 1 0 1 0 0 1 1 1 1 1 0 0 1 1 0 0 0 1 0 1 0       =⇒ Q 0 i :=       Q 0 i-1 Q 0 i-1 Q 0 i-1 Q 0 i-1 Q 1 i-1 Q 0 i-1 Q 1 i-1 Q 0 i-1 Q 0 i-1 Q 1 i-1 Q 1 i-1 Q 1 i-1 Q 1 i-1 Q 1 i-1 Q 0 i-1 Q 0 i-1 Q 1 i-1 Q 1 i-1 Q 0 i-1 Q 0 i-1 Q 0 i-1 Q 1 i-1 Q 0 i-1 Q 1 i-1 Q 0 i-1      $The resulting matrix (of size

$N i × N i ) is denoted Q 0 i . Matrix Q 1 i is defined as the bitwise inversion of Q 0 i . Claim 1. Assuming that t i t i$(in what follows we discuss the choice of t i in more detail) we have

$C t i (Q 0 i ) = Ω(N 1.5 i ) and C t i (Q 1 i ) = Ω(N 1.5 i ).$Proof of Claim 1. Given Q j i (for j = 0, 1) we can retrieve the matrix R i (this retrieval can be implemented in polynomial time). Therefore, for every time bound t

$C t+poly(Ni) (R i ) ≤ C t (Q j i ) + O(1). Therefore, if t i > t i + poly(N i ) then n 2 i ≤ C ti (R i ) ≤ C t i (Q j i ).$It remains to observe that our choice of parameters in (1) with c ≥ 3 implies n

$1/2 i ≥ (n 0 • . . . • n i-1 )$3/2 , and therefore

$n 2 i ≥ (n 0 • . . . • n i ) 1.5 = (N i ) 1.5 .$Thus, we obtain

$C t i (Q j i ) ≥ (N i ) 1.5 -O(1)$, and the claim is proven.

Remark 4. By choosing a larger constant c in (1), we can achieve a lower bound C t i (Q j i ) = Ω(n 2-) for any > 0. Claim 2. For every globally admissible pattern P of size N i × N i (and not only for the standard patterns, as it was in Claim 1) its time-bounded Kolmogorov complexity C T (Ni) (P ) is Ω(n 1.5 ) (assuming that

$T (N i ) t i ).$Proof of Claim 2. If a pattern P of size N i × N i is globally admissible then it is covered by a quadruple of standard patterns of rank i, see Remark 3 above. Then P can be divided into four rectangles which are "corners" of standard patterns of rank i, see Fig. [2](#fig_0) (a). Since the standard blocks Q 0 i and Q 1 i are the inversions of each other, these four "corners" (with a bitwise inversion if necessary) form together the entire standard pattern, as shown in Fig. [2 (b](#fig_0)). Therefore, we can reconstruct Q j i from P given (a) the position of P with respect to the grid of standard blocks (this involves O(log N i ) bits) and (b) the four bits identifying the standard blocks covering P (we need to know which of them is a copy of Q 0 i and which one is a copy of Q 1 i ). The retrieval of Q j i from P requires only poly(N i ) steps of computation (in addition to the time we need to produce P ). Now the claim follows from the bound for the resource-bounded Kolmogorov complexity of the standard patterns Q 0 i and

$Q 1 i . Claim 3. For every k × k-pattern in Q 0 i or Q 1 i , its plain Kolmogorov complexity is at most O(log k).$Proof of Claim 3. First of all, we observe that the standard patterns

$Q 0 i or Q 1 i can be computed given i. Therefore, C(Q 0 i ) = O(log i) and C(Q 1 i ) = O(log i). Every globally admissible k × k-pattern is covered by at most four standard patterns Q 0 i or Q 1 i with N i-1 < k ≤ N i ,$see Remark 3. Therefore, to obtain a globally admissible pattern P of size k × k we need to produce a quadruple of standard patterns of size N i × N i and then to specify the position of P with respect to the grid of standard blocks. This description consists of only O(log N i ) bits, and we conclude that

$C(P ) = O(log k).$It remains to fix the time bounds t i . Given a computable threshold T (N i ), we choose a suitable t i T (N i ) and then a suitable t i t i . The theorem follows from Claim 2 and Claim 3.

Remark 5. For all large enough i, the incompressible pattern R i constructed in the proof of Theorem 4 contains copies of all 2 4 binary patterns of size 2 × 2. Therefore, we can guarantee that every standard block Q j i contains all globally admissible patterns of size N i-1 × N i-1 . There exists a non-empty effective shift on Z 2 where the Kolmogorov complexity of all n × n patterns is Ω(n 2 ) (see [[2]](#b1) and [[17]](#b16)). So a natural question arises: can we improve Theorem 4 and strengthen condition (ii) to C T (n) (P ) = Ω(n 2 )? The answer is negative: we cannot achieve the resource bounded complexity Ω(n 2 ), even with a much weaker version of property (i) for the plain complexity: Proposition 1. For all large enough time bounds T (n), there is no shift on Z 2 such that (i) for every globally admissible pattern P of size n × n, we have that C(P ) = o(n 2 ), and (ii) for infinitely many n and for every globally admissible pattern P of size n × n, we have that C T (n) (P ) = Ω(n 2 ).

Proof. Assume for the sake of contradiction that such a shift exists. Let us fix a real number ε > 0. Condition (i) means that there exists an integer k = k(ε) such that the number of globally admissible

$k × k patterns in this shift is L k ≤ 2 εk 2 .$Let us estimate Kolmogorov complexity of globally admissible patterns of size (N k) × (N k). For any N , every globally admissible pattern P of size (N k) × (N k) can be specified by

$• the list of all globally admissible patterns of size k × k, which requires L k • k 2 bits (with O(L k • k 2 )$bits we can even provide a self-delimiting description of this list), and

• by an array of size N × N with indices of k × k blocks that constitute P (which requires

$N 2 • log L k bits).$We can combine these two parts of the description in one program. Clearly, P can be reconstructed from such a description in polynomial time. Thus, it follows that for some polynomial poly 1 (n)

$C poly 1 (N k) (P ) ≤ O(L k • k 2 ) + N 2 • k 2 . (3$$)$Now we estimate Kolmogorov complexity of a globally admissible pattern P of size n × n in case when n is not divisible by k. Let N be the integer number such that

$(N -1)k < n ≤ N k.$Pattern P can be embedded in a bigger globally admissible pattern P of size (N k) × (N k). To describe P , we need to describe P and then specify the position of P with respect to the borders of P . The gaps between P and the borders of P cannot be bigger than k. Therefore, to obtain an upper bound for Kolmogorov complexity of P , we only need to add O(log k) bits to [(3)](#b2). It follows that for some polynomial poly 2 (n)

$C poly 2 (n) (P ) ≤ O(L k • k 2 ) + N 2 • εk 2 + O(log k) ≤ (n + k) 2 + O(L k • k 2 ) ≤ n 2 + 2εnk + εk 2 + O(L k • k 2 ). (4$$)$For a fixed k and large enough n, the first term in (4) dominates the remaining terms, and we get

$C poly 2 (n) (P ) ≤ 2 n 2 .$Let us recall that we can prove this bound for every ε > 0 and for all large enough n. This contradicts condition (ii) of the proposition.

## Epitomes

The technique from Section 3 does not apply to the shifts that contain very simple configurations (with low resource-bounded Kolmogorov complexity of all patterns). In particular, it does not apply to Example 1 from the introduction. In this section we propose a different technique (also based on Kolmogorov complexity) that helps to handle such shifts. The intuitive idea behind this technique is as follows: we try to capture the "essential" information in each pattern (discarding irrelevant data) and then measure the plain or resource-bounded Kolmogorov complexity of an "epitome" extracted from this essential information. We show that in a sofic shift the complexity of properly defined "epitomes of the essential information" must be bounded by the length of the contour around the pattern. Thus, if the this condition is violated, then the shift is not sofic. Let us fix some notation. We denote by B n the set {0, . . . , n -1} 2 ⊂ Z 2 and by F n its complement, F n := Z 2 \ B n . We say that two patterns with disjoint supports are compatible (for a shift S) if the union of these patterns is globally admissible in S. In particular, a finite pattern P with support B n and an infinite pattern R with support F n are compatible, if the union of these patterns is a valid configuration of the shift.

In Section 4.1 we start with a simple and more restrictive definition of plain epitomes. Then, in Section 4.2 we proceed with a more general definition of ordered epitomes and discuss several examples of proofs of non-soficness based on this technique. In Section 4.3 we compare the technique of epitomes with the technique of union-increasing chains of extender sets proposed by Kass and Madden in [[6]](#b5); we show that the method of Kass and Madden is equivalent to a special case of the method of ordered epitomes.

## Plain epitomes

In this section we propose a general approach to the proof of non-soficness that captures the intuition behind the standard proof from Example 1. We begin with a definition of "plain" epitome functions.

Definition 2. Let P be the set of all patterns on Z 2 over some finite alphabet. Let E : P → {0, 1} * be a partial function mapping patterns to binary strings. We say that E is an epitome function for the shift S if for every pattern P with support B that is globally admissible in S (in brief, P is a valid pattern) such that E(P ) is defined, there exists an epitome witness pattern R on Z 2 \ B (the complement of B) for which (i) R is compatible with P , i.e., the union of P and R is a valid configuration in S, and (ii) for every pattern P with support B that is compatible with R and for which E(P ) is defined, E(P ) = E(P ). In other words, the epitome witness R uniquely determines the value of E for the valid patterns on the complement of its support.

Given an epitome function E and a pattern P , we refer to E(P ) as the epitome of P , or as the E-epitome of P if the epitome function is not clear from the context. In general, an epitome function can be defined for patterns of any shape. However, in this paper we only use epitome functions E defined on patterns with support B n (a square if size n × n) for different n > 0. In certain situations it can be helpful to focus on the restriction of an epitome function onto the patterns of a fixed size. Given an epitome function E, we write E n for the restriction of E onto the patterns with support B n . We refer to the sequence E n (n = 1, 2, . . .) as a family of restricted epitome functions for S. If an epitome function is defined only for patterns with supports B n (which is always the case in this paper), a family of restricted epitome functions E n for all n > 0 and an epitome function E are two equivalent languages to describe one and the same object.

We say that E is computable if there is an algorithm that computes E. As is customary in computability theory, we assume that an algorithm computing a partial function returns no result for inputs outside its domain. If, moreover, there is an algorithm computing the value E(P ) in time 2 O(n 2 ) for each input pattern P of size n × n (n = 1, 2, . . .) from the domain of E, then we say that this epitome function is exp-time computable.

Similarly, we say that an epitome function is computable with oracle O if the domain of E is decidable with oracle O and there is an algorithm that computes E given the access to oracle O. We can also talk about epitome functions that are exp-time computable with an oracle. Remark 6. If an epitome function is exp-time computable, then the domain of E can be decided in exponential time: it is enough to run the algorithm computing E and abort it if the computation does not converge in due time.

Remark 7. Formally speaking, E-epitomes are binary strings -objects for which we have defined Kolmogorov complexity. In applications, it can be convenient to assign the values of an epitome function to integer numbers, to vectors of integer numbers, or to multi-dimensional finite patterns over a finite alphabet. All these constructive objects can be represented by finite binary strings (with a naturally chosen encoding); so in some cases we abuse notation and talk about epitomes that are integer numbers (or vectors of integer numbers, or finite patterns, and so on) and their Kolmogorov complexities. (b) For every sofic shift with an exp-time computable epitome function E, for every globally admissible pattern P of size n × n such that E(P ) is defined, we have

$C T (n) (E(P )) = O(n) for a time threshold T (n) = 2 O(n 2 ) .$(c) The statements (a) and (b) relativize. That is, for every sofic shift with an epitome function E that is computable with oracle O (or exp-time computable with oracle O), for every globally admissible pattern P of size n × n such that E(P ) is defined, we have

$C O (E(P )) = O(n) (or, respectively, C T (n),O (E(P )) = O(n) for a time threshold T (n) = 2 O(n 2 ) ).$Proof. (a) Assume that S is a sofic shift with a covering SFT Ŝ (i.e., S is a coordinate-wise π-projection of Ŝ). Let P be a pattern with support B n in S and R be the pattern on the complement of B n that enforces the value of the E-epitome of P (as specified in Definition 2). Denote by Y a configuration in Ŝ whose π-projection gives the union of P and R. Let Q be a pattern of size n × n in Y such that P is a coordinate-wise projection of Q. Denote by ∂Q the "border zone," i.e., the nearest neighborhood of Q (the border zone of Q is not included in Q; if Q is an n × n square, then border zone ∂Q around Q consists of 4(n + 1) letters, see Fig. [3](#fig_1)).

We assume without loss of generality that the local constraints in Ŝ involve only pairs of neighboring nodes in Z 2 . Then, every locally admissible pattern Q of size n × n that is locally compatible with border zone ∂Q, must be compatible with the rest of configuration Y . Therefore, the π-projections of these Q are compatible with R. We apply the definition of an epitome function: if E is defined on the π-projection of such Q , then the epitome of Q must be equal to the epitome of P .

It follows that E(P ) can be computed given only the coloring of ∂Q: we use the brute-force search to find all patterns Q that are locally compatible with ∂Q, apply to them projection π, and run in parallel the computation of their epitomes. As soon as we find at least one Q compatible with ∂Q such that the epitome function is defined on its π-projection, we are done: though the projection π(Q ) can be different from P , the epitome of π(Q ) must coincide with the epitome of P . Since the size of ∂Q is linear in n, we conclude that C(E(P )) = O(n).

To prove claim (b), we observe that the brute force search over all patterns of size n × n runs in time

$2 O(n 2 ) , so we get C 2 O(n 2 ) (E(P )) = O(n).$It is easy to verify that the proof relativizes (each step of the argument works with any fixed oracle O), so we get claim (c).

Proposition 2 gives a necessary condition for soficness. To prove that a shift is not sofic, we need to provide a computable (or an exp-time computable) epitome function with high Kolmogorov complexities (or, respectively, resource-bounded [Kolmogorov complexities)](#). In what follows we discuss simple examples of application of this technique. We start with the standard example of mirror symmetric shift.

Example 1 revisited. Let S mirror be the shift from Example 1 in the introduction (the mirror-symmetric configurations). For this example we can define an epitome function E as follows:

• if an n × n pattern P contains only black and white letters, then E(P ) is a binary string of length n 2 that identifies P uniquely (roughly speaking, E does not compress the patterns in black and white);

• E is undefined for all patterns containing at least one red letter.

The defined E satisfies the definition of a computable epitome function, since the part of a configuration above the red line determines uniquely all black-and-white patterns below this line. More specifically, for every n × n pattern P that contains only black and white letters, let R be the infinite pattern defined as follows:

• the domain of R is the complement of the n × n domain of P ,

• the horizontal line in R that is one row above P must consist of only red letters,

• the positions that are symmetric (with respect to the red line) to the positions with black letters in P must be black,

• all other letters in R must be white, as shown in Fig. [4](#). It is clear that R is compatible with P and not compatible with other n × n patterns, as required in the definition of an epitome function.

Since there are 2 n 2 patterns of size n × n with black and white letters, for some patterns of size n × n we have C(E(P )) ≥ n 2 . Therefore, we can apply Proposition 2 (a) and conclude that the shift is not sofic.

## P R

Figure [4](#): An n × n pattern P with black and white letters and the corresponding pattern R with the complementary domain. The orange (dashed) frame contains the pattern that is mirror symmetric to P .

Example 3 (Mirror shift with low plain Kolmogorov complexity). Let us consider a subshift of S mirror from Example 1: we still admit only symmetric configurations, but we now allow only those n × n patterns P in black and white that are globally admissible for the shift S 0 introduced in Notation 5, p. 7. A non-degenerate configuration of the new shift looks as follows: there is an infinite horizontal line composed of red letters, and two symmetric half-planes (filled with black and white letters) above and below this line, with n × n patterns P such that C T (n) (P ) ≤ λ log n (the choice of λ and T (n) is explained before Notation 5). The new shift is effective, and the number of globally admissible patterns is at most 2 O(log n) = poly(n). We know also that some globally admissible n × n patterns in this shift satisfy

$C 2 n 3 (P ) = Ω(n 1.5 ).(5)$We cannot apply Theorem 3 directly and conclude that the new shift is non-sofic. The obstacle is that this shift admits some patterns with very low time-bounded complexity; for example, the shift admits the configuration with an infinite horizontal line in red and only white letters above and below this line. Proposition 2 (a) also does not apply since the plain Kolmogorov complexity of all admissible patterns (and, therefore, of the epitomes of these patterns) is logarithmic. However, in this case we can use exp-time computable epitome functions. The functions E defined for Example 1 (see p. 12) provide for this shift an exp-time computable epitome function. For some (though not for all) n × n patterns P we have [(5)](#b4), so it follows from Proposition 2 (b) that the shift is not sofic.

Remark 8. In the definition of epitome functions we permit that E can be defined for non-admissible patterns. In the next example we show that this possibility can be useful.

Example 4. In this example we use again the alphabet of three letters (red, black, and white). Before we define a shift on this alphabet, we need to introduce some terms. We say that a pattern P of size n × n is special if it contains only red letters on the border line, and only black and white letters in the internal points, as shown in Fig. [5](#fig_2). It is convenient to require that a special pattern contains at least one black letter, so there are 2 (n-2) 2 -1 special patterns of size n × n. For every n we fix a one-to-one correspondence between the special patterns of this size and the binary strings of length smaller than (n -2) 2 . We denote by x P the binary string corresponding to pattern P .

Let U be the computable function from the definition of Kolmogorov complexity (see Theorem 1). Fix an algorithm computing U . It is known that function U is partial, so the algorithm computing U diverges on some inputs. For every integer number m > 0 we denote by pm the string of length smaller than m such that the computation of U (p m ) converges but takes longer than the computation of U (p) for any other p with |p| < m. In case of a tie (if there are several p requiring the same number of steps to complete the computation) we chose pm that is lexicographically biggest. Now we define a shift on Z 2 by the following rule: for every n, a special pattern P of size n × n is globally admissible if U (x P ) is not defined or if x P = p(n-2) 2 (i.e., if the pattern corresponds to the longest converging computation of U among all inputs of length less than (n -2) 2 ). There is no other constraints: a configuration belongs to the shift if and only if it does not contain any special pattern forbidden by this rule.

This shift is effective: the set of inputs p where the computation of U (p) converges is recursively enumerable and, therefore, so is the set of forbidden special patterns. Now we prove that this shift is not sofic. To this end, we define an epitome function E as follows:

• for every special pattern P of size n we let E(P ) = P if U (x P ) is defined;

• E is not defined for other patterns.

This mapping E is obviously computable. Observe that E is defined for many inadmissible patterns and for one and only one globally admissible pattern of size n × n (namely, for the pattern representing the longest-running computation of U ). In this situation, the definition of an epitome function is trivially satisfied.

Given p(n-2) 2 , we can find the maximal number of steps required for a computation of U (p) to converge for |p| < (n -2) 2 . This information permits to find all converging computations of U (p) for |p| < (n -2) 2 , to reveal all strings x with Kolmogorov complexity strictly smaller than (n -2) 2 , and then to take the first incompressible string of length (n -2) 2 . In other words, given p(n-2) 2 we can find an object with Kolmogorov complexity at least (n -2) 2 . Hence, Kolmogorov complexity of p(n-2) 2 itself is close to (n -2) 2 . Thus, for the only n × n pattern P that is globally admissible and where E(P ) is defined, we have C(E(P )) = Ω(n 2 ).

It follows from Proposition 2 (a) that the shift is not sofic.

Let us note in conclusion that we used in this example epitome functions defined on many nonadmissible patterns, and that the domain of E is recursively enumerable but not decidable. These features seem to be essential for this argument.

## Ordered epitomes

The argument based on Definition 2 does not apply to [6, Example 2.5] and similar shifts. To handle this class of non-sofic shifts, we introduce a slightly more general definition of epitome functions: Definition 3. Let P be the set of all patterns on Z 2 over some finite alphabet, be a partial order on {0, 1} * , and E : P → {0, 1} * be a partial function. We say that E (together with the assigned partial order ) is an o-epitome function (a function computing ordered epitomes) for a shift S, if for every globally admissible pattern P with support B such that E(P ) is defined, there exists a pattern R on F = Z 2 \ B such that (i) R is compatible with P , i.e., the union of P and R provides a valid configuration in S, and

(ii) for every pattern P on support B compatible with R, if E(P ) is defined then

$E(P ) E(P ) (i.e.$, this configuration R on the complement of B determines the maximum of the E-epitomes over all valid P ).

To denote an o-epitome function (a mapping considered together with a partial order) we write (E, ). We say that values of E are ordered epitomes or o-epitomes.

Similarly to the case of plain epitomes, in general, ordered epitomes can be defined for patterns of any shape. However, in this paper we use only o-epitome functions defined on patterns with support B n (square of size n × n) for n > 0. It can be helpful to consider the restriction of an o-epitome function onto the patterns of a fixed size. Given an o-epitome function (E, ), we write E n and and n for the restrictions of E and respectively onto the patterns with support B n . We refer to the sequence (E n , n ) (n = 1, 2, . . .) as a family of restricted o-epitome functions [3](#foot_2) .

We say that an o-epitome function (E, ) is computable if there are algorithms that compute the mapping E and the relations . If, moreover, E and are computable in time 2 O(n 2 ) (for patterns of size n × n), we say that this o-epitome function is exp-time computable. As usual, an algorithm computing a partial function must not give any result for inputs outside its domain.

Similarly, we say that an o-epitome function is computable with oracle O if there are algorithms that can compute the mappings E and the relations given the access to oracle O. We can also talk about o-epitome functions that are exp-time computable with an oracle.

Plain epitome functions from Definition 2 can be viewed as a special case of Definition 3. If E is a computable (or exp-time computable) epitome in the sense of Definition 2 and if is an arbitrary effectively computable (exp-time computable) order on the E-epitomes, then (E, ) is a computable (or, respectively, an exp-time computable) o-epitome function in the sense of Definition 3. In Definition 2 the neighborhood R enforces the exact value of E(P ) over all P compatible with R, while in Definition 3 R enforces only the maximum of E(P ).

Remark 7 applies to the o-epitome functions: we may abuse notation and talk about ordered epitomes that are integer numbers (or vectors of integer numbers, or finite patterns, and so on) and their Kolmogorov complexities. Proposition 3. (a) For every sofic shift with a computable o-epitome function (E, ), for every globally admissible pattern P of size n × n such that E(P ) is defined, we have C(E(P )) = O(n).

(b) For every sofic shift with an exp-time computable o-epitome function (E, ), for every globally admissible pattern P of size n × n such that E(P ) is defined, we have

$C T (n) (E(P )) = O(n) for a time threshold T (n) = 2 O(n 2 ) .$(c) The statements (a) and (b) relativize. That is, for every sofic shift with an o-epitome function (E, ) that is computable with oracle O (or exp-time computable with oracle O), for every globally admissible pattern P of size n × n such that E(P ) is defined, we have

$C O (E(P )) = O(n) (or, respectively, C T (n),O (E(P )) = O(n) for a time threshold T (n) = 2 O(n 2 ) ).$Proof. We reuse the notation from the proof of Proposition 2: S denotes a sofic subshift, Ŝ denotes an SFT covering S, and π is a letter-to-letter projection mapping Ŝ onto S. We may assume that the local constraints in Ŝ involve only pairs of neighboring nodes in Z 2 . For an n × n pattern P in S, we denote by Q the n × n pattern in Ŝ projected on P , and ∂Q denotes the border zone (nearest neighborhood) around Q consisting of 4(n + 1) letters, as shown in Fig. [3](#fig_1). We call such patterns ∂Q n-border zones.

We start with a proof of (b), which is very similar to the proof of Proposition 2. In the previous proof, it was enough to find at least one pattern Q compatible with the given border zone ∂Q such that the epitome of π(Q ) is defined; then computing the epitome of π(Q ) we obtain the epitome of P . Now we should find all patterns Q compatible with ∂Q, apply to each of them the projection π, compute their epitomes (for those patterns where E is defined), and then take the maximum of the obtained results. The fact that E are partial functions provides no obstacle. Indeed, we assumed that the o-epitome function is computable in exponential time; so we can safely abort the computations that do not converge in due time. It only remains to observe that the exhaustive search over all patterns of size n × n requires to examine 2 O(n 2 ) possibilities, which can be performed in exponential time.

We cannot prove (a) in the same way because the computation of epitomes can take arbitrary long time, and we cannot find algorithmically the finalized list of E(P ) for all P compatible with ∂Q. In this case we need a more involved argument.

Claim 1. The number of n-border zones ∂Q that are globally admissible in Ŝ is not greater than 2 O(n) .

Proof. This claim is pretty trivial: the domain of such a border zone consists of 4(n + 1) nodes, and the number of all patterns of this size (admissible or not) is at most |Σ| 4(n+1) , where Σ is the alphabet of Ŝ.

Claim 2. The number of values E(P ) for globally admissible in S patterns P is not bigger than the number of all n-border zones ∂Q that are globally admissible in Ŝ.

Proof. By the definition of an o-epitome function, for every value E(P ) there is a pattern R on F n that determines implicitly E(P ): the maximum of E(P ) for all P compatible with R is equal to E(P ). Though R is infinite, the "interaction" between P and R goes through a contour of linear length. As we observed in the proof of Proposition 2, we can choose an n-border zone ∂Q (globally admissible in Ŝ) with the following property: if we take all n × n patterns Q locally compatible with ∂Q in Ŝ, and then take π-projections of these patterns, we obtain the required pattern P and possibly several other (globally admissible in S) patterns P such that E(P ), if defined, is inferior or equal to E(P ) in the sense of . Therefore, the chosen n-border zone ∂Q determines uniquely the value of E(P ).

Observe that ∂Q determines E(P ) in an abstract sense; we cannot compute E(P ) from ∂Q algorithmically. Indeed, since E is a partial function (and the algorithm computing E does not stop on inputs where the function is not defined), we cannot find algorithmically the maximum value of E(P ) for all P obtained from ∂Q. However, we can claim that the number of values E(P ) for globally admissible (in shift S) patterns P is not greater than the number of globally admissible (in shift Ŝ) ∂Q.

The set of n-border zones that are globally admissible in any SFT (actually, in any effective shift) is co-enumerable (the complement is recursively enumerable): we can examine progressively all patterns of bigger and bigger size, detect those that are forbidden, and reveal one by one the border zones that are inadmissible (because all their extensions contain forbidden patterns). Using this procedure we can eventually reveal each non-admissible pattern; but a priori we do not know when the last inadmissible n-border zone is detected.

Denote by N n the number of n-border zones that are globally admissible in Ŝ. Given this number (its binary expansion) we can determine the moment when the described algorithmic process finalizes the list of globally admissible n-border zones (i.e., when all inadmissible n-border zones are revealed). Then, given the list of all non-eliminated (globally admissible) n-border zones, we can find all n × n patterns in Ŝ that are locally compatible with at least one globally admissible n-border zone (so these patterns are also globally admissible). Then we apply to each of these patterns the mapping π and obtain the n × n patterns that are globally admissible in S. Finally, we apply the algorithm computing E to each obtained pattern and run these computations in parallel. Every value of E(P ) for globally admissible P will be eventually found by this procedure.

Thus, to describe one specific value of E, we need to describe the enumeration procedure explained above and to specify the ordinal number of the sought value of E in this enumeration (in the order of appearance). To run the enumeration process, we need to know the numbers n and N n . Due to Claim 1, the binary expansion of N n consists of only O(log N n ) = O(n) bits. The number of different values of E for globally admissible patterns is bounded by N n (Claim 2); so the ordinal number of an element in this enumeration can be specified by log N n = O(n) bits (again, due to Claim 1). Thus, every value of E can be described by an algorithm of size O(n), which is the claim (a) of the theorem.

The arguments used in the proofs of (a) and (b) obviously relativizes, and we get statement (c) for computations with an oracle. Proposition 3 provided us with another necessary condition for soficness. To prove that a shift is not sofic, it is enough to construct a computable (or exp-time computable) o-epitome function with super-linear resource-bounded Kolmogorov complexities.

Remark 9. When we provide an algorithm with an access to an oracle, its computational power can increase dramatically. Thus, when we say that C O (w) = O(n) with some (unspecified) oracle O, we do not say much about string w. However, for every oracle we still can say that there are it most 2 O(n) objects of complexity O(n). So when we claim that C O (E(P )) = O(n) for all P , we say essentially that there are 2 O(n) values of epitomes E. In other words, the bounds on Kolmogorov complexity with an oracle (and without a time bound) is only a different language for the usual counting argument. On the other hand, the meaning of Kolmogorov complexity becomes much subtler when we constrain the computational resources of algorithms in use; the claims C T

$(n) (w) = O(n) or C T (n),O (w) = O(n) cannot be reduced to a simple counting.$Example 5 (semi-mirror shift). In this example we define a shift space extending the one defined in Example 1. Let Σ be the alphabet with three letters (e.g., black, white, and red ); the admissible configurations of the shift are all black-and-white configurations (without any red letter) and the configurations with an infinite horizontal line of red letters and black-and-white half-planes above and below this line that are semi-symmetric in the following sense: if the letter in the ith column at the distance k below the horizontal red line is black, then the letter in the same ith column at the distance k above the red line must be also black. In other words, we may take symmetric half-planes above and below the red line, and then convert some of the black letters in the lower half-plane into white ones, see Fig. [6](#fig_3). We denote this shift by S semi-mirror . It is easy to see that this shift is effective: the forbidden patterns are those where the red letters are not horizontally aligned, and those where the areas above and below the horizontal red line do not satisfy the property of semi-symmetry. Below we prove that this shift is not sofic. To this end we use the technique of ordered epitomes.

We define the epitome function E trivially for the patterns of size n × n that contain only black and white letters. For these patterns, we let E(P ) be P (or its binary encoding). For patterns with at least R P P Figure [8](#): On the right: a black-and-white pattern P (in the blue frame) joined with the corresponding pattern R with the complementary domain (outside of the blue frame). On the left: another black-andwhite pattern P (such that P P ) joined with the same R. We show in green the positions that distinguish P and P , and the corresponding positions in R (symmetric with respect to the red line). one red letter, E is not defined. With this definition, for each n > 0 there are 2 n 2 possible values of E(P ) for n × n patterns.

We define the partial order as follows: E(P 1 ) E(P 2 ) if P 1 and P 2 are patterns of the same size n × n, and for every position with a black letter in P 1 the corresponding position in P 2 also contains a black letter, see Fig. [7](#fig_6).

$P 1 P2$Figure [7](#fig_6): A pair of patterns P 1 and P 2 : the relation E(P 1 ) E(P 2 ) means that the set of black position in P 1 is included in the set of black positions in P 2 .

Let us verify that (E, ) satisfies the definition of an o-epitome function. For every n × n pattern P with black and white letters we define the corresponding pattern R in exactly the same way as in Example 1 on p. 12, see Fig. [4](#). It is clear that when we join P with the corresponding R, we obtain an admissible configuration of the shift. Further, if we join the same R with some other pattern P (as in Fig. [8](#)), we obtain an admissible configuration if and only if P together with R form a semi-symmetric configuration, i.e., a letter in P can be black only if the letter at the symmetric position in R is black. Hence, R is compatible with P if and only if E(P ) E(P ), which is the property required in the definition of an o-epitome function.

We have observed that for every n we have 2 n 2 possible values of E. From the counting argument it follows that for every n there exists at least one pattern P of size n × n such that C(E(P )) ≥ n 2 n. Thus, the property C(E(P )) = O(n) cannot be true for this shift. From Proposition 3 (a) it follows that the shift is not sofic.

A non-degenerate configuration of shift S semi-mirror defined in Example 5 consists of two "semi-symmetric" half-planes separated by an infinite horizontal line of red letters. The property of semi-symmetry means that the lower half-plane can be obtained from the upper half-plane one by the composition of the usual mirror symmetry and repainting of some black letters into white ones. In that definition we do not restrict the number of black letters that are converted in white ones: the two half-planes can be Figure [9](#): A configuration of the shift S semi-mirror (we show in blue unique pair of symmetric positions where the upper and lower half-planes mismatch). exactly symmetric or, conversely, the lower half-plane can consist of only white letters. It is instructive to investigate subshifts of S semi-mirror where the mismatch between the upper and lower half-planes is under control. In the following two examples we briefly discuss two extremal cases: a subshift in S semi-mirror where the symmetry can be broken for at most one pair of letters, and another subshift where the symmetry is broken for all black letters except (possibly) one.

Example 5 (semi-mirror shift with very small discrepancy between half-planes). Let us define a new shift S semi-mirror (such that S semi-mirror ⊂ S semi-mirror ) by adding to the definition of S semi-mirror another condition saying that the symmetry between the two half-planes (above and below the line of red letters) is violated for at most one pair of letter, as shown in Fig 9 . It is easy to verify that this shift is effective. Exactly the same argument as in Example 5 implies that S semi-mirror is also non-sofic.

Example 5 (semi-mirror shift with very large discrepancy between half-planes). Let us define one more shift S semi-mirror (again S semi-mirror ⊂ S semi-mirror ) by the condition that the half-plane under the horizontal line of red letters contains at most one black letter, see Fig. [10](#). This shift is still effective. With the new restriction, the argument from Example 5 does not apply. Indeed, as we have at most one black letter in the lower half-plane, Kolmogorov complexity of the epitomes E(P ) defined Example 5 sinks to O(log n), and we cannot get a contradiction with Proposition 3 (a). The fact that our proof of non-soficness fails is not misleading: it is not hard to verify that S semi-mirror is actually sofic. We discuss this example below in Section 4.3 in the context of extender sets.

Figure [10:](#) A configuration of the shift S semi-mirror . We show in blue the position in the upper half-plane that is symmetric to the unique black letter in the lower half-plane.

In the next example we discuss a shift with very low block complexity, so its non-soficness can be proven only with help of time-bounded Kolmogorov complexity of ordered epitomes.

Example 6 (semi-mirror shift with low block complexity). In this example we use again subshift S 0 introduced in Notation 5, p. 7. We define a new shift S 0 semi-mirror (such that S 0 semi-mirror ⊂ S semi-mirror ) by adding to the definition of S semi-mirror the following requirement: every black-and-white pattern below the horizontal line of red letters must be globally admissible in S 0 .

It is easy to verify that S 0 semi-mirror is also effective. By the construction, for every globally admissible pattern P of size n × n that can appear below the horizontal line of red letters, we have C(P ) = O(log n). The same property holds for the patterns that appear above the horizontal line of red letters, since the mirror symmetry and adding one black letter increases Kolmogorov complexity by at most O(log n). The same is true for globally admissible patterns involving red letters, since such a pattern can be described by its parts above and below the horizontal red line, and both these parts have Kolmogorov complexity O(log n). Thus, for every globally admissible pattern P of size n × n we have C(P ) = O(log n). Hence, there are at most 2 O(log n) = poly(n) globally admissible patterns, i.e., the shift has only polynomial block complexity.

The technique of ordered epitomes with the plain Kolmogorov complexity does not apply to this shift since for every globally admissible pattern P the value of C(P ) is very low, so C(E(P )) is also sub-linear, and we cannot obtain a contradiction with Proposition 3 (a). However, we can prove non-soficness of this shift with help of time bounded Kolmogorov complexity. Indeed, the shift is defined in such a way that for some n × n patterns that appear below the horizontal line of red we have C 2 n 3 (E(P )) = Ω(n 1.5 ). So we can repeat the argument from Example 5 with the same o-epitome function E (it is exp-time computable) but this time using Kolmogorov complexity with a time bound T = 2 ω(n 2 ) . By applying Proposition 3 (b), we conclude that the shift is non-sofic.

In the next example we discuss an interesting instance of a shift proposed by Kass and Madden in [6, Example 2.5]. We reformulate the proof of non-soficness given in [[6]](#b5) in the language of Kolmogorov complexity, in terms of ordered epitomes. In this case, the definition of an epitome function is less straightforward than in the previous examples.

Example 7 (the shift with no hidden red-black squares). Let Σ be the alphabet with three letters (e.g., black, white, and red ), and the forbidden patterns be all squares (of all sizes) where the top side consists of red letters, and the bottom one consists of black letters (hidden red-black squares), as shown in Fig. [11a](#fig_5).

## Proposition 4 ([6]

). The shift on Z 2 defined by the set of forbidden patterns specified above is not sofic.

In [[6]](#b5) this proposition was proven with the technique of union-increasing chains of extender sets. In what follows we propose essentially the same argument, but explain it in terms of ordered epitomes.

Proof of Proposition 4. We define for this shift an o-epitome function. First of all, we define a class of simple patterns: the simple patterns are all square patterns that (i) consist of only black and white letters (with no red letters), where (ii) every row starts with a few successive black letters followed by a sequence of white letters, as show in Fig. [11b](#fig_5). Every simple pattern of size n × n can be specified by its profile -a tuple of integers (k 1 , . . . , k n ), where k i is the number of black letters in the i-th row of the pattern. (Thus, a simple pattern with the profile (k 1 . . . , k n ) is an n × n square where each i-th row starts with k i black letters followed by (n -k i ) white letters.)

Let epitome E assign to each simple pattern its profile, and be undefined for all other patterns. For example, for the pattern P show in Fig. [11b](#fig_5) we have E(P ) = [(4,](#b3)[3,](#b2)[8,](#b7)[5,](#b4)[4,](#b3)[2,](#b1)[4,](#b3)[6)](#b5).

We introduce the natural order on the profiles of simple patterns of the same size n × n; we say that the profile of P 1 is not greater than the profile of P 2 , if the first profile is coordinate-wise not greater than the second one. For example, the profiles of the two patterns shown in Fig. [11c](#fig_5) are not greater than the profile of the pattern in Fig. [11b](#fig_5) (and incomparable with each other).

The introduced E and are obviously computable, even in polynomial time. Some work is required to show that (E, ) satisfies Definition 3: Lemma 1. The defined above (E, ) provides an exp-time computable o-epitome function for the shift under consideration.

This lemma is proven implicitly in [[6]](#b5). We sketch this proof in C.

It remains to observe that for every n there are (n + 1) n simple patterns of size n × n (in each row of a simple pattern the frontier between black and white areas varies between 0 and n). Therefore, for some simple patterns P of size n × n the Kolmogorov complexity of their profile is greater than n log(n + 1), i.e., even the plain Kolmogorov complexity C(E(P )) is super-linear. We apply Proposition 3 (a) and conclude that the shift is not sofic.  

## The technique of ordered epitomes and union-increasing chains of extender sets

In Example 7 we translated in the language of epitomes a proof proposed by S. Kass and K. Madden in [[6]](#b5). In this section we show that this example is a special case of the general situation: the technique of Kass and Madden is equivalent to a special case of the technique of ordered epitomes. In this special case we require that the epitome functions have decidable domains, and we use the plain Kolmogorov complexity (i.e., with no bounds for computational resources). We begin with two definitions from [[6]](#b5). Definition 4. Let S in Z 2 be a shift and let P be a pattern with support B n . The extender set of P , denoted E S (P ), consists of all patterns Q on F n such that the union of P and Q gives a configuration in S. The family of extender sets for all globally admissible patterns P with support B n is denoted

Ext n S := {E S (P ) | P is a globally admissible pattern on B n }. In some sense, the cardinality of Ext n S corresponds to the "information flow" between an n×n pattern and the rest of the configuration on Z 2 . Intuitively, this "information flow" crosses the borderline around an n × n pattern, while the length of this borderline is only O(n). This intuition can be made more precise for SFTs: for every shift of finite type S on Z 2 the size of Ext n S cannot be bigger than 2 O(n) . However, this property is not necessary true for multi-dimensional sofic shifts. In fact, it is known that for some sofic shifts on Z 2 the size of Ext n S can grow faster than 2 O(n) (see Remark 1). For instance, for the sofic shift in Example 5 the size of Ext n S grows as 2 Ω(n 2 ) . Thus, to show that a shift is not sofic, it is not enough to study the size of the family of extender sets, we need to reveal subtler properties of these objects. More specifically, we are going to use the structure of the class of extender sets imposed by the relation of inclusion. Technically, we use union-increasing chains of extender sets. Definition 5. Let S 1 , . . . , S m be a finite sequence of non-empty sets. This sequence is called unionincreasing chain if the partial unions of the S i strictly increase, i.e., if for each 1

$≤ i ≤ m S i i-1 j=1 S j .$Now we can formulate the theorem of Kass and Madden.

## Theorem 5 ([6]

). Let S in Z 2 be a shift space. Suppose given any M > 0, there exists an n > 0, an m > M n , and globally admissible patterns P 1 , . . . , P m with support B n for which Ext S (P 1 ), . . . , Ext S (P m ) is a union-increasing chain. Then S is non-sofic.

Loosely speaking, this theorem claims that the "essential information" that must cross the borderline of an n × n pattern (in a sofic shift) corresponds not just to the number of extender sets but to the length of union-increasing chains of extender sets. This theorem can be reformulated as follows.

Corollary 2. Let S in Z 2 be a shift space. For every n we choose a sequence of globally admissible patterns P n 1 , . . . , P n m(n) with support B n for which the sequence of extender sets

$Ext S (P n 1 ), . . . , Ext S (P n m(n) ) is a union-increasing chain. If log m(n) = ω(n), then S is non-sofic.$This approach is pretty general. Kass and Madden have shown in particular that Theorem 5 allows to express any argument based on the technique of Pavlov ([15, Theorem 1.1]).

We show that every proof of non-soficness based on Theorem 5 can be rephrased in terms of oepitome functions from Definition 3 with decidable domains and with the plain (resource-unbounded) Kolmogorov complexity, and vice-versa. We prove this equivalence in two steps: first we show that an argument in the language of union-increasing chains of extender sets can be translated in the language of o-epitome functions (Proposition 5); then we prove the opposite implication and show that an argument explained in the language of o-epitome functions can be reformulated in terms of union-increasing chains of extender sets (Proposition 6 and Proposition 7).

Next proposition is formulated and proven in terms of families of restricted o-epitomes (let us remind that (E n , n ) is the restriction of (E, ) onto patterns of size n × n).

Proposition 5. Let S in Z 2 be a shift space. Assume that for every n there is a sequence of globally admissible patterns P 1 , . . . , P m(n) with support B n such that the set of extender sets

$Ext S (P 1 ), . . . , Ext S (P m(n) )$is union-increasing. Then for every n there exists an onto mapping

$E n : [patterns with domain B n ] → {1, . . . , m}$defined on a subset of globally admissible patterns in S with support B n and a partial order n on {1, . . . , m(n)} such that (E n , n ) satisfies the definition of a family of restricted o-epitome functions for S.

Proof. The construction of a suitable family of epitome functions is straightforward: we let E n (P i ) = i for i = 1, . . . , m(n), and assume that for all other patterns the function E n is undefined. We introduce on the values of E n the linear order that is inverse to the natural order on the integer numbers,

$m(n) n . . . n 2 n 1.$Let us verify that the obtained (E n , n ) satisfies the definition of a family of o-epitome functions. Since the sequence of extender sets Ext S (P i ) is union-increasing, for every i we have

$Ext S (P i ) ⊂ i-1 j=1 Ext S (P i ).$This means that there exists a pattern R with support F n that is compatible with P i (i.e., belongs to Ext S (P i )) but not with P 1 , . . . , P i-1 (i.e., does not belong to i-1 j=1

Ext S (P i )). Thus, for every n × n

$pattern P compatible R, if E n (P ) is defined then E n (P ) n i,$which is exactly the definition of restricted o-epitome function. Assume that for every positive integer number n we have a sequence of globally admissible patterns P n 1 , . . . , P n m(n) with support B n such that the corresponding sequence of extender sets Ext S (P n 1 ), . . . , Ext S (P n m(n) ) is a union-increasing chain. By applying Proposition 5 we obtain a family of restricted o-epitome functions E n that have m(n) values for patterns of size n × n. In general, this epitome function can be non computable. However, due to a trivial reason it is computable with the oracle O that contains a description of the sequences P n 1 , . . . , P n m(n) .

If the number log m(n) grows faster than a linear function (i.e., m(n) = 2 ω(n) , which is necessary to apply Corollary 2), then from the counting argument it follows that Kolmogorov complexity of E n (P n i ) (even with oracle O) is not bounded by a linear function. More precisely, for every λ > 0 and for a large enough n there is a pattern P n i such that C O (E n (P n i )) > λn. So we can apply Proposition 3(c) and conclude that S is non-sofic.

Thus, if we can prove that a shift S is non-sofic with the technique of Kass and Madden (Corollary 2), then due to Proposition 5 we can apply Proposition 3 (c) (with Kolmogorov complexity relativized conditional on the chosen above oracle O) and prove non-soficness of S with the technique of epitomes.

In the next two propositions we show that the reverse translation (from the language of ordered epitomes to the language of chains of extender sets) is also possible as long as we use o-epitome functions with decidable domains and resource-unbounded Kolmogorov complexity. Proposition 6. Let S be a shift space, (E n , n ) be a family of restricted o-epitome functions for S, and m = m(n) be the number of images of E n computed for globally admissible patterns. Then there exists a family of globally admissible patterns P 1 , . . . , P m such that the chain of extender sets Ext S (P 1 ), . . . , Ext S (P m ) is union-increasing.

Proof. Denote by e 1 , . . . , e m the images of E n . Without loss of generality we may assume that for every i e j n e i for all j < i

(in every finite partially ordered set we can arrange the indices of e j so that (6) holds true: e 1 should be one of the maximal elements, e 2 must be maximal among the remaining elements, and so on). Then, we fix globally admissible patterns P i with support B n such that E n (P i ) = e i . By the definition of an epitome function, for each i there exists a pattern R i with support F n that is compatible with P i but not compatible with P 1 , . . . , P i-1 . Therefore, Ext S (P i ) is not contained in the union i-1 j=1

Ext S (P i ). Thus, the sequence of extender sets Ext S (P i ) is union-increasing, and we are done. 

and m log n. Then there exist 2 Ω(m) different values of E corresponding to patterns of size n × n (globally admissible or non-admissible).

(b) Assume the domains of E are decidable (there is an algorithm that can decide for every n and every pattern P of size n × n whether E(P ) is defined or not) and that [(7)](#b6) with m log n holds for at least one globally admissible pattern P of size n × n. Then there exist 2 Ω(m) values of E corresponding to globally admissible patterns of this size.

(c) Both propositions (a) and (b) relativize: they remain true for Kolmogorov complexity relativized with any oracle O.

Proof. (a) For a given n, we can apply the algorithm computing E to each pattern of size n × n and run these computations in parallel. As some of these computations converge, we can write down the revealed values of E one by one. (If the domain of E is undecidable, we never know whether the last terminating computation is over, and some of these computations last infinitely long time without any result.) Let N n be the number of all values that eventually appear. Each value of E can be specified by its index in this list (in the order of appearance) together with the binary expansions of n. The index (position in the list) can be specified by log N n bits. Therefore, for every n × n pattern P we have

$C(E(P )) = O(log N n ) + O(log n),$and the statement (a) follows.

(b) Let N n be the number of values of E(P ) for all patterns P of size n × n, and let N n be the number of values of E(P ) for globally admissible patterns P of this size. Denote = log N n .

If N n > N n /2, the statement (b) follows from (a). Otherwise, we compute E(P ) for all patterns of size n × n (this is possible since the domain of an epitome function is decidable) and start enumerating non-admissible patterns of the shift. As non-admissible patterns are progressively revealed, we eliminate one by one the values of E(P ) that do not correspond to any non-discarded (and potentially globally admissible) pattern P . We stop this process when there remain exactly 2 non-eliminated values of epitomes (that can a priori represent globally admissible patterns). Now the epitome of every globally admissible P can be specified by the numbers n and and by the ordinal number of the value E(P ) in the list of 2 non-eliminated candidates. Such an ordinal number can be represented by a string of n bits. Thus, C(E(P )) = O( ) + O(log n), and we are done.

(c) It is easy to see that the argument remains valid for algorithms accessing an oracle.

Assume that we can prove non-soficness of a shift S with the technique of ordered epitomes from Proposition 3 using Kolmogorov complexity without time bounds. This is possible if we have for S an o-epitome function (E, ) that is computable (possibly with some oracle O) and such that C(E(P )) is not bounded by a linear function. Assume now that the union of domains of E is a decidable set. Then it follows from Proposition 7 (b) that the number of values of E for globally admissible patterns grows as 2 ω(n) . Now we apply Proposition 6 and obtain a list of globally admissible n × n patterns P n 1 , . . . , P n m(n)

with m(n) = 2 ω(n) such that the chain of extender sets Ext S (P n 1 ), . . . , Ext S (P n m(n) ) is union-increasing. Hence, we can apply Corollary 2 and prove non-soficness of S with the argument of Kass and Madden. Proposition 5 and Proposition 6 show that the technique of union-increasing chains of extender sets is closely connected with the version of the technique of ordered epitomes with a decidable domain and the plain Kolmogorov complexity. On the other hand, it seems that an argument using plain epitome functions with undecidable domains (see Example 4) cannot be translated directly in the language of union-increasing chains of extender sets. We also recall that the method of epitomes is getting stronger when we use resource-bounded version of Kolmogorov complexity. In particular, it helps to handle shifts with sub-exponential block complexity, which is unachievable with Theorem 5 and Corollary 2.

## Conclusion

To the best of our knowledge, all previously known proofs of non-soficness for multi-dimension effective shifts (including the one proposed in [[15]](#b14)) can be reformulated in terms of union-increasing chains of extender sets, as proposed in [[6]](#b5). Therefore, these proofs can be rephrased in terms of ordered epitomes with the plain Kolmogorov complexity, as we explained in Section 4.3. The technique of epitomes becomes more powerful if we use resource-bounded Kolmogorov complexity; in particular, it allows to handle shifts with sub-exponential block complexity. So it seems that Kolmogorov complexity helps to capture substantial properties that are necessary for soficness. It would be interesting to adapt the technique of resource-bounded Kolmogorov complexity to reveal properties that are sufficient for a shift to be sofic.

Open Problem. Find sufficient conditions of soficness that can be formulated in terms of resource-bounded Kolmogorov complexity.

## A Proof of Theorem 3

It is enough to prove the theorem for shifts of finite type (since a configuration in a sofic shift is a coordinate-wise projection of a configuration from a shift of finite type).

We fix an SFT (which can be defined by a set of forbidden patterns F where every pattern in F is a pair of neighboring letters) and show that for every k there exists a locally admissible (2 k + 1) × (2 k + 1)pattern P k with the required property: every n × n square pattern inside P k has Kolmogorov complexity O(n).

To this end we choose an arbitrary coloring of the border line of a square of size (2 k + 1) × (2 k + 1) so that this coloring can be extended in at least one way to a locally admissible coloring of the entire square, see Fig. [12 (a)](#fig_7). Since the set of all colorings of the square is finite, we can find algorithmically (by a naive brute-force search) the lexicographically first coloring of the horizontal and vertical centerlines of the square that are compatible with the fixed coloring of the border line (i.e., the coloring of the border line together with coloring of the centerlines can be extended to a locally admissible coloring of the whole square), see Fig. [12 (b)](#fig_7). Observe that the centerlines split the square into four squares of size Then, we repeat the same procedure recursively: in each of the four squares of size (2 k-1 + 1) × (2 k-1 + 1) we find the lexicographically first coloring of their horizontal and vertical centerlines that are compatible with the coloring of the border around each of these squares (see Fig. [12 (c](#fig_7))), and so on. On the last step we end up with the lexicographically first valid coloring of isolated patterns of size 1 × 1 (that must be coherent with the chosen above coloring of the neighborhood). This concludes the construction of P k .

$(2 k-1 + 1) × (2 k-1 + 1). (a) (b) (c) ⇒ ⇒ ⇒ ...$In the procedure explained above, the initial square of size (2 k + 1) × (2 k + 1) is split into four squares of size (2 k-1 + 1) × (2 k-1 + 1), then into sixteen squares of size (2 k-2 + 1) × (2 k-2 + 1), etc. This recursive procedure finds the coloring of each of these squares in "standard" positions given (as a kind of boundary condition) the coloring of the border around this square.

Thus, to find the assigned coloring of a square of size (2 m + 1) × (2 m + 1) in a "standard" position, the recursive procedure needs to know only the coloring of the border around this square (which requires O(2 m ) letters and therefore O(2 m ) bits of information); it is not hard to see that the recursive call runs in time

$2 O (2 m +1)×(2 m +1) + 4 × 2 O (2 m-1 +1)×(2 m-1 +1) + 16 × 2 O (2 m-2 +1)×(2 m-2 +1) + . . . = 2 O(2 2m )$(this is a recursive computation of depth m, with a brute-force search and four recursive calls on each level of the hierarchy).

An arbitrary square of size n × n (possibly in a non-standard position) is covered by at most four "standard" squares (of size at most twice bigger than n), see Fig. [13](#fig_1). Figure [13](#fig_1): A pattern of size 7 × 7 (hatched in red) covered by a quadruple of "standard" blocks of size 9 × 9.

Thus, to identify an n×n-pattern inside P k , it is enough to describe the quadruple of standard squares covering this pattern and, in addition, the position (the coordinates of the corners) of this pattern with respect to the covering standard squares. In turn, each standard square is, by construction, determined by its border line. Hence, every n × n square in P k can be specified with only O(n) bits of information; moreover, it can be recovered from this description in time 2 O(n 2 ) (at first we reconstruct the four standard squares from their border lines, and then cut out the pattern with the given coordinates of the corners).

To conclude the proof of the theorem, we observe that P k are defined for arbitrarily large k, and the compactness argument gives a valid coloring of the entire Z 2 with the required property.

## B Proof of Theorem 4

The high level scheme of the proof of Theorem 4 is similar to the proof of Theorem 4 . At first we construct "standard" building blocks of growing size so that all patterns in these blocks have a large time-bounded Kolmogorov complexity. Then we define a shift as the closure of these standard patterns.

Stage 1: building standard blocks. We fix parameters n i , i = 0, 1, 2, . . .

$n 0 1, n i+1 = (n 0 • . . . • n i ) c(8)$(the constant c to be specified later) and

$N i := n 0 • . . . • n i .$In what follows we define inductively standard blocks Q j i of size N i × N i for i = 0, 1, 2, . . . The major difference between this proof and the proof of Theorem 4 is that for each i we define a set of i = n 2 i+1 standard blocks of level i Q 1 i , . . . , Q i i (instead of only two of standard patterns used in the previous proof). The construction is hierarchical: each standard block of rank i is defined as an n i × n i array of standard blocks of level (i -1). In this inductive construction, we maintain for each i the following property: Main Property: For every i > 0, for the list of standard blocks Q 1 i , . . . , Q i i , we have that

$C ti (Q 1 i , . . . , Q i i ) ≥ i log( i-1 !) = (n i+1 ) 2 • log (n 2 i )!(9)$(the time threshold t i to be specified later). Our construction is explicit, and the standard blocks Q j i are computable (given i and j) though the time required for this computation can be pretty large.

Remark 10. Let us explain the intuition behind this construction. We inductively construct standard blocks that have the following two properties. On the one hand, all large enough patterns in each standard N i × N i blocks should have a high time-bounded Kolmogorov complexity due to the "local structure": each of the standard blocks of rank (i -1) (of size N i-1 × N i-1 ) is complex, and these blocks are independent of each other. On the other hand, the whole standard block of size N i × N i should have a high time bounded Kolmogorov complexity (with even a bigger time bound) due to the information embedded in its "global structure" (how the blocks of level (i -1) are arranged inside of a block of level i). To carry out the inductive argument, we construct for each i a large family of standard blocks of size N i × N i , and these blocks must be in some sense "independent." Base of induction: We defined blocks Q 1 0 , . . . , Q 0 0 as arbitrary distinct binary matrices of size n 0 × n 0 (we can do it assuming that 2 n 2 0 > 0 = n 2 1 ). Inductive step: Given a set of standard patterns Q

$1 i , . . . , Q i i of size N i ×N i , we construct the standard patterns of the next level, Q 1 i+1 , . . . , Q i i+1 of size N i+1 × N i+1 . Each new pattern Q j i+1 is defined as an n i+1 × n i+1 array composed of blocks Q 1 i , . . . , Q i i . Since i = n 2$i+1 , we may require that each block Q k i is used exactly once in every Q j i+1 . In other words, every standard block Q j i+1 can be represented by a permutation π j : {1, . . . , i } → {1, . . . , i } that arranges the set of standard patterns of the previous level.

There are ( i !) possibilities to choose each permutations π j and ( i ! ) i+1 possibilities to choose all permutations π 1 , . . . , π i+1 . From a trivial counting argument it follows that there exists a tuple of permutations π 1 , . . . , π i+1 such that C(π 1 , . . . , π i+1 ) ≥ i+1 log( i !) Therefore, for every computable threshold h i , we can algorithmically find a tuple of permutations such that C hi+1 (π 1 , . . . , π i+1 ) ≥ i+1 log( i !).

Since each π j is uniquely determined by the corresponding pattern Q j i+1 , we obtain

$C hi+1-gap i+1 (Q 1 i+1 , . . . , Q i+1 i+1 ) ≥ i+1 log( i !),$where gap i+1 is the time required to extract the permutations π j from the corresponding patterns Q j i+1 . Thus, if the threshold h i+1 is much bigger than t i , we conclude that

$C ti (Q 1 i+1 , . . . , Q i+1 i+1 ) ≥ i+1 log( i !),$i.e., the Main Property holds true for the level i + 1.

Lemma 2. For every i > 0 and every tuple of k (pairwise different) standard blocks Q j1 i , . . . , Q j k i , we have that

$C t i (Q j1 i , . . . , Q j k i ) ≥ 1 2 k log( i-1 !)$(the threshold t i is specified in what follows).

Remark 11. The factor of 1 2 in this lemma could be changed to any constant less than 1.

Proof of lemma. Assume for the sake of contradiction that for some blocks Q j1 i , . . . , Q j k i we have

$C t i (Q j1 i , . . . , Q j k i ) < 1 2 k log( i-1 !)$Then we can provide the following description of the entire list of standard blocks of level i:

• a description of size 1 2 k log( i-1 !) for these particular k blocks, • k log i bits to specify the indices j 1 , . . . , j k of these particular k block,

• a straightforward description for the other standard blocks of level i, which requires ( i -k) log( i-1 !) bits.

We need to add an overhead of size O(log k + log i) to join these parts in one description. It remains to observe that the summarized length of these data is less than i+1 log( i !) (the right-hand side of ( [9](#formula_58))).

Let us estimate the time required to produce the list of all standard blocks of level i using this description. First of all, we compute the list of all standard blocks of lower rank Q j i-1 (we have to assume that the time required to compute these blocks is much less than t i ). Then, in time t i we obtain the k "peculiar" blocks with a short description. With poly(N i ) steps we generate the remaining ( i -k) standard blocks, and in poly(N i ) more steps we merge all blocks in one list. Assuming that t i is large enough, we get a contradiction with the Main Property of standard blocks. Lemma 3. For every standard block of rank i, the plain Kolmogorov complexity of Q j i is very low:

$C(Q j i ) = O(log N i ).$Proof. There are i standard blocks of level i, and the list of all standard blocks can be computed given i. Therefore, C(Q j i ) = O(log i ). For the chosen parameters we have log i = log(n 2 i+1 ) = O(log N i ).

Observe that the construction of standard blocks is explicit, and we can choose a computable function T (n) so that all standard blocks are computed given i in time T (n). This observation implies the statement of Remark 2.

Stage 2: complexity of patterns inside standard blocks. Let P be an array of m × m (pairwise distinct) standard blocks of level i. Observe that the size of P (measured in individual letters) is k × k, where k = mN i .

Due to Lemma 2, we have

$C t i (P ) ≥ 1 2 m 2 log( i-1 !) = Ω(m 2 i-1 ) = Ω (mn i ) 2 .$In other words, the time-bounded Kolmogorov complexity of this pattern of size k × k is bigger than Ω (mn i ) 2 = Ω k 2 /(n 0 • . . . • n i-1 ) 2 .

Stage 3: the closure of standard blocks. We define a shift as the closure of the standard blocks: a finite pattern is globally admissible if and only if it appears in a 2 × 2 array composed of standard blocks (of some level i). Due to the hierarchical structure if standard blocks, we can conclude that an N i × N i pattern is not globally admissible if it never appears in 2 × 2 arrays composed of standard blocks of rank i.

Let P be a globally admissible pattern of size k × k in the shift defined above. Let 2N i ≤ k < 2N i+1 for some i > 0. Then P must be covered by a 2 × 2 array of standard blocks of level i + 1. Therefore, a constant fraction of P can be represented as an array of blocks of level i (inside a standard block of level (i + 1)). We can apply the bound from Stage 2 and conclude that C Ti (P ) = Ω(k 2 /(n 0 • . . .

$• n i-1 ) 2 ) (10$$)$(assuming that the gap between t i and T i is large enough).

On the other hand, the plain Kolmogorov complexity of every globally admissible block is very low. Indeed, to describe a globally admissible block P of size k, we need to specify four standard blocks covering P and the position of P with respect to the grid of standard blocks. Due to Lemma 3, we obtain C(P ) = O(log k).

Stage 4: the choice of parameters. We chose constants c in (8) so that for k = Ω(N i ) equality (10) rewrites to C Ti (P ) = Ω(k 2-).

It remains to comment the choice of time bounds. The threshold T i is given in the theorem. Given T i , we choose a suitable threshold t i (the gap between t i and T i must be large enough, so that the argument due to the bar of red letters on the top, this row in the 8 × 8 frame can start with at most 5 black letters we control max of E for this n × n frame  on Stage 3 works). Then, given t i we choose a suitable value t i (the gap between t i and t i must be large enough, so that the proof of Lemma 2 is valid). The choice of t i determines the value of h i on Stage 1. The definition of these sequences is inductive: to define t i we need to know t i-1 and the time required to produce the standard blocks of level (i -1) (see the proof of Lemma 2).

As T i is a computable function of i, we can choose computable sequences t i , t i , t i , and h i . This observation concludes the proof.

## C Proof of Lemma 1

In this section we sketch the proof of Lemma 1. For every simple pattern P of size n × n we should construct a configuration R on the complement of B n , so that (i) P and R are compatible, (ii) for every other simple pattern P compatible with R we have E(P ) E(P ).

To build the required R, we follow the construction from [[6]](#b5).

By definition, each row of P consists of a contiguous sequence of black letters followed by a contiguous sequence of white letters, as shown in Fig. [11b](#fig_5). The pattern R will consist of a finite number of black and red letters (the other letters will be white).

Black letters in R. To construct R, we extend each stripes of black letters in P to the left, so that in the first line we get a contiguous sequence of (3n -1) black letters (including those black letters that belong to P ), in the second line a contiguous sequence of (3n -3) black letters, in the third line a contiguous sequence of (3n -5) black letters, etc. In the n-th line we obtain a contiguous sequence of (n + 1) black letter, see Fig. [14](#fig_9).

Red letters in R. Similarly, we put in R stripes of red letters: 3n contiguous red letters in line 3n, (3n -2) contiguous red letters in line 3n -1, . . . , (n + 2) contiguous red letters in line (2n + 1). We place these stripes of red letters so that for each i = 1, . . . , n the leftmost red letter in the line (3n -i + 1) is vertically aligned with the leftmost black letter in the line i, as shown in Fig. [14](#fig_9).

All other letters outside B n are made white.

Claim 1. The constructed R is compatible with P .

Proof of Claim 1: This fact is easy to verify: we have chosen the lengths of black and red stripes so that they cannot form a forbidden pattern (as in Fig. [11a](#fig_5)), regardless the horizontal placement of each stripes. Indeed, on the one hand, the black letters of the i-th line cannot interfere with the red stripes in lines 3n, 3n -1, . . . , 3n -i, since this black stripe is too short to form a forbidden pattern together with any of these red stripes; on the other hand, the black letters of the i-th line cannot interfere with the red stripes in lines 3n -i -1, 3n -i -2, . . . , 2n + 1, since those red stripes are too short.

Claim 2. The constructed R is compatible only with simple patterns P such that E(P ) E(P ).

this n × n pattern P is compatible with the neighborhood Figure [15](#fig_2): A pattern P with E(P ) E(P ) matches the neighborhood. by adding one supplementary black letter we get a forbidden pattern this n × n pattern P is incompatible with the neighborhood Figure [16](#fig_3): A pattern P with E(P ) E(P ) does not match the neighborhood.

Proof of Claim 2: If R is compatible with an n × n pattern P , the profile of P is not determined uniquely. In fact, R can be compatible with simple patterns P whose profiles are strictly less than the profile of P (in each row of P the number of black letters must be not greater than the number of black letters in the corresponding row of P ), see Fig. [15](#fig_2). On the other hand, if at least one row of P contains more black letters that the same row in P , than P and R are incompatible, i.e., the joint of P and R contains a forbidden pattern, as shown in Fig. [16](#fig_3).

The lemma follows from Claim 1 and Claim 2. For a more detailed argument we refer the reader to [[6]](#b5).

Remark 12. In the construction discussed above, pattern R does not determine uniquely the epitomes of P compatible with R (these epitomes can be different, though they all must be not greater than the epitome of the initial pattern P ). This is why we cannot apply Proposition 2, and we have to use Proposition 3.

![Figure 2: A pattern of size N k × N k (shown in gray in fig. (a)) covered by a quadruple of standard blocks of the same size contains enough information to reconstruct a standard pattern (fig. (b)).]()

![Figure 3: Projection of an n × n pattern from an SFT onto a sofic shift.]()

![Figure 5: An example of a special pattern of size n × n from Example 4: the border line (included in the pattern) consists of red letters, and the remaining (n -2) × (n -2) letters can be only black or white.]()

![Figure 6: A configuration of the shift S semi-mirror (we show in blue the positions where the upper and lower half-planes mismatch).]()

![(a) Forbidden pattern: a square with a red top and a black bottom.(b) A pattern for which the epitome E is defined: each row starts with a few black letters on the left followed by white letters on the right.(c) A pair of incomparable patterns.]()

![Figure 11]()

![Let (E, ) be a computable o-epitome function for an effective shift S. (a) Assume that for an admissible pattern P of size n × n C(E(P )) = m,]()

![Figure 12: Three steps of the recursive coloring procedures for a pattern of size (2 n + 1) × (2 n + 1).]()

![Figure 14: An n × n pattern P with a neighborhood that enforces the desired maximum of E.]()

We can require that the set of forbidden finite patterns is decidable or recursively enumerable. Though formally speaking these requirements are different, they result in one and the same class of shifts. That is, if some shift is defined by a recursively enumerable set of forbidden finite patterns, then the same shift can be also defined by a decidable set of forbidden patterns.

For every instance of an optimal Turing machine U in the definition of Kolmogorov complexity one can compute the corresponding minimum value of n 0 that makes the construction work.

If an o-epitome function (E, ) is defined only for patterns with supports Bn, then it is determined uniquely by the corresponding family of restricted o-epitome functions (En, n).

