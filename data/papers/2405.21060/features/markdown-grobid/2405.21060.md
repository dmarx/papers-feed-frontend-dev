# Transformers are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality

## Abstract

## 

While Transformers have been the main architecture behind deep learning's success in language modeling, state-space models (SSMs) such as Mamba have recently been shown to match or outperform Transformers at small to medium scale. We show that these families of models are actually quite closely related, and develop a rich framework of theoretical connections between SSMs and variants of attention, connected through various decompositions of a well-studied class of structured semiseparable matrices. Our state space duality (SSD) framework allows us to design a new architecture (Mamba-2) whose core layer is an a refinement of Mamba's selective SSM that is 2-8√ó faster, while continuing to be competitive with Transformers on language modeling. * Alphabetical by last name.

## Introduction

Transformers, in particular decoder-only models (e.g. GPT [(Brown et al. 2020](#b18)), Llama [(Touvron, Lavril, et al. 2023](#b100))) which process input sequences in a causal fashion, are one of the main drivers of modern deep learning's success. Numerous approaches attempt to approximate the core attention layer to address its efficiency issues [(Tay et al. 2022)](#b96), such as scaling quadratically in sequence length during training and requiring a cache of size linear in sequence length during autoregressive generation. In parallel, a class of alternative sequence models, structured state-space models (SSMs), have emerged with linear scaling in sequence length during training and constant state size during generation. They show strong performance on long-range tasks (e.g. S4 (Gu, Goel, and R√© 2022)) and recently matched or beat Transformers on language modeling (e.g. Mamba [(Gu and Dao 2023](#b40))) at small to moderate scale. However, the development of SSMs have appeared disjoint from the community's collective effort to improve Transformers, such as understanding them theoretically as well as optimizing them on modern hardware. As a result, it is more difficult to understand and experiment with SSMs compared to Transformers, and it remains challenging to train SSMs as efficiently as Transformers from both an algorithmic and systems perspective.

Our main goal is to develop a rich body of theoretical connections between structured SSMs and variants of attention. This will allow us to transfer algorithmic and systems optimizations originally developed for Transformers to SSMs, towards the goal of building foundation models that perform better than Transformers while scaling more efficiently in sequence length. A milestone contribution in this direction was the Linear Attention (LA) framework [(Katharopoulos et al. 2020](#)), which derived a connection between autoregressive attention and linear RNNs by showing the equivalence between "dual forms" of quadratic kernelized attention and a particular linear recurrence. This duality allows new capabilities such as the ability to have both efficient parallelizable training and efficient autoregressive inference. In the same spirit, this paper provides multiple viewpoints connecting linear-complexity SSMs with quadratic-complexity forms to combine the strengths of SSMs and attention.[foot_0](#foot_0)

## Structured Matrices

Sec. 6

## Mamba-2

Sec. 7 State Space Duality. Our framework connecting structured SSMs and variants of attention, which we call structured state space duality (SSD), is made through the abstractions of structured matrices: matrices with subquadratic parameters and multiplication complexity. We develop two broad frameworks for representing sequence models, one as matrix transformations and one as tensor contractions, which each reveal different perspectives of the duality. Our technical contributions include:

‚Ä¢ We show an equivalence between state space models and a well-studied family of structured matrices called semiseparable matrices (Section 3). This connection is at the heart our framework, revealing new properties and algorithms for SSMs. A central message of this paper is that different methods of computing state space models can be reframed as various matrix multiplication algorithms on structured matrices.

‚Ä¢ We significantly improve the theory of linear attention [(Katharopoulos et al. 2020)](#). We first provide an incisive proof of its recurrent form through the language of tensor contractions, and then generalize it to a new family of structured masked attention (SMA) (Section 4).

‚Ä¢ We connect SSMs and SMA, showing that they have a large intersection that are duals of each other, possessing both SSM-like linear and attention-like quadratic forms (Section 5). We also prove that any kernel attention method possessing a fast recurrent form must be an SSM.

Beyond its intrinsic theoretical value, our framework opens up a broad set of directions for understanding and improving sequence models.

Efficient Algorithms. First and most importantly, our framework exposes new efficient and easily-implementable algorithms for computing SSMs (Section 6). We introduce a new SSD algorithm, based on block decompositions of semiseparable matrices, that takes advantage of both the linear SSM recurrence and quadratic dual form, obtaining optimal tradeoffs on all main efficiency axes (e.g. training and inference compute, memory usage, and ability to leverage matrix multiplication units on modern hardware). A dedicated implementation of SSD is 2 -8√ó faster than the optimized selective scan implementation of Mamba, while simultaneously allowing for much larger recurrent state sizes (8√ó the size of Mamba or even higher, with minimal slowdown). SSD is highly competitive with optimized implementations of softmax attention (FlashAttention-2 (Dao 2024)), crossing over at sequence length 2K and 6√ó faster at sequence length 16K.

Architecture Design. One major obstacle to adopting new architectures such as SSMs is the ecosystem tailored to Transformers, such as hardware-efficient optimization and parallelism techniques for large-scale training. Our framework allows using established conventions and techniques for attention to build a vocabulary of architecture design choices for SSMs, and further improve them (Section 7). For example, we introduce the analog of heads from multi-head attention (MHA) to SSMs. We show that the Mamba architecture is a multi-input SSM (MIS) that turns out to be analogous to multi-value attention (MVA), and compare other variants of Mamba with different head structures.

We also use these ideas to make slight modifications to the Mamba block, which allows tensor parallelism to be implemented (e.g. in the style of Megatron [(Shoeybi et al. 2019](#b92))). The main ideas include introducing grouped-value attention (GVA) head structure, and moving all data-dependent projections to occur in parallel at the beginning of the block.

The combination of the modified parallel Mamba block, together with using SSD as the inner SSM layer, results in the Mamba-2 architecture. We investigate Chinchilla scaling laws for Mamba-2 in the same setting as Mamba, finding that it Pareto dominates Mamba and Transformer++ in both perplexity and wall-clock time. We additionally train a family of Mamba-2 models at varying sizes on the Pile, showing that it matches or outperforms Mamba and open source Transformers on standard downstream evaluations. For example, Mamba-2 with 2.7B parameters trained on 300B tokens on the Pile outperforms Mamba-2.8B, Pythia-2.8B and even Pythia-6.9B trained on the same dataset.

Systems Optimizations. The SSD framework connects SSMs and Transformers, allowing us to leverage a rich body of work on systems optimizations developed for Transformers (Section 8).

‚Ä¢ For example, Tensor Parallelism (TP) is an important model parallelism technique to train large Transformer models by splitting each layer across GPUs on the same node. We design Mamba-2 to be TP-friendly, reducing the number of synchronization point per block by half.

‚Ä¢ For very long sequences whose activations do not fit on one device, sequence parallelism has been developed for the attention blocks. We describe how to train SSMs in general and Mamba-2 in particular with sequence parallelism, by passing the recurrent states between devices.

‚Ä¢ For finetuning with examples of different lengths, for best efficiency, Transformer requires sophisticated techniques to remove padding tokens and perform attention on variable length sequences. We show how Mamba-2 can be trained with variable sequence lengths efficiently, requiring no padding tokens.

Section 9 empirically validates Mamba-2 on language modeling, training efficiency, and a difficult multi-query associative recall task [(Arora, Eyuboglu, Zhang, et al. 2024)](#b5). Finally, in Section 10, we provide an extended related work and discuss potential research directions opened up by our framework.

Model code and pre-trained checkpoints are open-sourced at [https://github.com/state-spaces/mamba](https://github.com/state-spaces/mamba).

2 Background and Overview

## Structured State Space Models

Structured state space sequence models (S4) are a recent class of sequence models for deep learning that are broadly related to RNNs, CNNs, and classical state space models. They are inspired by a particular continuous system (1) that maps a 1-dimensional sequence ùë• ‚àà R T ‚Ü¶ ‚Üí ùë¶ ‚àà R T through an implicit latent state ‚Ñé ‚àà R (T,N) .

A general discrete form of structured SSMs takes the form of equation [(1)](#b0).

‚Ñé ùë° = ùê¥‚Ñé ùë° -1 + ùêµùë• ùë° (1a)

$ùë¶ ùë° = ùê∂ ‚ä§ ‚Ñé ùë°(1b)$‚Ñé ùë° = ùê¥ ùë° ‚Ñé ùë° -1 + ùêµ ùë° ùë• ùë° (2a)

$ùë¶ ùë° = ùê∂ ‚ä§ ùë° ‚Ñé ùë°(2b)$where ùê¥ ‚àà R (N,N) , ùêµ ‚àà R (N,1) , ùê∂ ‚àà R (N,1) . Structured SSMs are so named because the ùê¥ matrix controlling the temporal dynamics must be structured in order to compute this sequence-to-sequence transformation efficiently enough to be used in deep neural networks. The original structures introduced were diagonal plus low-rank (DPLR) (Gu, Goel, and R√© 2022) and diagonal [(Gu, Gupta, et al. 2022](#); Gupta, Gu, and Berant 2022; J. T. Smith, Warrington, and Linderman 2023), which remains the most popular structure.

In this work, we use the term state space model (SSM) to refer to structured SSMs. There are many flavors of such SSMs, with deep ties to several major paradigms of neural sequence models such as continuous-time, recurrent, and convolutional models [(Gu, Johnson, Goel, et al. 2021](#b44)). We provide a brief overview below, and refer to prior work for more context and details [(Gu 2023](#b39); Gu and Dao 2023).

Continuous-time Models. The original structured SSMs originated as continuous-time maps on functions ùë• (ùë°) ‚àà R ‚Ü¶ ‚Üí ùë¶ (ùë°) ‚àà R, rather than operating directly on sequences. In the continuous-time perspective, in equation (1a) the matrices (ùê¥, ùêµ) are not directly learned but generated from underlying parameters ( √Ö, B), along with a parameterized step size Œî.

The "continuous parameters" (Œî, √Ö, B) are converted to "discrete parameters" (ùê¥, ùêµ) through fixed formulas ùê¥ = ùëì ùê¥ (Œî, √Ö) and ùêµ = ùëì ùêµ (Œî, B), where the pair (ùëì ùê¥ , ùëì ùêµ ) is called a discretization rule.

Remark 1. While our main models adopt the same parameterization and discretization step as prior work (see [Gu and Dao (2023)](#b40) for details), for simplifying exposition and notation we omit it in the rest of this paper. We note that prior work on structured SSMs referred to the continuous parameters ( √Ö, B) and discrete parameters (ùê¥, ùêµ) as (ùê¥, ùêµ) and ( ƒÄ, B) instead; we have changed notation to simplify the presentation and focus directly on the discrete parameters, which govern the main SSM recurrence.

Recurrent Models. Equations ( [1](#formula_0)) and ( [2](#formula_1)) take the form of a recurrence which is linear in its input ùë•. Structured SSMs can therefore be viewed as types of recurrent neural networks (RNNs), where the linearity endows them with additional properties and allows them to avoid the sequential computation of traditional RNNs. Conversely, despite this simplification, SSMs are still fully expressive as sequence transformations (in the sense of universal approximation) [(Kaul 2020;](#b54)[Orvieto et al. 2023](#b68); Shida Wang and Xue 2023).

Convolutional Models. When the SSM's dynamics are constant through time as in equation ( [1](#formula_0)), the model is called linear time-invariant (LTI). In this case, they are equivalent to convolutions. Thus, SSMs can also be viewed as types of CNNs, but where (i) the convolution kernels are implicitly parameterized through the SSM parameters (ùê¥, ùêµ, ùê∂) and (ii) the convolution kernels are generally global instead of local. Conversely, through classical signal processing theory all sufficiently well-behaved convolutions can be represented as SSMs.

Commonly, previous LTI SSMs would use the convolutional mode for efficient parallelizable training (where the whole input sequence is seen ahead of time), and switched into recurrent mode [(1)](#b0) for efficient autoregressive inference (where the inputs are seen one step at a time).

Selective State Space Models. The form [(2)](#b1) where the parameters (ùê¥, ùêµ, ùê∂) can also vary in time was introduced in Mamba as the selective SSM. Compared to the standard LTI formulation [(1)](#b0), this model can selectively choose to focus on or ignore inputs at every timestep. It was shown to perform much better than LTI SSMs on information-dense data such as language, especially as its state size N increases allowing for more information capacity. However, it can only be computed in recurrent instead of convolutional mode, and requires a careful hardware-aware implementation to be efficient. Even so, it is still less efficient than hardware-friendly models such as CNNs and Transformers because it does not leverage matrix multiplication units, which modern accelerators such as GPUs and TPUs are specialized for.

While time-invariant SSMs are closely related to continuous, recurrent, and convolutional sequence models, they are not directly related to attention. In this paper, we show a deeper relationship between selective SSMs and attention, and use it to significantly improve the training speed of SSMs while simultaneously allowing for much larger state sizes N.

Structured SSMs as Sequence Transformations.

Definition 2.1. We use the term sequence transformation to refer to a parameterized map on sequences ùëå = ùëì ùúÉ (ùëã ) where ùëã, ùëå ‚àà R (T,P) and ùúÉ is an arbitrary collection of parameters. T represents the sequence or time axis; subscripts index into the first dimension, e.g. ùëã ùë° , ùëå ùë° ‚àà R P .

Sequence transformations (e.g. SSMs, or self-attention) are the cornerstone of deep sequence models, where they are incorporated into neural network architectures (e.g. Transformers). The SSM in (1) or ( [2](#formula_1)) is a sequence transformation with P = 1; it can be generalized to P > 1 by simply broadcasting across this dimension (in other words, viewing the input as P independent sequences and applying the SSM to each). One can think of P as a head dimension, which we will elaborate on in Section 7.

Definition 2.2. We define the SSM operator SSM(ùê¥, ùêµ, ùê∂) = SSM(ùê¥ 0:ùëá , ùêµ 0:ùëá , ùê∂ 0:ùëá ) as the sequence transformation ùëã ‚àà R (T,P) ‚Ü¶ ‚Üí ùëå ‚àà R (T,P) defined by equation (2).

In SSMs, the N dimension is a free parameter called the state size or state dimension. We also call it the state expansion factor, because it expands the size of the input/output by a factor of ùëÅ , with implications for the computational efficiency of these models.

Finally, we remark that many types of sequence transformations, such as attention, can be represented as a single matrix multiplication across the sequence dimension.

Definition 2.3. We call a sequence transformation ùëå = ùëì ùúÉ (ùëã ) a matrix transformation if it can be written in the form ùëå = ùëÄ ùúÉ ùëã where ùëÄ is a matrix depending on the parameters ùúÉ . We identify the sequence transformation with the matrix ùëÄ, and often drop the dependence on ùúÉ when clear from context.

## Attention

Attention broadly refers to a type of computation that assigns scores to every pair of positions in a sequence, allowing each element to "attend" to the rest. By far the most common and important variant of attention is softmax self-attention, which can be defined as

$ùëå = softmax(ùëÑùêæ ‚ä§ ) ‚Ä¢ ùëâ$for ùëÑ, ùêæ, ùëâ ‚àà R (T,P) . The mechanism of pairwise comparisons (induced by materializing ùëÑùêæ ‚ä§ ) leads to the characteristic quadratic training cost of attention.

Many variants of attention have been proposed, but all share the underlying core of these attention scores, with various approximations (

Tay et al. 2022). The most important variant for this work is linear attention (Katharopoulos et al. 2020). Roughly speaking, this family of methods drops the softmax by folding it into a kernel feature map, and uses associativity of matrix multiplication to rewrite (ùëÑùêæ ‚ä§ ) ‚Ä¢ ùëâ = ùëÑ ‚Ä¢ (ùêæ ‚ä§ ùëâ ). Moreover, in the important case of causal (autoregressive) attention, they show that when the causal mask is incorporated into the left-hand side as (ùêø ‚Ä¢ ùëÑùêæ ‚ä§ ) ‚Ä¢ ùëâ , where ùêø is the lower-triangular 1's matrix, then the right-hand side can be expanded as a recurrence. Several recent and concurrent works such as RetNet (Y. Sun et al. 2023) and GateLoop [(Katsch 2023](#b53)) strengthen this to more general forms of ùêø (Section 10). In this work, our formulation of structured masked attention will strongly generalize these ideas.

## Structured Matrices

General matrices ùëÄ ‚àà R (T,T) require T 2 parameters to represent and ùëÇ (T 2 ) time to perform basic operations such as matrix-vector multiplication. Structured matrices are those that (i) can be represented in subquadratic (ideally linear) parameters through a compressed representation, and

(ii) have fast algorithms (most importantly matrix multiplication) by operating directly on this compressed representation.

Perhaps the most canonical families of structured matrices are sparse and low-rank matrices. However, there exist many other families, such as Toeplitz, Cauchy, Vandermonde, and butterfly matrices, which have all been used in machine learning for efficient models [(Dao, Gu, et](#) al. 2019; D. Fu et al. 2024; Gu, Gupta, et al. 2022; Thomas et al. 2018). Structured matrices are a powerful abstraction for efficient representations and algorithms. In this work, we will show that SSMs are equivalent to another class of structured matrices that have not previously been used in deep learning, and use this connection to derive efficient methods and algorithms.

## Overview: Structured State Space Duality

While this paper develops a much richer framework of connections between SSMs, attention, and structured matrices, we provide a brief summary of the main method, which is actually quite self-contained and simple algorithmically.

Recurrent (Linear) Form. The state space dual (SSD) layer can be defined as a special case of the selective SSM [(2)](#b1). The standard computation of an SSM as a recurrence (or parallel scan) can be applied, which has linear complexity in sequence length. Compared to the version used in Mamba, SSD has two minor differences:

‚Ä¢ The structure on ùê¥ is further simplified from diagonal to scalar times identity structure. Each ùê¥ ùë° can also be identified with just a scalar in this case.

‚Ä¢ We use a larger head dimension P, compared to P = 1 used in Mamba. Typically P = {64, 128} is chosen which is similar to conventions for modern Transformers.

Compared to the original selective SSM, these changes can be viewed as slightly decreasing the expressive power in return for significant training efficiency improvements. In particular, our new algorithms will allow the use of matrix multiplication units on modern accelerators.

Dual (Quadratic) Form. The dual form of SSD is a quadratic computation closely related to attention, defined as

$(ùêø ‚Ä¢ ùëÑùêæ ‚ä§ ) ‚Ä¢ ùëâ ùêø ùëñ ùëó = ùëé ùëñ √ó ‚Ä¢ ‚Ä¢ ‚Ä¢ √ó ùëé ùëó+1 ùëñ ‚â• ùëó 0 ùëñ < ùëó$where ùëé ùëñ are input-dependent scalars bounded in [0, 1].

Compared to standard softmax attention, there are two main differences

‚Ä¢ The softmax is dropped.

‚Ä¢ The attention matrix is multiplied elementwise-wise by an additional mask matrix ùêø.

Both of these changes can be viewed as addressing problems in vanilla attention. For example, the softmax has been recently observed to cause problems in attention scores, such as the "attention sink" phenomenon [(Darcet et al. 2024;](#b28)[Xiao et al. 2024](#b106)). More importantly, the mask matrix ùêø can be viewed as replacing the heuristic positional embeddings of Transformers with a different data-dependent positional mask that controls how much information is transfered across time.

More broadly, this form is an instance of our structured masked attention generalization of linear attention, defined in Section 4.

Matrix Form and SSD Algorithm. The various forms of SSD are connected through a unified matrix representation, by showing that SSMs have a matrix transformation form ùëå = ùëÄùëã for a matrix ùëÄ ùúÉ ‚àà R (T,T) that depends on ùúÉ = (ùê¥, ùêµ, ùê∂).

In particular, the dual form of SSD is equivalent to naive (quadratic-time) multiplication by the matrix ùëÄ, and the recurrent form is a particular efficient (linear-time) algorithm that leverages the structure in ùëÄ.

Going beyond these, any algorithm for multiplication by ùëÄ can be applied. Our proposed hardware-efficient SSD algorithm (Section 6) is a new structured matrix multiplication method that involves block decompositions of ùëÄ, which obtains better efficiency tradeoffs than either the pure linear or quadratic forms. It is relatively simple and easy-to-implement compared to general selective SSMs [(Gu and Dao 2023)](#b40); Listing 1 provides a complete implementation in a few lines of code.

Figure [1](#fig_0) provides a simple roadmap of the relationships between the concepts presented in this paper.

## Notation

Throughout this paper, we prefer using precise notation that can be mapped to code.

Matrices and Vectors. We generally use lower case to denote vectors (i.e. tensors with a single axis) and upper case to denote matrices (i.e. tensors with more than one axes). We do not bold matrices in this work. Sometimes, if a matrix is tied or repeated along one axis (and hence can also be viewed as a vector), we may use either upper or lower case for it. [2](#foot_1)‚Ä¢ denotes scalar or matrix multiplication while ‚Ä¢ denotes Hadamard (elementwise) multiplication.

Indexing. We use Python-style indexing, e.g. ùëñ : ùëó refers to the range (ùëñ, ùëñ + 1, . . . , ùëó -1) when ùëñ < ùëó and (ùëñ, ùëñ -1, . . . , ùëó + 1) when ùëñ > ùëó. For example, for any symbol ùë£ we let ùë£ ùëó:ùëñ for ùëó ‚â• ùëñ denote the sequence (ùë£ ùëó , . . . , ùë£ ùëñ+1 ).

[ùëñ] is equivalent to 0 : ùëñ = (0, . . . , ùëñ -1). For shorthand, we also let ùë£ √ó ùëó:ùëñ denote the product

$ùë£ ùëó √ó ‚Ä¢ ‚Ä¢ ‚Ä¢ √ó ùë£ ùëñ+1 . 3$Dimensions. To distinguish from matrices and tensors, we often use capital letters in typewriter fonts (e.g. D, N, T) to denote dimensions and tensor shapes. Instead of the traditional notation ùëÄ ‚àà R ùëá √óùëá we frequently use ùëÄ ‚àà R (T,T) to reflect tensor shapes in code.

Tensor Contractions. We will heavily rely on tensor contraction or einsum notation both for clarity and as a central tool in stating and proving our results. We assume the reader to be familiar with this notation, which is commonly used in modern tensor libraries such as numpy. For example, we can use contract(MN, NK ‚Üí MK) to denote the matrix-matrix multiplication operator, and in our notation contract(MN, NK ‚Üí MK) (ùëã, ùëå ) (which is equivalent to ùëã ‚Ä¢ ùëå ) can be translated to code as numpy.einsum( ‚Ä≤ mn, nk ‚Üí mk ‚Ä≤ , X, Y).

A large glossary of notation is included in Appendix A.

## State Space Models are Structured Matrices

This section explores different perspectives of the state space model as a sequence transformation, and outlines properties and algorithms of such maps. The main results of this section are about the equivalence between state space models and a family of structured matrices called semiseparable matrices, which imply new efficiency results (Theorems 3.5 and 3.7).

## The Matrix Transformation Form of State Space Models

Recall that our definition of an SSM is defined as a parameterized map defined through [(2)](#b1). Our theoretical framework starts by simply writing this transformation as a matrix multiplication mapping the vectors

$ùë• ‚àà R T ‚Ü¶ ‚Üí ùë¶ ‚àà R T .$By definition, ‚Ñé 0 = ùêµ 0 ùë• 0 . By induction,

$‚Ñé ùë° = ùê¥ ùë° . . . ùê¥ 1 ùêµ 0 ùë• 0 + ùê¥ ùë° . . . ùê¥ 2 ùêµ 1 ùë• 1 + ‚Ä¢ ‚Ä¢ ‚Ä¢ + ùê¥ ùë° ùê¥ ùë° -1 ùêµ ùë° -2 ùë• ùë° -2 + ùê¥ ùë° ùêµ ùë° -1 ùë• ùë° -1 + ùêµ ùë° ùë• ùë° = ùë° ‚àëÔ∏Å ùë†=0 ùê¥ √ó ùë° :ùë† ùêµ ùë† ùë• ùë† .$Multiplying by ùê∂ ùë° to produce ùë¶ ùë° and vectorizing the equation over ùë° ‚àà [T], we derive the matrix transformation form of SSMs.

$ùë¶ ùë° = ùë° ‚àëÔ∏Å ùë†=0 ùê∂ ‚ä§ ùë° ùê¥ √ó ùë° :ùë† ùêµ ùë† ùë• ùë† ùë¶ = SSM(ùê¥, ùêµ, ùê∂) (ùë•) = ùëÄùë• ùëÄ ùëóùëñ ùê∂ ‚ä§ ùëó ùê¥ ùëó ‚Ä¢ ‚Ä¢ ‚Ä¢ ùê¥ ùëñ+1 ùêµ ùëñ(3)$
## Semiseparable Matrices

ùëÄ in equation ( [3](#formula_7)) is a particular representation of a class of matrices known as semiseparable matrices. Semiseparable matrices are a fundamental matrix structure. We first define these matrices and their properties.

Definition 3.1. A (lower triangular) matrix ùëÄ is N-semiseparable if every submatrix contained in the lower triangular portion (i.e. on or below the diagonal) has rank at most N. We call N the order or rank of the semiseparable matrix.

Definition 3.1, and other forms of related "separable" structure (e.g. quasiseparable matrices and other definitions of semiseparable matrices) are sometimes called structured rank matrices (or rank-structured matrices) because they are characterized by rank conditions on their submatrices. Semiseparable matrices have many structured representations including the hierarchical semiseparable (HSS), sequential semiseparable (SSS), and Bruhat forms (Pernet and Storjohann 2018). We will primarily use the SSS form. 3.2.1 The Sequentially Semiseparable (SSS) Representation Definition 3.2. A lower triangular matrix ùëÄ ‚àà R (T,T) has a N-sequentially semiseparable (SSS) representation if it can be written in the form

$ùëÄ ùëóùëñ = ùê∂ ‚ä§ ùëó ùê¥ ùëó ‚Ä¢ ‚Ä¢ ‚Ä¢ ùê¥ ùëñ+1 ùêµ ùëñ(4)$for vectors ùêµ 0 , . . . , ùêµ T-1 , ùê∂ 0 , . . . , ùê∂ T-1 ‚àà R N and matrices ùê¥ 0 , . . . , ùê¥ T-1 ‚àà R (N,N) .

We define the operator SSS so that ùëÄ = SSS(ùê¥ 0:T , ùêµ 0:T , ùê∂ 0:T ).

A fundamental result of semiseparable matrices is that they are exactly equivalent to matrices with SSS representations. One direction can be deduced with a simple constructive proof.

Lemma 3.3. An N-SSS matrix ùëÄ with representation (4) is N-semiseparable.

Proof. Consider any off-diagonal block ùëÄ ùëó:ùëó ‚Ä≤ ,ùëñ ‚Ä≤ :ùëñ where ùëó ‚Ä≤ > ùëó ‚â• ùëñ > ùëñ ‚Ä≤ . This has an explicit rank-N factorization as

$Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ ùëó ùê¥ √ó ùëó:ùëñ ‚Ä≤ ùêµ ùëñ ‚Ä≤ . . . ùê∂ ‚ä§ ùëó ùê¥ √ó ùëó:ùëñ -1 ùêµ ùëñ -1 . . . . . . ùê∂ ‚ä§ ùëó ‚Ä≤ -1 ùê¥ √ó ùëó ‚Ä≤ -1:ùëñ ‚Ä≤ ùêµ ùëñ ‚Ä≤ . . . ùê∂ ‚ä§ ùëó ‚Ä≤ -1 ùê¥ √ó ùëó ‚Ä≤ -1:ùëñ -1 ùêµ ùëñ -1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ ùëó ùê¥ √ó ùëó:ùëó . . . ùê∂ ‚ä§ ùëó ‚Ä≤ -1 ùê¥ √ó ùëó ‚Ä≤ -1:ùëó Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùê¥ √ó ùëó:ùëñ -1 ùê¥ √ó ùëñ -1:ùëñ ‚Ä≤ ùêµ ùëñ ‚Ä≤ ‚Ä¢ ‚Ä¢ ‚Ä¢ ùê¥ √ó ùëñ -1:ùëñ -1 ùêµ ùëñ -1 .(5)$‚ñ° Equation ( [5](#formula_9)) will be used extensively in deriving our fast algorithms for sequence models. The other direction is wellestablished in the literature on semiseparable matrices.

Proposition 3.4. Every N-semiseparable matrix has a N-SSS representation.

Furthermore, note that although Definition 3.2 involves ùëÇ (N 2 T) parameters for the representation (in particular to store the ùê¥ matrices), it can actually be compressed down to ùëÇ (NT) parameters, which is asymptotically tight (Pernet, Signargout, and Villard 2023). Therefore in the rest of this paper we will conflate the structured matrix class (Definition 3.1) and a particular representation of it (Definition 3.2); we will always use this representation instead of other candidates. In turn we will use N-SS to refer to an N-semiseparable matrix in SSS form.

Semiseparable matrices are a fundamental matrix structure and have many important properties. They are deeply related to recurrences at large, and can be defined by multiple characterizations (e.g. Definitions 3.1 and 3.2) which reveal different connections and efficient algorithms for them. We mention some of their other properties in Appendix C.1.

Remark 2. The notion of semiseparability is very broad and many similar but subtlely different definitions appear in the literature; our definitions may differ slightly from other conventions. First, because we are primarily concerned with causal or autoregressive settings in this paper, we have restricted the definition of semiseparability to the triangular case; Definition 3.1 more formally might be called (N, 0)-semiseparability by some authors. Some authors may also instead refer to it as a form of quasiseparability (Eidelman and Gohberg 1999; Pernet 2016). See [Vandebril et al. (2005)](#b102) for a brief survey.

## 1-Semiseparable Matrices: the Scalar SSM Recurrence

We will single out the special case of 1-SS matrices. Note that in this case, the ùê∂ ùëó and ùêµ ùëñ are scalars, and can be factored out of the SSS representation (4) (we also use lower-case to emphasize that the parameters are scalars in this case)

$SSS(ùëé, ùëè, ùëê) = diag(ùëê) ‚Ä¢ ùëÄ ‚Ä¢ diag(ùëè)$where ùëÄ ùëóùëñ = ùëé √ó ùëó:ùëñ .

Since diagonal matrices are easy to handle (e.g. multiplication by a diagonal matrix is the same as elementwise scalar multiplication), we can ignore these terms. Thus our basic representation of a 1-SS matrix is ùëÄ ùëóùëñ = ùëé ùëó:ùëñ or

$ùëÄ = 1SS(ùëé 0:ùëá ) Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 ùëé 1 1 ùëé 2 ùëé 1 ùëé 2 1 . . . . . . . . . . . . ùëé ùëá -1 . . . ùëé 1 ùëé ùëá -1 . . . ùëé 2 . . . ùëé ùëá -1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª . (6$$)$The importance of 1-SS matrices lies in their equivalence to the minimal form of a scalar recurrence -the case of a degenerate SSM with state dimension N = 1 and no (ùêµ, ùê∂) projections. Note that multiplication ùë¶ = ùëÄùë• can be computed by the recurrence ) As sequence transformations, state space models can be represented as a matrix transformation ùëÄ ‚àà R (T,T) acting on the sequence dimension T, sharing the same matrix for each channel in a head (Left). This matrix is a semiseparable matrix (Right), which is a rank-structured matrix where every submatrix contained on-and-below the diagonal (Blue) has rank at most N, equal to the SSM's state dimension.

$ùë¶ ùë° = ùëé ùë° :0 ùë• 0 + ‚Ä¢ ‚Ä¢ ‚Ä¢ + ùëé ùë° :ùë° ùë• ùë° = ùëé ùë° (ùëé ùë° -1:0 ùë• 0 + ‚Ä¢ ‚Ä¢ ‚Ä¢ + ùëé ùë° -1:ùë° -1 ùë• ùë° -1 ) + ùëé ùë° :ùë° ùë• ùë° = ùëé ùë° ùë¶ ùë° -1 + ùë• ùë° .(7)$
## Inputs

We thus also refer to matrix multiplication by 1-SS matrices as the scalar SSM recurrence or the cumprodsum (cumulative product sum; a generalization of cumulative product and cumulative sum) operator. As the fundamental form of recurrence, multiplication by 1-SS matrices is important as a building block for our main algorithms.

We emphasize that one of the central themes of this paper is that many algorithms on sequence models can be reduced to structured matrix multiplication algorithms. 1-SS matrices exemplify this connection: there are many fast algorithms for computing the primitive scalar recurrence or cumprodsum operator, and all of them turn out to be equivalent to different structured factorization of 1-SS matrices. We dedicate Appendix B to these algorithms for 1-SS matrix multiplication.

## State Space Models are Semiseparable Matrices

Recall that our definition of an SSM is defined as a parameterized map defined through Definition 2.1. The connection between SSMs and semiseparable matrices follows from simply writing this transformation as a matrix multiplication mapping the vectors ùë• ‚Ü¶ ‚Üí ùë¶ ‚àà R T .

Equation [(3)](#b2) directly establishes the link between state space models and the sequentially semiseparable representation, which in turn are equivalent to semiseparable matrices in general (Lemma 3.3 and Proposition 3.4).

Theorem 3.5. The state space model transformation ùë¶ = SSM(ùê¥, ùêµ, ùê∂) (ùë•) with state size N is identical to matrix multiplication by an N-SS matrix in sequentially semiseparable representation ùë¶ = SSS(ùê¥, ùêµ, ùê∂) ‚Ä¢ ùë•.

In other words the sequence transformation operator SSM (Definition 2.2) coincides with the matrix construction operator SSS (Definition 3.2), and we use them interchangeably (or sometimes SS as shorthand). Furthermore-by a twist of fate-structured state space models and sequentially semiseparable matrices have the same acronyms, underscoring their equivalence! Conveniently we can use any of these acronyms SSM (state space model or semiseparable matrix), SSS (structured state space or sequentially semiseparable), or SS (state space or semiseparable) interchangeably to unambiguously refer to either concept. However, we will generally use the convention that SSM refers to state space model, SS refers to semiseparable, and SSS refers to sequentially semiseparable.

Figure [2](#fig_1) illustrates the sequence transformation perspective of state space models as semiseparable matrices.

## Computing State Space Models through Structured Matrix Algorithms

The reason Theorem 3.5 is important is that it will allow us to reduce the problem of efficient computation of SSMs (and other sequence models) into efficient algorithms for structured matrix multiplication. We briefly provide an overview and defer our main new algorithm to Section 6, after showing the equivalence of SSMs to other sequence models in Sections 4 and 5.

As previously defined, semiseparable matrices (i.e. rank-structured matrices) are a classical type of structured matrix:

(i) They have compressed representations such as the SSS form which has only ùëÇ (T) instead of ùëÇ (T 2 ) parameters.

(ii) They have fast algorithms operating directly on the compressed representation.

Furthermore, the parameterization and matrix multiplication cost can be tight in the semiseparable order.

Proposition 3.6 [(Pernet, Signargout, and Villard (2023)](#b75)). An N-SS matrix of size T can be represented in ùëÇ (NT) parameters and has matrix-vector multiplication in time and space ùëÇ (NT).

For example, 1-SS matrices illustrate the essence of this connection. The matrix ùëÄ = 1SS(ùëé) is defined by exactly T -1 parameters ùëé 0:T-1 = ùëé 1 , . . . , ùëé T-1 , and can be computed in ùëÇ (T) time by following the scalar recurrence (7).

## The Linear (Recurrent) Mode

Proposition 3.6 can be easily seen in the case of diagonal structured SSMs (S4D [(Gu, Gupta, et al. 2022](#))), simply by leveraging the state space model formulation (2) and unrolling the recurrence. We provide the formal tensor-contraction algorithm in [(8)](#b7), where the dimension S is equal to T[foot_3](#foot_3) .

$ùëç = contract(SP, SN ‚Üí SPN) (ùëã, ùêµ) (S, P, N)(8a)$$ùêª = contract(TSN, SPN ‚Üí TPN) (ùêø, ùëç ) (T, P, N)(8b)$$ùëå = contract(TN, TPN ‚Üí TP) (ùê∂, ùêª ) (T, P)(8c)$Here, ùêø ‚àà R (T,T) is defined as 1SS(ùê¥), or in other words ùêø 0:T,0:T = 1SS(ùê¥ 0:T ) for ùëñ ‚àà [N]. This algorithm involves three steps corresponding to (2):

(i) expanding the input ùëã by the input matrix ùêµ (8a), (ii) unrolling independent scalar SSM recurrences (8b), and

(iii) contracting the hidden state ùêª by the output matrix ùê∂ (8c).

Note that we have used the equivalence between scalar SSMs and 1-SS matrices in step (8b).

Remark 3. We note that (8) is a special case of the Mamba (S6) model. however, a naive implementation is slow because of the expanded tensors ùëç and ùêª of size (T, P, N); Gu and Dao (2023) introduced a hardware-aware implementation to avoid materializing these tensors.

Surprisingly, Theorem 3.5 and Proposition 3.6 immediately imply that all SSMs have the same asymptotic efficiency as algorithm [(8)](#b7).

Theorem 3.7. Any state space model (Definition 2.2) of state size N on sequence length T can be computed in time ùëÇ (TN) (not accounting for potential preprocessing).

We note that this result is new to the structured SSM literature. In particular, given dense unstructured ùê¥ ùë° matrices, the total representation alone seems to be of size ùëÇ (TN 2 ). Thus Theorem 3.7 states the non-trivial result that with a preprocessing step, even an unstructured SSM can be computed optimally efficiently, with upper bound matching the lower bound ùëÇ (TN) given by the size of ùêµ and ùê∂.

Remark 4. Theorem 3.7 is perhaps not too surprising in light of the fact that almost all dense matrices over R (N,N) are diagonalizable over C, leading to the result that almost all dense real SSMs are equivalent to a diagonal complex SSM. This fact underlies the reason why diagonal SSMs are the most popular form of structured SSM [(Gu, Gupta, et al. 2022](#); Gupta, Gu, and Berant 2022; J. T. Smith, Warrington, and Linderman 2023). However, Theorem 3.7 implies the much stronger result for all real SSMs (not just the diagonalizable ones), as well as dense SSMs over other fields (including C itself).

In practice, efficiently computable SSMs still require additional structure on ùê¥, particularly to avoid the expensive preprocessing step (which both has order N extra FLOPs and involves hardware-inefficient operations such as singular value decompositions). These structures are the focus of past work on structured SSMs (e.g. S4(D) and Mamba) as well as our new algorithms. In particular, when slightly stronger structure is imposed on ùê¥, we will design very hardware-efficient algorithms through block decompositions of the SSM matrix ùëÄ = SSS(ùê¥, ùêµ, ùê∂) in Section 6.

## The Quadratic (Naive) Mode

We note that there is another way to compute an SSM exposed by our new matrix point of view. A naive computation of the matrix SSM representation (3) involves simply materializing the sequence transformation matrix ùëÄ = SSS(ùê¥, ùêµ, ùê∂). This is a (T, T) matrix, and therefore this naive algorithm will scale quadratically in sequence length. However, when the sequence length T is short, this can actually be more efficient than the linear algorithm due to constant factors and the hardware-friendliness of the computation pattern (e.g. leveraging matrix-matrix multiplications). In fact, for a particular case of structured SSMs, this looks very similar to a quadratic attention computation (Section 5).

## Summary

Many sequence models are explicitly motivated or defined as matrix sequence transformations -most notably Transformers, where the matrix mixer is the attention matrix. On the other hand, RNNs and SSMs have not previously been described in this way. By providing an explicit matrix transformation form of state space models, we reveal new ways of understanding and using them. From a computational perspective, any method of computing the forward pass of a state space model can be viewed as a matrix multiplication algorithm on semiseparable matrices. The semiseparable matrix perspective provides one lens into state space duality (SSD), where the dual modes respectively refer to a linear-time semiseparable matrix multiplication algorithm and quadratic-time naive matrix multiplication.

Moreover, leveraging the rich structure of semiseparable matrices can lead to even better algorithms and more insights (e.g. Section 6 and Appendix B). In Appendix C.1, we describe some additional properties of semiseparable matrices.

## Structured Masked Attention: Generalizing Linear Attention with Structured Matrices

In this section we revisit the linear attention framework from first principles. The main results in this section are a simple tensor-contraction-based proof of linear attention (Proposition 4.1), and our generalized abstraction of structured masked attention in Definition 4.2. We note that this section derives the main duality results from a different direction than state space models and can be read completely independently of Section 3.

‚Ä¢ Section 4.1 sets up our framework for variants of attention, with a particular focus on kernel attention and masked kernel attention.

‚Ä¢ Section 4.2 provides our first main attention result, a simple proof of linear attention through the lens of tensor contractions.

‚Ä¢ Section 4.3 defines structured masked attention, our generalization of prior attention variants through structured matrices.

## The Attention Framework

## Attention

The basic form of (single-head) attention is a map on three sequences of vectors (ùëÑ, ùêæ, ùëâ ) ‚Ü¶ ‚Üí ùëå .

$ùëÑ = input (T, N) ùêæ = input (S, N) ùëâ = input (S, P) ùê∫ = ùëÑùêæ ‚ä§ (T, S) ùëÄ = ùëì (ùê∫) (T, S) ùëå = ùê∫ùëâ (T, P)(9)$We use "shape annotations" to indicate the dimensions of tensors, e.g. ùëÑ ‚àà R (T,N) . In this general form, S and T represent source and target sequence lengths, N represents the feature dimension, and P represents the head dimension.

The most common variant of softmax attention uses a softmax activation ùëì = softmax to normalize the rows of the ùê∫ matrix.

## Self-Attention

Our treatment is motivated by the most important case of self-attention, where (i) the source and target sequences are the same (i.e. S = T),

(ii) usually the feature and head dimensions are the same (i.e. N = P),

(iii) and ùëÑ, ùêæ, ùëâ are generated by linear projections on the same input vector

$(ùëÑ = ùëä ùëÑ ‚Ä¢ ùëã, ùêæ = ùëä ùêæ ‚Ä¢ ùëã, ùëâ = ùëä ùëâ ‚Ä¢ ùëã ).$However, our presentation abstracts away these choices and begins from the ùëÑ, ùêæ, ùëâ matrices.

Remark 5. Our focus is on the self-attention case with equal head and feature dimensions (i.e. S = T and N = P), which should be used as the running example. We define the general formulation of attention not only so that our framework captures variants such as cross-attention, but also because separating the notation for dimensions (e.g. S and T) makes the contraction notation proofs of our main results in this section more clear.

Remark 6. While attention is usually framed as an operation on these three inputs ùëÑ, ùêæ, ùëâ which are viewed symmetrically, the input and output dimensions in (9) indicate otherwise. In particular, the feature dimension N is not present in the output; therefore in the case when S = T (e.g. self-attention), we view ùëâ as the main input, so that (9) defines a proper sequence transformation ùëâ ‚Ü¶ ‚Üí ùëå (Definition 2.1).

## Kernel Attention

The step where the softmax function is applied to the Gram matrix ùê∫ can be decomposed into two parts:

1. Exponentiating the ùê∫ matrix.

2. Normalizing the ùê∫ matrix on the S axis.

We can ignore the normalization term for now, as it amounts to simply passing in ùëâ = 1 and dividing (we revisit this in Section 7.3). The exponentiation term can be viewed as a kernel transformation: there is an (infinite-dimensional) feature map ùúë such that exp(ùëÑùêæ ‚ä§ ) = ùúë (ùëÑ)ùúë (ùêæ) ‚ä§ . By abstracting away the feature map into the definition of ùëÑ and ùêæ itself (i.e. define ùëÑ, ùêæ as the post-transformed versions), we can ignore the softmax transformation, and assume that ùëÑ, ùêæ are arbitrarily generated by kernel feature maps and potentially N ‚â† P.

## Many instantiations of kernel attention have been proposed, including:

‚Ä¢ The original Linear Attention [(Katharopoulos et al. 2020](#)) defines the kernel feature map as an arbitrary pointwise activation function, such as ùë• ‚Ü¶ ‚Üí 1 + elu(ùë•).

‚Ä¢ Random Feature Attention (RFA) (H. [Peng et al. 2021](#b73)) chooses the kernel feature map to approximate softmax attention (i.e. the exp feature map) using the random Fourier feature approximation of Gaussian kernels [(Rahimi and Recht 2007)](#b86). This involves random projections (i.e. multiplying ùëÑ and ùêæ by a random projection ùëä and applying the activation ùë• ‚Ü¶ ‚Üí (cos(ùë•), sin(ùë•)).

‚Ä¢ Performer [(Choromanski et al. 2021)](#b19) proposes the fast attention via positive orthogonal random features (FAVOR+).

The positive random features (PRF) part chooses the kernel feature map to be a random projection followed by the feature map ùë• ‚Ü¶ ‚Üí 2 -1/2 (exp(ùë•), exp(-ùë•)). This choice is motivated so that the kernel elements are positive-valued and provably approximates the softmax attention. [It also proposes choosing the random projections in orthogonal directions, which we do not consider.]

‚Ä¢ cosFormer [(Qin, Weixuan Sun, et al. 2022](#)) augment RFA with a cosine reweighting mechanism that incorporates positional information to emphasize locality. This effectively passes ùëÑ ùë° , ùêæ ùë° through the feature map ùë• ‚Ü¶ ‚Üí (ùë• cos(ùúãùë°/2ùëá ), sin(ùúãùë°/2ùëá )).

‚Ä¢ Linear Randomized Attention (Zheng, C. Wang, and Kong 2022) generalize RFA from the perspective of importance sampling, and generalize it to provide better estimates of the full softmax kernel (rather than just the exptransformed numerator).

Other related attention variants include Linformer (Sinong Wang et al. 2020) and Nystr√∂former [(Xiong et al. 2021)](#b107), which both use low-rank approximations of the attention matrix ùëÄ (and are thus compatible with equation ( [9](#formula_17))), through random projections (Johnson-Lindenstrauss) and kernel approximation (the Nystr√∂m method) respectively.

## Masked (Kernel) Attention

Let ùêø be a mask of shape (T, S). Most commonly, in the autoregressive self-attention case when S = T, ùêø may be a lowertriangular matrix of 1's representing a causal mask. Besides enforcing causality, many other types of masks can be applied -in particular various sparsity patterns such as banded, dilated, or block diagonal -which are motivated by reducing the complexity of dense attention.

Masked attention is usually written in matrix notation as

$ùë¶ = (ùêø ‚Ä¢ (ùëÑùêæ ‚ä§ )) ‚Ä¢ ùëâ .(10)$More precisely, with shape annotations and breaking this down into the precise sequence of computations:

$ùê∫ = ùëÑùêæ ‚ä§ (T, S) ùëÄ = ùê∫ ‚Ä¢ ùêø (T, S) ùëå = ùëÄùëâ (T, P)(11)$Our improved derivation of attention variants in this section starts by noticing that this formula can be written as a single contraction:

$ùëå = contract(TN, SN, SP, TS ‚Üí TP) (ùëÑ, ùêæ, ùëâ , ùêø)(12)$and the algorithm in ( [11](#formula_20)) can be reframed as computing ( [12](#formula_21)) by a particular ordering of pairwise contractions

$ùê∫ = contract(TN, SN ‚Üí TS) (ùëÑ, ùêæ) (T, S)(13a)$$ùëÄ = contract(TS, TS ‚Üí TS) (ùê∫, ùêø) (T, S)(13b)$$ùëå = contract(TS, SP ‚Üí TP) (ùëÄ, ùëâ ) (T, P) (13c)$
## Linear Attention

Linear attention, and many other variants of efficient attention, is often motivated by changing the order of matrix associativity in the core attention computation (ùëÑùêæ ‚ä§ )ùëâ = ùëÑ (ùêæ ‚ä§ ùëâ ). However when the mask is added, the derivation is somewhat less straightforward (for example, the original paper [(Katharopoulos et al. 2020](#)) and variants (Y. [Sun et al. 2023](#b95)) state the formula without proof).

Roughly, the linear attention method claims that the following formula is equivalent to [(10)](#b10), which must be verified by expanding the sum and tracking indices carefully. 

$ùëå = ùëÑ ‚Ä¢ cumsum(ùêæ ‚ä§ ùëâ )(14)$
## A Tensor Contraction Proof of Linear Attention

We present a simple and rigorous derivation of linear attention that will also immediately reveal how to generalize it. The main idea is to perform the contraction [(12)](#b12) in an alternate order. We avoid ambiguous matrix notation and work directly with contraction notation:

$ùëç = contract(SP, SN ‚Üí SPN) (ùëâ , ùêæ) (S, P, N) (15a) ùêª = contract(TS, SPN ‚Üí TPN) (ùêø, ùëç ) (T, P, N) (15b) ùëå = contract(TN, TPN ‚Üí TP) (ùëÑ, ùêª ) (T, P)(15c)$Intuitively, we interpret this contraction order as follows.

The first step (15a) performs an "expansion" into more features, by a factor of the feature dimension N. The third step (15c) contracts the expanded feature dimension away. If ùêæ is viewed as the input (Remark 6), then ùëâ and ùëÑ perform the expansion and contraction, respectively.

The second step is the most critical, and explains the linear part of linear attention. First notice that (15b) is just a direct matrix multiplication by ùêø (since the (P, N) axes can be flattened). Also note that this is the only term that involves both T and S axes, hence should have Œ©(TS) complexity (i.e. quadratic in sequence length). However, when the mask ùêø is the standard causal attention mask (lower triangular 1's), matrix-vector multiplication by ùêø is identical to a feature-wise cumulative sum

$ùë¶ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 . . . . . . 1 . . . 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùë• ‚áê‚áí ùë¶ 0 = ùë• 0 ùë¶ ùë° = ùë¶ ùë° -1 + ùë• ùë° .$
## Structured Masked Attention

With the tensor contraction perspective of masked attention [(15)](#b15), we can immediately see that the crux of the original linear attention is the fact that matrix-vector multiplication by the causal mask is equivalent to the cumulative sum operator.

However, we observe that there is no reason the attention mask has to be all 1's. All that is necessary for linear attention to be fast is for ùêø to be a structured matrix, which by definition are those that have fast matrix multiplication (Section 2.3).

In particular, we can use any mask matrix ùêø that has sub-quadratic (ideally linear) matrix-vector multiplication, which would have the same complexity as standard linear attention by speeding up the bottleneck equation (15b). The SMA quadratic mode algorithm is the sequence of pairwise contractions defined by [(13)](#b13), which corresponds to the standard (masked) attention computation.

The SMA linear mode algorithm is the sequence of pairwise contractions defined by [(15)](#b15), where step (15b) is optimized through the subquadratic structured matrix multiplication.

We can instantiate structured masked attention to any given class of matrix structure. Some examples include (Figure [3](#fig_4)):

‚Ä¢ Linear attention uses a causal mask.

‚Ä¢ ‚Ä¢ The decay mask could be generalized to a Toeplitz matrix ùêø ùëñ ùëó = ùõº ùëñ -ùëó for some learnable (or input-dependent) set of parameters ùõº ‚àà R T . This can be interpreted as a form of relative positional encoding, reminiscent of other methods such as AliBi (Press, N. Smith, and Lewis 2022) but multiplicative instead of additive.

‚Ä¢ Another variant could use a Fourier matrix ùêø ùëñ ùëó = ùúî ùëñ ùëó/T to encode positional structure a different way.

In Section 5, we consider semiseparable SMA, which defines our main SSD model.

## Summary: The Dual Forms of Masked Attention

Standard (masked kernel) attention is often conflated between a function and an algorithm. Separating this distinction presents a clear way to understand different variants of attention.

‚Ä¢ We view masked attention as a particular function [(12)](#b12).

‚Ä¢ The standard quadratic attention computation (13) can be viewed as an algorithm to compute the function.

‚Ä¢ Linear attention (15) is an alternate algorithm to compute the same function.

## Moreover, in this case

‚Ä¢ The masked attention function is simply a particular contraction on four terms.

‚Ä¢ The quadratic and linear attention algorithms are simply two different orders to perform the contractions.

It is known that contraction orderings can make large differences in computation complexity, leading to the quadratic vs. linear split. Just as state space models are a transformation that can be computed in multiple ways, with dual quadratic vs. linear forms (Section 3.4), linear attention has a similar duality that results from two contraction orders. In fact, these turn out to be different perspectives on the same underlying duality, which we make explicit in Section 5.

## State Space Duality

In Sections 3 and 4, we defined structured state space models and structured attention, discussed their properties, and showed that they both have a quadratic algorithm and a linear algorithm. This section connects them together. Our main result is showing that a particular case of structured state space models coincides with a particular case of structured attention, and that the linear-time SSM algorithm and quadratic-time kernel attention algorithm are dual forms of each other.

‚Ä¢ Section 5.1 specializes state space models to scalar structure, where the naive quadratic computation can be seen as an instance of kernel attention.

‚Ä¢ Section 5.2 specializes structured masked attention to semiseparable SMA, which characterizes masked attention with efficient autoregression.

‚Ä¢ Section 5.3 summarizes the connection between structured masked attention and structured state space models, termed structured state space duality.

## Scalar-Identity Structured State Space Models

In Section 3 we showed that state space models are equivalent to semiseparable matrix transformations, resulting in both a linear recurrent form and quadratic naive form.

Recall that SSMs are defined by ùë¶ = SSM(ùê¥, ùêµ, ùê∂) (ùë•), and the matrix form of SSMs uses the SSS (sequentially semiseparable) representation ùëÄ = SSS(ùê¥, ùêµ, ùê∂) where ùëÄ ùëóùëñ = ùê∂ ‚ä§ ùëó ùê¥ ùëó:ùëñ ùêµ ùëñ (equation ( [3](#formula_7))). Now let us consider the case where ùê¥ ùëó is simply a scalar; in other words, an instantiation of a structured SSM where the ùê¥ matrices are extremely structured: ùê¥ = ùëéùêº for scalar ùëé and identity matrix ùêº . Then we can rearrange

$ùëÄ ùëóùëñ = ùê¥ ùëó:ùëñ ‚Ä¢ (ùê∂ ‚ä§ ùëó ùêµ ùëñ ).$And this can be vectorized into

$ùêø 1SS(ùëé) ùëÄ = ùêø ‚Ä¢ (ùê∂ùêµ ‚ä§ )$where ùêµ, ùê∂ ‚àà R (T,N) .

Using this formulation, the full output ùëå = ùëÄùëã is computed precisely as

$ùê∫ = contract(TN, SN ‚Üí TS) (ùê∂, ùêµ) (T, S) ùëÄ = contract(TS, TS ‚Üí TS) (ùê∫, ùêø) (T, S) ùëå = contract(TS, SP ‚Üí TP) (ùëÄ, ùëã ) (T, P)(16)$where S = T. But this is exactly the same as original definition of masked kernel attention definition (13)! Therefore, as alluded to in Section 3.4, naively computing the scalar structured SSM-by materializing the semiseparable matrix ùëÄ and performing quadratic matrix-vector multiplication-is exactly the same as quadratic masked kernel attention.

## 1-Semiseparable Structured Masked Attention

Structured masked attention allows for the use of any structured mask ùêø. When ùêø is the causal mask, it is standard linear attention. Note that the causal mask is ùêø = SS(1 ùëá ), i.e. the 1-SS mask is generated by ùëé ùë° = 1 in definition [(6)](#b5). This motivates generalizing ùêø to the class of 1-semiseparable masks, or 1-semiseparable structured masked attention (1-SS SMA), where the cumsum in linear attention's recurrence is replaced by a more general recurrence -the scalar SSM scan, i.e. 1-semiseparable matrix multiplication (Section 3.2.2).

Finally, the most important reason we consider 1-semiseparable SMA is because the linear form for computing it is a special case of diagonal state space model. The linear form of SMA is algorithm [(15)](#b15), where the bottleneck step (15b) can be viewed as matrix multiplication by the 1-SS mask. In Section 3, we also wrote out the computation for a diagonal SSM [(8)](#b7), where the bottleneck step (8b) is a scalar SSM recurrence which is equivalent to 1-SS multiplication. The only difference is that (8b) has an extra N dimension in ùêø, because the matrix ùê¥ is a diagonal matrix of size N. This N dimension would disappear if all diagonal entries of ùê¥ are the same, which results in Corollary 5.1.

Corollary 5.1. 1-SS SMA (masked attention with 1-semiseparable structured matrices ùêø) (15) is a special case of a diagonal SSM [(8)](#b7) where the diagonal matrix is a scalar multiple of the identity.

While Corollary 5.1 says that 1-SS SMA has an efficient recurrent form, we can also show a converse result that characterizes which instances of SMA has efficient autoregression.

Theorem 5.2. For any instantiation of structured masked attention (Definition 4.2) that is an autoregressive process with bounded order, the structured mask ùêø must be a semiseparable matrix.

In other words, efficient autoregressive attention is general semiseparable SMA. Theorem 5.2 is proved in Appendix C.2.

Remark 7. While 1-semiseparable SMA is a special case of a state space model, general semiseparable SMA is strictly more expressive than 1-SS SMA, and cannot be described by a standard SSM. However, the semiseparable multiplication by ùêø and the linear form of SMA (equation (15a)) each involve an expansion and contraction step, and can be absorbed into a similar instance of 1-SS SMA with a single (larger) expansion.

In summary, 1-semiseparable structured attention is the most important case of SMA, because it is:

‚Ä¢ a natural generalization of linear attention with an input-dependent recurrence.

‚Ä¢ the simplest case of general semiseparable attention, which is equivalent to efficient autoregressive attention.

‚Ä¢ a special case of a diagonal state space model.

## Structured State-Space Duality (SSD)

To summarize our results:

‚Ä¢ Structured state-space models (Section 3) are a model usually defined through a linear-time recurrence. However, by expanding the matrix formulation characterizing its linear sequence-to-sequence transformation, one can derive a quadratic form.

‚Ä¢ Attention variants (Section 4) are a model defined through quadratic-time pairwise interactions. However, by viewing it as a four-way tensor contraction and reducing in a different order, one can derive a linear form.

‚Ä¢ A natural special case of each one -more precisely, state space models with scalar-identity structure on the ùê¥ matrices, and structured masked attention with 1-semiseparable structure on its ùêø mask -are duals of each other with the exact same linear and quadratic forms.

Figure [4](#) summarizes the duality between these two representations.

An extended related work and discussion (Section 10) describes the relationship between SSD and general SSMs / attention in more detail.

## A Hardware-Efficient Algorithm for SSD Models

The benefits of developing the theoretical SSD framework between SSMs, attention, and structured matrices lies in using the connections to improve the models and algorithms. In this section, we show how various algorithms for computing SSD models efficiently can be derived from various algorithms for computing structured matrix multiplication.

Our main computational result is an algorithm for computing SSD models that combines both the linear (recurrent) mode and quadratic (attention) mode. This algorithm is as computation efficient as SSMs (linear scaling in sequence length) and as hardware-friendly as attention (primarily uses matrix multiplications).

Theorem 6.1. Consider an SSD model with state expansion factor N and head dimension P = N. There exists an algorithm for computing the model on any input ùëã ‚àà R (T,P) which only requires ùëÇ (TN 2 ) training FLOPs, ùëÇ (TN) inference FLOPs, ùëÇ (N 2 ) inference memory, and whose work is dominated by matrix multiplications. Structured State Space Model Structured Masked Attention ùê∂ (contraction matrix) ùëÑ (queries) ùêµ (expansion matrix) ùêæ (keys) ùëã (input sequence) ùëâ (values) ùê¥ ùëó:ùëñ (state matrix) ùêø ùëóùëñ (mask) N (state expansion dim.) N (kernel feature dim.) ùêª (hidden states (8b)) SMA linear dual (15) = ùêø ‚Ä¢ ùëã ùêµ (linear mode) SSM quadratic dual (16) ùê∫ (Gram matrix (13a)) = ùëÑ ‚Ä¢ ùêæ ‚ä§ (quadratic mode) Structured State Space Model (SSM) Diagonal State Space Model Scalar-Identity SSM Structured Masked Attention (SMA) Semiseparable SMA 1-Semiseparable SMA S4D S5 S6 Linear Attention Efficient Autoregressive Attention RetNet TransNormer GateLoop Structured State Space Duality (SSD) DSS S4 Figure 4: (Structured State Space Duality.) State space duality describes the close relationship between state space models and masked attention. (Left) General SSMs and SMA both possess linear and quadratic forms, with direct analogs in notation. (Right) SSMs and SMA intersect at a large class of state space dual models (SSD) which capture many sequence models as special cases. Note that all of these bounds are tight, because a state space model with state expansion N operating on a head size of N has total state size N 2 (yielding the lower bounds for training and inference FLOPs of ùëÇ (TN 2 ) and ùëÇ (N 2 ) respectively). Furthermore the input ùëã itself has TN elements, yielding the memory lower bound.

The main idea behind Theorem 6.1 is once again viewing the problem of computing a state space model as a semiseparable matrix multiplication, but leveraging its structure in a new way. Instead of computing the whole matrix in either recurrent or attention mode, we perform a block decomposition of the matrix. The diagonal blocks can be computed using the dual attention mode, which can be efficiently done with matrix multiplications, while the off-diagonal blocks can be factored by the rank-structure of semiseparable matrices and reduced to a smaller recurrence. We highlight that Listing 1 provides a self-contained implementation of the SSD algorithm. Compared to the general selective SSM of Gu and Dao (2023), this implementation is much simpler, and relatively efficient even in native PyTorch without requiring special low-level kernels.

To begin, we partition the matrix ùëÄ into a T Q √ó T Q grid of submatrices of size Q √ó Q, for some block size Q. Note that the off-diagonal blocks are low-rank by the defining property of semiseparable matrices (Definition 3.1). [5](#foot_4)(Block Decomposition)

$ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëÄ (0,0) ùëÄ (1,0) ùëÄ (1,1) . . . . . . . . . ùëÄ (T/Q-1,0) ùëÄ (T/Q-1,1) . . . ùëÄ (T/Q-1,T/Q-1) Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª (Diagonal Block) ùëÄ ( ùëó,ùëó ) = SSM(ùê¥ ùëóQ:( ùëó+1)Q , ùêµ ùëóQ:( ùëó+1)Q , ùê∂ ùëóQ:( ùëó+1)Q ) (Low-Rank Block) ùëÄ ( ùëó,ùëñ ) = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ ùëóQ ùê¥ ùëóQ:ùëóQ-1 . . . ùê∂ ‚ä§ ( ùëó+1)Q-1 ùê¥ ( ùëó+1)Q-1:ùëóQ-1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùê¥ ùëóQ-1:(ùëñ+1)Q-1 Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùêµ ‚ä§ ùëñQ ùê¥ (ùëñ+1)Q-1:ùëñQ . . . ùêµ ‚ä§ (ùëñ+1)Q-1 ùê¥ (ùëñ+1)Q-1:(ùëñ+1)Q-1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ‚ä§$This is easiest illustrated through an example, e.g. for T = 9 and decomposing into chunks of length Q = 3. The shaded cells are low-rank factorizations of the off-diagonal blocks of the semiseparable matrix.

$ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ 0 ùê¥ 0:0 ùêµ 0 ùê∂ ‚ä§ 1 ùê¥ 1:0 ùêµ 0 ùê∂ ‚ä§ 1 ùê¥ 1:1 ùêµ 1 ùê∂ ‚ä§ 2 ùê¥ 2:0 ùêµ 0 ùê∂ ‚ä§ 2 ùê¥ 2:1 ùêµ 1 ùê∂ ‚ä§ 2 ùê¥ 2:2 ùêµ 2 ùê∂ ‚ä§ 3 ùê¥ 3:0 ùêµ 0 ùê∂ ‚ä§ 3 ùê¥ 3:1 ùêµ 1 ùê∂ ‚ä§ 3 ùê¥ 3:2 ùêµ 2 ùê∂ ‚ä§ 3 ùê¥ 3:3 ùêµ 3 ùê∂ ‚ä§ 4 ùê¥ 4:0 ùêµ 0 ùê∂ ‚ä§ 4 ùê¥ 4:$1 ùêµ 1 ùê∂ ‚ä§ 4 ùê¥ 4:2 ùêµ 2 ùê∂ ‚ä§ 4 ùê¥ 4:3 ùêµ 3 ùê∂ ‚ä§ 4 ùê¥ 4:4 ùêµ 4 ùê∂ ‚ä§ 5 ùê¥ 5:0 ùêµ 0 ùê∂ ‚ä§ 5 ùê¥ 5:1 ùêµ 1 ùê∂ ‚ä§ 5 ùê¥ 5:2 ùêµ 2 ùê∂ ‚ä§ 5 ùê¥ 5:3 ùêµ 3 ùê∂ ‚ä§ 5 ùê¥ 5:4 ùêµ 4 ùê∂ ‚ä§ 5 ùê¥ 5:5 ùêµ 5 ùê∂ ‚ä§ 6 ùê¥ 6:0 ùêµ 0 ùê∂ ‚ä§ 6 ùê¥ 6:1 ùêµ 1 ùê∂ ‚ä§ 6 ùê¥ 6:2 ùêµ 2 ùê∂ ‚ä§ 6 ùê¥ 6:3 ùêµ 3 ùê∂ ‚ä§ 6 ùê¥ 6:4 ùêµ 4 ùê∂ ‚ä§ 6 ùê¥ 6:5 ùêµ 5 ùê∂ ‚ä§ 6 ùê¥ 6:6 ùêµ 6 ùê∂ ‚ä§ 7 ùê¥ 7:0 ùêµ 0 ùê∂ ‚ä§ 7 ùê¥ 7:1 ùêµ 1 ùê∂ ‚ä§ 7 ùê¥ 7:2 ùêµ 2 ùê∂ ‚ä§ 7 ùê¥ 7:3 ùêµ 3 ùê∂ ‚ä§ 7 ùê¥ 7:4 ùêµ 4 ùê∂ ‚ä§ 7 ùê¥ 7:5 ùêµ 5 ùê∂ ‚ä§ 7 ùê¥ 7:6 ùêµ 6 ùê∂ ‚ä§ 7 ùê¥ 7:7 ùêµ ùê∂ ‚ä§ 8 ùê¥ 8:0 ùêµ 0 ùê∂ ‚ä§ 8 ùê¥ 8:1 ùêµ 1 ùê∂ ‚ä§ 8 ùê¥ 8:2 ùêµ 2 ùê∂ ‚ä§ 8 ùê¥ 8:3 ùêµ 3 ùê∂ ‚ä§ 8 ùê¥ 8:4 ùêµ 4 ùê∂ ‚ä§ 8 ùê¥ 8:5 ùêµ 5 ùê∂ ‚ä§ 8 ùê¥ 8:6 ùêµ 6 ùê∂ ‚ä§ 8 ùê¥ 8:7 ùêµ ùê∂ ‚ä§ 8 ùê¥ 8:8 ùêµ 8

$Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ 0 ùê¥ 0:0 ùêµ 0 ùê∂ ‚ä§ 1 ùê¥ 1:0 ùêµ 0 ùê∂ ‚ä§ 1 ùê¥ 1:1 ùêµ 1 ùê∂ ‚ä§ 2 ùê¥ 2:0 ùêµ 0 ùê∂ ‚ä§ 2 ùê¥ 2:1 ùêµ 1 ùê∂ ‚ä§ 2 ùê¥ 2:2 ùêµ 2 ùê∂ ‚ä§ 3 ùê¥ 3:3 ùêµ 3 ùê∂ ‚ä§$4 ùê¥ 4:3 ùêµ 3 ùê∂ ‚ä§ 4 ùê¥ 4:4 ùêµ 4 ùê∂ ‚ä§ 5 ùê¥ 5:3 ùêµ 3 ùê∂ ‚ä§ 5 ùê¥ 5:4 ùêµ 4 ùê∂ ‚ä§ 5 ùê¥ 5:5 ùêµ 5 ùê∂ ‚ä§ 6 ùê¥ 6:6 ùêµ 6 ùê∂ ‚ä§ 7 ùê¥ 7:6 ùêµ 6 ùê∂ ‚ä§ 7 ùê¥ 7:7 ùêµ ùê∂ ‚ä§ 8 ùê¥ 8:6 ùêµ 6 ùê∂ ‚ä§ 8 ùê¥ 8:7 ùêµ ùê∂ ‚ä§ 8 ùê¥ 8:8 ùêµ 8

$Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ 3 ùê¥ 3:2 ùê∂ ‚ä§ 4 ùê¥ 4:2 ùê∂ ‚ä§ 5 ùê¥ 5:2 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùê¥ 2:2 Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùêµ ‚ä§ 0 ùê¥ 2:0 ùêµ ‚ä§ 1 ùê¥ 2:1 ùêµ ‚ä§ 2 ùê¥ 2:2 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ‚ä§ Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ 6 ùê¥ 6:5 ùê∂ ‚ä§ 7 ùê¥ 7:5 ùê∂ ‚ä§ 8 ùê¥ 8:5 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùê¥ 5:2 Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùêµ ‚ä§ 0 ùê¥ 2:0 ùêµ ‚ä§ 1 ùê¥ 2:1 ùêµ ‚ä§ 2 ùê¥ 2:2 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ‚ä§ Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§ 6 ùê¥ 6:5 ùê∂ ‚ä§ 7 ùê¥ 7:5 ùê∂ ‚ä§ 8 ùê¥ 8:5 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùê¥ 5:5 Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùêµ ‚ä§ 3 ùê¥ 5:3 ùêµ ‚ä§ 4 ùê¥ 5:4 ùêµ ‚ä§ 5 ùê¥ 5:5 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ‚ä§ Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª$From here we can reduce the problem into these two parts. These can also be interpreted as dividing the output of a "chunk" ùë¶ ùëóQ:( ùëó+1)Q into two components: the effect of inputs within the chunk ùë• ùëóQ:( ùëó+1)Q , and the effect of inputs before the chunk ùë• 0:ùëóQ .

## Diagonal Blocks

The diagonal blocks are easy to handle, because they are simply self-similar problems of a smaller size. The ùëó-th block represents computing the answer SSM(ùê¥ ùëÖ , ùêµ ùëÖ , ùê∂ ùëÖ ) (ùë• ùëÖ ) for the range ùëÖ = ùëóQ :

$( ùëó + 1)Q = ( ùëóQ, ùëóQ + 1, . . . , ùëóQ + Q -1).$The key is that this block can be computed using any desired method. In particular, for small chunk lengths Q, this problem is computed more efficiently using the dual quadratic SMA form. Additionally, the chunks can be computed in parallel.

These subproblems can be interpreted as: what is the output per chunk supposing that the initial state (to the chunk) is 0.

In other words for chunk ùëó, this computes the correct outputs taking into account only the chunk inputs ùë• ùëóQ:( ùëó+1)Q .

## Low-Rank Blocks

The low-rank factorizations consist of 3 terms, and there are correspondingly three pieces of the computation. In this factorization, we will use the terminology

‚Ä¢ The terms like

$Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùêµ ‚ä§ 0 ùê¥ 2:0 ùêµ ‚ä§ 1 ùê¥ 2:1 ùêµ ‚ä§ 2 ùê¥ 2:2 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ‚ä§$are called the right factors or ùêµ-block-factors.

‚Ä¢ The terms like ùê¥ 5:2 are called the center factors or ùê¥-block-factors.

‚Ä¢ The terms like

$Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùê∂ ‚ä§$6 ùê¥ 6:5 ùê∂ ‚ä§ 7 ùê¥ 7:5 ùê∂ ‚ä§ 8 ùê¥ 8:5 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª are called the left factors or ùê∂-block-factors. ùëã Inputs ùëå Outputs ùêª States Diagonal Block: Input ‚Üí Output Low-Rank Block: Input ‚Üí State Low-Rank Block: State ‚Üí Output Low-Rank Block: State ‚Üí State Semiseparable Matrix Block Decomposition

## ùëÄ

Figure [5](#): (SSD Algorithm.) By using the matrix transformation viewpoint of state space models to write them as semiseparable matrices (Section 3), we develop a more hardware-efficient computation of the SSD model through a blockdecomposition matrix multiplication algorithm. The matrix multiplication also has an interpretation as a state space model, where blocks represent chunking the input and output sequence. Diagonal blocks represent intra-chunk computations and the off-diagonal blocks represent inter-chunk computations, factored through the SSM's hidden state.

Right Factors. This step computes the multiplication by the right ùêµ-block-factors of the low-rank factorization. Note that for each chunk, this is a (N, Q) by (Q, P) matrix multiplication, where N is the state dimension and ùëÉ is the head dimension. The result is a (N, P) tensor for each chunk, which has the same dimensionality as the expanded hidden state ‚Ñé.

This can be interpreted as: what is the final state per chunk supposing that the initial state (to the chunk) is 0. In other words this computes ‚Ñé ùëóQ+Q-1 assuming that ùë• 0:ùëóQ = 0.

Center Factors. This step computes the effect of the center ùê¥-block-factors terms in the low-rank factorization. In the previous step, the final states per chunk have total shape (T/Q, N, P). This is now multiplied by a 1-SS matrix generated by

$ùê¥ √ó 2Q-1:Q-1 , ùê¥ √ó 3Q-1:2Q-1 , . . . , ùê¥ √ó T-1:T-Q-1 .$This step can be computed by any algorithm for computing 1-SS multiplication (also known as the scalar SSM scan or cumprodsum operator).

This can be interpreted as: what is the actual final state per chunk taking into account all previous inputs; in other words, this computes the true hidden state ‚Ñé ùëóQ taking into account all of ùë• 0:( ùëó+1)Q .

Left Factors. This step computes the multiplication by the left ùê∂-block-factors of the low-rank factorization. For each chunk, this can be represented by a matrix multiplication contract(QN, NP ‚Üí QP).

This can be interpreted as: what is the output per chunk taking into account the correct initial state ‚Ñé ùëóQ-1 , and supposing the inputs ùë• ùëóQ:( ùëó+1)Q are 0. In other words for chunk ùëó, this computes the correct outputs taking into account only the prior inputs ùë• 0:ùëóQ .

## Computational Cost

We define the notation BMM(B, M, N, K) to define a batched matrix multiplication contract(MK, KN ‚Üí MN) with batch dimension B. From this notation we can infer three aspects of the efficiency:

‚Ä¢ Computation cost: total of ùëÇ (BMNK) FLOPs.

‚Ä¢ Memory cost: total of ùëÇ (B(MK + KN + MN)) space. Center Blocks. The cost of the quadratic SMA computation consists of three steps (equation ( [16](#formula_30))):

‚Ä¢ Computing the kernel matrix ùê∂ ‚ä§ ùêµ, which has cost BMM(T/Q, Q, Q, N).

‚Ä¢ Multiplying by the mask matrix, which is an elementwise operation on tensors of shape (T/Q, Q, Q).

‚Ä¢ Multiplying by the ùëã values, which has cost BMM(T/Q, Q, P, N) Low-Rank Blocks: Right Factors. This step is a single matrix multiplication with cost BMM(T/Q, N, P, Q).

Low-Rank Blocks: Center Factors. This step is a scalar SSM scan (or 1-SS multiplication) of length T/Q on (N, P) independent channels. The work of this scan is TNP/Q, which is negligible compared to the other factors.

Note that because of the blocking which reduces the length of the sequence from T to T/Q, this scan has Q times smaller cost than a pure SSM scan (e.g. the selective scan of Mamba). Thus we observe that on most problem lengths, other algorithms (Appendix B) may be more efficient or much easier to implement without a significant slowdown. For example, a naive implementation of this via 1-SS matrix multiplication has cost BMM(1, T/Q, NP, T/Q), which is much easier to implement and can be more efficient than a naive recurrence/scan implementation.

Low-Rank Blocks: Left Factors. This step is a single matrix multiplication with cost BMM(T/Q, Q, P, N).

Total Cost. If we set N = P = Q (in other words the state dimension, head dimension, and chunk length are equal), then all BMM terms above become BMM(T/N, N, N, N). The computational chacteristics of this are:

‚Ä¢ Total FLOP count of ùëÇ (TN 2 ).

‚Ä¢ Total memory of ùëÇ (TN).

‚Ä¢ The work consists primarily of matrix multiplications on matrices of shape (N, N).

Notice that the memory consumption is tight; the inputs and outputs ùë•, ùë¶ have shape (T, P) = (T, N). Meanwhile the flop count reflects an extra factor of N, which is cost incurred by the autoregressive state size and is common to all models.

Aside from the matmuls, there is a scalar SSM scan on NP = N 2 features and sequence length T/Q. This has cost ùëÇ (T/QN 2 ) FLOPs and ùëÇ (log(T/Q)) depth. Although it does not use matrix multiplications, it is still parallelizable and the total work done is negligible compared to the other steps; this has a negligible cost in our GPU implementation.

Comparison to Pure SSM and Attention Models. Quadratic attention is also very hardware efficient by only leveraging matrix multiplications, but has T 2 ùëÅ total FLOPs. Its slower computation speed at both training and inference can directly be seen as a consequence of having a larger state size -standard attention has a state size scaling with sequence length T because it caches its history and does not compress its state.

Linear SSMs have TNP = TN 2 total FLOPs, which is the same as SSD. However, a naive implementation requires a state expansion (15a) that materializes extra memory, and a scalar operation (15b) that does not leverage matrix multiplications.

## Attention SSM SSD

## State size

$T N N Training FLOPs T 2 N TN 2 TN 2 Inference FLOPs TN N 2 N 2 (Naive) memory T 2 TN 2 TN Matrix multiplication ‚úì ‚úì$We note that many other matrix decompositions are possible (for example, see Appendix B for a compendium of algorithms for 1-SS multiplication through different structured matrix decompositions) which may lead to more algorithms for SSDs that could be better for other specialized settings. Even more broadly, we note that semiseparable matrices have a rich literature and many more representations besides the SSS form that we use (Definition 3.2), and even more efficient algorithms may be possible. developed for Transformers. We discuss several design choices, resulting in the Mamba-2 architecture. These axes of variation are ablated in Section 9.4.

## Block Design

We first discuss modifications to the neural network block that are independent of the inner sequence mixing layer (i.e. outside the core SSD layer).

Parallel Parameter Projections. Mamba-1 was motivated by an SSM-centric point of view where the selective SSM layer is viewed as a map from ùëã ‚Ü¶ ‚Üí ùëå . The SSM parameters ùê¥, ùêµ, ùê∂ are viewed as subsidiary and are functions of the SSM input ùëã . Thus the linear projections defining (ùê¥, ùêµ, ùê∂) occur after the initial linear projection to create ùëã .

In Mamba-2, the SSD layer is viewed as a map from ùê¥, ùëã, ùêµ, ùê∂ ‚Ü¶ ‚Üí ùëå . It therefore makes sense to produce ùê¥, ùëã, ùêµ, ùê∂ in parallel with a single projection at the beginning of the block. Note the analogy to standard attention architectures, where ùëã, ùêµ, ùê∂ correspond to the ùëÑ, ùêæ, ùëâ projections that are created in parallel.

Note that adopting parallel projections for the ùê¥, ùêµ, ùê∂, ùëã inputs to the SSM slightly reduces parameters and more importantly is more amenable to tensor parallelism for larger models, by using standard Megatron sharding patterns (Shoeybi et al. 2019)).

Extra Normalization. In preliminary experiments, we found that instabilities were prone to arising in larger models. We were able to alleviate this by adding an extra normalization layer (e.g. LayerNorm, GroupNorm, or RMSNorm) to the block right before the final output projection. This usage of a normalization is most directly related to the NormFormer architecture (Shleifer, Weston, and Ott 2021), which also added normalization layers at the end of the MLP and MHA blocks.

We also note that this change is similar to other recent models related to Mamba-2 that were derived from a linear attention viewpoint. The original linear attention formulation normalizes by a denominator term that emulates the normalization of the softmax function in standard attention. TransNormerLLM [(Qin, Dong Li, et al. 2023](#)) and RetNet (Y. [Sun et al. 2023)](#b95) find that this normalization is unstable and add an extra LayerNorm or GroupNorm after the linear attention layer. Our extra normalization layer differs slightly from these, occuring after the multiplicative gate branch instead of before.

## Multihead Patterns for Sequence Transformations

Recall that SSMs are defined as a sequence transformation (Definition 2.1) where:

‚Ä¢ ùê¥, ùêµ, ùê∂ parameters have a state dimension N.

‚Ä¢ They define a sequence transformation R T ‚Üí R T , which for example can be represented as a matrix ùëÄ ‚àà R (T,T) .

‚Ä¢ This transformation operates over an input sequence ùëã ‚àà R (T,P) , independently over the P axis.

One can view this as defining one head of the sequence transformation. Definition 7.1 (Multihead patterns). A multihead sequence transformation consists of H independent heads, for a total model dimension of D = d_model. The parameters may be tied across heads, leading to a head pattern.

The state size N and head dimension P are analogous to the ùëÑùêæ head dimension and ùëâ head dimension of attention, respectively. Just as in modern Transformer architectures [(Chowdhery et al. 2023;](#b20)[Touvron, Lavril, et al. 2023)](#b100), in Mamba-2 we generally choose these to be constants around 64 or 128; when the model dimension D increases, we increase the number of heads while keeping the head dimensions N and P fixed. In order to describe how to do this, we can transfer and generalize ideas from multihead attention to define similar patterns for SSMs, or any general sequence transformation.

Multi-head SSM (Multi-head Attn.) ùëã (T, H, P)

$ùê¥ (T, H) ùêµ (T, H, N) ùê∂ (T, H, N)(17)$Multi-contract SSM (Multi-query Attn.)

$ùëã (T, 1, P) ùê¥ (T, H) ùêµ (T, 1, N) ùê∂ (T, H, N)(18)$Multi-expand SSM (Multi-key Attn.)

$ùëã (T, 1, P) ùê¥ (T, H) ùêµ (T, H, N) ùê∂ (T, 1, N)(19)$Multi-input SSM (Multi-value Attn.) ùëã (T, H, P)

$ùê¥ (T, H) ùêµ (T, 1, N) ùê∂ (T, 1, N)(20)$Multihead SSM (MHS) / Multihead Attention (MHA) Pattern. The classic MHA pattern assumes that the head dimension P divides the model dimension D. The number of heads is defined as H = D/P. Then, H copies of the core sequence transformation are created by creating H independent copies of each parameter. Note that while the MHA pattern was first described for the attention sequence transformation, it can be applied to anything compatible with Definition 2.1. For example, a multi-head SSD layer would accept inputs with shapes according to equation [(17)](#b17) where the SSD algorithm is broadcasted over the H = n_heads dimension.

Multi-contract SSM (MCS) / Multi-query Attention (MQA) Pattern. Multi-query attention [(Shazeer 2019](#b90)) is a clever optimization for attention that can dramatically improve the speed of autoregressive inference, which relies on caching the ùêæ and ùëâ tensors. This technique simply avoids giving ùêæ and ùëâ the extra head dimension, or in other words broadcasts a single head of (ùêæ, ùëâ ) across all the heads of ùëÑ.

Using the state space duality, we can define an equivalent SSM version of MQA as equation [(18)](#b18). Here, ùëã and ùêµ (the SSM analogs of attention's ùëâ and ùêæ) are shared across the H heads. We also call this the multi-contract SSM (MCS) head pattern, because the ùê∂ parameter which controls the SSM state contraction has independent copies per head.

We can similarly define a multi-key attention (MKA) or multi-expand SSM (MES) head pattern, where ùêµ (which controls the SSM expansion) is independent per head while ùê∂ and ùëã are shared across heads.

Multi-input SSM (MIS) / Multi-value Attention (MVA) Pattern. While MQA makes sense for attention because of its KV cache, it is not the natural choice for SSMs. In Mamba, instead, ùëã is viewed as the main input to the SSM, and therefore ùêµ and ùê∂ are parameters that are shared across the input channels. We define a new multi-value attention (MVA) of multi-input SSM (MIS) pattern in equation [(20)](#b20), which can again be applied to any sequence transformation such as SSD.

Armed with this vocabulary, we can characterize the original Mamba architecture more precisely.

Proposition 7.2. The selective SSM (S6) layer of the Mamba architecture (Gu and Dao 2023) can be viewed as having

‚Ä¢ Head dimension ùëÉ = 1: every channel has independent SSM dynamics ùê¥.

‚Ä¢ Multi-input SSM (MIS) or multi-value attention (MVA) head structure: the ùêµ, ùê∂ matrices (corresponding to ùêæ, ùëÑ in the attention duality) are shared across all channels of the input ùëã (corresponding to ùëâ in attention).

We can also ablate these head pattern variants when applied to SSD (Section 9.4.3). Interestingly, despite being controlled in parameter counts and total state dimension, there is a noticeable difference in downstream performance. We empirically find that the MVA pattern as originally used in Mamba performs best.

Grouped Head Patterns. The ideas of multi-query attention can be extended to grouped-query attention (Ainslie et al. 2023): instead of 1 K and V head, one can create G independent K and V heads, where 1 < G and G divides H. This is motivated both by bridging the performance difference between multi-query and multi-head attention, and enabling more efficient tensor parallelism by setting G to be a multiple of the number of shards (Section 8).

Similarly, the multi-input SSM head pattern used in Mamba-2 can be easily extended to grouped-input SSM (GIS), or synonymously grouped-value attention (GVA). The generalization is straightforward and we omit the details for simplicity.

## Other SSD Extensions from Linear Attention

We describe here an example of architectural modifications to SSD motivated by linear attention. We ablate these in Section 9.4.3 as a form of negative result, finding that they do not significantly improve performance enough to adopt them as default settings. Nonetheless, these illustrate how the vast literature on attention can be incorporated to define variants of SSD. We treat the choice of kernel feature map as a hyperparameter in the Mamba-2 architecture, and expect other simple modifications inspired by attention to be possible as well.

Kernel Attention Approximations to Softmax Attention. Many variants of linear attention or kernel attention are motivated by viewing the attention scores softmax(ùëÑùêæ ‚ä§ ) as composed of

1. An exponential kernel ùëç = exp(ùëÑùêæ ‚ä§ ), which can be approximated by ùëç = ùúì (ùëÑ)ùúì (ùêæ) ‚ä§ for some kernel feature map.

2. Normalizing the kernel so that rows sum to 1 via ùëÄ = ùê∫/ùê∫11 ‚ä§ , where the division happens elementwise and 1 is the all 1's vector.

Exponential Kernel Feature Maps. In Mamba-2, we incorporate a flexible kernel feature map, and apply it to the ùêµ and ùê∂ branches (corresponding to the ùêæ and ùëâ branches in attention). The feature map can also be optionally applied to the ùëã (ùëâ ) branch, for simplicity and symmetry. This is represented in Figure [6](#fig_6) by an arbitrary nonlinearity. By default, we simply choose ùúì to be an elementwise Swish / SiLU function (Hendrycks and Gimpel 2016; Ramachandran, Zoph, and Le 2017). We explore other options in the ablations in Section 9.4.3, including feature maps used by Linear Attention, Performer, Random Feature Attention, and cosFormer (Section 4.1.3).

Incorporating a Normalization (Denominator) Term. To find the denominator term, we simply have to compute ùëÄ1. But recall that the final output of the model is just ùëå = ùëÄùëã (equation ( [16](#formula_30))). So the normalization terms can be found simply by augmenting ùëã with an extra column 1, resulting in a tensor of shape (T, P + 1).

Note that in this case, the kernel feature map ùúì must be positive so that the sum is positive.

## Tensor Parallel

Tensor parallelism (TP) [(Shoeybi et](#) al. 2019) is a model parallelism technique that splits each layer (e.g., attention, MLP) to run on multiple accelerators such as GPUs. This technique is widely used to train most large models (Brown et al. 2020; Chowdhery et al. 2023; Touvron, Lavril, et al. 2023; Touvron, L. Martin, et al. 2023) on GPU clusters where each node typically has 4-8 GPUs with fast networking such as NVLink. TP was originally developed for the Transformer architecture, and it is not straight-forward to adapt it other architecture.

We first show the challenge of using TP with the Mamba architecture, and the show how the Mamba-2 architecture is designed to make TP efficient.

Recall the Mamba architecture, with a single input ùë¢ ‚àà R ùêø√óùëë (no batching for simplicity), input projection matrices ùëä (ùë• ) ,ùëä (ùëß ) ‚àà R ùëë √óùëíùëë where ùëí is the expansion factor (typically 2), and output projection matrix ùëä (ùëú ) ‚àà R ùëíùëë √óùëë :

$ùë• = ùë¢ùëä (ùë• ) ‚ä§ ‚àà R ùêø√óùëíùëë ùëß = ùë¢ùëä (ùëß ) ‚ä§ ‚àà R ùêø√óùëíùëë ùë• ùëê = conv1d(ùë•) ‚àà R ùêø√óùëíùëë (depthwise, independent along ùëë) Œî, ùêµ, ùê∂ = low-rank projection(ùë• ùëê ) ùë¶ = ùëÜùëÜùëÄ ùê¥,ùêµ,ùê∂,Œî (ùë• ùëê ) ‚àà R ùêø√óùëíùëë (independent along ùëë) ùë¶ ùëî = ùë¶ ‚Ä¢ ùúô (ùëß) (gating, e.g., with ùúô being SiLU) out = ùë¶ ùëî ùëä (ùëú ) ‚ä§ ‚àà R ùêø√óùëë .$With TP, suppose that we want to split the computation along 2 GPUs. It is easy to split the input projection matrices ùëä (ùë• ) and ùëä (ùëß ) into two partitions each of size ùëë √ó ùëíùëë 2 . Then each GPU would hold half of ùë• ùëê of size ùêø √ó ùëíùëë 2 . However, we see that since Œî, ùêµ, ùê∂ are functions are ùë• ùëê , so we would need an extra all-reduce between the GPUs to get the whole of ùë• ùëê before computing Œî, ùêµ, ùê∂. After that the two GPUs can compute the SSM in parallel since they are independent along ùëë. At the end, we can split the output projection matrices ùëä (ùëú ) into two partitions each of size ùëíùëë 2 √ó ùëë, and do an all-reduce at the end. Compared to Transformers, we would incur two all-reduces instead of one, doubling the time spent in communication. For large-scale Transformers training, communication might already take a significant fraction of time (e.g. 10-20%), and doubling communication would make Mamba not as efficient for large-scale training.

With Mamba-2, our goal is to have only one all-reduce per block, similar to attention or MLP blocks in Transformers. As a result, we have the projection to get Œî, ùêµ, ùê∂ directly from ùë¢ instead of from ùë• ùëê , allowing us to split these projection matrices. This implies that we have different sets of Œî, ùêµ, ùê∂ on different GPUs, which is equivalent to having several "groups" of Œî, ùêµ, ùê∂ on a larger "logical GPU". Moreover, we use GroupNorm within each block, with number of groups divisible by the TP degree, so that the GPUs in a TP group do not have a communicate within the block:

$ùë• = ùë¢ùëä (ùë• ) ‚ä§ ‚àà R ùêø√óùëíùëë ùëß = ùë¢ùëä (ùëß ) ‚ä§ ‚àà R ùêø√óùëíùëë Œî, ùêµ, ùê∂ = projection(ùë¢) (one or more groups of Œî, ùêµ, ùê∂ per GPU) ùë• ùëê = conv1d(ùë•) ‚àà R ùêø√óùëíùëë (depthwise, independent along ùëë) ùë¶ = ùëÜùëÜùëÄ ùê¥,ùêµ,ùê∂,Œî (ùë• ùëê ) ‚àà R ùêø√óùëíùëë (independent along ùëë)$ùë¶ ùëî = ùë¶ ‚Ä¢ ùúô (ùëß) (gating, e.g., with ùúô being SiLU) ùë¶ ùëõ = groupnorm(ùë¶ ùëî ) (number of groups divisible by degree of tensor parallel)

$out = ùë¶ ùëî ùëä (ùëú ) ‚ä§ ‚àà R ùêø√óùëë .$We see that we only need to split the input projection matrices, and the output projection matrices, and only need to do all-reduce at the end of the block. This is similar to the design of TP for attention and MLP layers. In particular, if we have TP degree 2, we would split ùëä (ùë• ) = [ùëä (ùë• )  1 ,ùëä (ùë• ) 2 ] with ùëä (ùë• )

$ùëñ ‚àà R ùëë √óùëíùëë/2 , ùëä (ùëß ) = [ùëä (ùëß ) 1 ,ùëä (ùëß ) 2 ] with ùëä (ùëß ) ùëñ ‚àà R ùëë √óùëíùëë/2 , B C X A GN Y B C X A GN Y Layer Input & ! (#) & ! (%) & & (#) & & (%) & ! (') & & (') All-reduce ! Inputs " Outputs # States GPU1 GPU2 GPU3$Figure [7](#): (Parallelism with the Mamba-2 Block.) (Left: Tensor Parallelism) We split the input projection matrices ùëä (ùë• ) ,ùëä (ùëß ) and the output projection matrix ùëä (ùëú ) . Each SSM head (ùê¥, ùêµ, ùê∂, ùëã ) ‚Ü¶ ‚Üí ùëå lives on a single device. Choosing GroupNorm for the final normalization layer avoids extra communication. We need one all-reduce per layer, just like the MLP or attention blocks in a Transformer. (Right: Sequence/Context Parallelism) Analogous to the SSD algorithm, with multiple devices, we can split along the sequence dimension. Each device computes the state of its sequence, then pass that state to the next GPU.

and

$ùëä (ùëú ) = ùëä (ùëú ) 1 ùëä (ùëú ) 2 with ùëä (ùëú ) ùëñ ‚àà R ùëíùëë/2√óùëë$. For ùëñ = 1, 2, the TP Mamba-2 layer can be written as:

$ùë• (ùëñ ) = ùë¢ùëä (ùë• ) ùëñ ‚ä§ ‚àà R ùêø√óùëíùëë/2 ùëß (ùëñ ) = ùë¢ùëä (ùëß ) ùëñ ‚ä§ ‚àà R ùêø√óùëíùëë/2$Œî (ùëñ ) , ùêµ (ùëñ ) , ùê∂ (ùëñ ) = projection(ùë¢) (one or more groups of Œî, ùêµ, ùê∂ per GPU)

$ùë• (ùëñ ) ùëê = conv1d(ùë• (ùëñ ) ) ‚àà R ùêø√óùëíùëë/2 ùë¶ (ùëñ ) = ùëÜùëÜùëÄ ùê¥,ùêµ,ùê∂,Œî (ùë• (ùëñ ) ùëê ) ‚àà R ùêø√óùëíùëë/2 ùë¶ (ùëñ ) ùëî = ùë¶ (ùëñ ) ‚Ä¢ ùúô (ùëß (ùëñ ) ) ùë¶ (ùëñ ) ùëõ = groupnorm(ùë¶ (ùëñ )$ùëî ) (number of groups divisible by degree of tensor parallel) ùëñ ) . (summing outputs from all GPUs with an all-reduce)

$out (ùëñ ) = ùë¶ (ùëñ ) ùëî ùëä (ùëú ) ùëñ ‚ä§ ‚àà R ùêø√óùëë/2 out = ‚àëÔ∏Å ùëñ out($We illustrate tensor parallel with Mamba-2 in Figure [7](#) (Left).

## Sequence Parallelism

For very long sequences, we might need to split the input and activation to different GPUs along the sequence length dimension. There are two main techniques:

1. Sequence parallelism (SP) for the residual and normalization operations: first proposed by Korthikanti et al. ( [2023](#)), this technique decomposes the all-reduce in TP as reduce-scatter and all-gather. Noticing that the residual and normalization operations are repeated on the same input for all GPUs in the same TP group, SP splits the activations along the sequence length dimension by performing: reduce-scatter, residual and normalization, then all-gather.

Since the Mamba-2 architecture uses the same residual and normalization structure, SP applies without modification.

2. Sequence parallelism for the token-mixing operations (attention or SSM), also known as "context parallelism" (CP).

Several techniques have been developed for attention layer (e.g., Ring attention (Liu, Yan, et al. 2024; Liu, Zaharia, 32 64 128 256 Model dimension 0.00 0.25 0.50 0.75 1.00 Accuracy Sequence Length: 256 32 64 128 256 Model dimension Sequence Length: 512 32 64 128 256 Model dimension Sequence Length: 1024 Attention Based Mamba (N=16) Mamba-2 (N=16) Mamba-2 (N=64) Mamba-2 (N=256) Figure 8: (Multi-Query Associative Recall (MQAR)). Associative recall tasks are challenging for SSMs, which must memorize all relevant information into their recurrent state. The SSD layer combined with improved architecture allows for much larger state sizes in Mamba-2, which performs significantly better than Mamba-1 and even vanilla attention. and Abbeel 2023)), with sophisticated load-balancing technique (Brandon et al. 2023). The difficulty with sequence parallelism in attention is that we can split queries and keys into block, but each query block needs to interact with key blocks, leading to communication bandwidth quadratic in the number of workers.

With SSMs, we can split the sequence in a simple manner: each worker takes an initial state, compute the SSM with respect to their inputs, return the final state, and pass that final state to the next worker. The communication bandwidth is linear in the number of workers. This decomposition is exactly the same as the block-decomposition in the SSD algorithm (Figure [5](#)) to split into blocks / chunks. We illustrate this context parallelism in Figure [7](#) (Right).

## Variable Length

While pretraining often uses the same sequence lengths for the batch, during finetuning or inference, the model might need to process different input sequences of different lengths. One naive way to handle this case is to right-pad all sequences in the batch to the maximum length, but this can be inefficient if sequences are wildly different lengths. With SSMs and Mamba in particular, we can handle variable sequence lengths by simply treating the whole batch as one long sequence, and avoid passing the states between individual sequences. This is equivalent to simply setting ùê¥ ùë° = 0 for tokens ùë° at the end of one sequence to prevent it from passing information to the token ùë° + 1, which belongs to a different sequence.

## Empirical Validation

We empirically evaluate Mamba-2 on synthetic recall tasks that have been challenging for recurrent models (Section 9.1), and standard language modeling pre-training and downstream evaluations (Section 9.2). We validate that our SSD algorithm is much more efficient than Mamba-1 (Section 9.3) and comparable to optimized attention for moderate sequence lengths. Finally, we ablate various design choices in the Mamba-2 architecture (Section 9.4).

## Synthetics: Associative Recall

Synthetic associative recall tasks have been popular for testing the ability of language models to look up information in their context. Broadly, they involve feeding autoregressive models pairs of key-value associations, and then prompting the model to produce the correct completion upon being shown a previously-seen key. The multi-query associative recall (MQAR) task is a particular formulation of this task that requires the model to memorize multiple associations [(Arora, Eyuboglu, Timalsina, et al. 2024](#)). The original Mamba paper reported results on related synthetic tasks, in particular Selective Copying [(Gu and Dao 2023](#b40)) and Induction Heads [(Olsson et al. 2022](#b67)), which can be seen as easier associative recall tasks. The MQAR task is also closely related to "phonebook look-up" tasks which has been shown to be challenging for recurrent models such as SSMs, due to their finite state capacity [(De et](#)   We compare on a challenging version of the MQAR setup from (Arora, Eyuboglu, Zhang, et al. 2024), using a harder task, longer sequences, and smaller models. Our baselines include standard multi-head softmax attention as well as the Based architecture which combines convolutions, local attention, and a linear attention variant.

Results are shown in Figure [8](#). While Mamba-1 struggles on this task, Mamba-2 performs well across all settings. Surprisingly, it is significantly better than Mamba-1 even when the state sizes are controlled (N = 16). (We are not sure which aspect of the architecture is the predominant factor, which remains a question to explore in future work.) Additionally, this task validates the importance of state size: increasing from N = 16 to N = 64 and N = 256 consistently improves performance on MQAR, as the larger state allows more information (key-value pairs) to be memorized.

## Language Modeling

Following standard protocols in LLMs, we train and evaluate the Mamba-2 architecture on standard autoregressive language modeling against other architectures. We compare both pretraining metrics (perplexity) and zero-shot evaluations.

The model sizes (depth and width) follow GPT3 specifications, from 125m to 2.7B. We use the Pile dataset (L. Gao, Biderman, et al. 2020), and follow the training recipe described in [Brown et al. (2020)](#b18). This follows the same setup as reported in Mamba (Gu and Dao 2023); training details are in Appendix D.

## Scaling Laws

For baselines, we compare against both Mamba and its Transformer++ recipe (Gu and Dao 2023), which is based on the PaLM and LLaMa architectures (e.g. rotary embedding, SwiGLU MLP, RMSNorm instead of LayerNorm, no linear bias, and higher learning rates). As Mamba has already demonstrated that it outperforms the standard Transformer architecture ( Figure [9](#) shows scaling laws under the standard Chinchilla [(Hoffmann et al. 2022](#b50)) protocol, on models from ‚âà 125ùëÄ to ‚âà 1.3ùêµ parameters.

## Downstream Evaluations

Table [1](#tab_9) shows the performance of Mamba-2 on a range of popular downstream zero-shot evaluation tasks, compared to the most well-known open source models at these sizes, most importantly Pythia [(Biderman et al. 2023](#)) which were trained with the same tokenizer, dataset, and training length (300B tokens) as our models. ) suggests that a hybrid architecture with both SSM layers and attention layers could improve the model quality over that of a Transformer, or a pure SSM (e.g., Mamba) model, especially for in-context learning. We explore the different ways that SSD layers can be combined with attention and MLP to understand the benefits of each. Empirically we find that having around 10% of the total number of layers being attention performs best. Combining SSD layers, attention layers, and MLP also works better than either pure Transformer++ or Mamba-2.

## SSD and Attention

We find that SSD and attention layers are complementary: by themselves (e.g. in the Mamba-2 architecture vs. Transformer++) their performance (measured by perplexity) is nearly the same, but a mixture of SSD and attention layers outperforms the pure Mamba-2 or Transformer++ architecture. We show some results (Table [2](#tab_10)) for the 350M model (48 layers) trained to 7B tokens on the Pile with the GPT-2 tokenizer (same number of parameters, same hyperparameters, same training and validation set). Adding in just a few attention layers already yields notable improvement and strikes the best balance between quality and efficiency. We hypothesize that the SSM layers function well as a general sequence-to-sequence mapping, and attention layers act as a retrieval mechanism to quickly refer to previous tokens in the sequence instead of forcing the model to compress all the context to its memory (SSM states). Hybrid Models with SSD, MLP, and Attention We compare different ways that SSD can be combined with the (gated) MLP and attention layers, and evaluate at the 2.7B scale (64 layers), trained to 300B tokens on the Pile (same number of parameters, same hyperparameters, same training and validation set, same data order):

1. Transformer++: 32 attention layers and 32 gated MLP, interleaving.

2. Mamba-2: 64 SSD layers.

3. Mamba-2-MLP: 32 SSD and 32 gated MLP layers, interleaving.

4. Mamba-2-Attention: 58 SSD layers and 6 attention layers (at indices 9, 18, 27, 36, 45, 56)[foot_7](#foot_7) .

5. Mamba-2-MLP-Attention: 28 SSD layers and 4 attention layers, interleaving with 32 gated MLP layers.

We report the validation perplexity on the Pile, as well as zero-shot evaluation, in Table [3](#tab_11). In general, the quality of Transformer++ and Mamba-2 models are around the same. We see that adding just 6 attention layers noticeably improves over the pure Mamba-2 model (and over Transformer++). Adding MLP layers reduces model quality, but can (i) speed up training and inference due to the simplicity and hardware-efficiency of the MLP layer (ii) be easier to up-cycle to MoE models by replacing MLP layers with mixture-of-experts. 

## Speed Benchmarks

We benchmark the speed of the SSD algorithm against Mamba's scan implementation and FlashAttention-2 (Figure [10](#fig_8)). SSD, thanks to its reformulation to use matrix multiplication as a subroutine, can exploit specialized matrix multiplication (matmul) units on GPUs, also known as tensor cores. As a result, it is 2-8√ó faster than Mamba's fused associative scan, which does not leverage matmul units. Due to its linear scaling in sequence length, SSD is faster than FlashAttention-2 starting at sequence length 2ùêæ.

However, we note that the Mamba-2 model as a whole might not be as efficient to train as Transformer at short sequence length (e.g. at 2ùêæ), since a Transformer with ùêø layers would have ùêø 2 MLP layers and ùêø 2 attention layers, while a Mamba-2 model would have ùêø SSD layers for the same number of parameters. Generally the MLP layers are very hardware efficient since they consist of simple matrix multiplication and pointwise linearity. As shown in Section 9.2.3, one can also combine  Section 7.1 introduces the Mamba-2 block, which has small modifications to the Mamba-1 block which are partly motivated by the connection to attention and also to improve the scalability of Mamba-2. Table [4](#tab_12) ablates these architecture changes to the block, which occur outside of the core SSM layer.

The ablations validate that parallel projections to create (ùê¥, ùêµ, ùê∂, ùëã ) saves parameters and performs slightly better than Mamba's sequential projections. More importantly, this modification is amenable to tensor parallelism at larger model sizes (Section 8). Additionally, the extra normalization layer also slightly improves performance. More importantly, preliminary experiments at larger scales observed that it also helps with training stability.

## Head Structure

Section 7.2 describes how the dimensions of the ùêµ, ùê∂, ùëã projections can be viewed as a hyperparameter analogous to notions of multi-head attention and multi-query attention. We also showed how the original Mamba architecture is analogous to multi-value attention (Proposition 7.2), which was a choice that naturally developed from the state-space model point of view and was not previously ablated.

Table [5](#tab_15) ablates choices of the multi-head structure for the Mamba-2 architecture. Strikingly, we find a large difference between multi-value and multi-query or multi-key head patterns, despite seeming very similar. Note that this is not explained by the total state size, which is the same for all of them (equal to HPN or the product of the number of heads, head dimension, and state dimension).

We also compare to multi-head patterns where the number of ùê∂, ùêµ, ùëã (analogous to ùëÑ, ùêæ, ùëâ ) heads is equal. We compare against the standard multi-head pattern, as well as one with aggressive sharing where they all have only 1 head. Note that in the latter case, the model still has H different sequence mixers ùëÄ, because each head still has a different ùê¥. When parameter matched, these multi-head patterns perform similarly to each other, in between the MVA and MQA/MKA patterns.

## Attention Kernel Approximations

Section 7.3 noted how SSD can be combined with ideas from the linear attention literature, such as various forms of kernel approximations. We ablate several variants of these suggested by previous works in Table [6](#tab_16). These include the cosFormer (Qin, Weixuan Sun, et al. 2022), Random Feature Attention H. Peng et al. 2021, and Positive Random Features (Performer) (Choromanski et al. 2021).

We also ablate adding a normalization term, akin to the denominator of the softmax function in standard attention. We found that this introduced instabilities to most variants, but slightly improved performance for the ReLU activation function ùúì .

Table 7 also tests more recent proposals to improve linear attention that involve expanding the feature dimension (Based (Arora, Eyuboglu, Zhang, et al. 2024) and ReBased (Aksenov et al. 2024)

). These linear attention extensions aim to appropriate the exp kernel with a quadratic approximation. ReBased also proposes to replace the QK activation function with a layer normalization; from an SSM-centric view we apply a normalization on top of (ùêµ, ùê∂) before applying the SSM function. We note that this technique has been independently proposed as the "QK-Norm" for softmax attention [(Team 2024](#b97)) and an "internal normalization" for Mamba [(Lieber et al. 2024](#b60)).

Overall, Table [6](#tab_16) and Table [7](#tab_17) found that the kernel approximation methods we tried did not seem to improve over simple pointwise non-linear activation functions for ùúì . Thus our default settings for Mamba-2 used ùúì (ùë•) = Swish(ùë•) to follow Mamba-1, but we suggest that removing this activation entirely may be a simpler choice that we did not extensively test.

We emphasize however that SSD and vanilla linear attention differ in the inclusion of the 1-semiseparable mask ùêø, while the various linear attention methods in the literature were derived to approximate softmax attention without this term; thus, our negative results may be not unexpected.

## Related Work and Discussion

The state space duality framework bridges connections between SSMs, structured matrices, and attention. We discuss in more depth the relations between SSD and these concepts more broadly. Using ideas from each of the viewpoints, we also suggest some directions that the SSD framework can be extended in future work.

## State Space Models

Structured state space models can be characterized along the axes (i) whether it is time-invariant or time-varying.

(ii) the dimensionality of the system.

(iii) the structure on the recurrent transitions ùê¥.

SSD can be described as a selective SSM with SISO dimensions and scalar-identity structure. Dimensionality and State Expansion. An important characteristic of SSD, shared by previous SSMs in its lineage (S4, H3, Mamba), is that it is a single-input single-output (SISO) system where input channels are processed independently. This leads to a much larger effective state size of ND where N is the SSM state size (also called state expansion factor) and D is the standard model dimension. Traditional RNNs either have N = 1 or are multi-input multi-output (MIMO) with dense ùêµ, ùê∂ matrices, either of which leads to a smaller state. While MIMO SSMs have been shown to work well in some domains [(Lu et al. 2023;](#b63)[Orvieto et al. 2023](#b68); J. T. Smith, Warrington, and Linderman 2023), Mamba showed that state expansion is crucial for information-dense domains such as language. One of the main advantages of SSD is allowing for even larger state expansion factors without slowing down the model. Many subsequent works have since adopted state expansion (Section 10.4).

Structure. Compared to previous structured SSMs, the main restriction of SSD is on the expressivity of the state transitions ùê¥ ùë° . We note that more general SSMs, such as the case of diagonal ùê¥ ùë° , have the same theoretical efficiency as SSD, but are less hardware-friendly. This is because the dual quadratic form loses its attention-like interpretation and becomes more difficult to compute. Thus compared to Mamba, SSD differs only in a slightly more restrictive form of diagonal ùê¥ ùë° , and trades off this expressivity for improved hardware efficiency (and ease of implementation).

We hypothesize that it may be possible to refine our structured matrix algorithms to improve to the general diagonal SSM case as well.

## Structured Matrices

The first viewpoint of the state space duality adopts the viewpoint of these models as matrix sequence transformations or "matrix mixers": sequence transformations (Definition 2.1) that can be represented as matrix multiplication (by a T √ó T matrix) along the sequence dimension T.

Several such matrix mixers have been proposed before, where the primary axis of variation is the representation of the matrix. These An important characterization is that efficient (sub-quadratic) matrix sequence transformations are exactly those which have structured matrix mixers. A core result of the SSD framework is viewing SSMs as matrix mixers with a particular structure -semiseparable matrices (Section 3). The linear vs. quadratic duality then takes the form of structured matrix multiplication vs. naive matrix multiplication.

The structure matrix representation led to our efficient SSD algorithm through block decompositions of particular semiseparable matrices (Section 6). We note that semiseparable matrices are well-studied in the scientific computing literature, and incorporating those ideas may be a promising avenue for more improvements to state space models. We also suggest that focusing on the matrix mixer viewpoint can lead to more fruitful directions for sequence models, such as designing principled non-causal variants of Mamba, or finding ways to characterize and bridge the gap between softmax attention and sub-quadratic models through analyzing their matrix transformation structure.

## (Linear) Attention

Compared to standard (causal) attention, SSD has only two main differences. Second, SSD multiplies the logits matrix by an input-dependent 1-semiseparable mask. Thus this mask can be viewed as replacing the softmax in standard attention. This semiseparable mask can also be viewed as providing positional information. The elements ùëé ùë° act as "gates" in the RNN sense, or a "selection" mechanism (see discussion in Mamba paper), and their cumulative products ùëé ùëó:ùëñ control how much interaction is allowed between positions ùëñ and ùëó. Positional embeddings (e.g. sinusoidal [(Vaswani et al. 2017](#b103)), AliBi (Press, N. Smith, and Lewis 2022), and RoPE [(Su et al. 2021](#b94))) are an important component of Transformers that are often viewed as heuristics, and the 1-SS mask of SSD can be seen as a more principled form of relative positional embeddings. We note that this view was also posited concurrently by GateLoop [(Katsch 2023](#b53)).

The second viewpoint of state space duality is a special case of our more general structured masked attention (SMA) framework, where the duality is revealed as different contraction orderings on a simple 4-way tensor contraction. SMA is a strong generalization of linear attention that is much more general than SSD as well; other forms of structured masks may lead to more variants of efficient attention with different properties than SSD.

Beside leading to new models, these connections to attention can lead to other directions for understanding SSMs. For example, we are curious whether the phenomenon of attention sinks [(Darcet et](#) al. 2024; Xiao et al. 2024) exist for Mamba models, and more broadly whether interpretability techniques can be transferred to SSMs (Ali, Zimerman, and Wolf 2024). Finally, many other variants of linear attention have been proposed (Arora, Eyuboglu, Timalsina, et al. 2024; Arora, Eyuboglu, Zhang, et al. 2024; Choromanski et al. 2021; H. Peng et al. 2021; Qin, Han, Weixuan Sun, Dongxu Li, et al. 2022; Qin, Weixuan Sun, et al. 2022; Schlag, Irie, and Schmidhuber 2021; Zhang et al. 2024; Zheng, C. Wang, and Kong 2022) (see Section 4.1.3 for descriptions of several of these), and we expect that many techniques can be transferred to SSMs (e.g. Section 7.3).

We emphasize that SSD does not generalize standard softmax attention, or any other transformation on the attention kernel matrix that does not have a finite feature map ùúì . Compared to general attention, SSD's advantage is having a controllable state expansion factor N that compresses the history, compared to quadratic attention's cache of the entire history scaling with sequence length T ‚â´ N. Concurrent work has starting studying the tradeoffs of these representations, for example on copying and in-context learning tasks [(Aky√ºrek et al. 2024;](#b2)[Grazzi et al. 2024;](#b38)[Jelassi et al. 2024;](#b51)[Park et al. 2024)](#b70). We note that Mamba-2 significantly improves on Mamba on some of these capabilities (e.g. as demonstrated by MQAR results in Section 9.1), but more remains to be understood.

## Related Models

We finally highlight a growing body of recent and concurrent work that have developed sequence models very similar to Mamba and Mamba-2.

‚Ä¢ RetNet (Y. [Sun et al. 2023](#b95)) and TransNormerLLM [(Qin, Dong Li, et al. 2023](#)) generalize Linear Attention using decay terms instead of a cumulative sum, and propose dual parallel/recurrent algorithms as well as a hybrid "chunkwise" mode. These algorithms can be seen as an instantiation of SSD where ùê¥ ùë° is time-invariant (constant for all ùë°); in the SMA interpretation, the mask matrix ùêø would be a decay matrix ùêø ùëñ,ùëó = ùõæ ùëñ -ùëó . These models also differ architecturally in various ways. For example, since they were derived from an attention-centric perspective they preserve the multi-head attention (MHA) pattern; since Mamba-2 was derived from an SSM-centric pattern it preserves the multi-value attention (MVA) or multi-expand SSM (MES) pattern, which we show to be better (Section 9.4).

‚Ä¢ GateLoop (Katsch 2023) concurrently proposed using input-dependent decay factors ùê¥ ùë° , and developed the same dual quadratic form as in SSD which they call a "surrogate attention" form.

‚Ä¢ Gated Linear Attention (GLA) [(Yang et al. 2024](#b108)) proposed a variant of linear attention with data-dependent gates, along with efficient algorithms to compute a chunkwise mode and hardware-aware implementations.

‚Ä¢ HGRN [(Qin, Yang, and](#) Zhong 2023) introduced an RNN with input-dependent gates, which was improved to incorporate state expansion in HGRN2 (Qin, Yang, Weixuan Sun, et al. 2024). ‚Ä¢ Griffin (De et al. 2024) and RecurrentGemma (Botev et al. 2024) showed that an RNN with input-dependent gating, combined with local attention, can be very competitive with strong modern Transformers. Jamba also showed that combining Mamba with a few layers of attention performs very well on language modeling (Lieber et al. 2024). ‚Ä¢ xLSTM (Beck et al. 2024) improves the xLSTM by adopting the idea of state expansion and other gating, normalization, and stabilization techniques. ‚Ä¢ RWKV(-4) (B. Peng, Alcaide, et al. 2023) is an RNN based on a different linear attention approximation (the attention-free Transformer (S. Zhai et al. 2021)). It has recently been improved to the RWKV-5/6 (Eagle and Finch) architectures (B. Peng, Goldstein, et al. 2024) by adopting the ideas of selectivity and state expansion.

## Conclusion

We proposed a theoretical framework based on well-studied classes of structured matrices that bridges the conceptual gap between SSMs and attention variants. This framework yields insights on how recent SSMs (e.g. Mamba) perform as well as Transformers on language modeling. Moreover, our theoretical tools provide new ideas to improve SSMs (and potentially Transformers) by connecting the algorithmic and systems advances on both sides. As a demonstration, the framework guides our design of a new architecture (Mamba-2) at the intersection of SSMs and structured attention. In this section we flesh out various algorithms for computing the scalar SSM scan, through the lens of structured matrix decompositions. The scalar SSM scan is defined as computing the recurrent part of the discrete SSM [(7)](#b6), in the case when ùëÅ = 1 (i.e. ùê¥ is a scalar). This is commonly used to compute SSMs recurrently; in particular, the case of structured SSMs where ùê¥ is diagonally structured reduces down to this operation, such as in the S5 (J. T. Smith, Warrington, and Linderman 2023) and S6 (Gu and Dao 2023) models.

## A Glossary

The goal of this section is to support a central theme of this paper that efficient algorithms for sequence models can be viewed as structured matrix multiplication algorithms. The various matrix decomposition ideas we show here are related to ideas used to derive fast SSM algorithms (Section 6), as well as directly used as a subroutine.

## B.1 Problem Definition

Let ùëé : (D, ) and ùëè : (D, ) be sequences of scalars. The scalar SSM scan is defined as

$‚Ñé ùë° = ùëé ùë° ‚Ñé ùë° -1 + ùëè ùë° .(21)$Here ‚Ñé -1 can be an arbitrary value representing the previous hidden state to the SSM recurrence; unless otherwise specified, we assume ‚Ñé -1 = 0.

We also call equation [(21)](#b21) the cumprodsum (cumulative product sum). Note that the cumprodsum reduces to the cumprod (cumulative product) when ùëè = 0 is the additive identity and it reduces to the cumsum (cumulative sum) when ùëé = 1 is the multiplicative identity.

Finally, note that in vectorized form we can write

$‚Ñé = ùëÄùëè ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 ùëé 1 1 ùëé 2 ùëé 1 ùëé 2 1 . . . . . . . . . . . . ùëé ùëá -1 . . . ùëé 1 ùëé ùëá -1 . . . ùëé 2 . . . ùëé ùëá -1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª$In other words, this is simply the matrix-vector product by a 1-SS matrix ùëÄ.

Therefore we have three ways of viewing this fundamental primitive operation that are all equivalent:

‚Ä¢ A (scalar) SSM scan.

‚Ä¢ A cumprodsum.

‚Ä¢ A 1-SS matrix-vector multiplication .

## B.2 Classical Algorithms

We first describe the two classical ways of computing the SSM scan [(21)](#b21), previously used by prior work.

## B.2.1 Sequential Recurrence

The recurrent mode simply computes [(21)](#b21) one timestep ùë° at a time. From the perspective of 1-SS multiplication, this was also described in Section 3.4.1.

## B.2.2 Parallel Associative Scan

Second, an important observation is that this recurrence can be turned into an associative scan (E. Martin and Cundy 2018; J. T. Smith, Warrington, and Linderman 2023). This fact is not completely obvious. For example, S5 defined the correct associative scan operator and then showed associativity of the operator through rote calculation.

A slightly cleaner way to see that this is computable with an associative scan is to turn the multi-term recurrence into a single-term recurrence on a hidden state of size 2 instead of 1:

$‚Ñé ùë° = ùëé ùë° ‚Ñé ùë° -1 + ùëè ùë° ‚Ñé ùë° 1 = ùëé ùë° ùëè ùë° 0 1 ‚Ñé ùë° -11$.

Then computing all the ‚Ñé ùë° is the same as taking the cumulative products of these 2 √ó 2 matrices. Since matrix multiplication is associative, this can be computed with an associative scan. The associative binary operator is simply matrix multiplication on these particular matrices:

$ùëé ùë° ùëè ùë° 0 1 ùëé ùë† ùëè ùë† 0 1 = ùëé ùë° ùëé ùë† ùëé ùë° ùëè ùë† + ùëè ùë° 0 1$.

Equating the top row yields the same associative scan operator as defined by S5:

$(ùëé ùë° , ùëè ùë° ) ‚äó (ùëé ùë† , ùëè ùë† ) = (ùëé ùë° ùëé ùë† , ùëé ùë° ùëè ùë† + ùëè ùë° ).(22)$The reason why associative scans are important is that they can be parallelized using a divide-and-conquer algorithm (Blelloch 1990). We omit the details of this algorithm, and instead show that the entire associative SSM scan algorithm can be derived from scratch through matrix decompositions (Appendix B.3.5).

## B.3 Efficient Algorithms via Structured Matrix Decompositions

We discuss several algorithms for computing the SSM scan, all through the lens of finding structured matrix decompositions of the 1-SS matrix ùëÄ. These algorithms or computation modes include

‚Ä¢ A dilated mode where information is propagated 1, 2, 4, 8, . . . steps at a time.

‚Ä¢ A state-passing mode where information is propagated forward in chunks.

‚Ä¢ A fully recurrent mode that increments one step at a time, which is a special case of the state-passing mode.

‚Ä¢ A block decomposition parallel mode where ùëÄ is divided into hierarchical blocks.

‚Ä¢ A scan mode where ùëÄ is divide into equal size blocks and reduced recursively.

## B.3.1 Dilated Mode

This mode factors the 1-SS matrix in a particular way involving increasing "strides". This is best illustrated through a concrete example:

$ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:0 ùëé 1:1 ùëé 2:0 ùëé 2:$1 ùëé 2:2 ùëé 3:0 ùëé 3:1 ùëé 3:2 ùëé 3:3 ùëé 4:0 ùëé 4:1 ùëé 4:2 ùëé 4:3 ùëé 4:4 ùëé 5:0 ùëé 5:1 ùëé 5:2 ùëé 5:3 ùëé 5:4 ùëé 5:5 ùëé 6:0 ùëé 6:1 ùëé 6:2 ùëé 6:3 ùëé 6:4 ùëé 6:5 ùëé 6:6 ùëé 7:0 ùëé 7:1 ùëé 7:2 ùëé 7:3 ùëé 7:4 ùëé 7:5 ùëé 7:6 ùëé 7:7

$Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:$1 ùëé 2:2 ùëé 3:3 ùëé 4:0 ùëé 4:4 ùëé 5:1 ùëé 5:5 ùëé 6:2 ùëé 6:6 ùëé 7:3 ùëé 7:7

$Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:1 ùëé 2:0 ùëé 2:2 ùëé 3:1 ùëé3$:3 ùëé 4:2 ùëé 4:4 ùëé 5:3 ùëé 5:5 ùëé 6:4 ùëé 6:6 ùëé 7:5 ùëé 7:7

$Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:0 ùëé 1:1 ùëé 2:$1 ùëé 2:2 ùëé 3:2 ùëé 3:3 ùëé 4:3 ùëé 4:4 ùëé 5:4 ùëé 5:5 ùëé 6:5 ùëé 6:6 ùëé 7:6 ùëé 7:7

$Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª$Note that this closely resembles the computation of dilated convolutions.

We also note that this factorization shows that 1-SS matrices are a special case of butterfly matrices, another broad and fundamental type of structured matrix [(Dao, Gu, et al. 2019;](#b26)[Dao, Sohoni, et al. 2020](#b27)).

Remark 8. This algoritihm is sometimes described as a "work-inefficient but more parallelizable" prefix sum algorithm (Hillis and Steele Jr 1986), becauses it uses ùëÇ (ùëá log(ùëá )) operations but has half the depth/span as the work-efficient associative scan algorithm.

## B.3.2 State-Passing (Chunkwise) Mode

This mode can be viewed as a generalization of the standard recurrent mode where instead of passing forward the recurrent state ‚Ñé one step at a time, we compute the answer on chunks of arbitrary length ùëò and pass the state through the chunk. This can also be derived from a simple block decomposition of the 1-SS matrix.

Remark 9. While we call this "state-passing" to refer to how states are passed from one local segment to another, this is related to the "chunkwise" algorithms proposed by related models (Y.

Sun et al. 2023; Yang et al. 2024). Consider computing ‚Ñé = ùëÄùëè in "chunks": for some index ùëò ‚àà [ùëá ], we want to compute ‚Ñé 0:ùëò or the output up to index ùëò, and have a way to reduce the problem to a smaller problem on indices [ùëò : ùëá ]. We write ùëÄ as ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:0 ùëé 1:1 . . . . . . ùëé ùëò -1:0 . . . . . . ùëé ùëò -1:ùëò -1 ùëé ùëò:0 . . . . . . ùëé ùëò:ùëò -1 ùëé ùëò:ùëò . . . . . . . . . . . . ùëé ùëá -1:0 . . . . . . ùëé ùëá -1:ùëò -1 ùëé ùëá -1:ùëò . . . ùëé ùëá -1:ùëá -1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Let the upper-left triangle be ùëÄ ùêø , lower-right be ùëÄ ùëÖ (left and right subproblems), and lower-left be ùëÄ ùê∂ . Divide up ùëè into ùëè ùêø = ùëè 0:ùëò and ùëè ùëÖ = ùëè ùëò:ùëá in the same way. Note that ùëÄùëè = ùëÄ ùêø ùëè ùêø ùëÄ ùëÖ ùëè ùëÖ + ùëÄ ùê∂ ùëè ùêø Also, ùëÄ ùê∂ has the rank-1 factorization (this is essentially the defining property of semiseparable matrices)

$ùëÄ ùê∂ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé ùëò:ùëò . . . ùëé ùëá -1:ùëò Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùëé ùëò ùëé ùëò -1:0 ‚Ä¢ ‚Ä¢ ‚Ä¢ ùëé ùëò -1:ùëò -1 Thus ùëÄ ùê∂ ùëè ùêø = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé ùëò:ùëò . . . ùëé ùëá -1:ùëò Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùëé ùëò ‚Ä¢ (ùëÄùëè) ùëò -1 .$Here we think of (ùëÄùëè) ùëò -1 = ‚Ñé ùëò -1 as the "final state" of the left chunk, because the row vector in ùëÄ ùê∂ 's factorization is the same as the final row of ùëÄ ùêø . Furthermore, note that the column vector in ùëÄ ùê∂ 's factorization is the same as the final column of ùëÄ ùëÖ . [7](#foot_8) Thus

$ùëÄ ùëÖ ùëè ùëÖ + ùëÄ ùê∂ ùëè ùêø = ùëÄ ùëÖ Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé ùëò ‚Ñé ùëò -1 + ùëè ùëò ùëè ùëò+1 . . . ùëè ùëá -1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª$Finally, we use the observation that ùëÄ ùêø and ùëÄ ùëÖ are self-similar to the original matrix ùëÄ; the answers for these two smaller 1-SS matrix multiplications can be performed arbitrarily using any algorithm. In total, the algorithm proceeds as follows:

1. Compute the left half of the answer ‚Ñé 0:ùëò using any desired method (i.e. any of the methods for 1-SS multiplication from this section).

2. Compute the final state ‚Ñé ùëò -1 .

3. Increment the state by one step to modify ùëè ùëò .

4. Compute the right half of the answer ‚Ñé ùëò:ùëá using any desired method.

In other words, we compute the left subproblem as a black box, pass its final state on to the right problem, and compute the right subproblem as a black box.

The utility of this method comes from more complicated settings, such as in the general ùëÅ -semiseparable case, and when the input ùëè has an additional "batch" dimension (or in other words this is a matrix-matrix instead of matrix-vector multiplication). In this case, we can use an alternate algorithm for the chunks (corresponding to MM by ùëÄ ùêø and ùëÄ ùëÖ ) that does not materialize the full hidden states ‚Ñé. Instead, we skip the hidden states and directly compute the final state ‚Ñé ùëò -1 in an alternate way, then "pass" the state to the next chunk.

Complexity. This method can be very work-efficient because steps 2-3 takes only constant time. Therefore assuming the two subproblems (steps 1 and 4) are linear time, the whole method takes linear time.

The downside is that this is also sequential.

## B.3.3 Fully Recurrent Mode

Note that the fully recurrent mode, where the recurrence is evolved one step at a time [(21)](#b21), is simply an instantiation of the state-passing mode with chunk size ùëò = 1.

## B.3.4 (Parallel) Block Decomposition Mode

This uses the same matrix decomposition as the state-passing mode, but computes subproblems in a different order that trades off computation for parallelization.

As usual, we write ùëÄ as

$ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 ùëé 1 1 ùëé 2 ùëé 1 ùëé 2 1 . . . . . . . . . . . . ùëé ùëá -1 . . . ùëé 1 ùëé ùëá -1 . . . ùëé 2 . . . ùëé ùëá -1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 -ùëé 1 1 0 -ùëé 2 1 . . . . . . . . . . . . 0 0 . . . -ùëé ùëá -1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª -1$The key observation is again that the bottom-left quadrant of ùëÄ is rank-1. Aside from inspection, another way to see this is by using the RHS, observing that the bottom-left quadrant of it is a trivial rank-1 matrix (it is all 0 except the top-right corner is -ùëé ùëá /2 ), and using the Woodbury inversion formula to see that the bottom-left corner of the LHS must also be rank 1. This also provides a way to deduce the rank-1 factorization, which can be verified through inspection:

$ùëÄ$lower-left-quadrant = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ (ùëé ùëá /2 . . . ùëé 1 ) . . . ùëé ùëá /2 . . . . . . . . . (ùëé ùëá -1 . . . ùëé ùëá /2 ùëé ùëá /2-1 . . . ùëé 1 ) . . . (ùëé ùëá -1 . . . ùëé ùëá /2 ) Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé ùëá /2 . . . ùëé ùëá -1 . . . ùëé ùëá /2 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª (ùëé ùëá /2-1 . . . ùëé 1 ) . . . ùëé ùëá /2-1 1 .

A second observation is that this matrix is self-similar: any principle submatrix has the same form. In particular, the top-left and bottom-right quadrants are both 1-SS matrices.

This provides an easy way to perform the matrix multiplication by ùëÄ: recurse on the two halves (i.e. top-left and bottomright) in parallel, and then account for the bottom-left submatrix. This "combination" step in the divide-and-conquer algorithm is easy since the submatrix is rank 1. This leads to a parallel algorithm.

Complexity. Like the state-passing algorithm, this method uses the same block decompositions of the rank-structured semiseparable matrices. The difference is that we recurse on both subproblems in parallel, while the state-passing algorithm handles the left and then right subproblems. This lowers the depth/span of the algorithm from linear to log(ùëá ). The tradeoff is that the combination step (accounting for the rank-1 bottom-left submatrix) requires linear instead of constant work, so the total work is ùëÇ (ùëá log(ùëá )) instead of linear.

Note also that in the recursion, we can stop at any time and compute the subproblems in any other way. This is a main idea behind the SSD algorithm (Section 6), where we switch to the dual quadratic attention formulation on small subproblems.

## B.3.5 Associative Scan Mode

The state passing (chunkwise) algorithm has linear work, but also involves sequential operations.

The block matrix reduction and dilated modes are parallelizable: they have log(ùëá ) depth/span. However, they do extra work (ùëÇ (ùëá log(ùëá )).

As noted in Appendix B.2.2, there is an algorithm that achieves both ùëÇ (logùëá ) depth and ùëÇ (ùëá ) work by leveraging the associative scan (also called prefix scan) algorithm [(Baker et al. 1996](#b8)). This algorithm is most easily seen from the SSM scan or cumprodsum view, and even then is not obvious: it requires separately deriving an associative operator [(22)](#b22), and then leveraging the parallel/associative/prefix scan algorithm as a black box [(Blelloch 1990](#b13)).

Here we show that it is actually possible to derive this parallel scan from leveraging a different matrix decomposition:

$ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø$Ô£∞ ùëé 0:0 ùëé 1:0 ùëé 1:1 ùëé 2:0 ùëé 2:1 ùëé 2:2 ùëé 3:0 ùëé 3:1 ùëé 3:2 ùëé 3:3 ùëé 4:0 ùëé 4:1 ùëé 4:2 ùëé 4:3 ùëé 4:4 ùëé 5:0 ùëé 5:1 ùëé 5:2 ùëé 5:3 ùëé 5:4 ùëé 5:5 ùëé 6:0 ùëé 6:1 ùëé 6:2 ùëé 6:3 ùëé 6:4 ùëé 6:5 ùëé 6:6 ùëé 7:0 ùëé 7:1 ùëé 7:2 ùëé 7:3 ùëé 7:4 ùëé 7:5 ùëé 7:6 ùëé 7:7 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:0 ùëé 1:1 ùëé 2:2 ùëé 3:2 ùëé 3:3 ùëé 4:4 ùëé 5:4 ùëé 5:5 ùëé 6:6 ùëé 7:6 ùëé 7:7 ùëé 2:2 ùëé 3:2 ùëé 2:1 ùëé 1:0 ùëé 1:1 ‚ä§ ùëé 4:4 ùëé 5:4 ùëé 4:1 ùëé 1:0 ùëé 1:1 ‚ä§ ùëé 4:4 ùëé 5:4 ùëé 4:3 ùëé 3:2 ùëé 3:3 ‚ä§ ùëé 6:6 ùëé 7:6 ùëé 6:1 ùëé 1:0 ùëé 1:1 ‚ä§ ùëé 6:6 ùëé 7:6 ùëé 6:3 ùëé 3:2 ùëé 3:3 ‚ä§ ùëé 6:6 ùëé 7:6 ùëé 6:1 ùëé 5:4 ùëé 5:5

$‚ä§ Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª$Now we proceed in three stages.

Stage 1. First we compute the answers for each of the diagonal blocks in the multiplication ùëÄùëè. This produces two numbers, but the first element is unchanged. For example, the second block is going to compute ùëè 2 and ùëé 3 ùëè 2 + ùëè 3 Note that this can be slightly modified with some off-by-one shifting of the indices. An equivalent way to view this algorithm is as the three-step matrix factorization

ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:0 ùëé 1:1 ùëé 2:0 ùëé 2:1 ùëé 2:2 ùëé 3:0 ùëé 3:1 ùëé 3:2 ùëé 3:3 ùëé 4:0 ùëé 4:1 ùëé 4:2 ùëé 4:3 ùëé 4:4 ùëé 5:0 ùëé 5:1 ùëé 5:2 ùëé 5:3 ùëé 5:4 ùëé 5:5 ùëé 6:0 ùëé 6:1 ùëé 6:2 ùëé 6:3 ùëé 6:4 ùëé 6:5 ùëé 6:6 ùëé 7:0 ùëé 7:1 ùëé 7:2 ùëé 7:3 ùëé 7:4 ùëé 7:5 ùëé 7:6 ùëé 7:7 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:1 ùëé 2:1 ùëé 2:2 ùëé 3:3 ùëé 4:3 ùëé 4:4 ùëé 5:5 ùëé 6:5 ùëé 6:6 ùëé 7:7 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:1 ùëé 2:2 ùëé 3:1 ùëé 3:3 ùëé 4:4 ùëé 5:1 ùëé 5:3 ùëé 5:5 ùëé 6:6 ùëé 7:1 ùëé 7:3 ùëé 7:5 ùëé 7:7 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùëé 0:0 ùëé 1:0 ùëé 1:1 ùëé 2:2 ùëé 3:2 ùëé 3:3 ùëé 4:4 ùëé 5:4 ùëé 5:5 ùëé 6:6 ùëé 7:6 ùëé 7:7 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Note that Stage 1 and Stage 3 require ùëÇ (ùëá ) work, while Stage 2 reduces to a self-similar problem of half the size. It is easy to check that this requires ùëÇ (ùëá ) total work and ùëÇ (logùëá ) depth/span.

Remark 10. In fact, it is possible to see that the computation graph of this algorithm is identical to that of the associative scan algorithm described in Appendix B.2.2. The key takeaway is that instead of the steps of (1) recognizing that ùëÄ defines a recurrence (2) observing that the recurrence can be defined with an associative binary operator; there is a completely different perspective of simply finding a structured matrix decomposition algorithm for ùëÄ.

## C Theory Details C.1 Extras: Closure Properties of SSMs

We present here some additional properties of semiseparable matrices to illustrate their flexibility and utility. This section is not necessary to understand our core results.

Proposition C.1 (Semiseparable Closure Properties). Semiseparable matrices are closed under several primitive operations.

‚Ä¢ Addition: The sum of an ùëÅ -SS and ùëÉ-SS matrix is at most (ùëÅ + ùëÉ)-SS.

‚Ä¢ Multiplication: The product of an ùëÅ -SS and ùëÉ-SS matrix is (ùëÅ + ùëÉ)-SS.

‚Ä¢ Inverse: The inverse of an ùëÅ -SS matrix is at most (ùëÅ + 1)-SS.

The addition and multiplication properties are easily seen. The inverse property has many proofs; one approach follows immediately from the Woodbury inversion identity, which has also featured prominently in the structured SSM literature (Gu, Goel, and R√© 2022).

In turn, these imply closure properties of state space models.

For example, the addition property says that summing two parallel SSM models is still an SSM. The multiplication property says that sequentially composing or chaining two SSMs can still be viewed as an SSM, whose total state size is additive-a somewhat nontrivial fact.

Finally, the inverse property can let us relate SSMs to other types of models. For example, one can notice that banded matrices are semiseparable, so their inverses are semiseparable. (In fact, the semiseparable family of structure is often motivated by taking inverses of banded matrices [(Vandebril et al. 2005)](#b102)). Moreover, the fast recurrence properties of semiseparable matrices can be viewed as a consequence of their inverse being banded.

Remark 11. The fact that 1-SS matrices are simple recurrences [(7)](#b6) are equivalent to the fact that the inverse of a 1-SS matrix is a 2-banded matrix:

$ùëÄ = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 ùëé$1 1 ùëé 2 ùëé 1 ùëé 2 1 . . . . . . . . . . . . ùëé ùëá -1 . . . ùëé 1 ùëé ùëá -1 . . . ùëé 2 . . . ùëé ùëá -1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 -ùëé 1 1 0 -ùëé 2 1 . . . . . . . . . . . . 0 0 . . . -ùëé ùëá -1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª -1 Thus ùë¶ = ùëÄùë• ‚Üî ùëÄ -1 ùë¶ = ùë•, or Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 -ùëé 1 1 0 -ùëé 2 1 . . . . . . . . . . . . 0 0 . . . -ùëé ùëá -1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª ùë¶ = ùë• . Or elementwise, ùë¶ ùë° -ùëé ùë° ùë¶ ùë° -1 = ùë• ùë° ùë¶ ùë° = ùëé ùë° ùë¶ ùë° -1 + ùë• ùë° .

Conversely, we also use these closure results to prove that autoregressive structured attention (under certain assumptions) must be SSMs, allowing us to show that more general families of efficient sequence models including attention variants can be reduced to state space models (Appendix C.2).

Vectorizing over ùë°, this can be expressed as a matrix transformation

$Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ 1 -‚Ñì ùë°$1 1 . . . . . . . . . -‚Ñì ùë°ùëò . . . -‚Ñì ùë° 1 1 . . . . . . . . . . . . . . . 0 . . . -‚Ñì ùëá -1,ùëò . . . -‚Ñì ùëá -1,1 1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùë¶ 0 ùë¶ 1 . . . ùë¶ ùëò . . . ùë¶ ùëá -1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª = Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùúá 0 ùúá 1 . . . ùúá ùëò . . . ùúá ùëá -1 Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª Ô£Æ Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£Ø Ô£∞ ùë• 0 ùë• 1 . . . ùë• ùëò . . . ùë• ùëá -1

$Ô£π Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£∫ Ô£ª$.

The ùúá diagonal matrix can be moved to the left and folded into the matrix of ‚Ñì coefficients, which remains a ùëò + 1-band lower-triangular matrix. But we also have ùêø -1 ùë¶ = ùë•, so ùêø is the inverse of this matrix.

Next, note that ùëò +1-band matrices are ùëò +1-semiseparable by the rank characterization of semiseparability (Definition 3.1). By Proposition C.1, the inverse ùêø is therefore at most ùëò +2-semiseparable. A slightly stronger bound of ùëò +1 can be obtained because of the additional structure of banded matrices. Finally, the characterization of ùêø as an order-ùëò +1 state space model follows from Theorem 3.5. ‚ñ°

In other words, efficient autoregressive attention is semiseparable SMA.

## D Experimental Details D.1 MQAR Details

We use a harder version of the task introduced in Based (Arora, Eyuboglu, [Zhang, et al. 2024)](#) where tokens that are not query/key/values are replaced with random tokens. We also use more key-value pairs, longer sequences, and smaller model sizes than the usual variant of MQAR used by prior work, all of which make the task harder.

For each sequence length ùëá ‚àà {256, 512, 1024}, we use ùëá /4 key-value pairs. The total vocab size is 8192.

We use a form of curriculum training where training cycles through datasets using (ùëá /32,ùëá /16,ùëá /8,ùëá /4) key-value pairs, where each dataset has 2 18 ‚âà 250000 examples, for a total of 8 epochs through each dataset (total of 2 28 ‚âà 270ùëÄ examples). The total batch size is 2 18 ‚âà 0.25ùëÄ tokens (e.g. for ùëá = 1024, the batch size is 256).

All methods use 2 layers with default settings; the attention baseline additionally receives positional embeddings. For each method, we sweep over model dimensions D = {32, 64, 128, 256} and learning rates {10 -3.5 , 10 -2 , 10 -2.5 }. We use a linear decay schedule that drops on every epoch (e.g. the last epoch would have a learning rate 1/8 of the maximum/starting learning rate).

## D.2 Scaling Law Details

All models were trained on the Pile. For the scaling law experiments, we use the GPT2 tokenizer.

Model Sizes.

Table 9 specifies the model sizes we use for scaling laws following GPT3 (Brown et al. 2020), First, we changed the batch size of the 1.3B model from 1M tokens to 0.5M tokens for uniformity. Second, we changed the number of training steps and total tokens to roughly match Chinchilla scaling laws (Hoffmann et al. 2022), which specify that training tokens should increase proportionally to model size. Training Recipes. All models used the AdamW optimizer with ‚Ä¢ gradient clip value 1.0 ‚Ä¢ weight decay 0.1 ‚Ä¢ no dropout ‚Ä¢ linear learning rate warmup with cosine decay

![Figure 1: (Structured State-Space Duality.) This paper fleshes out the relationship between state space models and attention through the bridge of structured matrices.]()

![Figure 2: (State Space Models are Semiseparable Matrices.) As sequence transformations, state space models can be represented as a matrix transformation ùëÄ ‚àà R (T,T) acting on the sequence dimension T, sharing the same matrix for each channel in a head (Left). This matrix is a semiseparable matrix (Right), which is a rank-structured matrix where every submatrix contained on-and-below the diagonal (Blue) has rank at most N, equal to the SSM's state dimension.]()

![(Katharopoulos et al. 2020)). Autoregressive kernel attention, i.e. masked kernel attention with the causal mask, can be computed in ùëÇ (ùëá ) time by a recurrence taking constant time per step.]()

![Structured masked attention (SMA) (or structured attention for short) is defined as a function on queries/keys/values ùëÑ, ùêæ, ùëâ as well as any structured matrix ùêø (i.e. has sub-quadratic matrix multiplication), through the 4-way tensor contraction ùëå = contract(TN, SN, SP, TS ‚Üí TP) (ùëÑ, ùêæ, ùëâ , ùêø).]()

![Figure 3: (Structured Masked Attention.) SMA constructs a masked attention matrix ùëÄ = ùëÑùêæ ‚ä§ ‚Ä¢ ùêø for any structured matrix ùêø, which defines a matrix sequence transformation ùëå = ùëÄùëâ . All instances of SMA have a dual subquadratic form induced by a different contraction ordering, combined with the efficient structured matrix multiplication by ùêø. Previous examples include Linear Attention (Katharopoulos et al. 2020) and RetNet (Y. Sun et al. 2023). Beyond SSD (1-semiseparable SMA), the focus of this paper, many other potential instantiations of structured attention are possible.]()

![PyTorch example of the state space dual (SSD) model. def segsum(x):"""Naive segment sum calculation. exp(segsum(A)) produces a 1-SS matrix, which is equivalent to a scalar SSM.""" T = x.size(-1) x_cumsum = torch.cumsum(x, dim=-1) x_segsum = x_cumsum[..., :, None] -x_cumsum[..., None, :] mask = torch.tril(torch.ones(T, T, device=x.device, dtype=bool), diagonal=0) x_segsum = x_segsum.masked_fill(~mask, -torch.inf) return x_segsum def ssd(X, A, B, C, block_len=64, initial_states=None): """ Arguments: X: (batch, length, n_heads, d_head) A: (batch, length, n_heads) B: (batch, length, n_heads, d_state) C: (batch, length, n_heads, d_state) Return: Y: (batch, length, n_heads, d_head) """ assert X.dtype == A.dtype == B.dtype == C.dtype assert X.shape[1] % block_len == 0 # Rearrange into blocks/chunks X, A, B, C = [rearrange(x, "b (c l) ... -> b c l ...", l=block_len) for x in (X, A, B, C)] A = rearrange(A, "b c l h -> b h c l") A_cumsum = torch.cumsum(A, dim=-1) # 1. Compute the output for each intra-chunk (diagonal blocks) L = torch.exp(segsum(A)) Y_diag = torch.einsum("bclhn,bcshn,bhcls,bcshp->bclhp", C, B, L, X) # 2. Compute the state for each intra-chunk # (right term of low-rank factorization of off-diagonal blocks; B terms) decay_states = torch.exp((A_cumsum[:, :, :, -1:] -A_cumsum)) states = torch.einsum("bclhn,bhcl,bclhp->bchpn", B, decay_states, X) # 3. Compute the inter-chunk SSM recurrence; produces correct SSM states at chunk boundaries # (middle term of factorization of off-diag blocks; A terms) if initial_states is None: initial_states = torch.zeros_like(states[:, :1]) states = torch.cat([initial_states, states], dim=1) decay_chunk = torch.exp(segsum(F.pad(A_cumsum[:, :, :, -1], (1, 0)))) new_states = torch.einsum("bhzc,bchpn->bzhpn", decay_chunk, states) states, final_state = new_states[:, :-1], new_states[:, -1] # 4. Compute state -> output conversion per chunk # (left term of low-rank factorization of off-diagonal blocks; C terms) state_decay_out = torch.exp(A_cumsum) Y_off = torch.einsum('bclhn,bchpn,bhcl->bclhp', C, states, state_decay_out) # Add output of intra-chunk and inter-chunk terms (diagonal and off-diagonal blocks) Y = rearrange(Y_diag+Y_off, "b c l h p -> b (c l) h p") return Y, final_state ‚Ä¢ Parallelization: larger M, N, K terms can leverage specialized matrix multiplication units on modern accelerators.]()

![Figure 6: (Mamba-2 Architecture.) The Mamba-2 block simplifies the Mamba block by removing sequential linear projections; the SSM parameters ùê¥, ùêµ, ùê∂ are produced at the beginning of the block instead of as a function of the SSM input ùëã . An additional normalization layer is added as in NormFormer (Shleifer, Weston, and Ott 2021), improving stability. The ùêµ and ùê∂ projections only have a single head shared across the ùëã heads, analogous to multi-value attention (MVA).]()

![For transformers, sophisticated techniques have been develop to avoid padding and do load-balancing between GPUs (Zeng et al. 2022; Y. Zhai et al. 2023), or packing multiple sequences in the same batch and adjust the attention mask (Ding et al. 2024; Pouransari et al. 2024).]()

![Figure 10: (Efficiency Benchmarks.) (Left) Our SSD is 2 -8√ó faster than a Mamba fused scan for large state expansion (ùëÅ = 64) and faster than FlashAttention-2 for sequence length 2k and above. (Right) Sequence length 4K: Increasing state expansion slows down the Mamba optimized scan implementation linearly. SSD can handle much larger state expansion factors without much slowdown.]()

![architecture) as well as recent subquadratic architectures (H3 (Dao, D. Y. Fu, et al. 2023), Hyena (Poli et al. 2023), RWKV-4 (B. Peng, Alcaide, et al. 2023), RetNet (Y. Sun et al. 2023)), we omit those in the plot for clarity (see Gu and Dao (2023) for comparisons).]()

![Hybrid Models: Combining SSD Layer with MLP and Attention Recent and concurrent work (Dao, D. Y. Fu, et al. 2023; De et al. 2024; Glorioso et al. 2024; Lieber et al. 2024]()

![layers and ùêø2 MLP layers to speed up training at short sequence length.]()

![Time Variance (Selectivity). The original structured SSMs (S4) were linear time-invariant (LTI) systems (Gu 2023; Gu, Goel, and R√© 2022) motivated by continuous-time online memorization (Gu, Dao, et al. 2020; Gu, Johnson, Goel, et al. 2021; Gu, Johnson, Timalsina, et al. 2023). Many variants of structured SSMs have been proposed (Dao, D. Y. Fu, et al. 2023; Gu, Gupta, et al. 2022; Gupta, Gu, and Berant 2022; Ma et al. 2023; J. T. Smith, Warrington, and Linderman 2023), including several that drop the recurrence and focus on the convolutional representation of LTI SSMs (D. Y. Fu et al. 2023; Y. Li et al. 2023; Poli et al. 2023; Qin, Han, Weixuan Sun, B. He, et al. 2023). SSD is a time-varying structured SSM, also known as a selective SSM introduced in Mamba (Gu and Dao 2023). Selective SSMs are closely related to gating mechanisms of RNNs, including classical RNNs such as the LSTM (Hochreiter and Schmidhuber 1997) and GRU (J. Chung et al. 2014) as well as more modern variants such as the QRNN (Bradbury et al. 2016), SRU (Lei 2021; Lei et al. 2017), RWKV (B. Peng, Alcaide, et al. 2023), HGRN (Qin, Yang, and Zhong 2023), and Griffin (Botev et al. 2024; De et al. 2024). These RNNs differ in their parameterizations in various ways, most importantly in the lack of a state expansion.]()

![include MLP-Mixer (Tolstikhin et al. 2021) (unstructured matrix), FNet (Lee-Thorp et al. 2021) (Fourier Transform matrix), M2 (Dao, B. Chen, et al. 2022; Dao, Gu, et al. 2019; Dao, Sohoni, et al. 2020; D. Fu et al. 2024) (butterfly/monarch matrix), Toeplitz matrices (Poli et al. 2023; Qin, Han, Weixuan Sun, B. He, et al. 2023), and even more exotic structures (De Sa et al. 2018; Thomas et al. 2018).]()

![SSD does not use the softmax activation of standard attention (Bahdanau, Cho, and Bengio 2015; Vaswani et al. 2017), which is what gives attention its quadratic complexity. When the softmax is dropped, the sequence can be computed with linear scaling through the linear attention framework (Katharopoulos et al. 2020).]()

![Now consider each of the 2 √ó 2 blocks factored as a rank-1 matrix in the strictly lower triangular part of the matrix. Note that each of the right side row vectors is the same as the bottom row vector in the diagonal block in its column: in particular the [ùëé 1:0 ùëé 1:1 ], [ùëé 3:2 ùëé 3:3 ], and [ùëé 5:4 ùëé 5:5 ] rows. Therefore we already have the answers to these from Stage 1, which is the second element of all ùëá /2 subproblems in Stage 1. If we call this array of elements ùëè ‚Ä≤ (of half the size of ùëè), then we need to multiply ùëè ‚Ä≤ by the 1-SS matrix generated by ùëé 3:-1 , ùëé 3:1 , ùëé 5:3 , ùëé 7:Stage Finally, each of the answers to Stage 2 can be broadcast into two final answers by multiplying by the left-side column vectors: in particular the [ùëé 2:2 ùëé 3:2 ] ‚ä§ , [ùëé 4:4 ùëé 5:4 ] ‚ä§ , and [ùëé 6:6 ùëé 7:6 ] ‚ä§ vectors.]()

![Models of size ‚âà 125ùëÄ to ‚âà 1.3ùêµ parameters, trained on the Pile. Mamba-2 matches or exceeds the performance of Mamba as well as a strong "Transformer++" recipe. Compared to our Transformer baseline, Mamba-2 is Pareto dominant on performance (perplexity), theoretical FLOPs, and actual wall-clock time.(Zero-shot Evaluations.) Best results for each size in bold, second best unlined. We compare against open source LMs with various tokenizers, trained for up to 300B tokens. Pile refers to the validation split, comparing only against models trained on the same dataset and tokenizer (GPT-NeoX-20B). For each model size, Mamba-2 outperforms Mamba, and generally matches Pythia at twice the model size. Full results in Table10.]()

![(Combining SSD and Attention Blocks.) Perplexity of a 350M model with 48 layers, with different number of attention layers. Having around a 10% ratio of attention layers performs best. .32 8.29 8.29 8.28 8.26 8.27 8.28 8.30 8.34 8.50 8.68]()

![(Zero-shot Evaluations.) Best results for each size in bold. We compare different ways SSD, MLP, and attention layers can be combined, evaluated at 2.7B scale trained to 300B tokens on the Pile.]()

![(Ablations: Mamba-2 block.) We ablate the major differences between the Mamba-2 and Mamba-1 neural network blocks (Figure6, Section 7.1). Note that these components are independent of the inner sequence mixing layer; in these ablations, we use SSD for the inner SSM layer (differing from the S6 layer of Mamba-1).]()

![(Ablations: Multi-head structure.) All models have state expansion factor ùëÅ = 64 and head size ùëÉ = 64 and are trained to Chinchilla scaling law token counts. The number of ùê¥ heads is always equal to the total heads H, i.e. each head has a separate input-dependent ùê¥ decay factor. (Top) 125M models, 2.5B tokens (Bottom) 360M models, 7B tokens SSM Head Pattern Attn. Analog ùê¥ heads ùêµ heads ùê∂ heads ùëã heads Layers Params Ppl.]()

![(Ablations: Kernel approximations.) We test various proposals for the kernel activation function ùúì , including linear attention variants aiming to approximate the exp kernel from standard softmax attention.]()

![(Ablations: Kernel approximations.) We test the (Re)Based methods for linear attention approximations, which involve expanded feature maps. (Top) 130M models. (Top) 380M models with ùëÅ = 256.]()

![Glossary of notation and terminology; mnemonics bolded. (Top) Frequently used tensor dimensions. (Bottom) Matrices and tensors used in state space models or structured masked attention.]()

Technically speaking, these connections only relate to certain flavors of attention; the title of this paper is an homage toKatharopoulos et al. (2020)   which first showed that "Transformers are RNNs".

In this work, this happens only with the ùê¥ parameter of SSMs.

In some contexts, it is always clear that the notation ùëé ùëñ:ùëó or ùê¥ ùëñ:ùëó means ùëé √ó ùëñ:ùëó , and the superscript is omitted.

A different symbol is required for the contraction notation.

Note that the block decomposition is valid even with partitions of varying size, e.g. if Q ‚à§ T, but we assume even divisibility for simplicity.

The Mamba-2 Architecture By connecting SSMs and attention, the SSD framework allows us to develop a shared vocabulary and library of techniques for both. In this section we discuss some examples of understanding and modifying SSD layers using ideas originally

We describe several systems optimizations for SSMs, in particular the Mamba-2 architecture, for large-scale efficient training and inference. In particular, we focus on tensor parallel and sequence parallel for large-scale training, as a well variable-length sequences for efficient finetuning and inference.

In small-scale experiments, we find that as long as the attention layers are spaced out, not at the very beginning or at the very end, the model quality does not depend very much on the exact location of the attention layers.

Both these facts can be seen from the Woodbury inverse...

