<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Online Locality Meets Distributed Quantum Computing</title>
				<funder ref="#_HBcyc8E">
					<orgName type="full">Research Council of Finland</orgName>
				</funder>
				<funder ref="#_y3Ku8s2">
					<orgName type="full">Action Exploratoire</orgName>
				</funder>
				<funder ref="#_4KqwjWX">
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
				<funder>
					<orgName type="full">Swiss National Science Foundation</orgName>
				</funder>
				<funder ref="#_tRTR34b">
					<orgName type="full">Helsinki Institute for Information Technology</orgName>
					<orgName type="abbreviated">HIIT</orgName>
				</funder>
				<funder ref="#_syCPr8d #_JzghQuc">
					<orgName type="full">unknown</orgName>
				</funder>
				<funder>
					<orgName type="full">INRIA</orgName>
				</funder>
				<funder ref="#_fQXR8Jr">
					<orgName type="full">Agence Nationale de la Recherche</orgName>
					<orgName type="abbreviated">ANR</orgName>
				</funder>
				<funder ref="#_qDAuY4k">
					<orgName type="full">MUR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2024-11-05">5 Nov 2024</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Amirreza</forename><surname>Akbari</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Xavier</forename><surname>Coiteux-Roy</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computation, Information and Technology</orgName>
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Munich Center for Quantum Science and Technology</orgName>
								<orgName type="institution">Technical University of Munich</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Francesco d&apos;Amore • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Bocconi University</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="institution">Technische Universität Berlin</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Université Paris-Saclay</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">François</forename><surname>Le Gall</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computation, Information and Technology</orgName>
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Munich Center for Quantum Science and Technology</orgName>
								<orgName type="institution">Technical University of Munich</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Francesco d&apos;Amore • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Bocconi University</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="institution">Technische Universität Berlin</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Université Paris-Saclay</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Henrik</forename><surname>Lievonen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computation, Information and Technology</orgName>
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Munich Center for Quantum Science and Technology</orgName>
								<orgName type="institution">Technical University of Munich</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Francesco d&apos;Amore • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Bocconi University</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="institution">Technische Universität Berlin</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Université Paris-Saclay</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Darya</forename><surname>Melnyk</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Augusto</forename><surname>Modanese</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computation, Information and Technology</orgName>
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Munich Center for Quantum Science and Technology</orgName>
								<orgName type="institution">Technical University of Munich</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Francesco d&apos;Amore • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Bocconi University</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="institution">Technische Universität Berlin</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Université Paris-Saclay</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shreyas</forename><surname>Pai</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computation, Information and Technology</orgName>
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Munich Center for Quantum Science and Technology</orgName>
								<orgName type="institution">Technical University of Munich</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Francesco d&apos;Amore • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Bocconi University</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="institution">Technische Universität Berlin</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Université Paris-Saclay</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Marc-Olivier</forename><surname>Renou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computation, Information and Technology</orgName>
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Munich Center for Quantum Science and Technology</orgName>
								<orgName type="institution">Technical University of Munich</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Francesco d&apos;Amore • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Bocconi University</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="institution">Technische Universität Berlin</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Université Paris-Saclay</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Václav</forename><surname>Rozhoň</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computation, Information and Technology</orgName>
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Munich Center for Quantum Science and Technology</orgName>
								<orgName type="institution">Technical University of Munich</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Francesco d&apos;Amore • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Bocconi University</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="institution">Technische Universität Berlin</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff10">
								<orgName type="institution" key="instit1">Inria</orgName>
								<orgName type="institution" key="instit2">Université Paris-Saclay</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Eth</forename><surname>Zurich</surname></persName>
						</author>
						<author>
							<persName><surname>Switzerland</surname></persName>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">BIDSA</orgName>
								<address>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Nagoya University</orgName>
								<address>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff8">
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff9">
								<orgName type="institution">Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff11">
								<orgName type="department">Ecole Polytechnique</orgName>
								<orgName type="institution" key="instit1">CPHT</orgName>
								<orgName type="institution" key="instit2">Institut Polytechnique de Paris</orgName>
								<address>
									<settlement>Palaiseau</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff12">
								<orgName type="institution">Jukka Suomela • Aalto University</orgName>
								<address>
									<country key="FI">Finland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Online Locality Meets Distributed Quantum Computing</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2024-11-05">5 Nov 2024</date>
						</imprint>
					</monogr>
					<idno type="MD5">71470BE00364F64169B4C9EE950B5E6E</idno>
					<idno type="arXiv">arXiv:2403.01903v3[cs.DC]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2-SNAPSHOT" ident="GROBID" when="2025-02-21T16:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We connect three distinct lines of research that have recently explored extensions of the classical LOCAL model of distributed computing: A. distributed quantum computing and non-signaling distributions [e.g. STOC 2024], B. finitely-dependent processes [e.g. Forum Math. Pi 2016], and C. locality in online graph algorithms and dynamic graph algorithms [e.g. ICALP 2023].</p><p>We prove new results on the capabilities and limitations of all of these models of computing, for locally checkable labeling problems (LCLs). We show that all these settings can be sandwiched between the classical LOCAL model and what we call the randomized online-LOCAL model. Our work implies limitations on the quantum advantage in the distributed setting, and we also exhibit a new barrier for proving tighter bounds. Our main technical results are these:</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In this work, we connect three distinct lines of research that have recently explored extensions of the classical LOCAL model of distributed computing:</p><p>A. Distributed quantum computing and non-signaling distributions <ref type="bibr" target="#b4">[3,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b37">36]</ref>. B. Finitely-dependent processes <ref type="bibr" target="#b45">[44,</ref><ref type="bibr" target="#b46">45,</ref><ref type="bibr" target="#b48">47]</ref>. C. Locality in online graph algorithms and dynamic graph algorithms <ref type="bibr">[2,</ref><ref type="bibr" target="#b23">22]</ref>.</p><p>We prove new results on the capabilities and limitations of all of these models of computing, for locally checkable labeling problems (LCLs), with the help of a unifying model that we call randomized online-LOCAL. Our work implies limitations on the quantum advantage in the distributed setting, and we also exhibit a new barrier for proving tighter bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Highlights</head><p>Our main technical results are these: This answers an open question by Holroyd <ref type="bibr" target="#b45">[44]</ref>. This also presents a new barrier for proving bounds on distributed quantum advantage: all current quantum-LOCAL lower bounds are, in essence, lower bounds for non-signaling distributions, and our result shows that fundamentally different techniques will be needed to solve some of the biggest open questions in this area (e.g., showing that there is no constant-round quantum-LOCAL algorithm for coloring cycles). One of many implications is that in rooted trees, O(log * n) locality in quantum-LOCAL is not stronger than O(log * n) locality in classical LOCAL, and also finitely-dependent distributions are not stronger than O(log * n) locality in classical LOCAL.</p><p>We will now proceed to explain what all of these terms and models mean, and how they are connected with each others.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Roadmap</head><p>As our main goal is to unify and relate several distinct models studied in prior work, we will need to introduce a fair number of models of computing. We recommend that the reader keep the roadmap that we have in Fig. <ref type="figure" target="#fig_13">10</ref> (final page) at hand while reading the introduction, in order to maintain a clear view of things, as well as to consult this overview again when needed. We start our adventure in Section 1.3 by introducing the classical models that we have at the very top of Fig. <ref type="figure" target="#fig_13">10</ref> and then relate these to the current landscape of LCLs in Section 1.4. Next, we gradually work our way through the quantum as well as bounded-dependence and non-signaling models in Section 1.5, after which we take our first break. At this point, we are familiar with the top half of Fig. <ref type="figure" target="#fig_13">10</ref>, and we are ready to state our first main contributions related to symmetry breaking with finitely-dependent processes in Section 1. <ref type="bibr" target="#b7">6</ref>.</p><p>In Section 1.7, we then turn to models that at first may seem completely unrelated. They deal with locality in sequential, dynamic, and online settings. As we will see in Section 1.8, however, we can connect all of these models into a single hierarchy, with seemingly orthogonal models sandwiched between deterministic LOCAL and randomized online-LOCAL, and we can prove various strong results that connect the complexity landscape between these two extremes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Classical models</head><p>Let us first recall the definitions of the classical models of distributed graph algorithms <ref type="bibr" target="#b55">[54,</ref><ref type="bibr" target="#b62">61]</ref> that form the foundation for our work; we keep it brief here and postpone formal definitions to Section 4.</p><p>• Deterministic LOCAL: Our input graph G = (V, E) represents a computer network; each node v ∈ V is a computer and each edge {u, v} ∈ E is a communication link between two computers. Each node is labeled with a unique identifier from {1, 2, . . . , poly(|V |)}. All nodes follow the same distributed algorithm. Initially a node is only aware of its own identifier and its own degree. Computation proceeds in synchronous rounds, and in each round a node can send and receive a message to and from each neighbor and update its state. Eventually each node must stop and announce its local output (its part of the solution, e.g. in graph coloring its own color). The running time, round complexity, or locality of the algorithm is the (worst-case) number of rounds T (n) until the algorithm stops in any n-node graph. • Randomized LOCAL: As above, but each node also has a private source of random bits.</p><p>We also define the following variants (see e.g. <ref type="bibr" target="#b51">[50]</ref> for more on the impact of shared global information):</p><p>• Deterministic LOCAL (shared): Deterministic LOCAL with shared global information. The set of nodes and their unique identifiers is globally known, and hence we also know n = |V |. • Randomized LOCAL (shared): Randomized LOCAL with shared global information and shared randomness. The set of nodes and their unique identifiers is globally known, and in addition to the private sources of random bits, there is also a shared source of random bits that all nodes can access.</p><p>We can interpret the shared versions of the models so that we get to see the set of nodes V and their unique identifiers in advance, and we can also initialize the nodes as we want based on this information (and hence in the randomized model, we can also initialize all nodes with the same shared random string), but the set of edges E is only revealed later. This interpretation will be useful especially with the quantum models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Landscape of LCL problems</head><p>There has been more than three decades of work on understanding the capabilities and limitations of the classical deterministic and randomized LOCAL models, but for our purposes most interesting is the recent line of work that has studied distributed algorithms for locally checkable labeling problems, or LCLs. This is a family of problems first introduced by Naor and Stockmeyer <ref type="bibr" target="#b58">[57]</ref>. LCL problems are graph problems that can be defined by specifying a finite set of valid neighborhoods. Many natural problems belong to this family: coloring graphs of maximum degree ∆ with ∆ + 1 colors, computing a maximal independent set, finding a maximal matching, etc.</p><p>Since 2016, we have seen a large body of work dedicated to understanding the computational complexity of LCL problems in the deterministic and randomized LOCAL models <ref type="bibr">[4-9, 11, 16, 17, 19, 20, 34, 37, 39, 40, 62]</ref>, and nowadays there are even algorithms and computer tools available for exploring such questions <ref type="bibr" target="#b10">[9,</ref><ref type="bibr" target="#b24">23,</ref><ref type="bibr" target="#b60">59]</ref>. As a result of this large international research effort, a landscape of the localities of LCL problems emerges <ref type="bibr" target="#b65">[64]</ref>. We can classify LCL problems in discrete classes based on their locality, and we also understand how much randomness helps in comparison with deterministic algorithms. Our main goal in this work is to extend this understanding of LCL problems far beyond the classical models, and especially explore what can be computed very fast in models that are much stronger than deterministic or randomized LOCAL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Quantum-LOCAL and finitely-dependent processes</head><p>We start our exploration of stronger models with distributed quantum computation. The key question is understanding the distributed quantum advantage: what can we solve faster if our nodes are quantum computers and our edges are quantum communication channels? There is a long line of prior work exploring this theme in different models of distributed computing <ref type="bibr" target="#b4">[3,</ref><ref type="bibr" target="#b19">18,</ref><ref type="bibr" target="#b28">27,</ref><ref type="bibr" target="#b34">33,</ref><ref type="bibr" target="#b36">35,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b44">43,</ref><ref type="bibr" target="#b49">48,</ref><ref type="bibr" target="#b50">49,</ref><ref type="bibr" target="#b52">51,</ref><ref type="bibr" target="#b53">52,</ref><ref type="bibr" target="#b56">55,</ref><ref type="bibr" target="#b67">[66]</ref><ref type="bibr" target="#b68">[67]</ref><ref type="bibr" target="#b69">[68]</ref>, but for our purposes these are the models of interest:</p><p>• Quantum-LOCAL: This model of computing is similar to the deterministic LOCAL model above, but now with quantum computers and quantum communication links. More precisely, the quantum computers manipulate local states consisting of an unbounded number of qubits with arbitrary unitary transformations, the communication links are quantum communication channels (adjacent nodes can exchange any number of qubits), and the local output can be the result of any quantum measurement. • Quantum-LOCAL (shared): Quantum-LOCAL with shared global information and a shared quantum state. As above, but now the algorithm may inspect and manipulate the set of nodes (before any edges are revealed). In particular, it may initialize the nodes with a globally shared entangled state.</p><p>As quantum theory intrinsically involves randomness, quantum-LOCAL is at least as strong as randomized LOCAL. There are some (artificial) problems that are known to be solvable much faster in quantum-LOCAL than deterministic or randomized LOCAL <ref type="bibr" target="#b53">[52]</ref>; however, whether any LCL admits such a quantum advantage is a major open question in the field. Directly analyzing quantum-LOCAL is beyond the scope of current techniques. In essence, the only known technique for proving limitations of quantum-LOCAL is sandwiching it between the classical randomized-LOCAL model and more powerful models than quantum-LOCAL that do not explicitly refer to quantum information. These more powerful models are based on the physical causality principle (a.k.a. non-signaling principle). The idea is perhaps easiest to understand with the help of the following thought experiment: = Y (G ′ )↾ U , it would be possible to use A to transmit information in T time steps between two parties, Alice and Bob, that are within distance T + 1 from each other: Bob holds all nodes of U , and he can, therefore, observe Y (G)↾ U , while Alice controls the graph outside G[U, T ] = G ′ [U, T ], and she can, therefore, instantiate either G or G ′ . This would enable Alice to send a signal to Bob even if no physical communication occurred from Alice to Bob (as they are at distance T + 1 from each other and only T communication steps occurred), and thus violate the non-signaling principle.</p><p>This thought experiment suggests the following definition, also known as the φ-LOCAL model and the causal model <ref type="bibr" target="#b4">[3,</ref><ref type="bibr" target="#b37">36]</ref>:</p><p>• Non-signaling model: We can produce an arbitrary output distribution as long as it does not violate the non-signaling principle: for any set of nodes U , modifying the structure of the input graph at more than a distance T (n) from U does not affect the output distribution of U .</p><p>We also need to introduce the following definition to better connect our work with the study of finitely-dependent processes and in particular finitely-dependent colorings <ref type="bibr" target="#b45">[44,</ref><ref type="bibr" target="#b46">45,</ref><ref type="bibr" target="#b48">47]</ref>:</p><p>• Bounded-dependence model: We can produce an arbitrary output distribution as long as it does not violate the non-signaling principle, and, furthermore, distant parts are independent: if we fix any sets of nodes U 1 and U 2 such that their radius-T (n) neighborhoods are disjoint, then the output labels of U 1 are independent of the output labels of U 2 . Now if we set T (n) = O(1), algorithms in the bounded-dependence model are in essence what is usually called finitely-dependent processes. Now we can connect all the above models with each others as follows, sandwiching the two versions of quantum-LOCAL between other models (see Appendix A for details; the connection with the non-signaling model is known <ref type="bibr" target="#b4">[3,</ref><ref type="bibr" target="#b37">36]</ref> but the connection with the bounded-dependence model is to our knowledge new): </p><p>Here an arrow M 1 → M 2 indicates that an algorithm with locality (or round complexity) T (n) in model M 1 implies an algorithm with the same locality in M 2 . For some problems it is possible to prove near-tight bounds for quantum-LOCAL by using diagram <ref type="bibr">(1)</ref>. For example, a very recent work <ref type="bibr" target="#b28">[27]</ref> used these connections to prove limits for the distributed quantum advantage in approximate graph coloring: they prove an upper bound for the deterministic LOCAL model and a near-matching lower bound for the non-signaling model.</p><p>1.6 Contribution 1: symmetry breaking with finitely-dependent processes Now we are ready to state our first contribution. Recall the following gap result by Chang et al. [21]: all LCL problems that can be solved with locality o(log n) in deterministic LOCAL or with locality o(log log n) in randomized LOCAL can also be solved with locality O(log * n) in deterministic LOCAL. The class of problems with locality Θ(log * n) contains in essence all symmetry-breaking problems: these are problems that could be solved with constant locality if only we had some means of breaking symmetry (e.g. distance-k coloring for some constant k would suffice). In Section 6 we show the following result: Theorem 1.2. Let Π be any LCL problem with locality O(log * n) in the deterministic LOCAL model. Then Π can be also solved with locality O(1) in the bounded-dependence model. Furthermore, the resulting finitely-dependent processes are invariant under subgraph isomorphism. Put otherwise, there is a finitely-dependent distribution over valid solutions of Π. Here the invariance under subgraph isomorphisms implies that, for any two graphs G, H that share some isomorphic subgraphs G ′ and H ′ such that their radius-O(1) neighborhoods are still isomorphic, the finitelydependent processes solving Π restricted to G ′ and H ′ are equal. For any constant d, the task of coloring d-regular trees with d + 1 colors is a problem with locality O(log * n) in the deterministic LOCAL model. Hence, we can answer the open question by Holroyd [44]: Corollary 1.3. For each d ≥ 2, there is a finitely-dependent coloring with d + 1 colors in d-regular trees. Furthermore, the resulting process is invariant over subgraph isomorphisms.</p><p>More specifically, there exists a finitely-dependent 4-coloring distribution of the infinite 3-regular tree that is invariant under automorphisms.</p><p>Theorem 1.2 also introduces a formal barrier for proving limitations on distributed quantum advantage. Recall that all current quantum-LOCAL lower bounds are, in essence, lower bounds in the non-signaling model. Before our work, there was a hope that we could discover a symmetry-breaking problem Π with the following properties: (1) its locality is O(log * n) in deterministic LOCAL, and (2) we can show that its locality is Ω(log * n) in the non-signaling model, and therefore (3) Π cannot admit any distributed quantum advantage. However, our work shows that no such problem Π can exist. In particular, arguments related to non-signal distributions are not sufficient to exclude distributed quantum advantage in this region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.7">Locality in online and dynamic settings</head><p>Let us now switch gears and consider a very different line of work. Ghaffari et al. <ref type="bibr" target="#b39">[38]</ref> introduced a sequential counterpart of the classical LOCAL model:</p><p>• Deterministic SLOCAL model: The nodes are processed in an adversarial order. When a node v is processed, the algorithm gets to see all information in its radius-T (n) neighborhood (including states and outputs of previously processed nodes). The algorithm has to label v with its local output, and the algorithm can also record other information in v, which it can exploit when other nodes near v are later processed. • Randomized SLOCAL model: As above, with access to a source of random bits.</p><p>Clearly SLOCAL is stronger than LOCAL. One key feature is that the processing order naturally breaks symmetry, and all symmetry-breaking LCLs can be solved with O(1) locality in SLOCAL.</p><p>One interpretation of our first contribution is that we also establish a new, unexpected similarity between SLOCAL and the bounded-dependence model: both are able to solve any symmetry-breaking LCL with constant locality.</p><p>A recent work <ref type="bibr">[2]</ref> introduced the following models that capture the notion of locality also in the context of centralized dynamic graph algorithms and centralized online graph algorithms:</p><p>• Deterministic dynamic-LOCAL model: The adversary constructs the graph one edge at a time. The algorithm has a global view of the graph (including states and outputs of previously processed nodes), but it has to maintain a feasible solution after each update. The algorithm is restricted so that after a modification at node v, it can only update the solution within distance T (n) from v. • Deterministic online-LOCAL model: The adversary presents the input graph one node at a time. When a node v is presented, the adversary also reveals the radius-T (n) neighborhood of v. The algorithm has to then choose the output label of v. Crucially, the algorithm has access to a global view of the graph (including states and outputs of previously processed nodes). This model can be seen as a stronger version of the deterministic SLOCAL model where all nodes have access to some global shared memory.</p><p>Both SLOCAL and dynamic-LOCAL can be sandwiched between LOCAL and online-LOCAL <ref type="bibr">[2]</ref>:</p><formula xml:id="formula_1">deterministic LOCAL deterministic SLOCAL deterministic dynamic-LOCAL deterministic online-LOCAL<label>(2)</label></formula><p>There are also some problems in which deterministic online-LOCAL is much stronger than deterministic LOCAL: 3-coloring in bipartite graphs has locality Θ( √ n) in deterministic LOCAL <ref type="bibr" target="#b18">[17,</ref><ref type="bibr" target="#b28">27]</ref> but O(log n) in online-LOCAL <ref type="bibr">[2]</ref>; very recently Chang et al. <ref type="bibr" target="#b23">[22]</ref> also showed that this is tight for online-LOCAL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.8">Contribution 2: connecting all models for LCLs in rooted trees</head><p>At first sight, the models discussed in Sections 1.5 and 1.7 seem to have very little in common; they seem to be orthogonal extensions of the classical deterministic LOCAL model. Furthermore, we have already seen evidence that online-LOCAL can be much stronger than deterministic LOCAL. Nevertheless, we can connect all these models in a unified manner, and prove strong limits on their expressive power. To this end, we introduce yet another model:</p><p>• Randomized online-LOCAL model: Like deterministic online-LOCAL, but the algorithm has access to a source of random bits, and we play against an oblivious adversary (the adversary fixes the graph and the order of presenting nodes before the algorithm starts to flip coins).</p><p>Trivially, this is at least as strong as all models in diagram (2). However, the big surprise is that it is also at least as strong as all models in diagram (1). In Section 5 we prove:</p><p>Theorem 1.4. Any LCL that can be solved in the non-signaling model with locality T (n) can also be solved in the randomized online-LOCAL model with the same locality.</p><p>Then we zoom into the case of rooted trees in Section 7 and prove:</p><p>Theorem 1.5. Any LCL on rooted trees that can be solved in the randomized online-LOCAL model with locality o(log log log n) can also be solved in the deterministic LOCAL model with locality O(log * n).</p><p>Together with Theorem 1.2 and previously-known results, we also obtain the following corollary:</p><p>Corollary 1.6. In rooted trees, the following families of LCLs are the same:</p><p>• locality O(log * n) in deterministic or randomized LOCAL or quantum-LOCAL,</p><p>• locality O(1) in bounded-dependence model, non-signaling model, deterministic or randomized SLOCAL, dynamic-LOCAL, or deterministic or randomized online-LOCAL.</p><p>In rooted trees, there is no LCL problem with locality between ω(log * n) and o(log log log n) in any of these models: deterministic and randomized LOCAL, quantum-LOCAL, boundeddependence model, non-signaling model, deterministic and randomized SLOCAL, dynamic-LOCAL, and deterministic and randomized online-LOCAL.</p><p>In particular, when we look at LCLs in rooted trees, O(log * n)-round quantum algorithms are not any stronger than O(log * n)-round classical algorithms. (However, it is still possible that there are some LCLs in trees that can be solved in O(1) rounds in quantum-LOCAL and that require Θ(log * n) rounds in deterministic LOCAL; recall the discussion in Section 1.6.) Theorem 1.5 can be seen as an extension of the result of Akbari et al. <ref type="bibr">[2]</ref> that connects deterministic online-LOCAL with LOCAL for LCLs on rooted regular trees without inputs. Our result is applicable to the randomized online-LOCAL (and hence we can connect it with the non-signaling and quantum models), and it holds for any LCLs on rooted trees (possibly with irregularities and inputs). Recall that the presence of inputs makes a huge difference already in the case of directed paths <ref type="bibr" target="#b6">[5,</ref><ref type="bibr" target="#b24">23]</ref>, and we need fundamentally new ideas, as we can no longer build on the classification from <ref type="bibr" target="#b10">[9,</ref><ref type="bibr" target="#b12">11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.9">Big picture</head><p>By putting together all our contributions (including some auxiliary results that we discuss later in Section 3), the landscape shown in Fig. <ref type="figure" target="#fig_13">10</ref> emerges. We can sandwich all models between deterministic LOCAL and randomized online-LOCAL. Going downwards, we get symmetry breaking for free (as indicated by the blue arrows). And in the case of rooted trees, for the low-locality region o(log log log n), we can also navigate upwards (as indicated by the orange arrows). Table <ref type="table">1</ref> gives some concrete examples of localities for LCL problems across the landscape of models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model</head><p>Symmetry-breaking problems 3-coloring in bipartite graphs</p><formula xml:id="formula_2">Deterministic LOCAL Θ(log * n) by definition Θ( √ n) [27] Randomized LOCAL Θ(log * n) [19] Θ( √ n) [27] Quantum LOCAL O(log * n) trivial Θ( √ n) [27] Bounded-dependence O(1) Theorem 6.16 Θ( √ n) [27] Deterministic SLOCAL O(1) [38] Õ( √ n), n Ω(1) [2, 27] Randomized SLOCAL O(1) [38] Õ( √ n), n Ω(1) [2, 27] Deterministic dynamic-LOCAL O(1) Theorem 9.2 Õ( √ n), Ω(log n) [22, 27] Deterministic online-LOCAL O(1) [2] Θ(log n) [2, 22] Randomized online-LOCAL O(1) [2] Θ(log n) Theorem 8.1</formula><p>Table 1: Examples of localities across the models. Here symmetry-breaking problems refer to LCL problems with locality Θ(log * n) in the deterministic LOCAL model; this includes many classical problems such as maximal independent set, maximal matching, and (∆ + 1)-vertex coloring.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Overview of techniques and key ideas</head><p>In this section, we give an overview of the techniques and key ideas that we use to prove our main results, and we also provide a roadmap to the rest of this paper. We note that our first contribution is presented in Section 6, while the second contribution comes before it in Section 5-the proofs are ordered this way since Section 5 also develops definitions that will be useful in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Bounded-dependence model can break symmetry (Section 6)</head><p>Let us first present an overview of the proof of Theorem 1.2 from Section 1.6. We show that the bounded-dependence model can break symmetry with constant locality; that is, there is a finitely-dependent process for any symmetry-breaking LCL.</p><p>It is well known that any LCL problem Π that has complexity O(log * n) in the LOCAL model has the following property: there exists a constant k ∈ N + (that depends only on the hidden constant in O(log * n)) such that, if the graph is given a distance-k coloring (with sufficiently small number of colors) as an input, then Π is solvable in time O(1) in the LOCAL model (using the distance-k coloring as a local assignment of identifiers) <ref type="bibr" target="#b21">[20]</ref>.</p><p>We prove that for each bounded-degree graph, there is a finitely-dependent process providing a distance-k coloring for constant k. Then, we can combine such a process with the LOCAL algorithm that solves the problem with locality O(1) if a distance-k coloring is given, and we prove that the resulting process is still a finitely-dependent distribution. Furthermore, we also prove that all these processes are invariant under subgraph isomorphisms (even those that do not preserve node identifiers), meaning that, for any two graphs G and H sharing two isomorphic subgraphs with isomorphic radius-O(1) neighborhoods, the restrictions of the finitely-dependent processes solving Π over G and H restricted to G ′ and H ′ are equal in law.</p><p>One of the key observations that we use is that LOCAL algorithms that do not exploit the specific assignment of node identifiers and do not depend on the size of the graph provide finitely-dependent distributions that are invariant under subgraph isomorphisms whenever the input labeling for the graphs is invariant under subgraph isomorphisms.</p><p>Overview. The cornerstone of our proof is a surprising result by Holroyd and Liggett <ref type="bibr" target="#b46">[45]</ref> and its follow-up in <ref type="bibr" target="#b48">[47]</ref>, that state that there exist k-dependent distributions giving a q-coloring of the infinite path and of cycles for (k, q) ∈ {(1, 4), <ref type="bibr">(2,</ref><ref type="bibr" target="#b4">3)</ref>} that are invariant under subgraph isomorphisms.</p><p>Recently, Holroyd has combined the finitely-dependent distributions of infinite paths to provide a finitely-dependent 4-coloring of the d-dimensional lattice <ref type="bibr" target="#b45">[44]</ref>. Getting a translation invariant distribution is quite easy: First, use the distributions for the paths on each horizontal and vertical path obtaining a distance-k coloring (with k being a large enough constant) of the lattice with constantly many colors as shown in <ref type="bibr" target="#b46">[45,</ref><ref type="bibr">Corollary 20]</ref>. Second, apply some LOCAL algorithm that starts from a distance-k coloring and reduces the number of colors to 4 while keeping the resulting distribution symmetric (e.g., the algorithms from <ref type="bibr" target="#b11">[10,</ref><ref type="bibr" target="#b18">17]</ref>). The major contribution of <ref type="bibr" target="#b45">[44]</ref> is transforming such a distribution into a process that is invariant under subgraph isomorphisms. However, this symmetrization phase is quite specific to the considered topology.</p><p>We come up with a new approach that obtains similar results in all bounded-degree graphs through the following steps:</p><p>1. We show that the finitely-dependent coloring of paths and cycles can be combined to obtain finitely-dependent 3-coloring distributions of rooted pseudoforests of bounded-degree that are invariant under subgraph isomorphisms.</p><p>2. We observe that all graphs of bounded-degree admit a random decomposition in rooted pseudoforests that satisfies the required symmetry properties. 3. We prove that such a random decomposition can be combined with the finitely-dependent 3-coloring of rooted pseudoforests to obtain finitely-dependent distributions that give a (∆ + 1)coloring of graphs of maximum degree ∆ that are invariant under subgraph isomorphism. 4. We show that we can use this finitely-dependent (∆ + 1)-coloring distributions to provide a distance-k coloring for bounded-degree graphs, which is enough to simulate any O(log * n)round LOCAL algorithms that solves an LCL Π. Such combinations result in finitely-dependent processes that are invariant under subgraph-isomorphisms and solve Π.</p><p>Notice that, in spirit, steps 1 to 3 are similar to the steps needed to produce a (∆ + 1)-coloring in time O(log * n) in the LOCAL model <ref type="bibr" target="#b43">[42,</ref><ref type="bibr" target="#b61">60]</ref>: however, the detailed way these steps are obtained in the bounded-dependence model is quite different and requires a careful analysis.</p><p>Step 1: Finitely-dependent 3-coloring distributions of rooted pseudoforests. A rooted pseudoforest is a directed graph in which each node has outdegree at most 1. Let us now fix any rooted pseudoforest of maximum degree ∆. Consider the following process: each node v colors its in-neighbors with a uniformly randomly permutation of {1, . . . , indeg(v)}. The graph G i induced by nodes colored with color i is a union of directed paths and cycles (see Fig. <ref type="figure" target="#fig_0">1</ref>) and, hence, admits a finitely-dependent 4-coloring given by <ref type="bibr" target="#b46">[45]</ref> that is invariant under subgraph isomorphisms; if a node is isolated, it can deterministically join any of the G i s, say G 1 . The sequence of graphs (G 1 , . . . , G ∆ in ) is said to be a random ∆ in -decomposition of the rooted pseudoforest. Furthermore, if two graphs G, H have isomorphic subgraphs G ′ , H ′ (together with some constant-radius neighborhoods), the decompositions in directed paths and cycles induced in G ′ and H ′ have the same distribution (because node colors are locally chosen uniformly). We prove that the combination of the random decomposition and the finitely-dependent coloring yields a finitely-dependent 4∆-coloring which is invariant under subgraph isomorphisms: by further combining such distribution with the Cole-Vishkin color reduction algorithm <ref type="bibr" target="#b30">[29,</ref><ref type="bibr" target="#b43">42,</ref><ref type="bibr" target="#b61">60]</ref> (that has complexity O(log * k) with k being the size of the input coloring), we can obtain a finitely-dependent 3-coloring distribution for rooted pseudoforests of maximum degree ∆ that is invariant under subgraph isomorphisms.</p><p>Steps 2-3: Finitely-dependent (∆ + 1)-coloring distribution of bounded-degree graphs. First, if the input graph is undirected, make it a directed graph by duplicating all edges and assigning both orientations to duplicated edges. Since a coloring of the nodes can be given in both cases equivalently, we focus on the directed case for simplicity. Second, consider the following process: each node v labels its out-edges with a uniformly sampled permutation of the elements of {1, . . . , outdeg(v)}; this way we obtain a random decomposition of the edges of the graph into rooted pseudoforests, as each node has at most one out-edge with label i. Furthermore, if two graphs G, H have isomorphic subgraphs G ′ , H ′ (together with some constant-radius neighborhoods), the decompositions induced in G ′ and H ′ have the same distribution (because edge labelings are locally chosen uniformly). We prove that if we apply the finitely-dependent 3-coloring from step 1 to each pseudoforest, we obtain a finitely-dependent 3 ∆ -coloring of the input graph which is invariant under subgraph isomorphisms. By further combining such a distribution with a variant of the Cole-Vishkin color reduction algorithm, we obtain a finitely-dependent (∆ + 1)-coloring distribution for bounded-degree graphs of maximum degree ∆ that is invariant under subgraph isomorphisms.</p><p>Step 4: Finitely-dependent distribution solving Π. Consider any graph G of maximum degree ∆, and its k-th power graph defined as follows: simply add edges to G between each pair of nodes at distance at most k, where k is some large enough constant. Observe that G k is a graph of maximum degree ∆ k . Now, step 3 implies that there is a finitely-dependent (∆ k + 1)-coloring of G k that is invariant under subgraph isomorphisms: such distribution yields a distance-k coloring of G. For any LCL Π that has complexity O(log * n) in LOCAL, we know that there exists a constant k such that, if given a distance-k coloring in input (with a constant number of colors), then there is an O(1)-round port-numbering algorithm solving Π <ref type="bibr" target="#b21">[20]</ref>: the combination of the input distance-k coloring of G given by step 2-3 with such an algorithm yields a finitely-dependent distribution solving Π that is invariant under subgraph isomorphisms.</p><p>Random decomposition of a graph. In steps 1 and 3 we proceed in an analogous way: First, we construct a process that induces a random decomposition of a graph. Second, we consider finitely-dependent distributions of output labelings over the outputs of the random decomposition. The combination of the random decomposition and the finitely-dependent distributions gives rise to a process over the whole graph. In Section 6, we derive a general result (Lemma 6.8) which gives sufficient conditions on the random decomposition and the finitely-dependent distributions in order to ensure the final process is still finitely-dependent (possibly with symmetry properties). Lemma 6.8 is then the tool used in practice in steps 1 and 3.</p><p>Independent related work. Very recently, an independent and parallel work provided a finitelydependent coloring of bounded-degree graphs with exponentially many colors (in the degree of the graph) <ref type="bibr" target="#b66">[65]</ref>. The technique employed in <ref type="bibr" target="#b66">[65]</ref> is very similar to ours: it exploits the decomposition of graphs in rooted pseudoforests, and then colors rooted pseudoforests using the finitely-dependent coloring of paths and cycles <ref type="bibr" target="#b46">[45,</ref><ref type="bibr" target="#b48">47]</ref>. However, <ref type="bibr" target="#b66">[65]</ref> stops at the mere coloring problem and does not make use of color reduction algorithms, which are the key ingredient for extending results to all symmetry-breaking LCLs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Simulating non-signaling in randomized online-LOCAL (Section 5)</head><p>Let us now give the intuition behind the proof of Theorem 1.4 from Section 1.8: we show that the non-signaling model can be simulated in randomized online-LOCAL without any loss in the locality.</p><p>A randomized online-LOCAL algorithm is given in input the size of the input graph, and a distribution that is non-signaling beyond distance T and that solves some problem Π over some graph family F. When the adversary picks any node v 1 and shows to the randomized online-LOCAL algorithm its radius-T neighborhood, the randomized online-LOCAL algorithm simply goes over all graphs of n nodes in F until it finds one, say H 1 , that includes the radius-T neighborhood of v 1 : then, it samples an output according to the restriction of the non-signaling distribution in H 1 to v 1 . Notice that such distribution does not change if the topology of the graph changes outside the radius-T neighborhood of v 1 . Recursively, when the adversary picks the i-th node v i , the randomized online-LOCAL algorithm goes over all graphs of n nodes in F until it finds one, say H i , that includes the union of radius-T neighborhoods of v 1 , . . . , v i (it must necessarily exist as the graph chosen by the adversary is a valid input): hence, it samples an output according to the restriction of the non-signaling distributions in H i to v i conditional on the outputs of v 1 , . . . , v i-1 . We prove that the non-signaling property ensures that the algorithm described above fails with at most the same probability of failure of the non-signaling distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Online-LOCAL can be simulated in SLOCAL for rooted trees (Section 7)</head><p>Next we give an overview of the proof of Theorem 1.5 from Section 1.8: we show that a randomized online-LOCAL algorithm that solves an LCL problem in rooted trees with locality o(log log log n) can be simulated in the deterministic SLOCAL model with locality O(1), and therefore also in the deterministic LOCAL model with locality O(log * n).</p><p>Online-LOCAL algorithms can be seen simply as SLOCAL algorithms with global memory. Notice that SLOCAL algorithms instead only have a form of "incremental" memory, i.e., they keep track of an incremental sequence of intersecting neighborhoods N 1 , N 2 . . . ., where N i intersects N i+1 .</p><p>The new ingredient we use in this section are component-wise online-LOCAL algorithms. Roughly speaking, a component-wise algorithm is a deterministic online-LOCAL algorithm that, when processing a node v, uses information only coming from the connected component of the input graph that has been revealed so far to which v belongs, and nothing else. (If two or more components are merged, then the algorithm may use information it knows from any component.)</p><p>We prove Theorem 1.5 in three steps:</p><p>1. We first show that any randomized online-LOCAL algorithm solving an LCL with locality T (n) can be turned into a deterministic component-wise online-LOCAL algorithm with locality</p><formula xml:id="formula_3">T (2 O(2 n 2 )</formula><p>). 2. We then prove that, for LCLs on rooted trees, we can simulate the component-wise algorithms in SLOCAL. 3. Finally, we show that SLOCAL algorithms solving any LCL Π with locality o(log n) over rooted trees can be turned into an O(log * n)-round LOCAL algorithm solving Π over rooted trees.</p><p>Step 1: Constructing component-wise algorithms from deterministic online-LOCAL algorithms. To give some intuition, consider an LCL problem Π on a family F of graphs that is closed under disjoint graph union and node and edge removals. Suppose there is a deterministic online-LOCAL algorithm A solving Π with locality T (n) on n-node graphs. Note that the output label A chooses for a node may depend arbitrarily on everything the algorithm has seen so far.</p><p>We show how to turn algorithm A into an algorithm whose output for isolated nodes depends only on the local topology and inputs and is oblivious to any previously-processed nodes. We call such algorithms 1-amnesiac. Here with isolated we mean the node v is such that all nodes belong to the radius T -neighborhood around v are new to algorithm A, that is, A has no knowledge of how v is connected (if at all) to the parts of the graph it has seen thus far.</p><p>Let</p><formula xml:id="formula_4">N 1 = |Σ out | |Σ in | n • 2 n 2 • n 2</formula><p>, and let G 1 be the set of all possible subgraphs of any n-node graphs (from F) with inputs (up to isomorphisms) that are the radius-T (N 1 ) neighborhood of some node, which we call the center of the neighborhood. Let</p><formula xml:id="formula_5">g 1 = |G 1 | and notice that g 1 ≤ 2 n 2 |Σ in | n .</formula><p>Consider now the following experiment:</p><formula xml:id="formula_6">1. Construct a simulation graph H 1 that consists of |Σ out | • n copies of all graphs in G 1 . The size of H 1 is at most N 1 = n 2 |Σ out | • g 1 ≤ |Σ out | |Σ in | n • 2 n 2 • n 2 . 2.</formula><p>Reveal the center node of each of those neighborhood graphs to A in an arbitrary order with locality T (N 1 ). For each type of radius-T (N 1 ) neighborhood T 1 (i.e., any element of G 1 ), there exists some output label σ T 1 that occurs at least n times. We call such neighborhoods good and such a label a canonical labeling of T 1 . 3. Continue labelling nodes of H 1 using A under an arbitrary ordering of the nodes.</p><p>We describe a new online-LOCAL algorithm B that, using this experiment, produces a correct labeling. Let G be an input graph n nodes, and let node v be revealed to B along with its radius-T ′ (n) neighborhood, where T ′ (n) = T (N 1 ). Whenever v is an isolated node, algorithm B finds a "fresh" (i.e., not previously chosen) good neighborhood in the experiment graph matching the radius-T (N 1 ) neighborhood of v in G. It then takes that unused good neighborhood, identifies all nodes with the revealed input neighborhood, and labels v accordingly. An unused good neighborhood always exists since there are at least n good neighborhoods in the experiment graph matching the radius-T (N 1 ) neighborhood of v in G. Algorithm B effectively cuts and pastes the neighborhood from the experiment graph to the actual input graph without algorithm A noticing. For non-isolated nodes, B just simulates what A would do, following the adversarial order of the nodes presented to B. This is always possible because the labels of isolated nodes come from valid online-LOCAL runs of A.</p><p>The correctness of algorithm B follows from that of A. Moreover, when labeling an isolated node, B always labels it in the same way that depends only on the local structure and inputs of the graph; hence B is 1-amnesiac. Clearly, there is an exponential overhead in the locality: the locality of B is</p><formula xml:id="formula_7">T ′ (n) = T (N 1 ) = T (2 O(n 2 ) ).</formula><p>Using the above, we now describe how to obtain a 2-amnesiac algorithm, that is, an algorithm that always produces the same labels for the same types of connected components formed by the union of intersecting neighborhoods of two distinct nodes. We modify the previous experiment as follows:</p><p>1. First we must increase the size of the experiment graph. Let</p><formula xml:id="formula_8">N 2 = |Σ out | 2 |Σ in | n • 2 n • n 2 and redefine G 1 with the radius-T (N 2 ) neighborhoods. 2. Instead of considering |Σ out | • n many disjoint copies of elements of G 1 , we now take |Σ out | 2 • n copies.</formula><p>By the same argument as before, there are at least n • |Σ out | good neighborhoods. 3. Let G 2 be the set of all possible unions of two non-disjoint radius-T (N 2 ) neighborhoods of two different nodes of any n-node graph (in F), with all possible input labelings and orderings of the center nodes. Notice that the size of</p><formula xml:id="formula_9">G 2 is g 2 ≤ 2 n 2 |Σ in | n .</formula><p>We take |Σ out | • n many disjoint copies of all graphs in G 2 , with the catch that the neighborhood of the center node that comes first in the processing order is chosen arbitrarily among the good neighborhoods. The resulting graph H 2 is our new experiment graph, whose size is now</p><formula xml:id="formula_10">N 2 ≤ |Σ out | |Σ in | n • 2 n 2 • n 3 . 4.</formula><p>Use A to label all nodes that come first in the input order in each graph, then all nodes that come second in the same respective order. 5. Use A to label the second center node of each connected component. By the pigeonhole principle, for all types of such connected components T 2 there are at least n identical labelings. These make out the canonical labelings σ T 2 .</p><p>The 2-amnesiac algorithm B starts by running the above experiment. When given in input an n-node graphs, it outputs the canonical labeling σ T 1 for isolated nodes whose radius-T ′ (n) = T (N 2 ) neighborhood matches type T 1 . Similarly, B outputs the canonical labeling σ T 2 for nodes seeing a connected component of type T 2 when we look at their radius-T ′ (n) = T (N 2 ) neighborhood. The correctness argument is the same as that for 1-amnesiac algorithms. For the remaining nodes, B just simulates A using global memory as usual.</p><p>We can continue this process all the way up to n-amnesiac algorithms, which are simply component-wise online-LOCAL algorithms. See Lemma 7.5 for the formal details. As a remark, notice the restriction to LCLs is necessary to prove correctness: if the amnesiac algorithm fails, it must fail locally; hence also the original online-LOCAL algorithm fails locally, contradicting its correctness.</p><p>Dealing with randomness. Let us now turn to the setting where A is randomized. For deterministic online-LOCAL algorithms, we adaptively picked the good neighborhoods before processing further; however, since in randomized online-LOCAL the adversary is oblivious, we must adapt our strategy.</p><p>Our experiment graph H n is now random. It is constructed exactly as before, though now the good connected components have to be "guessed" uniformly at random each time. Clearly, the probability that our guesses are good is incredibly small. Hence we would like to amplify the success probability so that the probability that the guesses are good enough and the randomized online-LOCAL algorithm works correctly is bounded away from zero. (Once we have this, we may apply a standard derandomization argument.) The amplification is by replicating k times the experiment graph H n , guessing the good components for each copy of H n independently. Since the randomness of the algorithm and the randomness of these guesses are independent for each copy of H n , a simple union bound together with the inclusion-exclusion principle give a positive probability that, in at least one copy of H n , the guesses are correct and the algorithm works properly.</p><p>We now apply a standard derandomization argument: Since there exists an assignment of a random bit string to the randomized online-LOCAL algorithm as well as for "guessing" the good components in the k copies of the experiment graph, there is a fixed, deterministic realization of H n that yields a (correct) deterministic online-LOCAL algorithm. Hence our n-amnesiac algorithm B goes over all possible definitions of H n and of deterministic online-LOCAL algorithms (according to an arbitrary order) until it finds this good combination. It must eventually succeed because, when the size of the input graph is fixed, there are only finitely many combinations. The proof then reduces to the previous case. See <ref type="bibr">Lemma 7.6</ref> for the formal details.</p><p>Step 2: From component-wise algorithms to SLOCAL algorithms on rooted trees. We heavily exploit the fact that, in rooted trees, there is a consistent orientation of the edges towards the root. We adapt results from <ref type="bibr" target="#b24">[23,</ref><ref type="bibr">Section 7]</ref> to the SLOCAL model to show how to "cluster" a rooted tree in connected components (which are also rooted trees) in time O(α) and so that the following properties are met:</p><p>1. All connected components have depth Θ(α). 2. All leaves of a connected component that are not at distance Θ(α) from the root of the component are real leaves of the original rooted tree. 3. All other leaves are either real leaves or roots of other connected components.</p><p>The formal details can be found in Lemma 7.8.</p><p>Suppose now we are given an n-amnesiac (equivalently, component-wise) algorithm A solving an LCL Π on rooted trees with locality T (n). We briefly describe how to construct an SLOCAL algorithm B that solves Π with locality O(T (n)) on rooted trees. Recall that in SLOCAL we may compose two algorithms with localities T 1 and T 2 and obtain an SLOCAL algorithm with locality O(T 1 + T 2 ) <ref type="bibr" target="#b39">[38]</ref>. Algorithm B is the composition of the following four algorithms with locality O(T ):</p><p>1. B 1 constructs a clustering with properties 1-3 above with α = O(T ), where the hidden constant is large enough. 2. B 2 ensures each root of a connected component of the cluster precommits a solution in the neighborhood of the leaves of the component using A. This can be done independently between different components if the localities are appropriately chosen. The root of the original tree also outputs a solution for itself. 3. B 3 outputs the precommitments on the nodes designated by B 2 . 4. The fact that we used A independently on disjoint components of the graph (and A being correct) ensures that a solution to the LCL exists and the "inner part" of all connected components can be completed with a correct solution. Hence B 4 simply brute-forces a solution inside the clusters.</p><p>Since Π is an LCL, different components will have compatible solutions as B 2 precommitted a solution around leaf nodes, which are roots of other connected components.</p><p>Step 3: From SLOCAL algorithms to LOCAL algorithms on rooted trees. Any o(log n)time SLOCAL algorithm A solving an LCL over rooted trees can be turned into an O(1)-time SLOCAL algorithm B achieving the same. This is obtained by exploiting the same tree decomposition described above and providing fake, repeating identifiers to each cluster so that two equal identifiers are "far enough". Then, we use A as a black-box and lie to A by providing the size of a cluster as the input graph size. Once we have an O(1)-time SLOCAL algorithm B, how to turn it into an O(log * n)-time LOCAL algorithm is folklore.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Additional results</head><p>We will now discuss some additional results that help to establish the missing parts of the big picture in Fig. <ref type="figure" target="#fig_13">10</ref>, and provide further intuition and examples on these models and their key properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Lower bound on 3-coloring in randomized online-LOCAL (Section 8)</head><p>So far we have connected randomized online-LOCAL with other models through simulation arguments that only work in rooted trees. Let us now put limitations on randomized online-LOCAL in a broader setting. Recall that in deterministic online-LOCAL we can 3-color bipartite graphs with locality O(log n) <ref type="bibr">[2]</ref>, and this is tight <ref type="bibr" target="#b23">[22]</ref>. In Section 8 we show that randomness does not help:</p><p>Theorem 3.1. 3-coloring in bipartite graphs is not possible with locality o(log n) in the randomized online-LOCAL model.</p><p>This demonstrates that even though randomized online-LOCAL is a very strong model, strong enough to simulate e.g. any non-signaling distribution, it is nevertheless possible to prove strong lower bounds in this model (which then imply lower bounds across the entire landscape of models).</p><p>Here it is important to assume that the adversary is oblivious, i.e., it cannot see the random decisions of the randomized algorithm. This lower bound complements a recent result of Chang et al. <ref type="bibr" target="#b23">[22]</ref> showing the same bound for the deterministic online-LOCAL model.</p><p>In this proof, we use the notion of a b-value defined in <ref type="bibr" target="#b23">[22]</ref> as a measure of the number of incompatible boundaries present in a region of a grid. We start with the assumption that a grid can be 3-colored with locality o(log n) and derive a contradiction. The high level idea is to construct two path segments below each other, where one path segment has a large count of incompatible boundaries (a high b-value) and the other segment has a low boundary count (incompatible b-value to the upper path). This forces an algorithm to make boundaries escape on the side between the two segments. We show that the boundary count is, however, too large compared to the distance between the two segments and thus the boundaries "cannot escape".</p><p>Two difficulties arise in the randomized case compared to the deterministic lower bound: (i) In order to create a path with a large b-value we have to use a probabilistic construction that produces a segment with a large b-value with high probability; (ii) Since the first construction is probabilistic and the adversary oblivious, we cannot "see" the large b-value segment constructed in (i), that is, we can neither predict its position nor its size. We therefore need to use another probabilistic construction that positions the segment in a position that forces a contradiction (and which succeeds with constant probability).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Deterministic dynamic-LOCAL can derandomize LOCAL (Section 9)</head><p>It is known that deterministic SLOCAL is strong enough to simulate randomized LOCAL. In Section 9 we show that the same holds also for dynamic-LOCAL, using the method of conditional expectation in a manner similar to how the result is proved for SLOCAL: Theorem 3.2. Deterministic dynamic-LOCAL can simulate randomized LOCAL.</p><p>We also show that dynamic-LOCAL can break symmetry for free, similar to SLOCAL and the bounded-dependence model: if we can solve an LCL problem with O(log * n) locality in LOCAL, we can solve it with O(1) locality in dynamic-LOCAL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Randomized online-LOCAL with adaptive adversary (Section 10)</head><p>The new model that we introduced, randomized online-LOCAL, is defined using an oblivious adversary. In Section 10 we show that this is also necessary: if we defined randomized online-LOCAL with an adaptive adversary, it would be as weak as the deterministic online-LOCAL model.</p><p>We show that an adaptive adversary in randomized online-LOCAL is so strong that a succeeding randomized online-LOCAL algorithm of locality T would admit a single random-bit string that outputs a good solution for all possible graphs of a given size: hence, a correct deterministic online-LOCAL algorithm exists. Since deterministic online-LOCAL algorithms of locality T for graphs of n nodes are only finitely many, the deterministic online-LOCAL algorithm in its initialization phase can go over all of them until it finds the one working for all graphs of n nodes: it then uses that one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Randomized online-LOCAL in paths and cycles (Section 11)</head><p>Our final technical part shows that LCL problems in paths and cycles have complexity either O(1) or Θ(n) in the randomized online-LOCAL model; moreover the locality is O(1) in randomized online-LOCAL if and only if it is O(log * n) in the deterministic LOCAL model. Together with prior work, this also shows that locality of an LCL problem in paths and cycles is decidable across all models <ref type="bibr" target="#b6">[5]</ref> (with the caveat that we cannot distinguish between O(1) and Θ(log * n) for quantum-LOCAL). The proof is a reworking of its deterministic variant from <ref type="bibr">[2]</ref>. The main take-home message of this result is the following: cycles are not a fundamental obstacle for simulating randomized online-LOCAL in weaker models. Hence, there is hope for generalizing the simulation result of Section 7 from trees to a broader class of graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Quantum, bounded-dependence, and non-signaling (Appendix A)</head><p>Appendix A aims at serving a dual purpose. First, it aims at formally introducing the non-signaling model based on the non-signaling principle, and at explaining why it is more powerful than the quantum-LOCAL model. This is not a new result, but included for completeness and to clarify the early works of Gavoille et al. <ref type="bibr" target="#b37">[36]</ref> and Arfaoui and Fraigniaud <ref type="bibr" target="#b4">[3]</ref>. Second, it formally introduces the bounded-dependence model based on finitely-dependent processes and argues why the relations in diagram (1) hold, and in particular why quantum-LOCAL without shared quantum state is contained not only in the non-signaling model but also in the bounded-dependence model. While all the ingredients are well-known, to our knowledge this relation between the quantum-LOCAL model and the bounded-dependence model is not made explicit in the literature before.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Open questions</head><p>Our work suggests a number of open questions; here are the most prominent ones: Question 1. Is quantum-LOCAL stronger than randomized LOCAL for any LCL problem? In particular, is there any LCL problem with constant locality in quantum-LOCAL but super-constant locality in LOCAL? We conjecture that such a problem does not exist. Our work proves that to show this conjecture, new proof techniques are needed. Question 2. Does shared global information or shared quantum state ever help with any LCL problem (beyond the fact that shared quantum state can be used to generate shared randomness, which is known to help <ref type="bibr" target="#b14">[13]</ref>)? Question 3. Is it possible to simulate deterministic or randomized online-LOCAL in SLOCAL and LOCAL also in a broader graph class than rooted trees? If we could extend the result to unrooted trees, it would also imply new lower bounds for the widely-studied sinkless orientation problem <ref type="bibr" target="#b13">[12,</ref><ref type="bibr" target="#b17">16]</ref> across all models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Follow-up work</head><p>Since the first versions of this work originally appeared in arXiv earlier this year, this work has already influenced at least two follow-up papers:</p><p>1. Dhar et al. <ref type="bibr" target="#b33">[32]</ref> study the relation between online-LOCAL and deterministic LOCAL in much greater depth, especially outside the o(log log log n) region. It turns out that e.g. in regular rooted trees the complexity classes of LCL problems in randomized online-LOCAL and deterministic LOCAL exactly coincide, and as a corollary all models in Fig. <ref type="figure" target="#fig_13">10</ref> are exactly as strong for this graph family in the Ω(log * n) region. 2. Balliu et al. <ref type="bibr" target="#b14">[13]</ref> show that there are LCL problems in which shared randomness strictly helps.</p><p>This implies a number of new separations between the models in Fig. <ref type="figure" target="#fig_13">10</ref>; for example, quantum-LOCAL with shared quantum state is strictly stronger than quantum-LOCAL without shared quantum state, the non-signaling model is strictly stronger than the bounded-dependence model, and randomized online-LOCAL is strictly stronger than randomized SLOCAL.</p><p>Put together, these papers demonstrate that especially in restricted graph classes such as trees, one can indeed often cover the entire hierarchy of models with a single theorem about randomized online-LOCAL, while in general we are dealing with a large number of genuinely distinct models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Preliminaries</head><p>We use the notation N = {0, 1, 2, . . . } and N + = N \ {0}. For any positive integer n ∈ N + , we denote the set {1, . . . , n} by [n].</p><p>Graphs. In this work, a graph G = (V, E) can be either directed (E ⊆ V 2 ) or undirected (E ⊆ V 2 ). If the set of nodes and the set of edges are not specified, we refer to them by V (G) and E(G), respectively. For any edge e = (u, v) ∈ E(G) we say that e is directed from u to v and is incident to u and to v (the latter holds also for undirected edges). All graphs in this paper are simple graphs without self-loops unless differently specified. The degree of a node v is the number of edges that are incident to v and is denoted by deg G (v), or simply by deg(v) when G is clear from the context. The indegree of a node v is the number of directed edges that are directed towards v and is denoted by indeg G (v), while the outdegree of v is the number of directed edges that are incident to v but directed to some other vertex and is denoted by outdeg G (v). Again, we omit the suffix G if the graph is clear from the context.</p><p>If G is a subgraph of H, we write G ⊆ H. For any subset of nodes A ⊆ V , we denote by G[A] the subgraph induced by the nodes in A. For any nodes u, v ∈ V , dist G (u, v) denotes the distance between u and v in G (i.e., the number of edges of any shortest path between u and v in G-it doesn't need to be a directed path); if u and v are disconnected, then dist G (u, v) = +∞. If G is clear from the context, we may also simply write dist(u, v) = dist G (u, v). Also, for subset of nodes A, B ⊆ V and any node v ∈ V , we can define dist</p><formula xml:id="formula_11">G (v, A) = min u∈A dist G (u, v) and, by extension, dist G (A, B) = min u∈A dist G (u, B). We assume that dist G (A, ∅) = +∞. Similarly, for subgraphs G 1 , G 2 ⊆ G, we define dist G (G 1 , G 2 ) = dist G (V (G 1 ), V (G 2 )): here, we also assume dist G (G 1 , ∅) = +∞ where ∅ is now the empty graph. For T ∈ [n], the T -neighborhood of a node u ∈ V of a graph G is the set N T (u, G) = {v ∈ V | dist G (u, v) ≤ T }. The T -neighborhood of a subset A ⊆ V is the set N T (A, G) = {v ∈ V | ∃u ∈ A : dist G (u, v) ≤ T }. Similarly, the T -neighborhood of a subgraph H ⊆ G is the set N T (H, G) = {v ∈ V | ∃u ∈ V (H) : dist G (u, v) ≤ T }. If G is clear from the context, we just write N T (u), N T (A), and N T (H). If u / ∈ V , A∩V = ∅, or V (H)∩V (G) = ∅, then the neighborhood N T (u) = ∅, N T (A) = ∅, or N T (H) = ∅,</formula><p>respectively. We make use of some graph operations: For any two graphs G, H, we denote by G ∩ H the intersection graph defined by</p><formula xml:id="formula_12">G ∩ H = (V (G) ∩ V (H), E(G) ∩ E(H)). The graph union is defined by G ∪ H = (V (G) ∪ V (H), E(G) ∪ E(H)). Moreover, the graph difference is the graph G \ H = (V (G) \ V (H), E(G) \ E(H)).</formula><p>Finally, for any two graphs G and H, we write G ∼ f H to denote that G and H are isomorphic and f :</p><formula xml:id="formula_13">V (G) → V (H) is an isomorphism.</formula><p>Labeling problems. We start with the notion of labeling problem. Definition 4.1 (Labeling problem). Let Σ in and Σ out two sets of input and output labels, respectively. A labeling problem Π is a mapping (G, λ in ) → {λ (out,i) } i∈I , with I being a discrete set of indexes, that assigns to every graph G with any input labeling λ in : V (G) → Σ in a set of permissible output vectors λ (out,i) : V (G) → Σ out that might depend on (G, λ in ). The mapping must be closed under graph isomorphism, i.e., if φ : V (G) → V (G ′ ) is an isomorphism between G and G ′ , and</p><formula xml:id="formula_14">λ (out,i) ∈ Π((G ′ , λ in )), then λ (out,i) • φ ∈ Π((G, λ in • φ)).</formula><p>A labeling problem can be thought as defined for any input graph of any number of nodes. If the set of permissible output vectors is empty for some input (G, λ in ), we say that the problem is not solvable on the input (G, λ in ): accordingly, the problem is solvable on the input</p><formula xml:id="formula_15">(G, λ in ) if Π(G, λ in ) ̸ = ∅.</formula><p>One observation on the generality of definition of labeling problem follows: one can actually consider problems that require to output labels on edges.</p><p>We actually focus on labeling problems where, for any input graph, an output vector λ out is permissible if and only if the restrictions of the problem on any local neighborhoods can be solved and there exist compatible local permissible output vectors whose combination provides λ out . This concept is grasped by the notion of locally checkable labeling (LCL) problems, first introduced by Naor and Stockmeyer <ref type="bibr" target="#b58">[57]</ref>. For any function f : A → B and any subset A ′ ⊆ A, let us denote the restriction of f to A ′ by f ↾ A ′ . Furthermore, we define a centered graph to be a pair (H, v H ) where H is a graph and v H ∈ V (H) is a vertex of H that we name the center of H. The radius of a centered graph is the maximum distance from v H to any other node in H. Definition 4.2 (Locally checkable labeling problem). Let r, ∆ ∈ N. Let Σ in and Σ out two finite sets of input and output labels, respectively, and Π a labeling problem. Π is locally checkable with checking radius r if there exists a family S = {((H, v H ), λin , λout ) i } i∈I of tuples, where (H, v H ) is a centered graph of radius at most r and maximum degree at most ∆, λin : V (H) → Σ in is an input labeling for H, λout : V (H) → Σ out is an output labeling for H (which can depend on λin ) with the following property</p><formula xml:id="formula_16">• for any input (G, λ in ) to Π with deg(G) ≤ ∆, an output vector λ out : V (G) → Σ out is permissible (i.e., λ out ∈ Π((G, λ in ))) if and only if, for each node v ∈ V (G), the tuple ((G[N r (v)]), λ in ↾ Nr(v) , λ out ↾ Nr(v)</formula><p>) belongs to S (up to graph isomorphisms).</p><p>Notice that the family S can be always thought to be finite up to graph isomorphisms, as r and ∆ are fixed and the set of input/output labels are finite. We now define the computational models we work in.</p><p>The port-numbering model. A port-numbered network is a triple N = (V, P, p) where V is the set of nodes, P is the set of ports, and p : P → P is a function specifying connections between ports. Each element x ∈ P is a pair (v, i) where v ∈ V , i ∈ N + . The connection function p between ports is an involution, that is,</p><formula xml:id="formula_17">p(p(x)) = x for all x ∈ P . If (v, i) ∈ P , we say that (v, i) is port number i in node v. The degree of a node v in the network N is deg N (v) is the number of ports in v, that is, deg N (v) = |{i ∈ N : (v, i) ∈ P }|.</formula><p>Unless otherwise mentioned, we assume that port numbers are consecutive, i.e., the ports of any node v ∈ V are (v, 1), . . . , (v, deg N (v)). Clearly, a port-numbered network identifies an underlying graph G = (V, E) where, for any two nodes u, v ∈ V , {u, v} ∈ E if and only if there exists ports x u , x v ∈ P such that p(x u ) = x v . Clearly, the degree of a node deg</p><formula xml:id="formula_18">N (v) corresponds to deg G (v).</formula><p>In the port-numbering model we are given distributed system consisting of a port-numbered network of |V | = n processors (or nodes) that operates in a sequence of synchronous rounds. In each round the processors may perform unbounded computations on their respective local state variables and subsequently exchange of messages of arbitrary size along the links given by the underlying input graph. Nodes identify their neighbors by using ports as defined before, where port assignment may be done adversarially. Barring their degree, all nodes are identical and operate according to the same local computation procedures. Initially all local state variables have the same value for all processors; the sole exception is a distinguished local variable x(v) of each processor v that encodes input data.</p><p>Let Σ in be a set of input labels. The input of a problem is defined in the form of a labeled graph (G, x) where G = (V, E) is the system graph, V is the set of processors (hence it is specified as part of the input), and x : V → Σ in is an assignment of an input label λ in (v) ∈ Σ in to each processor v. The output of the algorithm is given in the form of a vector of local output labels λ out : V → Σ out , and the algorithm is assumed to terminate once all labels λ out (v) are definitely fixed. We assume that nodes and their links are fault-free. The local computation procedures may be randomized by giving each processor access to its own set of random variables; in this case, we are in the randomized port-numbering model as opposed to the deterministic port-numbering model.</p><p>The running time of an algorithm is the number of synchronous rounds required by all nodes to produce output labels. If an algorithm running time is T , we also say that the algorithm has locality T . Notice that T can be a function of the size of the input graph. We say that a problem Π over some graph family F has complexity T in the port-numbering model if there is a port-numbering algorithm running in time T that solves Π over F, and T = T (n) is the minimum running time (among all possible algorithms that solve Π over F) in the worst case instance of size n. If the algorithm is randomized, we also require that the failure probability is at most 1/n, where n is the size of the input graph.</p><p>We remark that the notion of an (LCL) problem is a graph problem, and does not depend on the specific model of computation we consider (hence, the problem cannot depend on, e.g., port numbers).</p><p>The LOCAL model. The LOCAL model was first introduced by Linial <ref type="bibr" target="#b54">[53]</ref>: it is just the portnumbering model augmented with an assignment of unique identifiers to nodes. Let c ≥ 1 be a constant, and let Σ in be a set of input labels. The input of a problem is defined in the form of a labeled graph (G, x) where G = (V, E) is the system graph, V is the set of processors (hence it is specified as part of the input), and x : V → [n c ] × Σ in is an assignment of a unique identifier id(v) ∈ [n c ] and of an input label λ in (v) ∈ Σ in to each processor v. The output of the algorithm is given in the form of a vector of local output labels λ out : V → Σ out , and the algorithm is assumed to terminate once all labels λ out (v) are definitely fixed. We assume that nodes and their links are fault-free. The local computation procedures may be randomized by giving each processor access to its own set of random variables; in this case, we are in the randomized LOCAL (randomized LOCAL) model as opposed to deterministic LOCAL (deterministic LOCAL). Notice that the knowledge of n makes the randomized port-numbering model roughly equivalent to the randomized LOCAL model, as unique identifiers can be produced with high probability. We say that a problem Π over some graph family F has complexity T in the LOCAL model if there is a LOCAL algorithm running in time T that solves Π over F, and T = T (n) is the minimum running time (among all possible algorithms that solve Π over F) in the worst case instance of size n. If the algorithm is randomized, we also require that the failure probability is at most 1/n, where n is the size of the input graph.</p><p>The sequential LOCAL model. The sequential LOCAL model was first introduced by <ref type="bibr" target="#b39">[38]</ref>: it is a sequential version of the LOCAL model. Nodes are processed according to an adversarial order σ = v 1 , . . . , v n . When processing a node v i , a T -round algorithm collects all inputs in the radius-T neighborhood of v i (including the states and the outputs of previously processed nodes in N T (V i ), i.e., v j ∈ N T (V i ) for j &lt; i): we say that such an algorithm has complexity T . Note that the algorithm might store all inputs in N T (v i ) in the state of v i : hence, when processing v i , it can see the input of v j , j &lt; i, if and only if there is a subsequence of nodes {v</p><formula xml:id="formula_19">h k } k∈[m] with j = h k &lt; h k+1 &lt; • • • &lt; h km = i such that v h k ∈ N T (v h k+1 ) for all k ∈ [m].</formula><p>If the algorithm is given an infinite random bit string, we talk about the randomized SLOCAL model, as opposed to the deterministic SLOCAL model. We assume that the adversarial order according to which nodes are processed is oblivious to the random bit string, as in the original definition of the model. We say that a problem Π over some graph family F has complexity T in the SLOCAL model if there is an SLOCAL algorithm running in time T that solves Π over F, and T = T (n) is the minimum running time (among all possible algorithms that solve Π over F) in the worst case instance of size n. If the algorithm is randomized, we also require that the failure probability is at most 1/n, where n is the size of the input graph.</p><p>The dynamic-LOCAL model. The deterministic dynamic-LOCAL was introduced in <ref type="bibr">[2]</ref>. It is a centralized model of computing where the adversary constructs the graph one edge at a time. An adversary construct the input graph by adding one edge at a time (with an ordering of the nodes). The algorithm has a global view of the current state of the graph and has to commit for the newly added nodes (according to the ordering), but it has to maintain a feasible solution after each update. The algorithm is restricted so that after a modification at node v, it can only update the solution within distance T (n) from v. We say that a problem Π over some graph family F has complexity T (n) in the dynamic-LOCAL model if T (n) is the minimum function such that there is a dynamic-LOCAL algorithm running in time T (n) that solves Π over F, and T = T (n) is the minimum running time (among all possible algorithms that solve Π over F) in the worst case instance of size n.</p><p>The online-LOCAL model. The (deterministic) online-LOCAL model was introduced in <ref type="bibr">[2]</ref>. It is basically equivalent to the SLOCAL model with global memory. More specifically, the online-LOCAL model is a centralized model of computing where the algorithm initially knows only the set of nodes of the input graph G. The nodes are processed with respect to an adversarial input sequence</p><formula xml:id="formula_20">σ = v 1 , v 2 , . . . , v n . The output of v i depends on G i = G[ i j=1 N T (v j )],</formula><p>i.e., the subgraph induced by the radius-T neighborhoods of v 1 , v 2 , . . . , v i (including all input data), plus all the outputs of previously processed nodes (in order).</p><p>We define the randomized online-LOCAL model as a randomized variant of the online-LOCAL model where the label assigned by the algorithm to v i is a random outcome. Note that this model is oblivious to the randomness used by the algorithm. In particular this means that the graph G \ G i cannot be changed depending on the label assigned to v i . One could also define the randomized online-LOCAL model in an adaptive manner, but it turns out that this is equivalent to the deterministic online-LOCAL model as we show in Section 10. We say that a problem Π over some graph family F has complexity T in the online-LOCAL (randomized online-LOCAL) model if there is an online-LOCAL (randomized online-LOCAL) algorithm running in time T that solves Π over F, and T = T (n) is the minimum running time (among all possible algorithms that solve Π over F) in the worst case instance of size n. If the algorithm is randomized, we also require that the failure probability is at most 1/n, where n is the size of the input graph.</p><p>5 Simulating non-signaling in randomized online-LOCAL</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Framework</head><p>In this section we give the necessary framework to define the non-signaling model and is largely inspired by the definitions given in <ref type="bibr" target="#b28">[27,</ref><ref type="bibr" target="#b37">36]</ref>. Next definition introduces the concept of outcome. Definition 5.1 (Outcome). Let Σ in and Σ out be two sets of input and output labels, respectively, and let F be a family of graphs. An outcome O over F is a mapping (G, x) → {(λ (out,i) , p i )} i∈I , with I being a discrete set of indexes, assigning to every input graph G ∈ F with any input data x = (id :</p><formula xml:id="formula_21">V (G) → [|V (G)| c ], λ in : V (G) → Σ in ), a discrete probability distribution {p i } i∈I over output vectors λ (out,i) : V (G) → Σ out such that:</formula><p>1. for all i ∈ I, p i &gt; 0; 2.</p><p>i∈I p i = 1; 3. p i represents the probability of obtaining λ (out,i) as the output vector of the distributed system.</p><p>We say that an outcome O over some graph family F solves problem Π over F with probability p if, for every G ∈ F and any input data x = (id, λ in ), it holds that</p><formula xml:id="formula_22">(λ (out,i) ,p i )∈O((G,x)) : λ (out,i) ∈Π((G,λ in )) p i ≥ p.</formula><p>When p = 1, we will just say that O solves problem Π over the graph family F.</p><p>The next computational model tries to capture the fundamental properties of any physical computational model (in which one can run either deterministic, random, or quantum algorithms) that respects causality. The defining property of such a model is that, for any two (labeled) graphs (G 1 , x 1 ) and (G 2 , x 2 ) that share some identical subgraph (H, y), every node u in H must exhibit identical behavior in G 1 and G 2 as long as its local view, that is, the set of nodes up to distance T away from u together with input data and port numbering, is fully contained in H. As the port numbering can be computed with one round of communication through a fixed procedure (e.g., assigning port numbers 1, 2, . . . , deg(v) based on neighbor identifiers in ascending order) and we care about asymptotic bounds, we will omit port numbering from the definition of local view.</p><p>The model we consider has been introduced by <ref type="bibr" target="#b37">[36]</ref>. In order to proceed, we first define the non-signaling property of an outcome. Let T ≥ 0 be an integer, and I a set of indices. For any set of nodes V , subset S ⊆ V , and for any input (G = (V, E), x), we define its T -local view as the set</p><formula xml:id="formula_23">v T (G, x, S) = {(u, x(u)) | ∃ u ∈ V, v ∈ S such that dist G (u, v) ≤ T } ,</formula><p>where dist G (u, v) is the distance in G. Furthermore, for any subset of nodes S ⊆ V and any output distribution {λ (out,i) , p i } i∈I , we define the marginal distribution of {λ (out,i) , p i } i∈I on set S as the unique output distribution defined as follows: for any λ out : V (G) → Σ out , the probability of λ out ↾ S on S is given by p(λ out , S)</p><formula xml:id="formula_24">= i∈I : λout↾ S =λ (out,i) ↾ S p i ,</formula><p>where λ out ↾ S and λ (out,i) ↾ S are the restrictions of λ out and λ (out,i) on S, respectively.</p><p>Definition 5.2 (Non-signaling outcome). Let F be a family of graphs. An outcome</p><formula xml:id="formula_25">O : (G, x) → {(λ (out,i) , p i )} i∈I over F is non-signaling beyond distance T = T (G, x) if for any pair of inputs (G 1 = (V 1 , E 1 ), x 1 ), (G 2 = (V 2 , E 2 ), x 2 ), with the same number of nodes, such that v T (G 1 ,x 1 ) (G 1 , x 1 , S) is isomorphic to v T (G 1 ,x 1 ) (G 2 , x 2 , S)</formula><p>and G 1 , G 2 ∈ F, the output distributions corresponding to these inputs have identical marginal distributions on the set S.</p><p>Definition 5.2 is also the more general definition for the locality of an outcome: an outcome O has locality T if it is non-signaling beyond distance T .</p><p>The φ-LOCAL model. The φ-LOCAL model is a computational model that produces non-signaling outcomes over some family of graphs F. Let p ∈ [0, 1]. A problem Π over some graph family F has complexity T (and success probability p) if there exists an outcome O that is non-signaling beyond distance T which solves Π over F (with probability at least p), and T = T (n) is the minimum "non-signaling distance" (among all possible outcomes that solve Π over F) in the worst case instance of size n.</p><p>As every (deterministic or randomized) algorithm running in time at most T in the LOCAL model produces an outcome which has locality T , we can provide lower bounds for the LOCAL model by proving them in the φ-LOCAL model.</p><p>Notice that algorithms in the LOCAL model can be always thought as producing outputs for any input graph: when the computation at any round is not defined for some node, we can make the node output some garbage label, say ⊥. If we require that also outcomes are defined for every possible graph, then we are restricting the power of φ-LOCAL because outcomes must be defined accordingly. This gives rise to a slightly weaker model, the non-signaling model, which was considered in other works such as <ref type="bibr" target="#b28">[27]</ref> and is still stronger than any classical or quantum variation of the LOCAL model. Theorem 5.3. Let Π be any LCL problem over any family of graphs F. Let O : (G, λ in ) → {(λ (out,h) , p i )} h∈H be an outcome over F which solves Π with failure probability at most ε and is non-signaling at distance greater than T . There exists a randomized online-LOCAL algorithm A with complexity T that solves Π over F and has failure probability at most ε.</p><p>We want to design a randomized online-LOCAL algorithm A with complexity T that solves Π over F and has failure probability at most ε that somehow simulates O. We need to assume that the number of nodes of the input graph is known by A.</p><p>Fix any graph G ∈ F of n nodes and any input labeling λ in , and fix any sequence of nodes v 1 , . . . , v n the adversary might choose to reveal to the algorithm.</p><p>The adversary initially shows G[N T (v 1 )] to the algorithm (including input labels and identifiers) and asks it to label v 1 . In order for the algorithm to choose an appropriate output, it can arbitrarily choose a graph H 1 ∈ F with n nodes that contains a subgraph isomorphic to G[N T (v 1 )] (again, including input labels and identifiers). Notice that H 1 necessarily exists since G itself is such a graph. We stress that the arbitrariness in the choice of H 1 is thanks to the non-signaling property, which ensures that the restriction of the output distribution O(H 1 , λ in ) over N T (v 1 ) does not change if the topology of the graph outside G[N T (v 1 )] differs (i.e., no matter how the adversary chooses it). Indeed, if O did not have the non-signaling property, then it would be impossible to sample from it correctly since the marginal output distribution on G[N T (v 1 )] would depend on the topology of the graph beyond it, which the algorithm still has no knowledge of.</p><p>For any λ out : V (G) → Σ out , the probability that A labels v 1 with λ out (v 1 ) is</p><formula xml:id="formula_26">p(λ out , v 1 ) = k: λout↾ {v 1 } =λ (out,k) ↾ {v 1 } p k , where {(λ (out,k) , p k )} k∈K 1 = O(H 1 , λ in ).</formula><p>Let Λ i be the random variable yielding the label assigned to v i by A. In general, for any</p><formula xml:id="formula_27">λ out : V (G) → Σ out let p(λ out , v i ) denote the probability that Λ i = λ out (v i ). Assume now that G[N T (v i+1 )] is shown to the algorithm. Conditional on Λ 1 , . . . , Λ i , for any λ out : V (G) → Σ out such that λ out (v j ) = Λ j for all j = 1, . . . , i, the probability that Λ i+1 = λ out (v i+1 ) is p(λ out , v i+1 ) = k: λout↾ {v j } =λ (out,k) ↾ {v j } ∀ 1≤j≤i+1 p k 1≤l≤i p(λ out , v l )</formula><p>, where {(λ (out,k) , p k )} k∈K i+1 = O(H i+1 , λ in ) for any graph H i+1 ∈ F of n nodes that contains a subgraph isomorphic to G[∪ i+1 i=1 N T (v j )] (including input labels and identifiers). As before, H i+1 may be chosen arbitrarily due to the non-signaling property. Now consider O(G, λ in ) = {(λ (out,h) , p h )} h∈H for the right input graph G, and take any</p><formula xml:id="formula_28">(λ (out,h ⋆ ) , p h ⋆ ) ∈ O(G, λ in ).</formula><p>The probability that the outcomes of Λ 1 , . . . , Λ n give exactly λ (out,h ⋆ ) is</p><formula xml:id="formula_29">Pr Λ 1 = λ (out,h ⋆ ) (v 1 ), . . . , Λ n = λ (out,h ⋆ ) (v n ) = Pr Λ n = λ (out,h ⋆ ) (v n ) Λ 1 = λ (out,h ⋆ ) (v 1 ), . . . , Λ n-1 = λ (out,h ⋆ ) (v n-1 ) • Pr Λ n-1 = λ (out,h ⋆ ) (v n-1 ) Λ 1 = λ (out,h ⋆ ) (v 1 ), . . . , Λ n-2 = λ (out,h ⋆ ) (v n-2 )</formula><p>. . .</p><formula xml:id="formula_30">• Pr Λ 1 = λ (out,h ⋆ ) (v 1 ) = p(λ (out,h ⋆ ) , v 1 ) • . . . • p(λ (out,h ⋆ ) , v n ) = 1≤l≤n-1 p(λ out , v l ) • kn: λ (out,h ⋆ ) ↾ {v j } =λ (out,k j ) ↾ {v j } ∀ 1≤j≤n p kn 1≤l≤n-1 p(λ out , v l ) = kn: λ (out,h ⋆ ) ↾ {v j } =λ (out,k j ) ↾ {v j } ∀ 1≤j≤n p kn .</formula><p>Notice that</p><formula xml:id="formula_31">kn: λ (out,h ⋆ ) ↾ {v j } =λ (out,k j ) ↾ {v j } ∀ 1≤j≤n p kn = p h ⋆</formula><p>as H n is necessarily isomorphic to G. By the hypothesis,</p><formula xml:id="formula_32">h: λ (out,h) is valid for (G,λ in ) p h ≥ 1 -ε,</formula><p>implying that A succeeds with probability at least 1 -ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Bounded-dependence model can break symmetry</head><p>For any graph G = (V, E), a random process (or distribution) on the vertices of G is a family of random variables {X v } v∈V , indexed by V , while a random process on the edges of G is a family of random variables {X e } e∈E indexed by E. More generally, a random process on G is a family of random variables {X y } y∈V ∪E indexed by V ∪ E. The variables of a random process live in the same probability space and take values in some label set Σ. In general, we will consider random processes over vertices of graphs unless otherwise specified. We now introduce the notion of T -dependent distribution. To do so, we extend the definition of distance to edges as follows: For any two edges e = {v 1 , v 2 }, e ′ = {u 1 , u 2 } ∈ E, dist G (e, e ′ ) = min i,j∈ <ref type="bibr">[2]</ref> dist G (v i , u j ). Similarly, the distance between any edge e = (v 1 , v 2 ) and a vertex v is dist G (e, v) = min i∈ <ref type="bibr">[2]</ref> dist G (v i , v). The definition extends easily to subsets containing vertices and edges. Definition 6.1 (T -dependent distribution). Let T ∈ N be a natural number and G = (V, E) be any graph. A random process {X v } v∈V on the vertices G is said to be a T -dependent distribution if, for all subsets S, S ′ ⊆ V such that dist G (S, S ′ ) &gt; T , the two processes {X v } v∈S and {X v } v∈S ′ are independent. Analogous definitions hold for random processes on the edges of a graph and for random processes on the whole graph.</p><p>A way to define T -dependent distributions that uses the same notation of Section 5.1 is by describing the output probability of global labelings: Let I be a discrete set of indices, and G = (V, E) some graph. A distribution {(λ i , p i )} i∈I over output labelings, where λ i : V → Σ is an output labeling, is T -dependent if the following holds: for all output labelings λ in {(λ i , p i )}, for every two subsets of nodes</p><formula xml:id="formula_33">S 1 , S 2 ⊆ V (G) such that dist G (S 1 , S 2 ) &gt; T , we have that p(λ, S 1 ∪ S 2 ) = p(λ, S 1 ) • p(λ, S 2 ).</formula><p>Notice that outcomes, as defined in Definition 5.1, output a random process for every input. Often, we have a family of graphs of arbitrarily large size n on which a T (n)-dependent distribution is defined. <ref type="foot" target="#foot_0">1</ref>Now we define the hypothetical computational model that outputs T -dependent distributions on some input graph.</p><p>The bounded-dependence model. The bounded-dependence model is a computational model that, for a given family of graphs F, produces an outcome (as defined in Definition 5.1) over F that is non-signaling beyond distance T = T (G, x) (as defined in Definition 5.2), where G ∈ F and x represents the input, which, in turn, produces T (G, x)-dependent distributions. The random processes produced by an outcome are said to be finitely-dependent if T = O(1) for all graphs in F and all input data. If an outcome with the aforementioned properties solves a problem Π over a graph family F with probability at least p, we say that the pair (Π, F) has complexity T (with success probability p), and T = T (n) is the minimum dependence (among all possible distributions solving Π over F) in the worst case instance of size n. We remark that T is also called the locality or the complexity of the corresponding output distributions.</p><p>We are particularly interested in T -dependent distributions that satisfy invariance properties: We say that a random process {X v } v∈V over vertices of a graph G = (V, E) is invariant under automorphisms if, for all automorphisms f : V → V of G = (V, E), the two processes {X v } v∈V and {Y v = X f (v) } v∈V are equal in law. The definition is easily extendable to random processes on edges and random processes on the whole graph.</p><p>A stronger requirement is the invariance under subgraph isomorphism: Suppose we have an outcome O : (G, x) → {X v } v∈V (G) that maps each input graph G from family of graphs F and any input data x to a T = T (G, x)-dependent distribution over G from a family of random process R. We say that the random process over vertices in R are invariant under subgraph isomorphisms if, given any two graphs G 1 , G 2 ∈ F of size n 1 , n 2 with associated process {X</p><formula xml:id="formula_34">(1) v } v∈V (G 1 ) and {X (2) v } v∈V (G 2 )</formula><p>, and any two subgraphs</p><formula xml:id="formula_35">H 1 ⊆ G 1 , H 2 ⊆ G 2 such that G 1 [N T (n 1 ) (H 1 )] and G 2 [N T (n 2 ) (H 2 )] are isomorphic (with the isomorphism that brings H 1 into H 2 ), then {X (1) v } v∈V (H 1 ) and {X (2) v } v∈V (H 2 )</formula><p>are equal in law. <ref type="foot" target="#foot_1">2</ref> Trivially, invariance under subgraph isomorphisms implies invariance under automorphisms and the non-signaling property. This definition is again easily extendable to the case of families of random processes over edges or over graphs in general.</p><p>The baseline of our result is a finitely-dependent distribution provided by <ref type="bibr" target="#b46">[45,</ref><ref type="bibr" target="#b48">47]</ref> on paths and cycles. Theorem 6.2 (Finitely-dependent coloring of the integers and of cycles <ref type="bibr" target="#b46">[45,</ref><ref type="bibr" target="#b48">47]</ref>). Let G = (V, E) be a graph that is either a cycle with at least 2 nodes or has V = Z and E = {{i, i + 1} : i ∈ Z}. For (k, q) ∈ {(1, 4), (2, 3)}, there exists a k-dependent distribution {X (G) v } v∈V (G) that gives a q-coloring of G. Furthermore, such distributions can be chosen to meet the following properties: If {X i } i∈[n] is the k-dependent q-coloring of the n-cycle and {Y i } i∈Z is the k-dependent q-coloring of the integers, then</p><formula xml:id="formula_36">{X i } i∈[n-k] is equal in law to {Y i } i∈[n-k] . If n = 2,</formula><p>then the finitely-dependent colorings on the 2-cycle and on a path of 2 nodes are identical in distribution.</p><p>It is immediate that the disjoint union of any number of paths and cycles (even countably many) admits such distributions as well. Corollary 6.3. Let F be the family of graphs formed by the disjoint union (possibly uncountably many) paths with countably many nodes and cycles of any finite length. For all G ∈ F and for (k, q) ∈ {(1, 4), (2, 3)}, there exists a k-dependent distribution {X (G) v } v∈V (G) that gives a q-coloring of G. Furthermore, such distributions can be chosen to meet all the following properties:</p><formula xml:id="formula_37">1. On each connected component H ⊆ G, {X (G) v } v∈V (H) is given by Theorem 6.2. 2. {{X (G) v } v∈V (G) } G∈F is invariant under subgraph isomorphisms.</formula><p>We will use this result to provide "fake local identifiers" to the nodes of the graph to simulate an O(log * n)-round LOCAL algorithm through a random process with constant dependency. In order to do that, we introduce some results on the composition of T -dependent distributions.</p><p>Trivially, every T -round (deterministic or randomized) port-numbering algorithm defines a 2Tdependent distribution over the input graph. Furthermore, if the underlying port-numbering model has access to random bits, the distribution can be made invariant under subgraph isomorphisms (provided that, whenever a distribution over input labelings is given together with the input graph, such distribution is also invariant under subgraph isomorphisms). The composition of the T 2dependent distribution obtained by a T 2 -round port-numbering algorithm and any T 1 -dependent distribution yields a (2T 2 + T 1 )-dependent distribution. Lemma 6.4. Let Σ (1) and Σ (2) be two label sets with countably many labels. Let F be any family of graphs, and let R = {{X v } v∈V (G) : G ∈ F} be a family of T 1 -dependent distributions taking values in Σ (1) , where T 1 might depend on parameters of G. Consider any T 2 -round port-numbering algorithm A that takes as an input G ∈ F labelled by {X v } v∈V (G) : it defines another distribution {Y v } v∈V (G) taking values in some label set Σ (2) . Then, the following properties hold:</p><formula xml:id="formula_38">1. {Y v } v∈V (G) is a (2T 2 + T 1 )-dependent distribution on G.</formula><p>2. If the processes in R are invariant under subgraph isomorphisms, T 2 is constant, and A does not depend on the size of the input graph and permutes port numbers locally u.a.r. at round 0, then the processes in {{Y v } v∈V (G) : G ∈ F} are invariant under subgraph isomorphisms.</p><p>Proof. We prove the claim 1 first. Fix any G = (V, E) ∈ F, and the corresponding</p><formula xml:id="formula_39">T 2 -dependent distribution {X v } v∈V ∈ R. Fix any two subsets S, S ′ ⊆ V such that dist G (S, S ′ ) &gt; 2T 2 + T 1 .</formula><p>Consider any output labeling λ (2) : V → Σ (2) . Then,</p><formula xml:id="formula_40">Pr ∩ v∈S∪S ′ {Y v = λ (2) (v)} = λ (1) : V →Σ (1) Pr ∩ v∈S∪S ′ {Y v = λ (2) (v)} ∩ v∈V {X v = λ (1) (v)} • Pr ∩ v∈V {X v = λ (1) (v)} = λ (1) : V →Σ (1) Pr ∩ v∈S∪S ′ {Y v = λ (2) (v)} ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)}<label>(3)</label></formula><formula xml:id="formula_41">• Pr ∩ v∈V {X v = λ (1) (v)} = λ (1) : N T 2 (S∪S ′ )→Σ (1) Pr ∩ v∈S∪S ′ {Y v = λ (2) (v)} ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} • Pr ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} ,</formula><p>where Eq. ( <ref type="formula" target="#formula_40">3</ref>) holds because the output of</p><formula xml:id="formula_42">{Y v } v∈S∪S ′ is independent of {X v } v / ∈N T 2 (S∪S ′ ) . Since dist G (S, S ′ ) &gt; 2T 2 ,</formula><p>λ (1) : N T 2 (S∪S ′ )→Σ (1)   Pr</p><formula xml:id="formula_43">∩ v∈S∪S ′ {Y v = λ (2) (v)} ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} • Pr ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} = λ (1) : N T 2 (S∪S ′ )→Σ (1) Pr ∩ v∈S {Y v = λ (2) (v)} ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} • Pr ∩ v∈S ′ {Y v = λ (2) (v)} ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} • Pr ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} = λ (1) : N T 2 (S∪S ′ )→Σ (1) Pr ∩ v∈S {Y v = λ (2) (v)} ∩ v∈N T 2 (S) {X v = λ (1) (v)} • Pr ∩ v∈S ′ {Y v = λ (2) (v)} ∩ v∈N T 2 (S ′ ) {X v = λ (1) (v)} • Pr ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} . Now observe that dist G (N T 2 (S), N T 2 (S ′ )) &gt; T 1 . Since {X v } v∈V is a T 1 -dependent distribution, it holds that λ (1) : N T 2 (S∪S ′ )→Σ (1) Pr ∩ v∈S {Y v = λ (2) (v)} ∩ v∈N T 2 (S) {X v = λ (1) (v)} • Pr ∩ v∈S ′ {Y v = λ (2) (v)} ∩ v∈N T 2 (S ′ ) {X v = λ (1) (v)} • Pr ∩ v∈N T 2 (S∪S ′ ) {X v = λ (1) (v)} = λ (1) : N T 2 (S∪S ′ )→Σ (1) Pr ∩ v∈S {Y v = λ (2) (v)} ∩ v∈N T 2 (S) {X v = λ (1) (v)} • Pr ∩ v∈S ′ {Y v = λ (2) (v)} ∩ v∈N T 2 (S ′ ) {X v = λ (1) (v)} • Pr ∩ v∈N T 2 (S) {X v = λ (1) (v)} Pr ∩ v∈N T 2 (S ′ ) {X v = λ (1) (v)} = Pr ∩ v∈S {Y v = λ (2) (v)} • Pr ∩ v∈S ′ {Y v = λ (2) (v)} .</formula><p>We now prove claim 2. Given any G, H ∈ F of size n G and n H , respectively, consider any subgraph isomorphism f :</p><formula xml:id="formula_44">N 2T 2 +T 1 (n G ) (G ′ , G) → N 2T 2 +T 1 (n H ) (H ′ , H) for any two G ′ ⊆ G, H ′ ⊆ H such that f restricted to G ′ is an isomorphism to H ′ . Let {X (G) v } v∈V (G) and {X (H) v } v∈V (H) , and {Y (G) v } v∈V (G) and {Y (H) v</formula><p>} v∈V (H) be the corresponding distributions of interest before and after the combination with the port-numbering algorithm, respectively. Fix any subset of nodes U ⊆ V (G ′ ) and consider any family of labels {λ u } u∈U indexed by U . In order to prove property 1, it is sufficient to show that Pr</p><formula xml:id="formula_45">∩ u∈U {Y (G) u = λ u } = Pr ∩ u∈U {Y (H) f (u) = λ u } . Notice that Pr [∩ u∈U {Y u = λ u }] depends solely on the graph G[N T 2 (U, G)] = ∪ u∈U G[N T 2 (u, G)],</formula><p>the distribution of the port numbers in G[N T 2 (U, G)], and the random process </p><formula xml:id="formula_46">{X u } u∈N T 2 (U ) . By hypothesis, {X (G) u } u∈N T 2 (U,G) is equal in law to {X (H) f (u) } u∈N T 2 (U,G) . Furthermore, the restriction of f to G[N T 2 (U, G)] defines an isomorphism from G[N T 2 (U, G)] to H[N T 2 (f (U ), H)],</formula><formula xml:id="formula_47">f (u) = λ u } .</formula><p>T -dependent distributions over different graphs can be combined to obtain a T -dependent distribution over the graph union. Lemma 6.5.</p><formula xml:id="formula_48">Let {X v } v∈V 1 and {Y v } v∈V 2 be a T 1 -dependent distribution over a graph G 1 = (V 1 , E 1 )</formula><p>taking values in Σ (1) and a T 2 -dependent distribution over a graph G 2 = (V 2 , E 2 ) taking values in Σ (2) , respectively. Assume {X v } v∈V 1 and {Y v } v∈V 2 to be independent processes. Consider the graph</p><formula xml:id="formula_49">H = (V = V 1 ∪ V 2 , E = E 1 ∪ E 2 ) and a distribution {Z v } v∈V over H taking values in Σ = (Σ (1) ∪ {0}) × (Σ (2) ∪ {0}) defined by Z v =      (X v , 0) if v ∈ V 1 \ V 2 , (X v , Y v ) if v ∈ V 1 ∩ V 2 , (0, Y v ) if v ∈ V 2 \ V 1 . Then, {Z v } v∈V is max(T 1 , T 2 )-dependent. Proof. For any vector v ∈ Σ 1 × • • • × Σ n , we write v[i]</formula><p>to denote its i-th entry. Fix any output labeling λ :</p><formula xml:id="formula_50">V → Σ such that λ(v)[2] = 0 for all v ∈ V 1 \ V 2 and λ(v)[1] = 0 for all v ∈ V 2 \ V 1 .</formula><p>Observe that for any subset S ⊆ V it holds that</p><formula xml:id="formula_51">Pr [∩ v∈S {Z v = λ(v)}] = Pr [(∩ v∈S∩V 1 {X v = λ(v)[1]}) ∩ (∩ v∈S∩V 2 {Y v = λ(v)[2]})] = Pr [∩ v∈S∩V 1 {X v = λ(v)[1]}] • Pr [∩ v∈S∩V 2 {Y v = λ(v)[2]}] ,<label>(4)</label></formula><p>where the latter equality follows by independence between</p><formula xml:id="formula_52">{X v } v inV 1 and {Y v } v inV 2 . W.l.o.g., suppose T 1 ≥ T 2 . Consider two subsets S, S ′ ⊆ V such that dist G (S, S ′ ) &gt; T 1 . Fix any output labeling λ : V → Σ such that λ(v)[2] = 0 for all v ∈ V 1 \ V 2 and λ(v)[1] = 0 for all v ∈ V 2 \ V 1 .</formula><p>Using Eq. ( <ref type="formula" target="#formula_51">4</ref>), we have that</p><formula xml:id="formula_53">Pr [∩ v∈S∪S ′ {Z v = λ(v)}] = Pr ∩ v∈(S∪S ′ )∩V 1 {X v = λ(v)[1]} • Pr ∩ v∈(S∪S ′ )∩V 2 {Y v = λ(v)[2]} = Pr ∩ v∈(S∩V 1 )∪(S ′ ∩V 1 ) {X v = λ(v)[1]} • Pr ∩ v∈(S∩V 2 )∪(S ′ ∩V 2 ) {Y v = λ(v)[2]} = Pr [∩ S∩V 1 {X v = λ(v)[1]}] • Pr [∩ S ′ ∩V 1 {X v = λ(v)[1]}]<label>(5)</label></formula><p>•</p><formula xml:id="formula_54">Pr [∩ S∩V 2 {Y v = λ(v)[2]}] • Pr [∩ S ′ ∩V 2 {Y v = λ(v)[2]}] = Pr [(∩ v∈S∩V 1 {X v = λ(v)[1]}) ∩ (∩ v∈S∩V 2 {Y v = λ(v)[2]})]<label>(6)</label></formula><p>•</p><formula xml:id="formula_55">Pr [(∩ v∈S ′ ∩V 1 {X v = λ(v)[1]}) ∩ (∩ v∈S ′ ∩V 2 {Y v = λ(v)[2]})] = Pr [∩ v∈S {Z v = λ(v)}] • Pr [∩ v∈S ′ {Z v = λ(v)}] ,</formula><p>where Eq. ( <ref type="formula" target="#formula_53">5</ref>) holds because {X v } v∈V 1 is T 1 -dependent and {Y v } v∈V 2 is T 2 -dependent, while Eq. ( <ref type="formula" target="#formula_54">6</ref>) holds because {X v } v∈V 1 and {Y v } v∈V 2 are independent. Now we present a final lemma on the composition of random processes. To do so, we first introduce the notation of random decomposition of a graph. Definition 6.6 (Random decomposition). Let G = (V, E) be any graph and P a family of subgraphs of G. For any k ∈ N, let Γ(G) be a random variable taking values in P k that is sampled according to any probability distribution. We say that Γ(G) is a random k-decomposition of G in P.</p><p>Given a random k-decomposition Γ(G) of G in P, for any y ∈ V ∪ E, we define the random variable Γ(G) y ∈ {0, 1} k as follows: Γ(G) y [i] = 1 if y belongs to Γ(G)[i] and 0 otherwise. Notice that {Γ(G) y } y∈V ∪E is a random process on G. If {Γ(G) y } y∈V ∪E is invariant under automorphisms, then we say that the random k-decomposition Γ(G) is invariant under automorphisms. If, for a family of graphs F and any graph G ∈ F, {Γ(G) y } y∈V (G)∪E(G) is T -dependent (with T being a function of the size of G) and the processes in {{Γ(G) y } y∈V (G)∪E(G) : G ∈ F} are invariant under subgraph isomorphisms, then we say that the random k-decompositions in {Γ(G) : G ∈ F} are T -dependent and invariant under subgraph isomorphisms.</p><p>For a random decomposition, we define the notion of induced random process.</p><p>Definition 6.7 (Induced process). Let G = (V, E) be a graph that admits a family of subgraphs P. Suppose there exists a random process {X v } v∈V (H(P)) with H(P) being the graph obtained by the disjoint union of all elements of P. Let Γ(G) be a random k-decomposition of G in P. For all v ∈ V and G ′ ∈ P, define the random process {X</p><formula xml:id="formula_56">(G ′ ) v } v∈V by setting X (G ′ ) v = X f G ′ (v) for all v ∈ V (G ′ ),</formula><p>where</p><formula xml:id="formula_57">f G ′ : V (G ′ ) → V (H(P)) is the natural immersion of G ′ into H(P) otherwise set X (G ′ ) v = 0. Let {Y (Γ(G)) v</formula><p>} v∈V be a random process that we define conditional on the output of Γ(G): for all</p><formula xml:id="formula_58">G ∈ P k , conditional on Γ(G) = G, Y (Γ(G)) v = Y (G) v = (X (G[1]) v , . . . , X (G[k]) v ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The random process {Y (Γ(G)) v</head><p>} v∈V on G is said to be induced by the action of {X v } v∈V (H(P)) over the random k-decomposition Γ(G). Now we present a result on the induced random process whenever the random decomposition and the family of random processes that acts on the random decomposition meet some invariance properties. Lemma 6.8. Let F be a family of graphs. For any G = (V, E) ∈ F, let P G be any family of subgraphs of G that is closed under node removal and disjoint graph union, that is, if } v∈V (G) be the random process induced by the action of</p><formula xml:id="formula_59">G 1 , G 2 ∈ P G and V (G 1 ) ∩ V (G 2 ) = ∅, then G 1 ∪ G 2 ∈ P G . Furthermore, suppose that, for each pair of isomorphic subgraphs G 1 , G 2 ⊆, G 1 ∈ P G =⇒ G 2 ∈ P G . Moreover, let Γ(G) be a random k-decomposition of G in P G that is T 1 -dependent,</formula><formula xml:id="formula_60">{X v } v∈V (H(P G )) over Γ(G). Then, {Y (Γ(G)) v } v∈V (G) is a (T 1 + 2T 2 )-dependent distribution. Furthermore, the processes in {{X v } v∈V (H(P G )) : G ∈ F} are invariant under subgraph isomorphism.</formula><p>Proof. Fix G ∈ F and let Γ = Γ(G), P = P G . Since P k might be uncountable, we consider the density function f Γ and the probability measure P associated to Γ. Consider two subsets of nodes S, S ′ ⊆ V at distance at least max(T 1 , T 2 ) + 1. Fix any labeling λ :</p><formula xml:id="formula_61">V → Σ k . It holds that Pr ∩ v∈S∪S ′ {Y (Γ) v = λ(v)} = P k Pr ∩ v∈S∪S ′ {Y (Γ) v = λ(v)} Γ = G f Γ (G) dP (7) = P k Pr ∩ v∈S∪S ′ {Y (G) v = λ(v)} f Γ (G) dP = P k Pr ∩ v∈S {Y G v = λ(v)} Pr ∩ v∈S ′ {Y G = λ(v)} f Γ (G) dP (8) = P k i∈[k] Pr ∩ v∈S {X G[i] v = λ(v)[i]} Pr ∩ v∈S ′ {X G[i] v = λ(v)[i]} f Γ (G) dP ,<label>(9)</label></formula><p>where Eq. ( <ref type="formula">7</ref>) holds by the law of total probability, Eq. ( <ref type="formula">8</ref>) holds since {Y</p><formula xml:id="formula_62">(G) v</formula><p>} v∈V is T 2 -dependent for all G ∈ P k by Lemma 6.5, and Eq. ( <ref type="formula" target="#formula_61">9</ref>) holds since {X</p><formula xml:id="formula_63">G[i] v } v∈V and {X G[j] v } v∈V are independent if i ̸ = j. Notice that, for any set S ⊆ V , G ′ = G[i][N T 2 (S, G[i])] ∈ P and the event ∩ v∈S {X G[i] v = λ(v)[i]} has the same probability as ∩ v∈S {X G ′ v = λ(v)[i]} because {X v } v∈V (H(P)) is invariant under subgraph isomorphisms.</formula><p>For any subset U ⊆ V and any integer T ≥ 0, let</p><formula xml:id="formula_64">H(T, U ) = (G[1][N T (U, G[1])], . . . , G[k][N T (U, G[k])]) G ∈ P k ⊆ P k ,</formula><p>and let P[H(T, U )] be the restriction of P to H(T, U ) defined as follows: for any event E,</p><formula xml:id="formula_65">P[H(T, U )](E) = P(E ∩ H(T, U ))/P(H(T, U )).</formula><p>Finally, define the random variable Γ (T,U ) to be a k-dimensional vector, taking values in H(T, U ), whose i-th entry is</p><formula xml:id="formula_66">Γ[i][N T (U, Γ[i])],</formula><p>and let f Γ (T,U ) be its density function. Define U = S ∪ S ′ : Eq. ( <ref type="formula" target="#formula_61">9</ref>) becomes</p><formula xml:id="formula_67">P k i∈[k] Pr ∩ v∈S {X G[i] v = λ(v)[i]} Pr ∩ v∈S ′ {X G[i] v = λ(v)[i]} f Γ (G) dP<label>(10)</label></formula><p>=</p><formula xml:id="formula_68">H(T 2 ,U ) i∈[k] Pr ∩ v∈S {X H[i] v = λ(v)[i]} Pr ∩ v∈S ′ {X H[i] v = λ(v)[i]} f Γ (T 2 ,U ) (H) dP[H(T 2 , U )] .</formula><p>Now notice that, since the random decomposition Γ is T 1 -dependent and dist G (S, S ′ ) &gt; T 1 + 2T</p><p>2 , the probability space H(T 2 , U ) (with measure P[H(T 2 , U )]) is isomorphic to the product space H(T 2 , S) × H(T 2 , S ′ ) (with product measure P[H(T 2 , S)] × P[H(T 2 , S ′ )]). The isomorphism brings any element</p><formula xml:id="formula_69">(G[1][N T 2 (U, G[1])], . . . , G[k][N T 2 (U, G[k])]) of H(T 2 , U ) into (G[1][N T 2 (S, G[1])], . . . , G[k][N T 2 (S, G[k])]), (G[1][N T 2 (S ′ , G[1])], . . . , G[k][N T 2 (S ′ , G[k])])</formula><p>which belongs to H(T 2 , S) × H(T 2 , S ′ ). Hence, we get</p><formula xml:id="formula_70">H(T 2 ,U ) i∈[k] Pr ∩ v∈S {X H[i] v = λ(v)[i]} Pr ∩ v∈S ′ {X H[i] v = λ(v)[i]} f Γ (T 2 ,U ) (H) dP[H(T 2 , S)] = H(T 2 ,S) H(T 2 ,S ′ ) i∈[k] Pr ∩ v∈S {X H[i] v = λ(v)[i]} Pr ∩ v∈S ′ {X H[i] v = λ(v)[i]} • f Γ (T 2 ,S) (H 1 )f Γ (T 2 ,S ′ ) (H 2 ) dP[H(T 2 , S)] dP[H(T 2 , S ′ )] .</formula><p>The latter becomes</p><formula xml:id="formula_71">H(T 2 ,S) H(T 2 ,S ′ ) i∈[k] Pr ∩ v∈S {X H[i] v = λ(v)[i]} Pr ∩ v∈S ′ {X H[i] v = λ(v)[i]} • f Γ (T 2 ,S) (H 1 )f Γ (T 2 ,S ′ ) (H 2 ) dP[H(T 2 , S)] dP[H(T 2 , S ′ )] = H(T 2 ,S) i∈[k] Pr ∩ v∈S {X H[i] v = λ(v)[i]} f Γ (T 2 ,S) (H 1 ) dP[H(T 2 , S)] • H(T 2 ,S ′ ) i∈[k] Pr ∩ v∈S ′ {X H[i] v = λ(v)[i]} f Γ (T 2 ,S ′ ) (H 2 ) dP[H(T 2 , S ′ )] = P k i∈[k] Pr ∩ v∈S {X G[i] v = λ(v)[i]} f Γ (G) dP<label>(11)</label></formula><p>•</p><formula xml:id="formula_72">P k i∈[k] Pr ∩ v∈S ′ {X G[i] v = λ(v)[i]} f Γ (G) dP = Pr ∩ v∈S {Y (Γ(G)) v = λ(v)} Pr ∩ v∈S ′ {Y (Γ(G)) v = λ(v)} ,</formula><p>where Eq. ( <ref type="formula" target="#formula_71">11</ref>) follows by the same reasoning as for Eq. ( <ref type="formula" target="#formula_67">10</ref>) but in reverse. Now we want to prove that {{Y</p><formula xml:id="formula_73">(Γ(G)) v</formula><p>} v∈V : G ∈ F} is invariant under subgraph isomorphism. Fix any two graphs G, H ∈ F of sizes n G and n H , respectively. Consider any isomorphism α between the radius-(T 1 (n G ) + 2T 2 (n G )) neighborhoods of any subgraph G ′ ⊆ G and the radius-</p><formula xml:id="formula_74">(T 1 (n H ) + 2T 2 (n H )) neighborhoods of any subgraph H ′ ⊆ H, such that the restriction of α to G ′ is an isomorphism to H ′ . With an abuse of notation, for any subgraph K ⊆ G ′ , let us denote α(K) ⊆ H ′ its isomorphic image in H ′ through α. Let T G = T 1 (n G ) + 2T 2 (n G ) and T H = T 1 (n H ) + 2T 2 (n H ). Fix any labeling λ : V → Σ k . We have that Pr ∩ v∈V (G ′ ) {Y (Γ(G)) v = λ(v)} = P k G Pr ∩ v∈V (G ′ ) {Y (Γ(G)) v = λ(v)} Γ(G) = G f Γ(G) (G) dP G . = P k G Pr ∩ v∈V (G ′ ) {Y (G) v = λ(v)} f Γ(G) (G) dP G = P k G i∈[k] Pr ∩ v∈V (G ′ ) {X (G[i]) v = λ(v)[i]} f Γ(G) (G) dP G = H G (T G ,V (G ′ )) i∈[k] Pr ∩ v∈V (G ′ ) {X (H[i]) v = λ(v)[i]} f Γ(G) (T G ,V (G ′ )) (H) dP G (H G (T G , V (G ′ ))) = H G (T G ,V (G ′ )) i∈[k] Pr ∩ v∈V (G ′ ) {X (α(H[i])) α(v) = λ(v)[i]} f Γ(G) (T G ,V (G ′ )) (H) dP G (H G (T G , V (G ′ ))) ,</formula><p>where the latter holds because</p><formula xml:id="formula_75">Pr ∩ v∈V (G ′ ) {X (H[i]) v = λ(v)[i]} = Pr ∩ v∈V (G ′ ) {X (α(H[i])) α(v) = λ(v)[i]} as {{X v } v∈V (H(P G )) : G ∈ F} is T 2 -dependent</formula><p>and invariant under subgraph isomorphism. Furthermore, since the processes in {Γ(G) : G ∈ F} are T 1 -dependent and invariant under subgraph isomorphism, we have that f</p><formula xml:id="formula_76">Γ(G) (T G ,V (G ′ )) (H) = f Γ(H) (T H ,V (H ′ )) ((α(H[1]), . . . , α(H[k]))) almost everywhere in H G (T G , V (G ′ ))</formula><p>, and that the probability space</p><formula xml:id="formula_77">H G (T G , V (G ′ )) with measure dP G (H G (T G , V (G ′ ))) is isomorphic to H H (T H , V (H ′ )) with measure dP H (H H (T H , V (H ′ )))</formula><p>, where the isomorphism brings</p><formula xml:id="formula_78">H into (α(H[1]), . . . , α(H[k])). Hence, H G (T G ,V (G ′ )) i∈[k] Pr ∩ v∈V (G ′ ) {X (α(H[i])) α(v) = λ(v)[i]} f Γ(G) (T G ,V (G ′ )) (H) dP G (H G (T G , V (G ′ ))) = H H (T H ,V (H ′ )) i∈[k] Pr ∩ v∈V (H ′ ) {X (H[i]) v = λ(v)[i]} f Γ(H) (T H ,V (H ′ )) (H) dP H (H H (T H , V (H ′ ))) = Pr ∩ v∈V (H ′ ) {Y (Γ(H)) v = λ(v)} ,</formula><p>concluding the proof.</p><p>Remark 6.9. When the underlying graph is a directed graph, Lemma 6.8 guarantees invariance under subgraph isomorphisms that keep edge orientation.</p><p>We are going to work on rooted pseudotrees and pseudoforests. A pseudotree is a graph that is connected and contains at most one cycle. A pseudoforest is a graph obtained by the disjoint union of pseudotrees; an equivalent definition of pseudoforest is a graph in which each connected component has no more edges than vertices. Note that a pseudotree might contain multiple edges: however, we assume it does not contain self-loops as self-loops are useless communication links in the LOCAL model. A rooted tree is a tree where each edge is oriented and all nodes have outdegree at most 1: it follows that all but one node have outdegree exactly 1 and one node (the root) has outdegree 0. Trivially, a tree can be rooted by selecting one node and orienting all edges towards it. A rooted pseudotree is a pseudotree where each edge is oriented and each node has outdegree at most 1: if the pseudotree contains a cycle, then all nodes necessarily have outdegree exactly 1. Any pseudotree can be oriented so that it becomes rooted: just orient the cycle first (if it exists) in a consistent way, then remove it, and make the remaining trees rooted at nodes that belonged to the cycle. A rooted pseudoforest is the union of rooted pseudotrees.</p><p>We will show that pseudoforests of maximum degree ∆ admit a O(log * ∆)-dependent 3-coloring distributions. In order to do so, we use a color reduction technique that follows by known revisions of the Cole-Vishkin technique <ref type="bibr" target="#b30">[29,</ref><ref type="bibr" target="#b43">42]</ref>. Lemma 6.10 (port-numbering algorithm for color reduction in pseudoforests <ref type="bibr" target="#b30">[29,</ref><ref type="bibr" target="#b43">42]</ref>). Let G be a pseudoforest with countably many nodes. Assume G is given as an input a k-coloring for some k ≥ 3. There exists a deterministic port-numbering algorithm that does not depend on the size of G and outputs a 3-coloring of G in time O(log * k). Now we are ready to prove our result on pseudoforests. Lemma 6.11 (Finitely-dependent coloring of rooted pseudoforests). Let F be a family of rooted pseudoforests of countably many nodes of maximum degree ∆. Then, there exists an outcome that associates to each graph G ∈ F a O(log * ∆)-dependent distribution on the vertices of G that gives a 3-coloring of G. Furthermore, the family of distributions outputted by the outcome are invariant under subgraph isomorphisms.</p><p>Proof. Let us fix the rooted pseudoforest G ∈ F. Let P G be the family of all subgraphs of G formed by the disjoint union of directed paths and cycles. Notice that P G is closed under node removal and disjoint graph union. Furthermore, for any two pair of isomorphic subgraphs</p><formula xml:id="formula_79">G 1 , G 2 ⊆ G, G 1 ∈ P G =⇒ G 2 ∈ P G .</formula><p>Let H(P G ) be the graph formed by the disjoint union of a copy of each element of P G . By Corollary 6.3, H(P G ) admits a 1-dependent 4-coloring distribution {X v } v∈H(P G ) (with colors in <ref type="bibr" target="#b5">[4]</ref>), such that {{X v } v∈H(P G ) : G ∈ F} is invariant under subgraph isomorphism. Consider now a (non-proper) coloring of the pseudoforest in which each node u colors its indegree neighbors with a permutation of {1, . . . , indeg(u)} sampled uniformly at random: if a node has outdegree zero, then it is deterministically colored with color 1. Such a coloring is described by a 2-dependent distribution {Z v } v∈V that is (trivially) invariant under subgraph isomorphisms that keep edge orientation. Also, {Z v } v∈V identifies ∆ in disjoint random subset of nodes V 1 , . . . , V ∆ in , where nodes in V i are colored with the color i, and ∆ in is the maximum indegree of the graph.</p><formula xml:id="formula_80">Let Γ(G) = (G[V 1 ], . . . , G[V ∆ in ])</formula><p>, where Γ(G)[i] is the random graph induced by V i . Furthermore, observe that, the output of Γ(G)[i] is the disjoint union of oriented paths and/or oriented cycles, with Γ(G)[i] being the i-th entry of the ∆ in -tuple Γ(G) (see Fig. <ref type="figure" target="#fig_0">1</ref>). Notice that process Γ(G) is 2-dependent and is a random ∆ in -decomposition of G in P G (according to Definition 6.6), such that the random decompositions in {Γ(G) : G ∈ F} are invariant under subgraph isomorphism. By Lemma 6.8, the random process {Y</p><formula xml:id="formula_81">(Γ(G)) v } v∈V , that is induced by the action of {X v } v∈H(P G ) over the random ∆ in -decomposition Γ(G) (according to Definition 6.7), is a 4-dependent distribution that gives a 4∆ in -coloring of G: in fact, Γ(G)[i] and Γ(G)[j] are disjoint if i ̸ = j, hence only one entry of Y (Γ(G)) v is non-zero, for all v ∈ V . We then combine {Y (Γ(G)) v</formula><p>} v∈V and a modified version of the port-numbering algorithm from Lemma 6.10 where at round 0 each node permutes port numbers locally u.a.r.: by Lemma 6.4, we obtain an O(log * ∆)-dependent 3-coloring distribution {Q</p><formula xml:id="formula_82">(G) v } v∈V (G) of G such that processes in {{Q (G) v } v∈V (G) : G ∈ F} are invariant under subgraph isomorphisms.</formula><p>Our finitely-dependent coloring of pseudoforests can be used as a baseline to provide a (∆ + 1)coloring of graphs with maximum degree ∆. The tool we use is again an application of the Cole-Vishkin color reduction technique <ref type="bibr" target="#b57">[56]</ref>. Lemma 6.12 (port-numbering algorithm for color reduction of general graphs <ref type="bibr" target="#b57">[56]</ref>). Let G = (V, E) be a graph with maximum degree ∆ and countably many nodes. Suppose G is given in input a k-coloring  Figure <ref type="figure" target="#fig_1">2</ref>: A decomposition of a graph of maximum degree ∆ = 5 in rooted pseudoforests: for the sake of image clarity, we focus on the undirected case. In Fig. <ref type="figure" target="#fig_11">2a</ref>, each node v rearranges its port-numbers with a uniformly sampled permutation of the elements in [deg(v)]. As shown in Fig. <ref type="figure" target="#fig_11">2b</ref>, edges hosting port number i at some endpoint are oriented away from that port (in case both endpoints host port number i, the edge is duplicated) and form a rooted pseudoforest.</p><p>for some k ≥ ∆ + 1. There exists a deterministic port-numbering algorithm that does not depend on the size of the input graph and outputs a</p><formula xml:id="formula_83">(∆ + 1)-coloring of G in time O log * k + √ ∆ log ∆ .</formula><p>We first present a corollary of Lemma 6.12 where we characterize the combination of an input finitely-dependent coloring distribution and the port-numbering color-reduction algorithm. Corollary 6.13. Let G = (V, E) be a graph with maximum degree ∆ and countably many nodes. Let {X v } v∈V be a T -dependent distribution that gives a k-coloring of G, with k ≥ ∆+1. Then there exists a distribution Y vv∈V that gives a (∆ + 1)-coloring of G and is</p><formula xml:id="formula_84">O log * k + √ ∆ log ∆ + T -dependent. Furthermore, if {X v } v∈V is invariant under subgraph isomorphism, then so it is {Y v } v∈V .</formula><p>Proof. We combine the distribution {X v } v∈V with a modified version of the port-numbering algorithm from Lemma 6.12 where at round 0 each node permutes port numbers locally u.a.r.: Lemma 6.4 implies the existence of an <ref type="bibr">Lemma 6.4</ref> implies that {Y v } v∈V has the same property. Lemma 6.14 (Finitely-dependent coloring of bounded-degree graphs). Let F be a family of graphs of countably many nodes and maximum degree ∆. Then, there exists an outcome that associates to each graph G ∈ F an O( √ ∆ log ∆)-dependent distribution on the vertices of G that gives a (∆ + 1)-coloring of G. Furthermore, the family of distributions outputted by the outcome are invariant under subgraph isomorphisms.</p><formula xml:id="formula_85">O log * k + √ ∆ log ∆ + T -dependent (∆ + 1)-coloring distribution of G. If {X v } v∈V is invariant under subgraph isomorphism,</formula><p>Proof. Let us fix G = (V, E) ∈ F First, if G is not directed, then duplicate each edge and give to each pair of duplicates different orientations. Since a coloring of the original graph is a proper coloring if and only if the same coloring is proper in the directed version, w.l.o.g., we can assume G to be directed.</p><p>Let P G be a family of all subgraphs of G formed by rooted pseudotrees and disjoint union of rooted pseudotrees. Notice that P G is closed under node removal and disjoint graph union. Furthermore, for any two pair of isomorphic subgraphs</p><formula xml:id="formula_86">G 1 , G 2 ⊆ G, G 1 ∈ P G =⇒ G 2 ∈ P G .</formula><p>The graph H(P G ) that is the disjoint union of all elements of copies of each P G is a rooted pseudoforest of maximum degree ∆ and, by Lemma 6.11, admits a 3-coloring O(log * ∆)-dependent distribution {X v } v∈H(P G ) such that processes in {{X v } v∈H(P G ) : G ∈ F} are invariant under subgraph isomorphism. Now, consider a process in which each node v samples uniformly at random a permutation of a port numbering from {1, . . . , outdeg(v)} for its outgoing edges. For each i ∈ [∆ out ], consider the graph G i induced by edges that host port i: notice that G i is a rooted pseudoforest as each node has at most one out-edge with port i. If a node has degree 0, it deterministically joins G 1 , which remains a pseudoforest. The random choice of port numbering defines a random variable Γ ∈ P k G , where Γ[i] is the graph induced by port number i: according to Definition 6.6, we obtain a random ∆ out -decomposition Γ(G) of G in P G which is 2-dependent (by construction): also, the random decompositions in {Γ(G) : G ∈ F} are invariant under subgraph isomorphisms. For an example of a possible output of the random decomposition, see Fig. <ref type="figure" target="#fig_1">2</ref>.</p><p>Hence, the random process {Y</p><formula xml:id="formula_87">(Γ(G)) v</formula><p>} v∈V from Definition 6.7 is well defined, and provides a proper 3 ∆ -coloring of G. By Lemma 6.8, the random process {Y</p><formula xml:id="formula_88">(Γ(G)) v } v∈V is O(log * ∆)-dependent and, when G ∈ F varies, the processes {Y (Γ(G)) v</formula><p>} v∈V are invariant under subgraph isomorphisms. By Corollary 6.13 we obtain an O( √ ∆ log ∆)-dependent (∆ + 1)-coloring distribution on G that is invariant under subgraph isomorphism (as G ∈ F varies). Lemma 6.14 answers an open question posed by Holroyd <ref type="bibr" target="#b45">[44]</ref>. (See also Corollary 1.3 and the discussion around it.) Corollary 6.15. Let G = (V, E) be the infinite d-regular tree. There exists a finitely-dependent distribution giving a (d + 1)-coloring of G that is invariant under automorphisms.</p><p>Proof. Finding a (d + 1)-coloring of any d-regular tree has complexity O(1) in SLOCAL; the coloring can just be performed greedily. Lemma 6.14 yields the desired result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consider any graph</head><formula xml:id="formula_89">G = (V, E). For any k ∈ N + , a distance-k coloring of G is an assignment of colors c : V → Σ such that, for each node v ∈ V , all nodes in N k (v) \ {v} = {u ∈ V : dist G (u, v) ≤ k} \ {v} have colors that are different from c(v).</formula><p>It is well known that any LCL problem Π that has complexity O(log * n) in the LOCAL model has the following property: there exists a constant k ∈ N + (that depends only on the hidden constant in O(log * n)) such that, if the input graph is given a distance-k coloring, then Π is solvable in time O(1) in the port-numbering model <ref type="bibr" target="#b21">[20]</ref>. Furthermore, no knowledge of the size of the input graph is required. Theorem 6.16. Consider any LCL problem Π with checking radius r that has complexity T ≥ r in the LOCAL model over a family F of graphs with maximum degree ∆, where T = O(log * n) for input graphs of size n. For each G ∈ F, there exists an</p><formula xml:id="formula_90">O(f (∆))-dependent distribution {Y (G) v } v∈V (G)</formula><p>that solves Π over G. Furthermore, the processes in {{Y</p><formula xml:id="formula_91">(G) v } v∈V (G) : G ∈ F} are invariant under subgraph isomorphisms.</formula><p>Proof. Fix G ∈ F of size n. As said before, there exists a constant k ∈ N + (that depends only on the description of the Π) such that, if the input graph is given a distance-k coloring, then Π is solvable in time O(1) (hiding some dependence on ∆) in the port-numbering model <ref type="bibr" target="#b21">[20]</ref>. Furthermore, no knowledge of the size of the input graph is required. Consider the power graph G k , where k ≥ T , defined by</p><formula xml:id="formula_92">G k = {V, E k } with E k = {{u, v} : u, v ∈ V, dist G (u, v) ≤ k}. The maximum degree of G k is ∆ k . By Lemma 6.14, G k admits an O k∆ k log ∆ -dependent (∆ k + 1)-coloring distribution {X v } v∈V</formula><p>that is invariant under subgraph isomorphisms (as G ∈ F varies). Notice that such a coloring provides a distance-k coloring for G.</p><p>Let A be the algorithm in port-numbering model that solves Π in time O(1) while given the distance-k coloring in input. Consider a port-numbering algorithm A ′ that simulates A and is defined as follows: At round 0, A ′ permutes ports locally u.a.r. Then, A ′ simply simulates A using identifiers given by the distance-k coloring and properly solves Π by the hypotheses. Notice that {Y v } v∈V , that is, the random process induced by combining {X v } v∈V and A ′ is a O(f (∆))-dependent distribution on G by Lemma 6.4 with the required invariance properties, and we get the thesis by choosing k = T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Simulation of online-LOCAL in SLOCAL for rooted trees</head><p>In this section, we show how to turn an online-LOCAL algorithm solving an LCL problem in rooted forests into a deterministic SLOCAL algorithm solving the same problem. More concretely, we prove the following theorems: Theorem 7.1. Let Π be an LCL problem with degree constraint ∆, input label set Σ in , output label set Σ out , and checking radius r &gt; 0. In addition, let A be an online-LOCAL algorithm solving Π with locality T (n) over rooted forests. Then the following holds:</p><p>1. If A is deterministic, then there exists a deterministic SLOCAL algorithm solving Π with locality O(r) + T (2 O(n 3 ) ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">If</head><p>A is randomized and has success probability p(n) &gt; 0, then there exists a deterministic</p><formula xml:id="formula_93">SLOCAL algorithm solving Π with locality O(r) + T (2 O(n 3 ) + 2 O(2 n 2 ) • log 1 p(n)</formula><p>). Theorem 7.1 implies that any randomized online-LOCAL algorithm with locality o(log log log n) solving an LCL Π over rooted trees can be turned into an SLOCAL algorithm solving Π with locality o(log n). Next theorem shows that, over rooted trees, the class of LCL problems with complexity o(log n) is the same as that of LCL problems with complexity O(1). Theorem 7.2. Let A be an SLOCAL algorithm solving an LCL problem Π that runs with locality o(log ∆ n) over rooted forests of maximum degree ∆ and n nodes. Then, there exists an SLOCAL algorithm B solving Π with locality O(1).</p><p>It is folklore that any O(1)-round SLOCAL algorithm solving an LCL can be turned into an O(log * n)-round LOCAL algorithm solving the same LCL, implying the thesis of Theorem 1.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Amnesiac online-LOCAL algorithms</head><p>We start by formalizing what an online-LOCAL algorithm sees when run for a fixed number of steps on a graph. We then define formally what we mean by amnesiac algorithms: Definition 7.3 (Partial online-LOCAL run of length ℓ). Let G be a graph with an ordering of nodes v 1 , v 2 , . . . , v n . Consider the subgraph G ℓ ⊆ G induced by the radius-T neighborhoods of the first ℓ nodes v 1 , . . . , v ℓ . We call (G ℓ , (v 1 , . . . , v ℓ )) the partial online-LOCAL run of length ℓ of G as this is exactly the information that an online-LOCAL algorithm would know about G when deciding the output for node v ℓ .</p><p>We denote by the pair ( Ḡℓ , (w 1 , . . . , w k )) where Ḡℓ ⊆ G ℓ is the connected component containing v ℓ , and (w 1 , . . . , w k ) is the maximal subsequence of (v 1 , . . . , v ℓ ) of nodes that belong to Ḡℓ . In such case, k is the length of (G ℓ , (v 1 , . .</p><formula xml:id="formula_94">. , v ℓ ))[v ℓ ]. Trivially, w k = v ℓ .</formula><p>If (G ℓ , (v 1 , . . . , v ℓ ))[v ℓ ] = (G ℓ , (v 1 , . . . , v ℓ )), then we say that (G ℓ , (v 1 , . . . , v ℓ )) is a partial onecomponent online-LOCAL run of length ℓ of G. In such case, we call v ℓ the center of the neighborhood.</p><p>Finally, we denote by G - ℓ the disjoint set of partial one-component online-LOCAL runs formed by v 1 , . . . , v ℓ-1 , that is, one step shorter than G ℓ ; this is exactly the information that an online-LOCAL algorithm knows before labeling node v ℓ when (G ℓ , (v 1 , . . . , v ℓ )) is a partial one-component online-LOCAL run. Definition 7.4 (Amnesiac algorithm). Let A be a deterministic online-LOCAL algorithm, and let us fix the number of nodes to be n. We say that A is amnesiac if the following condition is met:</p><p>Consider any two graphs G, H of n nodes and any adversarial orderings of the nodes (v 1 , . . . , v n ) (for G) and (u 1 , . . . , u n ) (for H). Fix any pair (i, j) ∈ [n] 2 of indices such that</p><formula xml:id="formula_95">(G i , (v 1 , . . . , v i ))[v i ] = ( Ḡi , (v ′ 1 , . . . , v ′ k )) and (H j , (u 1 , . . . , u j ))[u j ] = ( Hi , (u ′ 1 , . . . , u ′ k ))</formula><p>and are isomorphic (with the isomorphism being order-preserving, i.e., bringing v ′ h into u ′ h , for all h ∈ [k]). Then the outputs of u i and v j coincide. Intuitively, A is amnesiac if the output of A for some node v depends only on the local connected component of the partial online local run and not anything else the algorithm has seen.</p><p>In general, an online-LOCAL algorithm uses global memory and hence it is not amnesiac. and the whole construction needs to work for all up to g = 2 n 2 |Σ in | n different partial one-component online-LOCAL runs, the total probability of finding a good label in all N ℓ , ℓ ∈ [n], is at least q gn 2 . This probability is minuscule, but we can boost it by increasing the size of the construction by considering</p><formula xml:id="formula_96">k = 1 + q -2 n 2 |Σ in | n n 2 log 1 p(n)</formula><p>disjoint copies of the simulation graph independently. Letting N be the size of a single simulation graph, kN is then the size of the whole experiment. Since N = 2 O(n 3 ) in Lemma 7.5, we have</p><formula xml:id="formula_97">kN = 2 O(n 3 ) + 2 O(2 n 2 ) log 1 p(n) .</formula><p>The probability that each simulation graph does not contain all the necessary good labels in all layers is at most</p><formula xml:id="formula_98">1 -q gn 2 k ≤ e -kq gn 2 = e -kq 2 n 2 |Σ in | n n 2 &lt; p(n).</formula><p>Since the success probability of A is p(n), by the inclusion-exclusion principle, we get positive probability that least one simulation graph in the experiment contains all the necessary good labels and, in addition, A does not fail on it. We show that the probability of sampling a good component is indeed at least q = 1/(2|Σ out | ). Consider the components in phase ℓ. For each component type, there are at least N ℓ /|Σ out | that are good. By the calculations in the proof of Lemma 7.5, future layers will use at most N ℓ /(2|Σ out | ) of them. Hence, after each step, at least 1/(2|Σ out | ) = q fraction of the components are still good and unused, as desired.</p><p>We finish the proof by showing that there indeed exists an amnesiac algorithm A ′ as in the claim. As argued above, our experiment succeeds with positive probability. After fixing the randomness f : V (H) → {0, 1} N of the algorithm A, we obtain a uniquely defined deterministic online-LOCAL algorithm A[f ] that behaves exactly as A when given the random bit string f as input. In particular, for such f , the following holds:</p><p>1. There exists a simulation graph with the necessary number of good labels in all layers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A[f ]</head><p>does not fail on the aforementioned simulation graph. Now the amnesiac algorithm B works as follows: Since there are finitely many possible simulation graphs and finitely many behaviors of A[f ] (for all possible f ), B executes a preprocessing phase in which it goes over all possible simulation graphs and tries all possible deterministic online-LOCAL algorithms (according to some ordering, e.g., lexicographical in the description) until it finds the pair with the properties 1 and 2 above. We take such pair and use the labeling for that component as the base for our amnesiac algorithm. Proceeding as in the proof of Theorem 7.1, we then obtain an amnesiac algorithm that has locality</p><formula xml:id="formula_99">T 2 O(n 3 ) + 2 O(2 n 2 ) log 1 p(n) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">From online-LOCAL to SLOCAL</head><p>We first show how the SLOCAL model can nicely "partition" a rooted forest. The idea is not new and comes from <ref type="bibr" target="#b24">[23,</ref><ref type="bibr">Section 7]</ref> where it is directly applied to the LOCAL model; we present here an adaptation to SLOCAL. The definition of rooted forest is given in Section 6. For a rooted forest G = (V, E) and each node v ∈ V , we denote by G v the subtree of G that is rooted at v. A root-to-leaf path v 0 v 1 . . . v k , where v i ∈ V for all i ∈ {0, 1, . . . , k}, is a path of a rooted tree such that (v i , v i-1 ) is an edge for all i ∈ [k]: we say that the path starts at v 0 and ends at v k .</p><p>Definition 7.7 ((α, β)-clustering of rooted trees). Let G = (V, E) be a rooted forest. An (α, β)clustering of G is a subset L ⊆ V of leader nodes that contains the root and is such that, for each v ∈ L, the following properties are met:</p><p>1. G v does not contain elements of L at levels 1, . . . , α -1.</p><p>2. Each maximal oriented path in G v contains exactly one element u ∈ L such that dist Gv (u, v) ∈ [α, β], unless the length of the maximal oriented path is at most β -1, in which case there is at most one element of L in the path (and possibly none).</p><p>A cluster is a maximally connected component of non-leader nodes. A closed cluster is a cluster together with its adjacent leader nodes. See Fig. <ref type="figure" target="#fig_9">3</ref> for an example.</p><p>We will combine many SLOCAL algorithms: it is easy to prove that the combination of two SLOCAL algorithms with localities T 1 , T 2 gives an SLOCAL algorithm with locality O(T 1 + T 2 ) [38, Lemma 2.3]. Lemma 7.8. Let α ∈ N + , and let G = (V, E) be a rooted forest. There is an SLOCAL algorithm with locality O(α) that produces an (α -1, 2α + 1)-clustering of G.</p><p>Proof. We combine some SLOCAL algorithms. Consider first the following algorithm A 1 : Suppose a node v ∈ V is picked by the adversary and asked to commit to something. For each root-to-leaf path v 0 v 1 . . . v 2α-1 (with v 0 = v) that v can distinguish using locality 2α -1, in parallel, v precommits that the node v α-1 is the leader of the path v α-1 v α . . . v 2α-1 unless there is another precommitment on the path within distance α from v.</p><p>Next we define an algorithm A 2 that takes as input a rooted forest labelled by A 1 : Each node v looks at its radius-α neighborhood and checks if there is some other (unique) node that precommitted for v in the neighborhood. If so, it becomes a leader and stores the path that is under its leadership, otherwise it does nothing.</p><p>The final algorithm A 3 takes as input a rooted forest labelled by A 2 and is defined as follows: Each node v becomes a leader if and only if it belongs to an oriented root-to-leaf path v 0 v 1 . . . v α-1 , with v α-1 = v lead by v 0 . All other nodes do not output anything, except the root, that becomes a leader.</p><p>We now prove that the SLOCAL algorithm A providing the clustering is the composition of A 1 , A 2 , and A 3 , and has locality O(α).</p><p>Notice that the root is a leader thanks to A 3 . Property 1 in Definition 7.7 is satisfied due to A 3 as well. Furthermore, for each maximal root-to-leaf path, consecutive leader nodes must be within distance at most 2α + 1 between each other, unless the path ends with a leaf at distance at most 2α from the last leader. In fact, if the distance between consecutive leaders is at least 2α + 2, or there is only one leader and the path is longer than 2α from the last leader, there would be at least one non-leader node that does not see any leader within distance α in the path, which is impossible due to how precommitments are done in A 1 .</p><p>We can now prove Theorem 7.1, which we restate here for the reader's convenience: Theorem 7.1. Let Π be an LCL problem with degree constraint ∆, input label set Σ in , output label set Σ out , and checking radius r &gt; 0. In addition, let A be an online-LOCAL algorithm solving Π with locality T (n) over rooted forests. Then the following holds:</p><p>1. If A is deterministic, then there exists a deterministic SLOCAL algorithm solving Π with locality O(r) + T (2 O(n 3 ) ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">If</head><p>A is randomized and has success probability p(n) &gt; 0, then there exists a deterministic SLOCAL algorithm solving Π with locality O(r) + T (2 O(n 3 ) + 2 O(2 n 2 ) • log 1 p(n) ). Proof. Let G denote the input graph, which is a rooted forest, and assume A is a deterministic online-LOCAL algorithm. We can apply Lemma 7.5 to get an amnesiac algorithm A ′ that solves Π with locality T ′ (n) = T (2 O(n 3 ) ). We now show how to get an SLOCAL algorithm B solving the problem with roughly the same locality. B is the composition of four different SLOCAL algorithms B 1 , B 3 , B 3 , B 4 , each of them having locality O(T ′ ):</p><p>1. We first use Lemma 7.8 with α = 10T ′ + 4r, where r is the checking radius of Π, and obtain an algorithm B 1 that outputs an (α -1, 2α + 1)-clustering of G with locality O(α).</p><p>2. Now consider an algorithm B 2 with locality 2α + 4r that takes as input G as labelled by B 1 and works as follows: When processing a leader node v, it collects the topology of the radius-2r neighborhood of the set composed of the closest leaders v sees in each root-to-leaf path. Then, v runs A ′ in this neighborhood and precommits a solution to the LCL for the nodes in such neighborhood. If v is the root, it also presents its own radius-2r neighborhood to A ′ and precommits a solution for the whole neighborhood. Observe that all such neighborhoods are disjoint by construction of the (α -1, 2α + 1)-clustering.</p><p>3. B 3 also has locality 2α + 4r and just makes all nodes whose label has been precommitted by some other node actually output the precommitted label. (The output of B 2 guarantees there are no conflicts to be resolved.)</p><p>4. Finally, B 4 has again locality 2α + 4r and just brute-forces a solution in each cluster. The solution is guaranteed to exist because A ′ was run in all disjoint neighborhoods and works correctly. In fact, B 4 can just continue calling A ′ on each cluster it sees. The combination of B 1 , B 2 , B 3 , and B 4 yields a deterministic SLOCAL algorithm B that has locality O</p><formula xml:id="formula_100">(α) = O(r) + O(T ′ (n)).</formula><p>The same argument applies to a randomized online-LOCAL algorithm, the only change is that now</p><formula xml:id="formula_101">T ′ is T ′ (n) = T (2 O(n 3 ) + 2 O(2 n 2 ) • log 1 p(n) ).</formula><p>7.4 From SLOCAL to LOCAL It is folklore that all LCL problems that have complexity O(1) in SLOCAL belong to the complexity class O(log * n) in LOCAL. Then, to obtain Theorem 1.5, it suffices to show that all LCLs with complexity o(log n) in SLOCAL in rooted trees actually belong to the complexity class O(1). We restate Theorem 7.2. Theorem 7.2. Let A be an SLOCAL algorithm solving an LCL problem Π that runs with locality o(log ∆ n) over rooted forests of maximum degree ∆ and n nodes. Then, there exists an SLOCAL algorithm B solving Π with locality O(1).</p><p>Proof. Assume Π has checking radius r ≥ 0, and T (n) = o(log ∆ n) to be the locality of A. Furthermore, w.l.o.g., suppose T (n) ≥ r for all n large enough. Let N be a large enough integer such that T (N ) = k ≥ r. Let G be a rooted tree of maximum degree ∆ with n nodes. We now construct a new SLOCAL algorithm B which is the composition of many SLOCAL algorithms.</p><p>For the first SLOCAL algorithm B 1 , we make use of Lemma 7.8 where α = ⌊(log ∆ N -2)/4⌋. Hence, B 1 yields an (α -1, 2α + 1)-clustering of G in time O(α), with α -1 ≥ (log ∆ N -10)/4 and 2α + 1 ≤ (log ∆ N )/2. Hence, any closed cluster will have at most ∆ 2α+1 ≤ √ N nodes (including the adjacent leader nodes).</p><p>Then, we consider a second SLOCAL algorithm B 2 that takes G and the (α -1, 2α + 1)-clustering of G in input and reassigns identifiers from the set [N ] "locally". To better describe how B 2 works, let us define some notation. For each leader node v, let C v denote the closed cluster where v is the leader node of minimum level, and let L v be the set of leader nodes in C v except for v. Consider a partition of the nodes in (C v \ N k (v)) ∪ N k (L v ) according to their distance from v. More specifically, C</p><p>v contains all nodes that have distance between k + 1 and ⌊(α -1)/4⌋ from v, while, for i ∈ {2, 3}, C (i) v contains nodes that have distance between ⌊(α -1)/(6 -i)⌋ + 1 and ⌊(α -1)/(5 -i)⌋ from v. Finally, C</p><p>v contains all the other nodes in C v , which have distance at least ⌊(α -</p><formula xml:id="formula_104">1)/2⌋ + 1 from v. Notice that |(C v \ N k (v)) ∪ N k (L v )| ≤ ∆ 2α+1+k ≤ ∆ (log ∆ N )/2+o(log ∆ N ) ≤ N 2/3 for N large enough.</formula><p>Then, B 2 works as follows: When a non-leader node is picked by the adversary, nothing happens. When a leader node v is selected, it precommits identifiers for the nodes in</p><formula xml:id="formula_105">(C v \ N k (v)) ∪ N k (L v ). In details, it assigns identifiers from 1 to ⌊N/4⌋ to nodes in C (1) v , from ⌊N/4⌋ + 1 to ⌊N/2⌋ to C (3) v , from ⌊N/2⌋ + 1 to ⌊3N/4⌋ to C (2) v , from ⌊3N/4⌋ + 1 to N to C (4) v . Notice that, since C (i) v ≤ N 2/4</formula><p>, then even ⌊N/5⌋ distinct identifiers are enough to cover the whole region C (i) v when N is large enough. Furthermore, if v is the root of the whole graph, it precommits distinct identifiers from the set {⌊3N/4⌋ + 1, . . . , N } for the nodes that have distance at most k from v (v itself included).</p><p>The third and last SLOCAL algorithm B 3 takes as input the whole rooted tree with the clustering given by B 1 and the output of leader nodes given by B 2 , and computes the solution to the problem as follows: Every node u (that does not belong to C v where v is the root of the graph) looks at its two closest leader nodes v   is crucial to observe that the boundaries of color 3 are not always compatible and that they have parities of their own (see Fig. <ref type="figure" target="#fig_12">4</ref>). Indeed, the core idea of the proof is to constrict many incompatible boundaries of color 3 to a small space, thus requiring a view of Ω(log n) to resolve them. Using the same terminology as <ref type="bibr" target="#b23">[22]</ref>, we count incompatible boundaries between two points by using so-called a-and b-values. The a-value is defined as an edge weight between any two nodes and captures the change of colors 1 and 2. Definition 8.2 (a-value <ref type="bibr" target="#b23">[22]</ref>). Given a directed edge (u, v) and a 3-coloring of the nodes c : V → {1, 2, 3}, we define</p><formula xml:id="formula_106">a(u, v) = c(u) -c(v), if c(u) ̸ = 3 and c(v) ̸ = 3 0, otherwise.</formula><p>Observe that the a-value of any directed 4-cycle in a grid is equal to 0. Using the a-value, we define the b-value of a path. Definition 8.3 (b-value <ref type="bibr" target="#b23">[22]</ref>). For a directed path P , its b-value is defined as</p><formula xml:id="formula_107">b(P ) = (u,v)∈H a(u, v).</formula><p>On a high level, the b-value of a path describes the cumulative total of incompatible boundaries along this path. Note we say "cumulative" because in this count boundaries of the same parity cancel each other out. Indeed, if we consider the b-value of a simple directed cycle in a grid, then it must be equal to 0: Lemma 8.4 (b-value of a cycle is zero <ref type="bibr" target="#b23">[22]</ref>). Let C be a directed cycle in G. Then b(C) = 0.</p><p>As an example, observe that a path that starts and ends with color 3 and otherwise is colored with colors 1 and 2 always has a b-value of 0 or 1. In particular, the b-value is 1 if the distance between the nodes of color 3 is even (and thus the boundaries are incompatible). Meanwhile, a path that goes through two incompatible regions has a total b-value of 2. Nevertheless, a path going through two boundaries that are compatible has a total b-value of 0. Lemma 8.5 (Parity of the b-value <ref type="bibr" target="#b23">[22]</ref>). Let P denote any directed path of length ℓ that starts in node u and ends in node v in a grid. Then, the parity of b(P ) is b</p><formula xml:id="formula_108">(P ) ≡ β(u) + β(v) + ℓ (mod 2)</formula><p>where β is an indicator variable stating whether a node is of color 3 or not:</p><formula xml:id="formula_109">β(u) = 1, if c(u) = 3 0, otherwise.</formula><p>Observe that the parity of the b-value of a path is determined by the colors of the endpoints of this path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">From deterministic to randomized online-LOCAL</head><p>Suppose that we are given a randomized online-LOCAL algorithm with visibility radius T = o(log n). Our goal is to prove the algorithm fails to solve the 3-coloring problem. Using Yao's minimax principle, we show how to construct an (oblivious) adversarial distribution of inputs so that any deterministic online-LOCAL algorithm fails with noticeable probability.</p><p>As in <ref type="bibr" target="#b23">[22]</ref>, the lower bound consists of two main steps:</p><p>1. First we show how to force paths to have an arbitrarily large b-value. Generally we cannot force a large b-value between the path's endpoints (or in fact between any two fixed nodes), but we do get the guarantee that it contains two nodes v 1 and v 2 where b(v 1 , v 2 ) is large. Note the location of v 1 and v 2 is completely unknown to us since we are working with an oblivious adversary. The construction is inductive: Given a procedure that generates a path with b-value ≥ k -1 with probability ≥ 1/2, we show how to generate a path with b-value ≥ k also with probability ≥ 1/2. (Cf. the construction in <ref type="bibr" target="#b23">[22]</ref> with an adaptive adversary, which succeeds every time.) Since we invoke the construction for k -1 a constant number of times, we are able to obtain any desired b-value of k = o(log n) with high probability. Note it is logical that we cannot do much better than this as it would contradict the existing O(log n) deterministic online-LOCAL algorithm.</p><p>2. The second step is to actually obtain a contradiction. (See Fig. <ref type="figure" target="#fig_14">5</ref>.) First we construct a path P 1 with large b-value, say ≫ 4T , between nodes u s and v t . To get the contradiction, we wish to place two nodes w s and w t next to u s and v t , respectively, so that the four node cycle has positive b-value (which is impossible due to Lemma 8.4). If we had an adaptive adversary as in <ref type="bibr" target="#b23">[22]</ref>, this would be relatively simple: Since the adaptive adversary knows the location of u s and v t , it just constructs an arbitrary path P 2 with the same size as P 1 , picks any two w s and w t that are at the same distance from each other as u s and v t , mirrors P 2 if needed to obtain a non-negative b-value, and then places this at minimal distance to P 1 . We show that, allowing for some failure probability, we do not need any information about u s and v t (i.e., nor their location nor the distance between them) in order to obtain the same contradiction.</p><p>We now proceed with the proof as outlined above. Accordingly, the first step is the following: Lemma 8.6. Given any k = o(log n), there is an adversarial strategy to construct a directed path of length n o (1) with a b-value of at least k against any online-LOCAL algorithm with locality T = o(log n). Moreover, this strategy succeeds with high probability.</p><p>Proof. Consider the following recursive construction:</p><p>• If k = 0, create a single node with previously unrevealed nodes all around it (inside the visibility radius T ).</p><p>• Otherwise, repeat the following steps four times in total:</p><p>-Create four distinct paths P 1 , P 2 , P 3 , P 4 by following the procedure for k -1.</p><p>-Toss independent fair coins c 1 , c 2 , c 3 ∈ {0, 1}.</p><p>-Connect the P i 's horizontally aligned and in order while placing c i + 1 nodes between paths P i and P i+1 .</p><p>Let Q 1 , Q 2 , Q 3 , Q 4 be the four paths created by this procedure (each having their own four P i 's coming from the procedure in the previous iteration k -1). Next, we connect the Q i 's horizontally aligned with each other and in arbitrary order. Note that we need to place an additional node between each pair of Q i 's. Otherwise, we would have to have revealed the edge between the two endpoints too early to the algorithm.</p><p>Thus, for k ≥ 1 we have 16 invocations of the procedure for k -1 in total. We argue that, with probability at least 1/2, the path yielded by this procedure contains a segment with b-value at least k. By repeating this procedure O(log n) times independently, we obtain at least one path with the desired property with high probability.</p><p>To prove that the recursive construction works, we proceed by induction. Fix k ≥ 1 and suppose that the procedure for k -1 succeeds with probability p ≥ 1/2 at yielding a segment with b-value at least k -1. Let us first consider Q 1 . Let X i be a random variable that is 1 if this occurs for path P i and 0 otherwise. Then we have</p><formula xml:id="formula_110">Pr 4 i=1 X i &lt; 2 = Pr 4 i=1 X i = 0 + Pr 4 i=1 X i = 1 = (1 -p) 4 + 4p(1 -p) 3 = (1 -p) 3 (1 + 3p) ≤ 1 2 .</formula><p>Hence, with probability at least 1/2 there are at least two paths P i and P j , i &lt; j, for which the construction succeeds. Since we are dealing with paths, we may simplify the notation and write b(u, v) for the b-value of the (unique) segment that starts at u and ends at v. Let thus u i , v i , u j , v j appear in this order in</p><formula xml:id="formula_111">Q 1 and |b(u i , v i )|, |b(u j , v j )| ≥ k -1.</formula><p>Next we will show that, conditioned on this assumption, the probability that Q 1 contains a segment with b-value at least k is at least 1/2. Hence, a priori, Q 1 contains such a segment with probability at least 1/4. Since all Q i 's are constructed the in the same way and independently of one another, the probability that at least one of the Q i 's contains such a segment is at least 1</p><formula xml:id="formula_112">-(1 -1/4) 4 &gt; 1 -1/e &gt; 1/2.</formula><p>Let us write σ(x) for the sign function of x (i.e., σ(x) = 1 if x &gt; 0, σ(x) = -1 if x &lt; 0, and σ(0) = 0). To see why the above holds for Q 1 , consider the two following cases:</p><formula xml:id="formula_113">Case 1: σ(b(u i , v i )) = σ(b(u j , v j )). Using Lemma 8.5, we have that b(v i , u j ) ≡ β(v i ) + β(u j ) + c i + • • • + c j-1 (mod 2</formula><p>). Since β(v i ) and β(u j ) are fixed, and the coin tosses are independent, we have |b(v i , u j )| ̸ ≡ k -1 (mod 2) with probability 1/2. Assuming this holds, we have either |b(v i , u j )| ≥ k, in which case we are done, or |b(v i , u j )| ≤ k -2. Since b(u i , v i ) and b(u j , v j ) have the same sign, we have |b</p><formula xml:id="formula_114">(u i , v j )| = |b(u i , v i ) + b(v i , u j ) + b(u j , v j )| ≥ |b(u i , v i ) + b(u j , v j )| -|b(v i , u j )| ≥ 2(k -1) -(k -2) = k. Case 2: σ(b(u i , v i )) ̸ = σ(b(u j , v j )).</formula><p>Arguing by using Lemma 8.5 as before, we obtain that |b(v i , u j )| ̸ ≡ 0 (mod 2) holds with probability 1/2. Assuming this is the case, we have thus</p><formula xml:id="formula_115">|b(v i , u j )| ≥ 1. Without restriction, let σ(b(u i , v i )) = σ(b(v i , u j )). Then |b(u i , u j )| = |b(u i , v i ) + b(v i , u j )| ≥ k -1 + 1 = k.</formula><p>Finally, let us confirm that the construction fits into the ( √ n × √ n)-grid. We only reveal at most 2T + 1 = o( √ n) in a column, so we need to only consider nodes along a row. The initial path contains m 0 = 2T + 1 visible nodes and in the i-th recursive step we have m i ≤ 16p i-1 + 27 visible nodes in total for i ≥ 1. (Inside each Q i we need at most 2(4 -1) = 6 additional nodes to join the four P i 's, and to join the four Q i 's we need an additional 3 nodes.) Solving the recursion, in the k-th step we have thus</p><formula xml:id="formula_116">m k = 1 5 2 4k+1 (5T + 7) -9 = n o(1)</formula><p>visible nodes along the path since k, T = o(log n).</p><p>We now illustrate the idea for getting the contradiction previously described. (See Fig. <ref type="figure" target="#fig_14">5</ref>.) Invoking Lemma 8.6, we obtain a path P 1 with a b-value of 4T + 4 between two nodes u s and v t (whose positions are unknown to us). Letting L be the length of P 1 , we (arbitrarily) create a second path P 2 of length 10L and then randomly choose how to align P 1 and P 2 . More specifically, letting u be the first node in P 1 , we choose some node w of P 2 uniformly at random and align u and w; then we mirror P 2 with probability 1/2 and reveal it at distance 2T + 2 to P 1 (which is consistent with all previously revealed nodes).</p><p>The reason why this works is the following: Since P 1 has length L and P 2 length 10L, with at least 4/5 we align the paths so that each node in P 1 has a matching node underneath it in P 2 . Let w s and w t be the nodes matching u s and v t , respectively. Then because we mirror P 2 with probability 1/2, we get that b(w s , . . . , w t ) is at least zero in expectation (conditioned on having properly aligned the two paths). Hence, with probability at least 2/5 we obtain a cycle (u s , . . . , v t , . . . , w t , . . . , w s , . . . , u s ) where b(u s , . . . , v t ) &gt; 4T + 4, b(w t , . . . , w s ) ≥ 0, and b(v t , . . . , w t ), b(w s , . . . , u s ) ≥ -2T -2 (due to the distance between the two paths).</p><p>Proof of Theorem 8.1. Observe that, using Lemma 8.6, we can construct a path P 1 = (u 0 , . . . , u L ) of length L = n o (1) where some segment (u s , . . . , u t ) of P 1 has a b-value of k &gt; 4T + 4. Next we construct a path P 2 = (v 0 , . . . , v 10L ) of length 10L that will be placed below P 1 . We assume that the points of the path are revealed to the algorithm in some predefined order.</p><p>The position and orientation of P 2 are chosen as follows:  Here the blue area includes the nodes revealed so far around the path segments (u 0 , . . . , u L ) and the corresponding part of P 2 underneath it. The green segments are the two segments we consider in the proof. A cycle going through both paths leads to a contradiction.</p><p>The nodes of P 2 are revealed to the algorithm in the same predefined and possibly mirrored order. See Fig. <ref type="figure" target="#fig_14">5</ref> for an example.</p><p>We next prove that we obtain the desired lower bound. First notice that, since we pick v r ∈ [L, 9L], every node in P 1 has a counterpart in P 2 whether we mirror P 2 or not. Let (w s , . . . , w t ) denote the segment matched to (u s , . . . , u t ). Consider the case where either of the following is true: (In fact, the probability is exactly 1/2 if b(w t , . . . , w s ) &gt; 0 and 1 if b(w t , . . . , w s ) = 0.) Thus, the probability that b(w t , . . . , w s ) ≥ 0 is &gt; (2/3) • (1/2) = 1/3. From here on, we proceed as in <ref type="bibr" target="#b23">[22]</ref>. By Lemma 8.4, the cycle (u s , . . . , u t , . . . , w t , . . . , w s , . . . , u s ) must have a b-value of 0. However, recall that the b-value of a path is bounded by its length by definition. In our case, -2T -2 &lt; b(u t , . . . , w t ) &lt; 2T + 2, -2T -2 &lt; b(w s , . . . , u s ) &lt; 2T + 2, b(u s , . . . , u t ) ≥ k, and b(w t , . . . , w s ) ≥ 0. In order for the b-value of the cycle to be 0, we would need to have 2(2T + 2) ≥ k, which is a contradiction. Since this occurs with noticeable probability (i.e., &gt; 1/3), the claim follows. Proof of <ref type="bibr">Lemma 11.3</ref>. This proof closely follows the argument presented in [2, <ref type="bibr">Lemma 5.6]</ref>. Let Π denote an LCL problem with a constant checking-radius r, and suppose A is a randomized online-LOCAL algorithm solving Π with constant locality T . Define β = T + r + 1. As in [2, Lemma 5.6], we consider an input-labeled graph P formed by many copies of all feasible input neighborhoods with a radius of β. We can depict P as a collection of disjoint path fragments that we later connect to each other and create a long path with. Each of these path fragments has size 2β + 1, so the node in the center of each segment (i.e., the (β + 1)-th node in the segment) has the same view (up to radius β) as in the final path. Let V be the set of central nodes within these fragments.</p><p>We apply A to each node within the radius-r neighborhood of the nodes in V following an arbitrary order and then terminate. These nodes have the same view as in the final path because their distance to the endpoints is at most β -r = T + 1. We iterate the process multiple times, yielding a distribution of output labels around the central nodes. Given that the size of P is constant, there exists an output labeling L of the nodes occurring with probability p = Ω(1). If needed, we can augment P with (constantly many) additional nodes such that |P | &gt; 1/p.</p><p>We set this labeling L as the deterministic output for graph P and proceed similarly to the deterministic case by constructing the canonical labeling f from L. Then, we use the function f to construct a LOCAL algorithm with O(log * n) locality following the same steps as in the proof of <ref type="bibr">[2,</ref><ref type="bibr">Lemma 5.6]</ref>. It is important to highlight that it is feasible to fill any gap of sufficient length between parts labeled with the canonical labeling: If the algorithm A would never produce a valid labeling for this gap, then the algorithm would fail to label P with probability at least p and, since p ≥ 1/|P |, the algorithm A would not succeed with high probability.  LOCAL model within T = 2 steps of synchronous communication. The difficulty is that a given node ignore which G ∈ G connects the set of labelled nodes: it can only discover a local part of the structure of G by communicating to its neighbors. The most general (T = 2)-round strategy for the node 1 consists of the following procedure, which alternates between randomized processing steps and communication steps (the computational power and size of exchanged messages are unbounded):</p><p>Processing 0: Sample a random real number and store it locally.</p><p>Communication 1: Send all stored information, including the sampled random number, to all neighbors. Receive information from all neighbors and store it for subsequent rounds (in G 0 , the neighbors are 2, 3, 5).</p><p>Processing 1: Process all stored information (possibly in a randomized way) and store the result. <ref type="foot" target="#foot_5">4</ref>Communication 2: Send all stored information, including all received messages and the outputs of processing steps, to all neighbors. Receive information from neighbors and store it.</p><p>Processing 2: Process all stored information (possibly in a randomized way) to output a color.</p><p>Such T -round strategy on the graph G can be represented formally as a circuit C G,T , such as in Fig. <ref type="figure" target="#fig_23">8a</ref> where semicircles, line wires, and squares respectively represent the sampling of a random number, the transfer (or storage) of information, and the processing of information. Once the concrete operations performed by the nodes (i.e. randomness sampling and processing) are made explicit, it is possible to compute (using classical information theory) the exact output distribution of the strategy on graph G, that is, the probability distribution Pr [c 1 , . . . , c n | C G,T ] of observing that the set of nodes {1, . . . , n} outputs the colors {c 1 , . . . , c n } when connected as per one of the lifebuoy-shaped graphs G ∈ G. Importantly, in our model, the operations performed by the nodes cannot depend on the connection graph G.   The above circuits represent non-signaling strategies (it includes as special cases the classical strategies and quantum strategies) executed by the nodes 1 and 2 in various scenarios. The semicircles represent private (Fig. <ref type="figure" target="#fig_23">8a</ref>) or shared (Fig. <ref type="figure" target="#fig_23">8b</ref> and Fig. <ref type="figure" target="#fig_23">8c</ref>) arbitrary-but-non-signaling resources; the wires depict communication (or storage), and the squares are local operations (using possibly private resources). The last layer of gates (or measurements) outputs the individual colors of the nodes (i.e. classical variables). Since the nodes start with no knowledge about the identity of their neighbors, the operations of the gates are a priori independent of the graph structure (as long as the nodes have the right degree). For the special cases of classical and quantum strategies, the output distribution can be computed directly from those circuits, which define it uniquely. Definition A.7 (Device-replication principle). Identical and independent copies of non-signaling gates and non-signaling resources can be prepared <ref type="foot" target="#foot_7">10</ref> .</p><p>Then, we obtain the following definition: Note a subtlety related to subgraph isomorphisms in the bounded-dependence model. There is the variant where the nodes have identifiers in G, and the one where they do not. When the nodes do not have any identifiers, the class of subgraph isomorphisms of all alternative graphs H created out of the nodes in G and their replicates is obviously larger than with identifiers, because the subgraph isomorphisms must respect the identifiers. However, even if the nodes of G do have distinct identifiers, as H is created out of possibly many copies of the original nodes of G, H might contain several nodes with the same identifiers. Hence, the group of subgraph isomorphism of H might be nontrivial even if all nodes in G have distinct identifiers. For instance, in lifebuoy-shaped graphs, one could consider the case represented in Fig. <ref type="figure" target="#fig_22">9</ref>, which starts from the graph G 0 in Fig. <ref type="figure" target="#fig_18">7b</ref>, duplicates all nodes, and constructs a new graph H of 24 nodes with identifiers ranging from 1 to 12 with one non-trivial graph isomorphism cyclically permuting the nodes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1 .</head><label>1</label><figDesc>All LCL problems solvable with locality O(log * n) in the classical deterministic LOCAL model admit a finitely-dependent distribution, i.e., a bounded-dependence distribution with constant locality: classical LOCAL algorithm, locality O(log * n) bounded-dependence distribution, locality O(1) non-signaling distribution, locality O(1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>2 .</head><label>2</label><figDesc>In rooted trees, if we can solve an LCL problem with locality o(log log log n) in the randomized online-LOCAL model (or any of the weaker models, such as quantum-LOCAL), we can solve it with locality O(log * n) in the classical deterministic LOCAL model: quantum-LOCAL algorithm, locality o(log log log n) bounded-dependence distribution, locality o(log log log n) randomized online-LOCAL algorithm, locality o(log log log n) classical LOCAL algorithm, locality O(log * n)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 1 . 1 .</head><label>11</label><figDesc>Fix a distributed algorithm A in the quantum-LOCAL model (with shared global information and quantum state) that runs in T rounds on graphs with n nodes. Let G = (V, E) be some n-node input graph. Apply A repeatedly to G to obtain some probability distribution Y (G) of outputs. Now fix some subset of nodes U ⊆ V , and consider the restriction ofY (G) to U , in notation Y (G)↾ U . Let G[U, T ] be the radius-T neighborhood of set U in G. Now modify G outside G[U, T ] to obtain a different n-node graph G ′ with G[U, T ] = G ′ [U, T ]. Apply A to G ′repeatedly, and we obtain another probability distribution Y (G ′ ) of outputs. If Y (G)↾ U ̸</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><figDesc>hence the distribution of the port numbers in G[N T 2 (U, G)] is the same as that in H[N T 2 (f (U ), H)] because each node permutes the port numbers locally u.a.r. Thus, Pr ∩ u∈U {Y (G) u = λ u } must be the same as Pr ∩ u∈U {Y (H)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><figDesc>and suppose that the random decompositions in {Γ(G) : G ∈ F} are invariant under subgraph isomorphism. Suppose there is T 2 -dependent distribution {X v } v∈V (H(P G )) , taking values in a finite set Σ, such that {{X v } v∈V (H(P G )) : G ∈ F} is invariant under subgraph isomorphism, where H(P G ) is obtained by the disjoint union of a copy of each element of P G . Let {Y (Γ(G)) v</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A decomposition of rooted pseudoforests in directed paths and cycles: each node v colors its indegree neighbors with a uniformly sampled permutation of the elements in [indeg(v)]. The graph induced by nodes colored with color i is a disjoint union of directed paths and cycles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><figDesc>Each node v rearranges its port numbers uniformly at random.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><figDesc>The ∆ = 5 rooted pseudoforests that we take by considering port numbers i ∈ [∆].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: A (3, 4)-clustering of a rooted tree. The leader nodes are colored and their closed clusters marked with their respective color.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>( 1 )</head><label>1</label><figDesc>u (the closest one) and v</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>( 2 )</head><label>2</label><figDesc>u (the second closest one) that are ancestors</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Example of a 3-colored grid with two boundaries B 1 and B 2 that have different parities. As one can see, b(u, v) = 2: No matter if we take the blue or the red path from u to v, we always cross B 1 and then B 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>1 b</head><label>1</label><figDesc>(u s , . . . , u t ) ≥ k b(w t , . . . , w s ) ≥ 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: How to turn paths with large b-value into a contradiction.Here the blue area includes the nodes revealed so far around the path segments (u 0 , . . . , u L ) and the corresponding part of P 2 underneath it. The green segments are the two segments we consider in the proof. A cycle going through both paths leads to a contradiction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>• m = 0 3 .</head><label>03</label><figDesc>and r ∈ [L, 9L -s -t]• m = 1 and r ∈ [L + s + t, 9L]Denoting by E the event in which this occurs, note we havePr[E] = 1 2 Pr[r ∈ [L, 9L -s -t]] + 1 2 Pr[r ∈ [L + s + t, 9L]] = 8L -s -Now conditionedon E, notice that every segment (v x , . . . , v y ) where x ∈ [L + s, 9L -s] and y ∈ [L + t, 9L -t] has equal probability of being matched with (u s , . . . , u t ) either in the same direction (i.e., w s = v x and u t = v y ) or reversed (i.e., w s = v y and w t = v x ). Hence, Pr[b(w t , . . . , w s ) ≥ 0 | E] ≥ 1 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>9</head><figDesc>Dynamic-LOCAL derandomizes LOCAL and breaks symmetryThis section presents a derandomization result for the dynamic-LOCAL model: we show that not only dynamic-LOCAL can simulate randomized LOCAL with no overhead in the locality, but actually it brings the complexity class O(log * n) in randomized LOCAL down to O(1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><figDesc>(a) H has chromatic number 3. (b) A distributed algorithm that finds a 2coloring of the lifebuoy-shaped graphs G ∈ G would by definition 2-color the particular instance G = G 0 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The joint view of the couple of nodes u, v = 1, 2 after T = 2 rounds of communication is limited to the gray area. In this region the graphs G 0 and H are identical. The non-signaling principle implies that the outputs (c 1 , c 2 ) must therefore be identically distributed in both G 0 and H.</figDesc><graphic coords="61,99.38,72.00,127.76,125.97" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><figDesc>Circuit representation of a non-signaling strategy on graph G 0 of Fig.7b, without a shared resource. Note the cyclicity of the circuit. Highlighted in red is the past-light-cone of the joint output (c 1 , c 2 ), that is the set of gates which connects to the output gates producing (c 1 , c 2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><figDesc>Circuit representation of a non-signaling strategy on graph G 0 of Fig.7b, with an arbitrary shared resource. The joint output (c 1 , c 2 ) remain, after T = 2 rounds of communication, independent of the graph structure around nodes 11 and 12, because the difference lies outside their joint past light-cones.Circuit representation of a non-signaling strategy on graph H of Fig.7a, with an arbitrary shared resource. Note the difference between this circuit and the one of Fig.8b(namely, the different connections between the top layer and bottom layer of the circuit) is only manifested outside the joint past light-cone of the outputs (c 1 , c 2 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>Figure 8 :</head><label>8</label><figDesc>Figure8: The above circuits represent non-signaling strategies (it includes as special cases the classical strategies and quantum strategies) executed by the nodes 1 and 2 in various scenarios. The semicircles represent private (Fig.8a) or shared (Fig.8band Fig.8c) arbitrary-but-non-signaling resources; the wires depict communication (or storage), and the squares are local operations (using possibly private resources). The last layer of gates (or measurements) outputs the individual colors of the nodes (i.e. classical variables). Since the nodes start with no knowledge about the identity of their neighbors, the operations of the gates are a priori independent of the graph structure (as long as the nodes have the right degree). For the special cases of classical and quantum strategies, the output distribution can be computed directly from those circuits, which define it uniquely.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: In the bounded-dependence model, one can find non-trivial subgraph isomorphisms even when the nodes are provided with unique identifiers.</figDesc><graphic coords="66,189.00,72.00,233.99,118.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Definition A. 8 (</head><label>8</label><figDesc>Bounded-dependence model, with unique identifiers). The distributionPr [c 1 , . . . , c n | C G,T ]with unique identifiers has bounded dependence with locality T on graph G (without pre-shared non-signaling resources) if and only if for all possible alternative connecting graph H of the nodes and their replicates, there exists a distribution Pr [c 1 , . . . , c m | C H,T ] such as the non-signaling and independence principles are respected, and such that the distribution is invariant under subgraph isomorphisms.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Note that the dependency T might depend on other graph parameters such as the maximum degree ∆, the chromatic number χ, etc.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>We remark that, as opposed to Definition 5.2, the isomorphism must preserve the input but not the node identifiers.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_2"><p>Choose a node v r ∈ [L, 9L] of P 2 uniformly at random. This node is placed below the node u 0 of P 1 at 2T + 2 distance from it.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_3"><p>Throw a fair coin m ∈ {0, 1}. If m = 1, mirror P 2 along the vertical axis that goes through u 0 and v r .</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_4"><p>A reader used to standard quantum nonlocality should see the graph -H or G ∈ G -as an input of the problem, split and distributed among the local parties.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_5"><p>In classical information theory, it is known that intermediate processing gates can be taken as identity gates, that is, any strategy can be simulated by a two-layer circuit where the parties send their first random number to all parties up to a distance T , and then make a unique processing step after all the communication has taken place. In quantum and non-signaling theories, this is not the case anymore<ref type="bibr" target="#b29">[28]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_6"><p>While we are deceiving the nodes by promising a lifebuoy-shaped connecting graph but imposing instead H, the nodes cannot locally detect the fraud in T = 2 communication steps or less. (More formally, the past light-cone in H of any node is then compatible with a lifebuoy-shaped graph -an individual node cannot detect the difference and must therefore, according to the non-signaling principle, output a color as if it were in a lifebuoy-shaped graph.)</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_7"><p>Note that this principle does not imply that one can duplicate unknown non-signaling resources: device-replication compatible with the quantum no-cloning theorem.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>We thank anonymous reviewers for their helpful feedback on previous versions of this work. This work was supported in part by the <rs type="funder">Research Council of Finland</rs>, Grant <rs type="grantNumber">333837</rs>. <rs type="person">Xavier Coiteux-Roy</rs> is supported by the <rs type="funder">Swiss National Science Foundation</rs>. Francesco d'Amore is supported by <rs type="funder">MUR</rs> <rs type="programName">FARE 2020 -Project PAReCoDi</rs> <rs type="grantNumber">CUP J43C22000970001</rs>. <rs type="person">Darya Melnyk</rs> is supported by the <rs type="funder">European Research Council (ERC)</rs>, grant agreement No. <rs type="grantNumber">864228</rs> (AdjustNet), <rs type="programName">Horizon 2020</rs>, <rs type="grantNumber">2020-2025</rs>. <rs type="person">Augusto Modanese</rs> and <rs type="person">Shreyas Pai</rs> are supported by the <rs type="funder">Helsinki Institute for Information Technology (HIIT)</rs>. <rs type="person">Marc-Olivier Renou</rs> acknowledges funding by <rs type="funder">INRIA</rs> through the <rs type="funder">Action Exploratoire</rs> project <rs type="projectName">DEPARTURE</rs>, and by the <rs type="funder">ANR</rs> for the JCJC grant <rs type="projectName">LINKS</rs> (<rs type="grantNumber">ANR-23-CE47-0003</rs>).</p><p><rs type="person">Errata. An</rs> earlier version of this manuscript (arXiv:<rs type="grantNumber">2403</rs>.01903v1, posted on <rs type="grantNumber">2024-03-04</rs>) had a mistake: we claimed a result analogous to Theorem 1.5 for unrooted trees (which would also have implications on the complexity of the sinkless orientation problem). However, the proof had a missing step, and we do not know if the proof can be fixed.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_HBcyc8E">
					<idno type="grant-number">333837</idno>
				</org>
				<org type="funding" xml:id="_qDAuY4k">
					<idno type="grant-number">CUP J43C22000970001</idno>
					<orgName type="program" subtype="full">FARE 2020 -Project PAReCoDi</orgName>
				</org>
				<org type="funding" xml:id="_4KqwjWX">
					<idno type="grant-number">864228</idno>
					<orgName type="program" subtype="full">Horizon 2020</orgName>
				</org>
				<org type="funding" xml:id="_tRTR34b">
					<idno type="grant-number">2020-2025</idno>
				</org>
				<org type="funded-project" xml:id="_y3Ku8s2">
					<orgName type="project" subtype="full">DEPARTURE</orgName>
				</org>
				<org type="funded-project" xml:id="_fQXR8Jr">
					<idno type="grant-number">ANR-23-CE47-0003</idno>
					<orgName type="project" subtype="full">LINKS</orgName>
				</org>
				<org type="funding" xml:id="_syCPr8d">
					<idno type="grant-number">2403</idno>
				</org>
				<org type="funding" xml:id="_JzghQuc">
					<idno type="grant-number">2024-03-04</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Online to amnesiac</head><p>We are now ready to generalize the intuition we provided in Section 2.3 for turning any online-LOCAL algorithm into an amnesiac algorithm with the cost of blowing up its locality. Lemma 7.5. Let Π be an LCL problem with degree constraint ∆, input label set Σ in and output label set Σ out . Let A be a deterministic online-LOCAL algorithm solving Π over a family F of graphs that is closed under disjoint graph union and node/edge removal. Assume A has locality T (n) for an n-node graph. Then there exists an amnesiac online-LOCAL algorithm A ′ that solves Π on an n-node graph in F with locality T (2 O(n 3 ) ).</p><p>Proof. Let T = T (N ) be the locality of the following experiment; we determine the size N of the experiment graph later. Let G ℓ be the set of all partial one-component online-LOCAL runs of length ℓ for n-node graphs in F (up to isomorphisms). We denote g ℓ = |G ℓ | and remark that g ℓ ≤ g = 2 n 2 |Σ in | n . Notice that the term 2 2 n takes into accounts not only all possible topologies (up to isomorphisms), but also all possible orderings of the nodes: indeed, there are at most 2 2 n directed graphs of n nodes where the vertices are labelled with elements of [n] (which defines an ordering). We set N ℓ = (3|Σ out | ng) n-ℓ+1 n.</p><p>We now adaptively construct an experiment graph H in n phases. In the first phase, we construct N 1 copies of all graphs in G 1 , that is, we construct N 1 g 1 disjoint components describing all possible isolated neighborhoods an online-LOCAL algorithm might see. We then show the centers of these regions to A and let it label them. As there are N 1 copies of each partial online local run of length 1, for each of these, say T , there exists a canonical label σ T that appears at least N 1 /|Σ out | times, by the pigeonhole principle. We say that such online-LOCAL runs of length 1 are good, and ignore the rest.</p><p>In each subsequent phase ℓ, we again construct N ℓ copies of all graphs in G ℓ , with the catch that, for each graph (G, (v 1 , . . . , v ℓ )) ∈ G ℓ and for each component of G -, we take the corresponding good partial one-component online-LOCAL run from a previous phase; we defer arguing why such good runs exist for now. Next we show node v ℓ to A and let it label the node. Finally, again by the pigeonhole principle, for each partial one-component online-LOCAL run T (of length ℓ) we find a canonical label σ T that appears at least N ℓ /|Σ out | times, and mark the corresponding runs as good.</p><p>Now our new online-LOCAL algorithm B works as follows: Before even processing the first node of the input, B runs the above-described experiment by simulating A on H with locality T . Notice that the nodes of the experiment graph will be processed according to a global ordering which is locally consistent with that of the nodes in the single partial one-component online-LOCAL runs. We do not care about the specific global ordering of the nodes.</p><p>When processing node v, algorithm B looks at partial one-component online-LOCAL run around v and finds a corresponding good and unused run from the experiment graph H. Algorithm B labels v with the good label that it found in H and marks the neighborhood in H used.</p><p>In each step, algorithm B can find such unused good neighborhoods as after the whole input has been processed, what the algorithm has seen corresponds to a partial online-LOCAL run, and in particular each component of this run corresponds to a partial one-component online-LOCAL run in H. There are at most n such component. By construction, there are at least N n copies of each type of partial one-component runs in H. At least N n /|Σ out | ≫ n of those are good, and hence the algorithm can find good and unused neighborhoods for each of the final partial one-component online-LOCAL runs. But as each good run in H is formed by combining only good components in H, there must also be a good and unused partial one-component online-LOCAL run corresponding to each processed node v. This construction ensures that B is amnesiac. Now, by contradiction, assume that B doesn't solve Π. Since Π is an LCL, there must be a node v of the input graph such that the whole output in its radius-r neighborhood, with r being the checking radius, is not admissible. However, the output of B in this neighborhood is the output of A from the experiment graph in a partial one-component online-LOCAL run, which must be correct by the hypothesis.</p><p>The only thing left to do is to argue that we can always find a good online-LOCAL run in the construction and to compute the final size of the experiment graph, and hence the locality of B. We start with the former: Consider phase ℓ. All subsequent phases contain n k=ℓ+1 N k g k graphs, the simulation uses at most n graphs, and each of those may use at most n previously-used components. Hence, nodes from phase ℓ can be used at most</p><p>that is the future phases won't run out of components.</p><p>Finally, the size of the experiment graph is</p><p>and it belongs to F as F is closed under disjoint graph union and node/edge removal.</p><p>The next lemma shows how to generalize the idea behind Lemma 7.5 all the way up to randomized online-LOCAL. Lemma 7.6. Let Π be an LCL problem with degree constraint ∆, input label set Σ in and output label set Σ out . Let A be a randomized online-LOCAL algorithm solving Π over a family Fof graphs that is closed under disjoint graph union and node and edge removals. Assume A has locality T (n) and success probability p(n) &gt; 0 for an n-node graph. Then there exists an amnesiac online-LOCAL algorithm A ′ that solves Π on a graph in F with n nodes with locality T (2</p><p>Note the locality is such that, if p(n) converges to 1 fast enough, then we only have a 2 poly(n) blowup in the locality (instead of a doubly-exponential one).</p><p>Proof. The main idea is to adapt the proof of Lemma 7.5. The main challenge is that the construction of the simulation graph in the proof of Lemma 7.5 was adaptive to the output of the deterministic online-LOCAL algorithm; however, the adversary in the randomized online-LOCAL model is oblivious to the randomness of the algorithm. In fact only a q ′ = 1/|Σ out | fraction of components in each phase of the proof of Lemma 7.5 are good, and we cannot adaptively choose to use only those.</p><p>To combat this, we modify the experiment: instead of adaptively choosing only the good components and discarding the rest, we sample the components from the previous phases uniformly at random without replacement. We later show that the sampled component is good with probability at least q = q ′ /2. In the worst case, each component at layer N ℓ may use up to n partial onecomponent online-LOCAL runs from the previous layers N 1 , . . . , N ℓ-1 , each of which is sampled to be good with probability only q. As the construction is n levels deep (i.e., there are n layers N 1 , . . . , N n ) (if u is a leader, it still looks up in the tree for two different leader ancestor), and collects all the information regarding identifiers for G</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>u</head><p>) ≤ N nodes. The adversarial ordering according to which</p><p>u )] is induced by the ordering of the identifiers. Notice that it might still be that A processes two nodes at the same time but, due to the assignment of identifiers done by B 2 , the outputs of these nodes can be determined independently of each other. Then, u outputs whatever A outputs on u according to this simulation. If u is the root of the whole graph, then it knows already the all the identifiers needed to run</p><p>C v is the cluster of the root node of the graph, then by accessing the memory of v it gets access to all the information it needs to compute its output.</p><p>Notice that each B i has locality O(α), hence the whole algorithm B obtained by the composition of B 1 , B 2 , and B 3 has locality O(α) by <ref type="bibr" target="#b39">[38,</ref><ref type="bibr">Lemma 2.3]</ref>. Observe also that</p><p>Also, the final output of B is correct: Suppose, by contradiction, that there is a failure somewhere, that is, a node v could detect its neighborhood N r (v) as non-admissible. Suppose v does not belong C u where u is the root of the graph, and denote its two closest ancestors that are leader nodes by v  </p><p>and hence can be extended to a valid input for A with N nodes (choosing identifiers arbitrarily in [N 2 ] \ [N ] and extending the adversarial processing order respecting the ordering induced by identifiers). In the second case, u ∈ C</p><p>. Also in this case the output of u must be correct:</p><p>))] which contains only distinct identifiers</p><p>) and hence can be extended to a valid input for A with N nodes (choosing identifiers arbitrarily in [N 2 ] and extending the adversarial processing order respecting the ordering induced by identifiers). An analogous argument holds for nodes in C v where v is the root node of the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Lower bound for 3-coloring grids in randomized online-LOCAL</head><p>In this section, we will show that 3-coloring ( √ n × √ n)-grids in randomized online-LOCAL requires Ω(log n)-locality: Theorem 8.1. The locality of a randomized online-LOCAL algorithm for solving 3-coloring in</p><p>We will base our proof on the recent result of Chang et al. <ref type="bibr" target="#b23">[22]</ref>, where the authors show a similar lower bound for the deterministic online-LOCAL model. We will start with a brief overview of the techniques used in <ref type="bibr" target="#b23">[22]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Relevant ideas from Chang et al. [22]</head><p>The lower bound in <ref type="bibr" target="#b23">[22]</ref> is based on the idea that any coloring of a grid G with the three colors {1, 2, 3} can be partitioned into regions with colors 1 and 2 that are separated by boundaries of color 3. Formally, a region is a maximal connected component that is colored only with colors 1 and 2, while a boundary is a maximal connected component in G 2 that is colored only with color 3. It We make use of the method of conditional expectations from <ref type="bibr" target="#b40">[39]</ref> to derandomize the model of dynamic-LOCAL computation. We note that while the following theorems are proven for the class of all graphs, they can be extended to any subclass of graphs. Theorem 9.1. Let Π be an LCL problem, and let A be a randomized LOCAL algorithm solving Π with locality T (n) and probability p &gt; 1 -1/n. Then there exists a deterministic dynamic-LOCAL algorithm A ′ solving Π with locality O(T (n)).</p><p>Proof. The randomized LOCAL algorithm A can be viewed as a deterministic LOCAL algorithm which is given i.i.d. random variables R v locally for each node v. We show that there exists a dynamic-LOCAL algorithm with locality O(T (n)) that assigns fixed values ρ v for each R v such that when A is run on these values as R v , it produces a correct output for problem Π. Such dynamic-LOCAL clearly implies an O(T (n))-locality dynamic-LOCAL algorithm for problem Π as one can compose it with A. The proof uses a technique similar to that of derandomizing LOCAL algorithms in SLOCAL <ref type="bibr" target="#b40">[39]</ref>.</p><p>We use the method of conditional expectation. Let F v be a flag that is 1 when the output around node v is invalid, and 0 otherwise. Note that F v depends only on the radius-r neighborhood of node v. Let F = v∈V F v . As Π is an LCL problem, F = 0 iff the labeling is correct for the whole graph, and otherwise</p><p>Let σ = e 1 , e 2 , . . . , e m be the order of edges in which the adversary dynamically modifies the graph, and let G i be the graph after modification i. Note that any edge can appear multiple times in the sequence if the adversary also removes edges. Now algorithm A ′ sets the randomness as follows:</p><p>in the previous step. Hence, there exists some concrete values for ρ u for dist(u,</p><p>sets all ρ u to such values. Finally, algorithm A ′ simulates A for all nodes within radius T (n) + r from e i with randomness fixed at ρ. This produces a correct labeling for all nodes as</p><p>Theorem 9.2. Let Π be an LCL problem, and let there exist a randomized LOCAL algorithm solving it with locality O(log * n). Then there exists a dynamic-LOCAL algorithm solving Π with locality O(1).</p><p>Proof. Using <ref type="bibr" target="#b22">[21]</ref>, a randomized LOCAL algorithm for solving Π with locality O(log * n) implies the existence of a deterministic LOCAL algorithm solving Π with locality O(log * n). Moreover, the deterministic LOCAL algorithm can be normalized into an algorithm that first finds a distance-k coloring with O(∆ k ) colors for some constant k, and then applies an O(k)-locality LOCAL algorithm A on this coloring. The dynamic-LOCAL algorithm for solving Π maintains a distance-k coloring with O(∆ k ) colors on the graph, and then applies A on these colors. When the dynamic-LOCAL algorithm encounters an update, it first clears the colors of all nodes within distance k from the update, and greedily assigns new colors for those nodes. The greedy assignment always succeeds since each node can have at most ∆ k neighbors within distance k hence they can use at most ∆ k of the available colors. Finally, the algorithm applies A on all nodes of the graph. As A is a deterministic LOCAL algorithm with locality O(k), and only the colors of nodes within distance k of the update have changed, we have that only the output of nodes within distance O(k) = O(1) from the update change.</p><p>10 Randomized online-LOCAL with an adaptive adversary This section aims at showing that randomized online-LOCAL with an adaptive adversary is as strong as its deterministic counterpart. The proof is very similar to the proof of Theorem 9.1 and uses, again, the method of conditional expectations. Also, as in the previous section, the results can be extended to any subclass of graphs.</p><p>Theorem 10.1. Let Π be an LCL problem, and let A be an online-LOCAL algorithm with an adaptive adversary solving Π with locality T (n) and probability p &gt; 1 -1/n. Then there exists a deterministic online-LOCAL algorithm A ′ solving Π with locality T (n).</p><p>Proof. Let A be an algorithm in the online-LOCAL model with an adaptive adversary and with round complexity T (n). We construct a deterministic online-LOCAL algorithm A ′ with the same round complexity T (n) as follows: The algorithm A ′ simulates A with certain fixed random-bit-strings. In particular, whenever new nodes arrive at the input, the algorithm A ′ fixes the random bits in all newly arrived nodes in the way we describe below.</p><p>We view a run of an online-LOCAL algorithm with an adaptive adversary as a game between an algorithm A and an adversary. In each step of that game, first the adversary chooses a set of nodes that arrive at the input (one special node and its neighborhood). Then the algorithm A samples the random bits of the newly arrived nodes and fixes the label of the arrived node. After i steps of this game, we use F to denote the event that the adversary wins the game, that is algorithm A produces an invalid output according to problem Π. By definition, we have Pr [F] ≤ 1/n. Here and from now on, the probability expressions assume that the adversary maximizes the probability of F happening.</p><p>Our algorithm A ′ in each i-th step fixes the random bits of the newly arrived nodes in a way that guarantees that</p><p>Here, B j = b j stands for fixing the values of random bits of nodes that arrived in the j-th step to b j . We note that this can always be done since, by definition, we have</p><p>Moreover, the online-LOCAL algorithm importantly both knows all the past arrived nodes and their randomness, and can also consider all the different choices of the adversary in the future, and hence can compute the above conditional probabilities.</p><p>At the end of the simulation of A, we have Pr [F|B 1 = b 1 , . . . , B n = b n ] &lt; 1, and hence the bad event F does not occur. This implies that the algorithm A ′ is always correct.</p><p>Remark 10.2. This proof assumes that we have white-box access to the randomized online-LOCAL algorithm and that it uses finitely many random bits. If either of these assumptions does not hold, we can use a more inefficient derandomization along the lines of <ref type="bibr" target="#b31">[30]</ref>. Here, we just observe that an online-LOCAL algorithm working against an adaptive adversary implies the existence of a function f that maps all possible input sequences on all possible n-node graphs that can be produced by the adversary to a valid output of the problem Π. The deterministic online-LOCAL algorithm finds such a function f at the beginning of its execution and produces the output according to f .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">LCL problems in paths and cycles in randomized online-LOCAL</head><p>In this section, we show that the complexity of LCLs in paths and cycles is either O(1) or Θ(n) in randomized online-LOCAL (with an oblivious adversary).</p><p>Theorem 11.1. Let Π be an LCL problem on paths and cycles (possibly with inputs). If the locality of Π is T in the randomized online-LOCAL model, then its locality is O(T + log * n) in the LOCAL model.</p><p>This theorem is a simple corollary of the following two lemmas: Lemma 11.2. Let Π be an LCL problem on paths and cycles (possibly with inputs), and let A be a randomized online-LOCAL algorithm solving Π with locality o(n). Then there exists a randomized online-LOCAL algorithm A ′ solving Π with locality O(1).</p><p>Lemma 11.3. Let Π be an LCL problem on paths and cycles (possibly with inputs), and let A be a randomized online-LOCAL algorithm solving Π with locality O(1). Then there exists a LOCAL algorithm A ′ solving Π with locality O(log * n).</p><p>By previous results <ref type="bibr">[2]</ref>, it is known that, in the case of paths and cycles, any (deterministic) online-LOCAL algorithm with sublinear locality can be sped up to an online-LOCAL algorithm with constant locality. We show how to extend [2, Lemma 5.5]. We start by constructing a large virtual graph P ′ such that, when the original algorithm runs on the virtual graph P ′ , the labeling produced by the algorithm is locally compatible with the labeling in the original graph P .</p><p>Proof of Lemma 11.2. Let Π be an LCL problem in paths or cycles with checking-radius r, let P be a path or a cycle with n nodes, and let A be a randomized online-LOCAL algorithm solving Π with locality T (n) = o(n). In the proof of [2, Lemma 5.5], the authors use three phases to speed up (deterministic) online-LOCAL with sublinear locality to only constant locality. We use the same strategy to construct a randomized online-LOCAL algorithm A ′ for solving Π with constant locality. The phases for constructing randomized online-LOCAL algorithm A ′ are as follows:</p><p>1. In the first phase, the algorithm deterministically creates an (α, α)-ruling set R for the path P , mirroring the approach outlined in the proof of [2, Lemma 5.5].</p><p>2. In the second phase, the algorithm constructs a larger virtual path P ′ with N nodes and simulates algorithm A on P ′ in the neighborhoods of nodes in R. Intuitively this path P ′ is constructed based on the pumping-lemma-style argument on LCL problems presented by Chang and Pettie <ref type="bibr" target="#b20">[19]</ref>, and it only relies on (the definition of) problem Π, not the algorithm A. During this simulation, the algorithm encounters a failure only if A fails within specific neighborhoods of P ′ . Consequently, the algorithm's success in this phase aligns with the success rate of A, ensuring a high probability of success.</p><p>3. The third phase is also as in [2, Lemma 5.5]: The algorithm extends the fixed labels around R to the entire path P by applying brute force for nodes outside the neighborhood of R. Note that this extending is feasible because of the way the path P ′ is created and the pumping-lemma-style argument as discussed in <ref type="bibr">[2]</ref>.</p><p>In the end, we compose these three phases together to obtain the randomized online-LOCAL algorithm A ′ for solving Π with constant locality.</p><p>A Quantum, bounded-dependence, and non-signaling</p><p>This appendix introduces both the non-signaling model and the bounded-dependence model, which are the most powerful models that satisfy physical causality, and thus they generalize the quantum-LOCAL model. The distinction between the non-signaling model and the bounded-dependence depends on whether shared states are available (in the non-signaling model) or not (in the boundeddependence model). We illustrate the difference between these models by analyzing the problem of c = 2-coloring a lifebuoy-shaped graph (see Fig. <ref type="figure">6</ref> and Fig. <ref type="figure">7b</ref>) with locality T = 2.</p><p>We first introduce a circuit formalism which allows us to clarify the early works of Arfaoui and Fraigniaud <ref type="bibr" target="#b4">[3]</ref>, and Gavoille et al. <ref type="bibr" target="#b37">[36]</ref>, by re-expressing the randomized LOCAL and quantum-LOCAL models in this formalism (see Appendix A.1). Second, we introduce the concept of light-cones and the principle of non-signaling, explaining how (together with the symmetries of the graph) they define the non-signaling model (see Appendices A.1.3 and A.1.4). Third, we show in Appendix A.2 that lifebuoy-shaped graphs are not 2-colorable in the non-signaling model with locality T = 2 through a reduction from the 2-colorability of the cheating graph H shown in Fig. <ref type="figure">7a</ref>. At last, we define the bounded-dependence model based on our circuit formalism and on the following three principles: device replication; non-signaling and independence <ref type="bibr" target="#b15">[14,</ref><ref type="bibr" target="#b26">25,</ref><ref type="bibr" target="#b27">26,</ref><ref type="bibr" target="#b42">41]</ref>; and invariance under symmetries of the graph (see Appendix A.3). We stress its connection to the concept of finitely-dependent distributions <ref type="bibr">[1,</ref><ref type="bibr" target="#b45">44,</ref><ref type="bibr" target="#b46">45,</ref><ref type="bibr" target="#b48">47,</ref><ref type="bibr" target="#b64">63]</ref>. Figure <ref type="figure">6</ref>: An example of a lifebuoy-shaped graph G. The lifebuoy-shaped graphs are defined by the set G of graphs that are isomorphic to the above. Notice that their chromatic number is 2. In our case, the node labels required by the LOCAL model are unique and go from 1 to 12. Granting this extra power is not restrictive as we are proving a lower bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Randomized LOCAL, quantum-LOCAL, and non-signaling models</head><p>In the next two sections, we re-introduce the randomized LOCAL model and the quantum-LOCAL model for coloring lifebuoy-shaped graphs in a circuit formalism. This will later enable us to clarify the definitions of the non-signaling and bounded-dependence models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1.1 Randomized LOCAL model</head><p>We consider twelve nodes with unique identifiers ranging from 1 to 12 and that are connected in a lifebuoy-shaped graph that is a priori unknown to the nodes 3 (an example of such graph is the labeled graph G 0 ∈ G illustrated in Fig. <ref type="figure">7b</ref>). The nodes try to color this graph in the randomized A generic classical strategy with shared randomness can be in the same way represented by the general circuit of Fig. <ref type="figure">8b</ref>, by initializing the circuit with a source of randomness common to all nodes (the large semicircle).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1.2 Quantum-LOCAL model</head><p>Any quantum strategy can also be represented by the circuit formalism of Fig. <ref type="figure">8</ref> by using resources and processing operations that are quantum rather than classical. Quantum information theory provides a concrete mathematical formalism (based on the tensor product of Hilbert spaces) with rules to represent the potential operations performed by each of the gates of the circuit. Semicircles, line wires, and squares now respectively represent the creation of a quantum state (a density matrix), the transfer (or storage) of quantum information, and the processing of quantum information with quantum channels (or quantum measurements in the last layer) represented by completely positive operators. Once the quantum states and channels are made explicit, the Born rule of quantum information theory <ref type="bibr" target="#b16">[15,</ref><ref type="bibr" target="#b59">58]</ref> allows computing Pr [c 1 , . . . , c n |C G,T ], the output distribution of the strategy on graph G.</p><p>However, analyzing the quantum-LOCAL model directly is complicated. Instead, we employ the fact that it is possible to bound the time complexity of the quantum-LOCAL model by analyzing models that do not depend on the mathematical formalism of quantum information theory (and which are, therefore, arguably simpler). In the present appendix, we utilize the fact that quantum-LOCAL is sandwiched between the randomized LOCAL model (less powerful) and the non-signaling model (the most powerful model satisfying the information-theoretic principles of non-signaling, independence and device replication we introduce bellow). We next introduce the non-signaling model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1.3 The non-signaling model (with unique identifiers)</head><p>The non-signaling model is the most powerful model of synchronous distributed computing that does not violate physical causality, when a pre-established shared resource exists.</p><p>The formulation of the non-signaling model is radically different from the randomized LOCAL and quantum-LOCAL models. The randomized LOCAL and quantum-LOCAL models are based on classical (randomized) and quantum information theory which both provide a mathematical formalism to describe information processing gates and to compute the probability distribution of outputs when these gates are placed in a circuit. To show that some probability distribution is feasible in these models, one needs to propose a valid strategy in these mathematical formalisms. The non-signaling model does not rely on any underlying mathematical formalism, but on some information-theoretical principles which should not be violated. More precisely, to show that some probability distribution is feasible in the non-signaling model, one needs to explain how to obtain it, but only to make sure that this probability distribution is compatible with the non-signaling principle in a way we now explain.</p><p>Before introducing this principle, we state the following definition of light-cones:</p><p>Definition A.1 (Past light-cone). Consider a circuit. Consider a subset of gates R, and another gate s / ∈ R in that circuit. We say that s is in the past light-cone of R if starting from s, one can reach a gate in R by traveling down the circuit. For instance, in Fig. <ref type="figure">8b</ref>, the past light-cone of the second processing gates of nodes {1, 2} is composed of all gates in red.</p><p>Remark A.2. Light-cones allow to formalize the fact that, in a circuit, the precise time ordering in which the gates process information has no influence over the result, as long as physical causality (that is, information can be transferred only through communication) is preserved. For instance, in Fig. <ref type="figure">8a</ref>, our drawing of the circuit represents the processing-1 gate of node 8 as being in the past of the processing-2 gate of node 2. However, by stretching the communication lines, another drawing in which this time ordering is exchanged exists, and this is possible as long as one node is not in the past light cone of another. The name "light-cone" refers to relativity, where physical causality is bounded by the speed of light. Circuits provide an abstracted representation of physical causality that is not based on any notion of spacetime.</p><p>We now state the non-signaling principle 5 , which is essentially the only constraint in the nonsignaling model. </p><p>Implicitly, a non-signaling theory assumes that, given a set of gates and a valid way to connect them in a circuit C, one obtains a corresponding distribution Pr [c 1 , . . . , c n | C] 6 (here the alphabet of the outputs c i is not limited: e.g., in case of unexpected circuits, the measurement gates can produce failure outputs).</p><p>We are now ready to define the non-signaling model, which is associated to circuits with a pre-shared non-signaling resource such as in Fig. <ref type="figure">8b</ref>: Definition A.4 (Non-signaling model, with unique identifiers). The distribution</p><p>is feasible in the non-signaling model (with unique identifiers) with locality T on graph G if and only if, for all possible alternative connecting graphs H of the nodes, there exists a distribution P = Pr [c 1 , . . . , c n | C H,T ] such that the no-signaling principle is respected. 7   Note that H might not be a lifebuoy-shaped graph: in the case a gate 'discovers' this unexpected situation, it has the possibility to produce a new output from a set of error outputs (i.e. it crashes and no further useful constraint can be derived).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1.4 The non-signaling model without unique identifiers</head><p>We have up until now considered N = 12 nodes with unique identifiers ranging from 1 to N = 12. When the nodes do not start with unique identifiers, the situation is slightly more complicated. In that case, the resulting distribution should be invariant under subgraph isomorphism, as all nodes are running identical programs and the circuit is thus completely symmetric under permutations of nodes 8 . For instance, if the nodes were to color the graph of Fig. <ref type="figure">7b</ref> without being a priori assigned 5 Chiribella and Spekkens <ref type="bibr" target="#b25">[24]</ref> call this principle no-signaling from the future. 6 Note that the gates have "types" and can only be connected to other gates of matching types: For instance, in our case, the inputs of gates from the second processing step must correspond to the outputs of gates from the first processing step. The theory of circuits can be formalized using category theory -see, e.g. <ref type="bibr" target="#b32">[31]</ref>.</p><p>7 Note that considering scenarios with more than one copies of each node does not allow us to derive additional constraints, since the pre-shared non-signaling resource cannot by definition be cloned and extended to more than one copy of each of its original recipient.</p><p>8 Note that while a shared classical resource is inherently symmetric, because it can be without a loss of generality taken to be distributed identically to each party, a non-signaling resource is not a priori symmetric under permutation of the parties that it connects. The absence of identifiers thus forces the non-signaling model to pre-share only a subset of all possible non-signaling resources, namely the subset that respects such symmetry.</p><p>unique identifiers, the resulting circuit C G,T would have some symmetries (as all processing gates would be the same in any layer of the respective steps 0, 1 and 2), implying that the distribution should be invariant by several non-trivial graph isomorphisms cyclically permuting the nodes, or inverting the inner and outer cycle of 6 nodes. This definition can also be generalized to the case where several nodes with the same identifiers are present in G, or were the number of identifiers ranges from 1 to M ̸ = N .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Graph G is not 2-colorable in T = 2 rounds</head><p>We now show by contradiction that the nodes 1, . . . , 12 cannot 2-color the set G of lifebuoy-shaped graphs with a non-signaling strategy (including pre-shared non-signaling resources) in T = 2 rounds of communication. More precisely, we prove that if there existed such a non-signaling algorithm able to color any G ∈ G, then the same algorithm would also color the cheating graph H with 2 colors, which is impossible.</p><p>Proof. Assume by contradiction that there exists such a non-signaling algorithm, that is, there exist gates as in Fig. <ref type="figure">8b</ref>  We consider the same nodes performing the same gates, but we change the edges so that the connected nodes now form the graph H in Fig. <ref type="figure">7b</ref>. Let Pr [c 1 , . . . , c 12 | C H,T ] be the distribution of output colors in that new configuration 9 . Consider two nodes connected by an edge in H: by symmetry of H, we can without a loss of generality assume that these are nodes 1 and 2. We introduce the lifebuoy-shaped graph G 0 of Fig. <ref type="figure">7b</ref> (G 0 ∈ G depends on our choice of nodes, here 1, 2, in H). Then, we observe that the common past light-cones of the two nodes is the same when connected through H or through G 0 (compare the circuit of Fig. <ref type="figure">8b</ref> with the circuit of Fig. <ref type="figure">8c</ref>). It hence holds that Pr</p><p>T ] due to the non-signaling principle. We conclude that the non-signaling distributed algorithm outputs a 2-coloring for H, which is impossible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Bounded-dependence model</head><p>The bounded-dependence model is similar to the non-signaling model, but the former does not allow pre-shared non-signaling resources between the nodes. The following two new principles are needed to define feasible distributions in the bounded-dependence model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3.1 Relation with finitely-dependent distributions</head><p>Our bounded-dependence model is directly connected to the concept of finitely-dependent distributions introduced in mathematics <ref type="bibr">[1,</ref><ref type="bibr" target="#b45">[44]</ref><ref type="bibr" target="#b46">[45]</ref><ref type="bibr" target="#b47">[46]</ref><ref type="bibr" target="#b48">[47]</ref><ref type="bibr" target="#b64">63]</ref>. In this framework, in a graph H, the color c i produced by each node i is seen as the result of a random process C i . The set of all random processes {C i } i is said to be k-dependent in graph H if, for any two subsets U, V of the nodes of H which are at least at distance k + 1, the two sets of processes {C u } u∈U and C vv∈V are independent. In our notation, assuming even k and taking T = k/2, this is equivalent to asking that Pr Hence, the question of the existence of distributions with bounded dependence that solve some problem can directly be formulated in terms of the existence of finitely dependent distributions over a family of graphs that satisfy additional constraints of compatibility (to satisfy the non-signaling principle) and symmetries (to cope with subgraph isomorphisms). </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">This answers an open question by Holroyd [2024], and also presents a new barrier for proving bounds on distributed quantum advantage using causality-based arguments</title>
		<imprint/>
	</monogr>
	<note>All LCL problems solvable with locality O(log * n) in the classical deterministic LOCAL model admit a finitely-dependent distribution with locality O(1)</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">In rooted trees, if we can solve an LCL problem with locality o(log log log n) in the randomized online-LOCAL model (or any of the weaker models, such as quantum-LOCAL), we can solve it with locality O(log * n) in the classical deterministic LOCAL model. One of many implications is that in rooted trees, O(log * n) locality in quantum-LOCAL is not stronger than O(log * n) locality in classical LOCAL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An algebraic construction of a class of one-dependent processes</title>
		<author>
			<persName><forename type="first">Jon</forename><surname>Aaronson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Gilat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Keane</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vincent</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Valk</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Probability</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="128" to="143" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Locality in online, dynamic, sequential, and distributed graph algorithms</title>
		<author>
			<persName><forename type="first">Amirreza</forename><surname>Akbari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Navid</forename><surname>Eslami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Lievonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darya</forename><surname>Melnyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joona</forename><surname>Särkijärvi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.ICALP.2023.10</idno>
	</analytic>
	<monogr>
		<title level="m">50th International Colloquium on Automata, Languages, and Programming, ICALP 2023</title>
		<editor>
			<persName><forename type="first">Kousha</forename><surname>Etessami</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Uriel</forename><surname>Feige</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gabriele</forename><surname>Puppis</surname></persName>
		</editor>
		<meeting><address><addrLine>Paderborn, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2023">July 10-14, 2023</date>
			<biblScope unit="volume">261</biblScope>
			<biblScope unit="page">2023</biblScope>
		</imprint>
		<respStmt>
			<orgName>20. Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">What can be computed without communications?</title>
		<author>
			<persName><forename type="first">Heger</forename><surname>Arfaoui</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Fraigniaud</surname></persName>
		</author>
		<idno type="DOI">10.1145/2670418.2670440</idno>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="82" to="104" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">New classes of distributed time complexity</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juho</forename><surname>Hirvonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janne</forename><forename type="middle">H</forename><surname>Korhonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tuomo</forename><surname>Lempiäinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.1145/3188745.3188860</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2018</title>
		<editor>
			<persName><forename type="first">Ilias</forename><surname>Diakonikolas</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">David</forename><surname>Kempe</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Monika</forename><surname>Henzinger</surname></persName>
		</editor>
		<meeting>the 50th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2018<address><addrLine>Los Angeles, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">June 25-29, 2018. 2018</date>
			<biblScope unit="page" from="1307" to="1318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The distributed complexity of locally checkable problems on paths is decidable</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikaël</forename><surname>Rabie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.1145/3293611.3331606</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing, PODC 2019</title>
		<editor>
			<persName><forename type="first">Peter</forename><surname>Robinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Faith</forename><surname>Ellen</surname></persName>
		</editor>
		<meeting>the 2019 ACM Symposium on Principles of Distributed Computing, PODC 2019<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019-08-02">July 29 -August 2, 2019. 2019</date>
			<biblScope unit="page" from="262" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">How much does randomness help with locally checkable problems?</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.1145/3382734.3405715</idno>
	</analytic>
	<monogr>
		<title level="m">PODC &apos;20: ACM Symposium on Principles of Distributed Computing, Virtual Event</title>
		<editor>
			<persName><forename type="first">Yuval</forename><surname>Emek</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Christian</forename><surname>Cachin</surname></persName>
		</editor>
		<meeting><address><addrLine>Italy</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">August 3-7, 2020. 2020</date>
			<biblScope unit="page" from="299" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Lower bounds for maximal matchings and maximal independent sets</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juho</forename><surname>Hirvonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikaël</forename><surname>Rabie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.1145/3461458</idno>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">2021</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Almost global problems in the LOCAL model</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.1007/S00446-020-00375-2</idno>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="259" to="281" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient classification of locally checkable problems in regular trees</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Studený</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.DISC.2022.8</idno>
	</analytic>
	<monogr>
		<title level="m">36th International Symposium on Distributed Computing, DISC 2022</title>
		<editor>
			<persName><forename type="first">Christian</forename><surname>Scheideler</surname></persName>
		</editor>
		<meeting><address><addrLine>Augusta, Georgia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2022">October 25-27, 2022</date>
			<biblScope unit="volume">246</biblScope>
			<biblScope unit="page">2022</biblScope>
		</imprint>
	</monogr>
	<note>LIPIcs</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Local mending</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juho</forename><surname>Hirvonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Darya</forename><surname>Melnyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Rybicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-031-09993-9_1</idno>
	</analytic>
	<monogr>
		<title level="m">Structural Information and Communication Complexity -29th International Colloquium, SIROCCO 2022</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Merav</forename><surname>Parter</surname></persName>
		</editor>
		<meeting><address><addrLine>Paderborn, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2022">June 27-29, 2022</date>
			<biblScope unit="volume">13298</biblScope>
			<biblScope unit="page">2022</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Locally checkable problems in rooted trees</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Studený</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aleksandr</forename><surname>Tereshchenko</surname></persName>
		</author>
		<idno type="DOI">10.1007/S00446-022-00435-9</idno>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="277" to="311" />
			<date type="published" when="2023">2023</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Sinkless orientation made simple</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janne</forename><forename type="middle">H</forename><surname>Korhonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Lievonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shreyas</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ami</forename><surname>Paz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Rybicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stefan</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Studený</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jara</forename><surname>Uitto</surname></persName>
		</author>
		<idno type="DOI">10.1137/1.9781611977585.CH17</idno>
	</analytic>
	<monogr>
		<title level="m">2023 Symposium on Simplicity in Algorithms, SOSA 2023</title>
		<editor>
			<persName><forename type="first">Telikepalli</forename><surname>Kavitha</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Kurt</forename><surname>Mehlhorn</surname></persName>
		</editor>
		<meeting><address><addrLine>Florence, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2023">January 23-25, 2023</date>
			<biblScope unit="page">2023</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Shared randomness helps with local distributed problems</title>
		<author>
			<persName><forename type="first">Alkida</forename><surname>Balliu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Ghaffari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Augusto</forename><surname>Modanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikaël</forename><surname>Rabie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jara</forename><surname>Uitto</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2407.05445" />
		<imprint>
			<date type="published" when="2024">2024</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Covariance decomposition as a universal limit on correlations in networks</title>
		<author>
			<persName><forename type="first">Salman</forename><surname>Beigi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc-Olivier</forename><surname>Renou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="384" to="394" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Quantenmechanik der Stoßvorgänge</title>
		<author>
			<persName><forename type="first">Max</forename><surname>Born</surname></persName>
		</author>
		<idno type="DOI">10.1007/bf01397184</idno>
	</analytic>
	<monogr>
		<title level="j">Zeitschrift für Physik</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">11-12</biblScope>
			<biblScope unit="page" from="803" to="827" />
			<date type="published" when="1926">1926</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A lower bound for the distributed Lovász local lemma</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orr</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juho</forename><surname>Hirvonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Barbara</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tuomo</forename><surname>Lempiäinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Rybicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jara</forename><surname>Uitto</surname></persName>
		</author>
		<idno type="DOI">10.1145/2897518.2897570</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2016</title>
		<editor>
			<persName><forename type="first">Daniel</forename><surname>Wichs</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yishay</forename><surname>Mansour</surname></persName>
		</editor>
		<meeting>the 48th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2016<address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">June 18-21, 2016. 2016</date>
			<biblScope unit="page" from="479" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">LCL problems on grids</title>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juho</forename><surname>Hirvonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janne</forename><forename type="middle">H</forename><surname>Korhonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tuomo</forename><surname>Lempiäinen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Patric</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Östergård</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joel</forename><surname>Purcell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Rybicki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Przemyslaw</forename><surname>Suomela</surname></persName>
		</author>
		<author>
			<persName><surname>Uznanski</surname></persName>
		</author>
		<idno type="DOI">10.1145/3087801.3087833</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Principles of Distributed Computing</title>
		<editor>
			<persName><forename type="first">Michael</forename><surname>Elad</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Alexander</forename><forename type="middle">A</forename><surname>Schiller</surname></persName>
		</editor>
		<editor>
			<persName><surname>Schwarzmann</surname></persName>
		</editor>
		<meeting>the ACM Symposium on Principles of Distributed Computing<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017-07-25">2017. July 25-27, 2017. 2017</date>
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">13th Innovations in Theoretical Computer Science Conference, ITCS 2022</title>
		<author>
			<persName><forename type="first">Keren</forename><surname>Censor-Hillel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Orr</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Gall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dean</forename><surname>Leitersdorf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rotem</forename><surname>Oshman</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.ITCS.2022.35</idno>
	</analytic>
	<monogr>
		<title level="j">LIPIcs</title>
		<editor>
			<persName><forename type="first">Mark</forename><surname>Braverman</surname></persName>
		</editor>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page">2022</biblScope>
			<date type="published" when="2022-02-03">January 31 -February 3, 2022</date>
			<pubPlace>Berkeley, CA, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>25. Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
	<note>Quantum distributed algorithms for detection of cliques</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A time hierarchy theorem for the LOCAL model</title>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seth</forename><surname>Pettie</surname></persName>
		</author>
		<idno type="DOI">10.1137/17M1157957</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="33" to="69" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An exponential separation between randomized and deterministic complexity in the LOCAL model</title>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tsvi</forename><surname>Kopelowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seth</forename><surname>Pettie</surname></persName>
		</author>
		<idno type="DOI">10.1109/FOCS.2016.72</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE 57th Annual Symposium on Foundations of Computer Science, FOCS</title>
		<editor>
			<persName><forename type="first">Irit</forename><surname>Dinur</surname></persName>
		</editor>
		<meeting><address><addrLine>Hyatt Regency, New Brunswick, New Jersey, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2016-09-11">2016, 9-11 October 2016. 2016</date>
			<biblScope unit="page" from="615" to="624" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">An exponential separation between randomized and deterministic complexity in the LOCAL model</title>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tsvi</forename><surname>Kopelowitz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Seth</forename><surname>Pettie</surname></persName>
		</author>
		<idno type="DOI">10.1137/17M1117537</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="122" to="143" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A tight lower bound for 3-coloring grids in the online-LOCAL model</title>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gopinath</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hung</forename><forename type="middle">Thuan</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingyang</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu-Cheng</forename><surname>Yeh</surname></persName>
		</author>
		<idno type="DOI">10.48550/ARXIV.2312.01384</idno>
		<imprint>
			<biblScope unit="page">2023</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Distributed graph problems through an automata-theoretic lens</title>
		<author>
			<persName><forename type="first">Yi-Jun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Studený</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.1016/J.TCS.2023.113710</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">951</biblScope>
			<biblScope unit="page">2023</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">Giulio</forename><surname>Chiribella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">W</forename><surname>Spekkens</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-94-017-7303-4</idno>
		<title level="m">Quantum Theory: Informational Foundations and Foils</title>
		<meeting><address><addrLine>Netherlands</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Any physical theory of nature must be boundlessly multipartite nonlocal</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Coiteux-Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elie</forename><surname>Wolfe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc-Olivier</forename><surname>Renou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review A</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">52207</biblScope>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">No Bipartite-Nonlocal Causal Theory Can Explain Nature&apos;s Correlations</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Coiteux-Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Elie</forename><surname>Wolfe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc-Olivier</forename><surname>Renou</surname></persName>
		</author>
		<idno type="DOI">10.1103/physrevlett.127.200401</idno>
	</analytic>
	<monogr>
		<title level="j">Physical Review Letters</title>
		<imprint>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="issue">20</biblScope>
			<biblScope unit="page">2021</biblScope>
			<date>200401</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">No distributed quantum advantage for approximate graph coloring</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Coiteux-Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><surname>Amore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rishikesh</forename><surname>Gajjala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Gall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Lievonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Augusto</forename><surname>Modanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc-Olivier</forename><surname>Renou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gustav</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 56th Annual ACM Symposium on Theory of Computing (STOC 2024)</title>
		<meeting>56th Annual ACM Symposium on Theory of Computing (STOC 2024)</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2024">2024</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">The genuinely multipartite nonlocality of graph states is model-dependent, 2024</title>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Coiteux-Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Owidiusz</forename><surname>Makuta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fionnuala</forename><surname>Curran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Remigiusz</forename><surname>Augusiak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marc-Olivier</forename><surname>Renou</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In preparation</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Deterministic coin tossing with applications to optimal parallel list ranking</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Cole</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Uzi</forename><surname>Vishkin</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0019-9958(86)80023-7</idno>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="32" to="53" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Brief announcement: Distributed derandomization revisited</title>
		<author>
			<persName><forename type="first">Sameep</forename><surname>Dahal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Francesco</forename><forename type="middle">D</forename><surname>'amore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Lievonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Timothé</forename><surname>Picavet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.DISC.2023.40</idno>
	</analytic>
	<monogr>
		<title level="m">37th International Symposium on Distributed Computing, DISC 2023</title>
		<editor>
			<persName><forename type="first">Rotem</forename><surname>Oshman</surname></persName>
		</editor>
		<meeting><address><addrLine>L&apos;Aquila, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2023">October 10-12, 2023</date>
			<biblScope unit="volume">281</biblScope>
			<biblScope unit="page">2023</biblScope>
		</imprint>
	</monogr>
	<note>LIPIcs</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Quantum Theory from First Principles: An Informational Approach</title>
		<author>
			<persName><forename type="first">Giacomo</forename><surname>Mauro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D'</forename><surname>Ariano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Giulio</forename><surname>Chiribella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paolo</forename><surname>Perinotti</surname></persName>
		</author>
		<idno type="DOI">10.1017/9781107338340</idno>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Local problems in trees across a wide range of distributed models</title>
		<author>
			<persName><forename type="first">Anubhav</forename><surname>Dhar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eli</forename><surname>Kujawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Henrik</forename><surname>Lievonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Augusto</forename><surname>Modanese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mikail</forename><surname>Muftuoglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Studený</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Leibniz International Proceedings in Informatics (LIPIcs). Schloss Dagstuhl-Leibniz-Zentrum für Informatik</title>
		<imprint>
			<date type="published" when="2024">2024</date>
		</imprint>
	</monogr>
	<note>Proc. 28th International Conference on Principles of Distributed Systems (OPODIS 2024)</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Can quantum communication speed up distributed computation</title>
		<author>
			<persName><forename type="first">Hartmut</forename><surname>Michael Elkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danupon</forename><surname>Klauck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gopal</forename><surname>Nanongkai</surname></persName>
		</author>
		<author>
			<persName><surname>Pandurangan</surname></persName>
		</author>
		<idno type="DOI">10.1145/2611462.2611488</idno>
	</analytic>
	<monogr>
		<title level="m">ACM Symposium on Principles of Distributed Computing, PODC &apos;14</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Magnús</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Shlomi</forename><surname>Halldórsson</surname></persName>
		</editor>
		<editor>
			<persName><surname>Dolev</surname></persName>
		</editor>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014">July 15-18, 2014. 2014</date>
			<biblScope unit="page" from="166" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Sublogarithmic distributed algorithms for Lovász local lemma, and the complexity hierarchy</title>
		<author>
			<persName><forename type="first">Manuela</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Ghaffari</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.DISC.2017.18</idno>
	</analytic>
	<monogr>
		<title level="m">st International Symposium on Distributed Computing</title>
		<editor>
			<persName><forename type="first">W</forename><surname>Andréa</surname></persName>
		</editor>
		<editor>
			<persName><surname>Richa</surname></persName>
		</editor>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-10-16">2017. October 16-20, 2017. 2017</date>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
		<respStmt>
			<orgName>16. Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Even-cycle detection in the randomized and quantum CONGEST model</title>
		<author>
			<persName><forename type="first">Pierre</forename><surname>Fraigniaud</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maël</forename><surname>Luce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Magniez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ioan</forename><surname>Todinca</surname></persName>
		</author>
		<idno type="DOI">10.1145/3662158.3662767</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd ACM Symposium on Principles of Distributed Computing, PODC 2024</title>
		<editor>
			<persName><forename type="first">Ran</forename><surname>Gelles</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Petr</forename><surname>Kuznetsov</surname></persName>
		</editor>
		<meeting>the 43rd ACM Symposium on Principles of Distributed Computing, PODC 2024<address><addrLine>Nantes, France</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2024">June 17-21, 2024</date>
			<biblScope unit="page">2024</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">What can be observed locally?</title>
		<author>
			<persName><forename type="first">Cyril</forename><surname>Gavoille</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrian</forename><surname>Kosowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marcin</forename><surname>Markiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-04355-0_26</idno>
	</analytic>
	<monogr>
		<title level="m">Distributed Computing, 23rd International Symposium</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">Idit</forename><surname>Keidar</surname></persName>
		</editor>
		<meeting><address><addrLine>Elche, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009-09-23">2009. September 23-25, 2009. 2009</date>
			<biblScope unit="volume">5805</biblScope>
			<biblScope unit="page" from="243" to="257" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Distributed degree splitting, edge coloring, and orientations</title>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Ghaffari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hsin-Hao</forename><surname>Su</surname></persName>
		</author>
		<idno type="DOI">10.1137/1.9781611974782.166</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eighth Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<editor>
			<persName><forename type="first">N</forename><surname>Philip</surname></persName>
		</editor>
		<editor>
			<persName><surname>Klein</surname></persName>
		</editor>
		<meeting>the Twenty-Eighth Annual ACM-SIAM Symposium on Discrete Algorithms<address><addrLine>Barcelona, Spain, Hotel Porta Fira</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-01-16">2017. January 16-19. 2017</date>
			<biblScope unit="page" from="2505" to="2523" />
		</imprint>
	</monogr>
	<note>SIAM</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">On the complexity of local distributed graph problems</title>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Ghaffari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannic</forename><surname>Maus</surname></persName>
		</author>
		<idno type="DOI">10.1145/3055399.3055471</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing, STOC</title>
		<editor>
			<persName><forename type="first">Hamed</forename><surname>Hatami</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Pierre</forename><surname>Mckenzie</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Valerie</forename><surname>King</surname></persName>
		</editor>
		<meeting>the 49th Annual ACM SIGACT Symposium on Theory of Computing, STOC<address><addrLine>Montreal, QC, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017-06-19">2017. June 19-23, 2017. 2017</date>
			<biblScope unit="page" from="784" to="797" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">On derandomizing local distributed algorithms</title>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Ghaffari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">G</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Kuhn</surname></persName>
		</author>
		<idno type="DOI">10.1109/FOCS.2018.00069</idno>
	</analytic>
	<monogr>
		<title level="m">59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018</title>
		<editor>
			<persName><forename type="first">Mikkel</forename><surname>Thorup</surname></persName>
		</editor>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2018">October 7-9, 2018. 2018</date>
			<biblScope unit="page" from="662" to="673" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Improved distributed degree splitting and edge coloring</title>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Ghaffari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Juho</forename><surname>Hirvonen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fabian</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yannic</forename><surname>Maus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jara</forename><surname>Uitto</surname></persName>
		</author>
		<idno type="DOI">10.1007/S00446-018-00346-8</idno>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="293" to="310" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Constraints on nonlocality in networks from no-signaling and independence</title>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Gisin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Daniel</forename><surname>Bancal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Remy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Armin</forename><surname>Tavakoli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emmanuel</forename><forename type="middle">Zambrini</forename><surname>Cruzeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandu</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicolas</forename><surname>Brunner</surname></persName>
		</author>
		<idno type="DOI">10.1038/s41467-020-16137-4</idno>
	</analytic>
	<monogr>
		<title level="j">Nature Communications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">2378</biblScope>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Parallel symmetry-breaking in sparse graphs</title>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">V</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Serge</forename><forename type="middle">A</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gregory</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
		<idno type="DOI">10.1137/0401044</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="434" to="446" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">On the power of quantum distributed proofs</title>
		<author>
			<persName><forename type="first">Atsuya</forename><surname>Hasegawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Srijita</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harumichi</forename><surname>Nishimura</surname></persName>
		</author>
		<idno type="DOI">10.1145/3662158.3662788</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd ACM Symposium on Principles of Distributed Computing, PODC 2024</title>
		<editor>
			<persName><forename type="first">Ran</forename><surname>Gelles</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Petr</forename><surname>Kuznetsov</surname></persName>
		</editor>
		<meeting>the 43rd ACM Symposium on Principles of Distributed Computing, PODC 2024<address><addrLine>Nantes, France</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2024">June 17-21, 2024</date>
			<biblScope unit="page">2024</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Symmetrization for finitely dependent colouring</title>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">E</forename><surname>Holroyd</surname></persName>
		</author>
		<idno type="DOI">10.1214/24-ecp600</idno>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page">2024</biblScope>
		</imprint>
	</monogr>
	<note>Electronic Communications in Probability</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">E</forename><surname>Holroyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">M</forename><surname>Liggett</surname></persName>
		</author>
		<idno type="DOI">10.1017/fmp.2016.7</idno>
	</analytic>
	<monogr>
		<title level="j">Finitely Dependent Coloring. Forum of Mathematics</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>Pi, 4:e9</note>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Finitary coloring. The Annals of Probability</title>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">E</forename><surname>Holroyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Oded</forename><surname>Schramm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">B</forename><surname>Wilson</surname></persName>
		</author>
		<idno type="DOI">10.1214/16-aop1127</idno>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="2867" to="2898" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Electronic Communications in Probability</title>
		<author>
			<persName><forename type="first">Alexander</forename><forename type="middle">E</forename><surname>Holroyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tom</forename><surname>Hutchcroft</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Avi</forename><surname>Levy</surname></persName>
		</author>
		<idno type="DOI">10.1214/18-ecp118</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">23</biblScope>
		</imprint>
	</monogr>
	<note>Finitely dependent cycle coloring</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Quantum distributed algorithm for the all-pairs shortest path problem in the CONGEST-CLIQUE model</title>
		<author>
			<persName><forename type="first">Taisuke</forename><surname>Izumi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename><forename type="middle">Le</forename><surname>Gall</surname></persName>
		</author>
		<idno type="DOI">10.1145/3293611.3331628</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing, PODC 2019</title>
		<editor>
			<persName><forename type="first">Peter</forename><surname>Robinson</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Faith</forename><surname>Ellen</surname></persName>
		</editor>
		<meeting>the 2019 ACM Symposium on Principles of Distributed Computing, PODC 2019<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019-08-02">July 29 -August 2, 2019. 2019</date>
			<biblScope unit="page" from="84" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Quantum distributed algorithm for triangle finding in the CONGEST model</title>
		<author>
			<persName><forename type="first">Taisuke</forename><surname>Izumi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">François</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Le</forename><surname>Gall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Magniez</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.STACS.2020.23</idno>
	</analytic>
	<monogr>
		<title level="m">37th International Symposium on Theoretical Aspects of Computer Science, STACS 2020</title>
		<editor>
			<persName><forename type="first">Christophe</forename><surname>Paul</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Markus</forename><surname>Bläser</surname></persName>
		</editor>
		<meeting><address><addrLine>Montpellier, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">March 10-13, 2020. 2020</date>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="page" from="1" to="23" />
		</imprint>
		<respStmt>
			<orgName>13. Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Toward more localized local algorithms: removing assumptions concerning global knowledge</title>
		<author>
			<persName><forename type="first">Amos</forename><surname>Korman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jean-Sébastien</forename><surname>Sereni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Viennot</surname></persName>
		</author>
		<idno type="DOI">10.1007/S00446-012-0174-8</idno>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">5-6</biblScope>
			<biblScope unit="page" from="289" to="308" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Sublinear-time quantum computation of the diameter in CONGEST networks</title>
		<author>
			<persName><forename type="first">Le</forename><surname>François</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Gall</surname></persName>
		</author>
		<author>
			<persName><surname>Magniez</surname></persName>
		</author>
		<idno type="DOI">10.1145/3212734.3212744</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM Symposium on Principles of Distributed Computing</title>
		<meeting>the 2018 ACM Symposium on Principles of Distributed Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="337" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Quantum advantage for the LOCAL model in distributed computing</title>
		<author>
			<persName><forename type="first">Le</forename><surname>François</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harumichi</forename><surname>Gall</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ansis</forename><surname>Nishimura</surname></persName>
		</author>
		<author>
			<persName><surname>Rosmanis</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.STACS.2019.49</idno>
	</analytic>
	<monogr>
		<title level="m">36th International Symposium on Theoretical Aspects of Computer Science, STACS 2019</title>
		<editor>
			<persName><forename type="first">Rolf</forename><surname>Niedermeier</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Christophe</forename><surname>Paul</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">March 13-16, 2019. 2019</date>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="page" from="1" to="49" />
		</imprint>
		<respStmt>
			<orgName>14. Schloss Dagstuhl -Leibniz-Zentrum für Informatik</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Distributive graph algorithms-global solutions from local data</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Linial</surname></persName>
		</author>
		<idno type="DOI">10.1109/SFCS.1987.20</idno>
	</analytic>
	<monogr>
		<title level="m">28th Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Los Angeles, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1987-10-29">27-29 October 1987. 1987</date>
			<biblScope unit="page" from="331" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Locality in distributed graph algorithms</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Linial</surname></persName>
		</author>
		<idno type="DOI">10.1137/0221015</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="193" to="201" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Quantum distributed complexity of set disjointness on a line</title>
		<author>
			<persName><forename type="first">Frédéric</forename><surname>Magniez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashwin</forename><surname>Nayak</surname></persName>
		</author>
		<idno type="DOI">10.1145/3512751</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computation Theory</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">2022</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Linial for lists</title>
		<author>
			<persName><forename type="first">Yannic</forename><surname>Maus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tigran</forename><surname>Tonoyan</surname></persName>
		</author>
		<idno type="DOI">10.1007/S00446-022-00424-Y</idno>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="533" to="546" />
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">What can be computed locally?</title>
		<author>
			<persName><forename type="first">Moni</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><forename type="middle">J</forename><surname>Stockmeyer</surname></persName>
		</author>
		<idno type="DOI">10.1137/S0097539793254571</idno>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1259" to="1277" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Isaac</forename><forename type="middle">L</forename><surname>Chuang</surname></persName>
		</author>
		<idno type="DOI">10.1017/cbo9780511976667</idno>
		<title level="m">Quantum Computation and Quantum Information: 10th Anniversary Edition</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">Round eliminator: a tool for automatic speedup simulation</title>
		<author>
			<persName><forename type="first">Dennis</forename><surname>Olivetti</surname></persName>
		</author>
		<ptr target="https://github.com/olidennis/round-eliminator" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Some simple distributed algorithms for sparse networks</title>
		<author>
			<persName><forename type="first">Alessandro</forename><surname>Panconesi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Romeo</forename><surname>Rizzi</surname></persName>
		</author>
		<idno type="DOI">10.1007/PL00008932</idno>
	</analytic>
	<monogr>
		<title level="j">Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="97" to="100" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Distributed Computing: A Locality-Sensitive Approach</title>
		<author>
			<persName><forename type="first">David</forename><surname>Peleg</surname></persName>
		</author>
		<idno type="DOI">10.1137/1.9780898719772</idno>
	</analytic>
	<monogr>
		<title level="j">Society for Industrial and Applied Mathematics</title>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Polylogarithmic-time deterministic network decomposition and distributed derandomization</title>
		<author>
			<persName><forename type="first">Václav</forename><surname>Rozhon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohsen</forename><surname>Ghaffari</surname></persName>
		</author>
		<idno type="DOI">10.1145/3357713.3384298</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual ACM SIGACT Symposium on Theory of Computing, STOC 2020</title>
		<editor>
			<persName><forename type="first">Konstantin</forename><surname>Makarychev</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yury</forename><surname>Makarychev</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Madhur</forename><surname>Tulsiani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Gautam</forename><surname>Kamath</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Julia</forename><surname>Chuzhoy</surname></persName>
		</editor>
		<meeting>the 52nd Annual ACM SIGACT Symposium on Theory of Computing, STOC 2020<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2020">June 22-26, 2020. 2020</date>
			<biblScope unit="page" from="350" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Finitely dependent processes are finitary</title>
		<author>
			<persName><forename type="first">Yinon</forename><surname>Spinka</surname></persName>
		</author>
		<idno type="DOI">10.1214/19-aop1417</idno>
	</analytic>
	<monogr>
		<title level="j">The Annals of Probability</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="2088" to="2117" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">:1. Schloss Dagstuhl -Leibniz-Zentrum für Informatik</title>
		<author>
			<persName><forename type="first">Jukka</forename><surname>Suomela</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPICS.SWAT.2020.2</idno>
	</analytic>
	<monogr>
		<title level="m">17th Scandinavian Symposium and Workshops on Algorithm Theory, SWAT 2020</title>
		<editor>
			<persName><forename type="first">Susanne</forename><surname>Albers</surname></persName>
		</editor>
		<meeting><address><addrLine>Tórshavn, Faroe Islands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020">June 22-24, 2020. 2020</date>
			<biblScope unit="volume">162</biblScope>
		</imprint>
	</monogr>
	<note>Landscape of locality (invited talk)</note>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title level="m" type="main">Finitely dependent random colorings of bounded degree graphs</title>
		<author>
			<persName><forename type="first">Ádám</forename><surname>Timár</surname></persName>
		</author>
		<idno type="DOI">10.48550/arXiv.2402.17068</idno>
		<imprint>
			<biblScope unit="page">2024</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">A framework for distributed quantum queries in the CONGEST model</title>
		<author>
			<persName><forename type="first">Joran</forename><surname>Van Apeldoorn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tijn</forename><surname>De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vos</forename></persName>
		</author>
		<idno type="DOI">10.1145/3519270.3538413</idno>
	</analytic>
	<monogr>
		<title level="m">PODC &apos;22: ACM Symposium on Principles of Distributed Computing</title>
		<editor>
			<persName><forename type="first">Alessia</forename><surname>Milani</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Philipp</forename><surname>Woelfel</surname></persName>
		</editor>
		<meeting><address><addrLine>Salerno, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2022">July 25 -29, 2022</date>
			<biblScope unit="page">2022</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Complexity of eccentricities and allpairs shortest paths in the quantum CONGEST model</title>
		<author>
			<persName><forename type="first">Chengsheng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xudong</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Penghui</forename><surname>Yao</surname></persName>
		</author>
		<idno type="DOI">10.48550/ARXIV.2206.02766</idno>
		<imprint>
			<biblScope unit="page">2022</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Quantum complexity of weighted diameter and radius in CONGEST networks</title>
		<author>
			<persName><forename type="first">Xudong</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Penghui</forename><surname>Yao</surname></persName>
		</author>
		<idno type="DOI">10.1145/3519270.3538441</idno>
	</analytic>
	<monogr>
		<title level="m">PODC &apos;22: ACM Symposium on Principles of Distributed Computing</title>
		<meeting><address><addrLine>Salerno, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2022">July 25 -29, 2022</date>
			<biblScope unit="page">2022</biblScope>
		</imprint>
	</monogr>
	<note>Alessia Milani and Philipp Woelfel</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
