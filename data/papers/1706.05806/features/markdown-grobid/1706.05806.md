# SVCCA: Singular Vector Canonical Correlation Analysis for Deep Learning Dynamics and Interpretability

## Abstract

## 

We propose a new technique, Singular Vector Canonical Correlation Analysis (SVCCA), a tool for quickly comparing two representations in a way that is both invariant to affine transform (allowing comparison between different layers and networks) and fast to compute (allowing more comparisons to be calculated than with previous methods). We deploy this tool to measure the intrinsic dimensionality of layers, showing in some cases needless over-parameterization; to probe learning dynamics throughout training, finding that networks converge to final representations from the bottom up; to show where class-specific information in networks is formed; and to suggest new training regimes that simultaneously save computation and overfit less. 1 Convnet layers: conv-conv-bn-pool-conv-conv-conv-bn-pool-fc-bn-fc-bn-out. Resnet layers: conv-(x10 c/bn/r block)-(x10 c/bn/r block)-(x10 c/bn/r block)-bn-fc-out.

## Introduction

As the empirical success of deep neural networks ( [[7,](#b6)[9,](#b8)[18]](#b17)) become an indisputable fact, the goal of better understanding these models escalates in importance. Central to this aim is a core issue of deciphering learned representations. Facets of this key question have been explored empirically, particularly for image models, in [[1,](#b0)[2,](#b1)[10,](#b9)[12,](#b11)[13,](#b12)[14,](#b13)[15,](#b14)[19,](#b18)[20]](#b19). Most of these approaches are motivated by interpretability of learned representations. More recently, [[11]](#b10) studied the similarities of representations learned by multiple networks by finding permutations of neurons with maximal correlation.

In this work we introduce a new approach to the study of network representations, based on an analysis of each neuron's activation vector -the scalar outputs it emits on input datapoints. With this interpretation of neurons as vectors (and layers as subspaces, spanned by neurons), we introduce SVCCA, Singular Vector Canonical Correlation Analysis, an amalgamation of Singular Value Decomposition and Canonical Correlation Analysis (CCA) [[5]](#b4), as a powerful method for analyzing deep representations. Although CCA has not previously been used to compare deep representations, it has been used for related tasks such as computing the similarity between modeled and measured brain activity [[16]](#b15), and training multi-lingual word embeddings in language models [[3]](#b2).

The main contributions resulting from the introduction of SVCCA are the following:

1. We ask: is the dimensionality of a layer's learned representation the same as the number of neurons in the layer? Answer: No. We show that trained networks perform equally well with a number of directions just a fraction of the number of neurons with no additional training, provided they are carefully chosen with SVCCA (Section 2.1). We explore the consequences for model compression (Section 4.4). 2. We ask: what do deep representation learning dynamics look like? Answer: Networks broadly converge bottom up. Using SVCCA, we compare layers across time and find they Figure [1](#fig_3): To demonstrate SVCCA, we consider a toy regression task (regression target as in Figure [3](#fig_2)). (a)

We train two networks with four fully connected hidden layers starting from different random initializations, and examine the representation learned by the penultimate (shaded) layer in each network. (b) The neurons with the highest activations in net 1 (maroon) and in net 2 (green). The x-axis indexes over the dataset: in our formulation, the representation of a neuron is simply its value over a dataset (Section 2). (c) The SVD directions -i.e. the directions of maximal variance -for each network. (d) The top SVCCA directions. We see that each pair of maroon/green lines (starting from the top) are almost visually identical (up to a sign). Thus, although looking at just neurons (b) seems to indicate that the networks learn very different representations, looking at the SVCCA subspace (d) shows that the information in the representations are (up to a sign) nearly identical.

solidify from the bottom up. This suggests a simple, computationally more efficient method of training networks, Freeze Training, where lower layers are sequentially frozen after a certain number of timesteps (Sections 4.1, 4.2). 3. We develop a method based on the discrete Fourier transform which greatly speeds up the application of SVCCA to convolutional neural networks (Section 3). 4. We also explore an interpretability question, of when an architecture becomes sensitive to different classes. We find that SVCCA captures the semantics of different classes, with similar classes having similar sensitivities, and vice versa. (Section 4.3).

Experimental Details Most of our experiments are performed on CIFAR-10 (augmented with random translations). The main architectures we use are a convolutional network and a residual network 1 . To produce a few figures, we also use a toy regression task: training a four hidden layer fully connected network with 1D input and 4D output, to regress on four different simple functions.

## Measuring Representations in Neural Networks

Our goal in this paper is to analyze and interpret the representations learned by neural networks. The critical question from which our investigation departs is: how should we define the representation of a neuron? Consider that a neuron at a particular layer in a network computes a real-valued function over the network's input domain. In other words, if we had a lookup table of all possible input → output mappings for a neuron, it would be a complete portrayal of that neuron's functional form.

However, such infinite tables are not only practically infeasible, but are also problematic to process into a set of conclusions. Our primary interest is not in the neuron's response to random data, but rather in how it represents features of a specific dataset (e.g. natural images). Therefore, in this study we take a neuron's representation to be its set of responses over a finite set of inputs -those drawn from some training or validation set.

More concretely, for a given dataset X = {x 1 , • • • x m } and a neuron i on layer l, z z z l i , we define z z z l i to be the vector of outputs on X, i.e.

$z z z l i = (z z z l i (x 1 ), • • • , z z z l i (x m ))$Note that this is a different vector from the often-considered vector of the "representation at a layer of a single input." Here z z z l i is a single neuron's response over the entire dataset, not an entire layer's response for a single input. In this view, a neuron's representation can be thought of as a single vector in a high-dimensional space. Broadening our view from a single neuron to the collection of neurons in a layer, the layer can be thought of as the set of neuron vectors contained within that layer. This set of vectors will span some subspace. To summarize:

Considered over a dataset X with m examples, a neuron is a vector in R m .

A layer is the subspace of R m spanned by its neurons' vectors.

Within this formalism, we introduce Singular Vector Canonical Correlation Analysis (SVCCA) as a method for analysing representations. SVCCA proceeds as follows:

• Input: SVCCA takes as input two (not necessarily different) sets of neurons (typically layers of a network) l 1 = {z z z l1 1 , ..., z z z l1 m1 } and l 2 = {z z z l2 1 , ..., z z z l2 m2 } • Step 1 First SVCCA performs a singular value decomposition of each subspace to get subsubspaces l 1 ⊂ l 1 , l 2 ⊂ l 2 which comprise of the most important directions of the original subspaces l 1 , l 2 . In general we take enough directions to explain 99% of variance in the subspace. This is especially important in neural network representations, where as we will show many low variance directions (neurons) are primarily noise. • Step 2 Second, compute the Canonical Correlation similarity ( [[5]](#b4)) of l 1 , l 2 : linearly transform l 1 , l 2 to be as aligned as possible and compute correlation coefficients. In particular, given the output of step 1,

$l 1 = {z z z l1 1 , ..., z z z l1 m 1 }, l 2 = {z z z l2 1 , ..., z z z l2 m 2 }$, CCA linearly transforms these subspaces l1 = W X l 1 , l2 = W Y l 2 such as to maximize the correlations corrs = {ρ 1 , . . . ρ min(m 1 ,m 2 ) } between the transformed subspaces.

• Output: With these steps, SVCCA outputs pairs of aligned directions, (z z z l1 i , z z z l2 i ) and how well they correlate, ρ i . Step 1 also produces intermediate output in the form of the top singular values and directions.

For a more detailed description of each step, see the Appendix. SVCCA can be used to analyse any two sets of neurons. In our experiments, we utilize this flexibility to compare representations across different random initializations, architectures, timesteps during training, and specific classes and layers.

Figure [1](#fig_3) shows a simple, intuitive demonstration of SVCCA. We train a small network on a toy regression task and show each step of SVCCA, along with the resulting very similar representations. SVCCA is able to find hidden similarities in the representations.

## Distributed Representations

An important property of SVCCA is that it is truly a subspace method: both SVD and CCA work with span(z z z 1 , . . . , z z z m ) instead of being axis aligned to the z z z i directions. SVD finds singular vectors z z z i = m j=1 s ij z z z j , and the subsequent CCA finds a linear transform W , giving orthogonal canonically correlated directions {z z z 1 , . . . , z z z m } = { m j=1 w 1j z z z j , . . . , m j=1 w mj z z z j }. In other words, SVCCA has no preference for representations that are neuron (axes) aligned.

If representations are distributed across many dimensions, then this is a desirable property of a representation analysis method. Previous studies have reported that representations may be more complex than either fully distributed or axis-aligned [[17,](#b16)[21,](#b20)[11]](#b10) but this question remains open.

We use SVCCA as a tool to probe the nature of representations via two experiments:

(a) We find that the subspace directions found by SVCCA are disproportionately important to the representation learned by a layer, relative to neuron-aligned directions. (b) We show that at least some of these directions are distributed across many neurons.

Experiments for (a), (b) are shown in Figure [2](#fig_1) as (a), (b) respectively. For both experiments, we first acquire two different representations, l 1 , l 2 , for a layer l by training two different random initializations of a convolutional network on CIFAR-10. We then apply SVCCA to l 1 and l 2 to get directions

0 100 200 300 400 500 Number of directions 0.2 0.4 0.6 0.8 Accuracy CIFAR10: Accuracy with SVCCA directions and random neurons p2 (4096 neurons) SVCCA p2 max acts neurons p2 random neurons fc1 (512 neurons) SVCCA fc1 random neurons fc2 (256 neurons) SVCCA fc2 max acts neurons 0 10 20 30 40 50 Number of directions 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Accuracy CIFAR10 acc vs neurons used for SVCCA dirns SVCCA fc1 (512 neurons) SVCCA p2 (4096 neurons) 50 neurons for fc1 150 neurons for p2 300 neurons for p2 100 neurons for fc1 We project the output of the top three layers, pool1, fc1, fc2, onto this top-k subspace. We see accuracy rises rapidly with increasing k, with even k num neurons giving reasonable performance, with no retraining. Baselines of random k neuron subspaces and max activation neurons require larger k to perform as well. (b): after projecting onto top k subspace (like left), dotted lines then project again onto m neurons, chosen to correspond highly to the top k-SVCCA subspace. Many more neurons are needed than k for better performance, suggesting distributedness of SVCCA directions.

{z z z l1 1 , ..., z z z l1 m } and {z z z l2 1 , ..., z z z l2 m }, ordered according to importance by SVCCA, with each z z z li j being a linear combination of the original neurons, i.e. z z z

$li j = m r=1 α (li)$jr z z z li r . For different values of k < m, we can then restrict layer l i 's output to lie in the subspace of span(z z z li 1 , . . . , z z z li k ), the most useful k-dimensional subspace as found by SVCCA, done by projecting each neuron into this k dimensional space.

We find -somewhat surprisingly -that very few SVCCA directions are required for the network to perform the task well. As shown in Figure [2](#fig_1)(a), for a network trained on CIFAR-10, the first 25 dimensions provide nearly the same accuracy as using all 512 dimensions of a fully connected layer with 512 neurons. The accuracy curve rises rapidly with the first few SVCCA directions, and plateaus quickly afterwards, for k m. This suggests that the useful information contained in m neurons is well summarized by the subspace formed by the top k SVCCA directions. Two baselines for comparison are picking random and maximum activation neuron aligned subspaces and projecting outputs onto these. Both of these baselines require far more directions (in this case: neurons) before matching the accuracy achieved by the SVCCA directions. These results also suggest approaches to model compression, which are explored in more detail in Section 4.4.

Figure [2](#fig_1)(b) next demonstrates that these useful SVCCA directions are at least somewhat distributed over neurons rather than axis-aligned. First, the top k SVCCA directions are picked and the representation is projected onto this subspace. Next, the representation is further projected onto m neurons, where the m are chosen as those most important to the SVCCA directions . The resulting accuracy is plotted for different choices of k (given by x-axis) and different choices of m (different lines). That, for example, keeping even 100 fc1 neurons (dashed green line) cannot maintain the accuracy of the first 20 SVCCA directions (solid green line at x-axis 20) suggests that those 20 SVCCA directions are distributed across 5 or more neurons each, on average. Figure [3](#fig_2) shows a further demonstration of the effect on the output of projecting onto top SVCCA directions, here for the toy regression case.

Why the two step SV + CCA method is needed. Both SVD and CCA have important properties for analysing network representations and SVCCA consequently benefits greatly from being a two step method. CCA is invariant to affine transformations, enabling comparisons without natural alignment (e.g. different architectures, Section 4.4). See Appendix B for proofs and a demonstrative figure. While CCA is a powerful method, it also suffers from certain shortcomings, particularly in determining how many directions were important to the original space X, which is the strength of SVD. See Appendix for an example where naive CCA performs badly. Both the SVD and CCA steps are critical to the analysis of learning dynamics in Section 4.1.

## Scaling SVCCA for Convolutional Layers

Applying SVCCA to convolutional layers can be done in two natural ways:

(1) Same layer comparisons: If X, Y are the same layer (at different timesteps or across random initializations) receiving the same input we can concatenate along the pixel (height h, width w) coordinates to form a vector: a conv layer h × w × c maps to c vectors, each of dimension hwd, where d is the number of datapoints. This is a natural choice because neurons at different pixel coordinates see different image data patches to each other. When X, Y are two versions of the same layer, these c different views correspond perfectly.

(2) Different layer comparisons: When X, Y are not the same layer, the image patches seen by different neurons have no natural correspondence. But we can flatten an h×w ×c conv into hwc neurons, each of dimension d. This approach is valid for convs in different networks or at different depths.

## Scaling SVCCA with Discrete Fourier Transforms

Applying SVCCA to convolutions introduces a computational challenge: the number of neurons (h×w×c) in convolutional layers, especially early ones, is very large, making SVCCA prohibitively expensive due to the large matrices involved. Luckily the problem of approximate dimensionality reduction of large matrices is well studied, and efficient algorithms exist, e.g. [[4]](#b3).

For convolutional layers however, we can avoid dimensionality reduction and perform exact SVCCA, even for large networks. This is achieved by preprocessing each channel with a Discrete Fourier Transform (which preserves CCA due to invariances, see Appendix), causing all (covariance) matrices to be block-diagonal. This allows all matrix operations to be performed block by block, and only over the diagonal blocks, vastly reducing computation. We show:

Theorem 1. Suppose we have a translation invariant (image) dataset X and convolutional layers l 1 , l 2 . Letting DF T (l i ) denote the discrete fourier transform applied to each channel of l i , the covariance cov(DF T (l 1 ), DF T (l 2 )) is block diagonal, with blocks of size c × c.

We make only two assumptions: 1) all layers below l 1 , l 2 are either conv or pooling layers with circular boundary conditions (translation equivariance) 2) The dataset X has all translations of the images X i . This is necessary in the proof for certain symmetries in neuron activations, but these symmetries typically exist in natural images even without translation invariance, as shown in For a multiple channel image X i , an (a, b) translation is an (a, b) height/width shift on every channel separately. X is then translation invariant as above.

To prove Theorem 1, we first show another theorem: Theorem 2. Given a translation invariant dataset X, and a convolutional layer l with channels {c 1 , . . . c k } applied to X (a) the DFT of c i , F cF T has diagonal covariance matrix (with itself). (b) the DFT of c i , c j , F c i F T , F c j F T have diagonal covariance with each other. Finally, both of these theorems rely on properties of circulant matrices and their DFTs: Lemma 1. The covariance matrix of c i applied to translation invariant X is circulant and block circulant. Lemma 2. The DFT of a circulant matrix is diagonal.

## Applications of SVCCA 4.1 Learning Dynamics with SVCCA

We can use SVCCA as a window into learning dynamics by comparing the representation at a layer at different points during training to its final representation. Furthermore, as the SVCCA computations are relatively cheap to compute compared to methods that require training an auxiliary network for each comparison [[1,](#b0)[10,](#b9)[11]](#b10), we can compare all layers during training at all timesteps to all layers at the final time step, producing a rich view into the learning process.

The outputs of SVCCA are the aligned directions (x i , ỹi ), how well they align, ρ i , as well as intermediate output from the first step, of singular values and directions, λ

$(i) X , x (i) , λ(j)$Y , y (j) . We condense these outputs into a single value, the SVCCA similarity ρ, that encapsulates how well the representations of two layers are aligned with each other,

$ρ = 1 min (m 1 , m 2 ) i ρ i ,(1)$where min (m 1 , m 2 ) is the size of the smaller of the two layers being compared. The SVCCA similarity ρ is the average correlation across aligned directions, and is a direct multidimensional analogue of Pearson correlation.

The SVCCA similarity for all pairs of layers, and all time steps, is shown in Figure [4](#fig_4) for a convnet and a resnet architecture trained on CIFAR10.

## Freeze Training

Observing in Figure [4](#fig_4) that networks broadly converge from the bottom up, we propose a training method where we successively freeze lower layers during training, only updating higher and higher layers, saving all computation needed for deriving gradients and updating in lower layers.

We apply this method to convolutional and residual networks trained on CIFAR-10, Figure [5](#fig_5), using a linear freezing regime: in the convolutional network, each layer is frozen at a fraction (layer number/total layers) of total training time, while for resnets, each residual block is frozen at a fraction (block number/total blocks). The vertical grey dotted lines show which steps have another set of layers frozen. Aside from saving computation, Freeze Training appears to actively help generalization accuracy, like early stopping but with different layers requiring different stopping points.

## Interpreting Representations: when are classes learned?

We also can use SVCCA to compare how correlated representations in each layer are with the logits of each class in order to measure how knowledge about the target evolves throughout the network.

In Figure [6](#fig_13) we apply the DFT CCA technique on the Imagenet Resnet [[6]](#b5). We take five different classes and for different layers in the network, compute the DFT CCA similarity between the logit of that class and the network layer. The results successfully reflect semantic aspects of the classes: the firetruck class sensitivity line is clearly distinct from the two pairs of dog breeds, and network develops greater sensitivity to firetruck earlier on. The two pairs of dog breeds, purposefully chosen so that each pair is similar to the other in appearance, have cca similarity lines that are very close to each other through the network, indicating these classes are similar to each other.  

## Other Applications: Cross Model Comparison and compression

SVCCA similarity can also be used to compare the similarity of representations across different random initializations, and even different architectures. We compare convolutional networks on CIFAR-10 across random initializations (Appendix) and also a convolutional network to a residual network in Figure [7](#), using the DFT method described in 3.

In Figure [3](#fig_2), we saw that projecting onto the subspace of the top few SVCCA directions resulted in comparable accuracy. This observations motivates an approach to model compression. In particular, letting the output vector of layer l be x x x (l) ∈ R n×1 , and the weights W (l) , we replace the usual W (l) x x x (l) with (W (l) P T x )(P x x x x (l) ) where P x is a k × n projection matrix, projecting x x x onto the top SVCCA directions. This bottleneck reduces both parameter count and inference computational cost Resnet and Convnet trained on CIFAR-10. We find that the lower layrs of both models are noticeably similar to each other, and get progressively less similar as we compare higher layers. Note that the highest layers of the resnet are least similar to the lower layers of the convnet.

for the layer by a factor ∼ k n . In Figure App.5 in the Appendix, we show that we can consecutively compress top layers with SVCCA by a significant amount (in one case reducing each layer to 0.35 original size) and hardly affect performance.

## Conclusion

In this paper we present SVCCA, a general method which allows for comparison of the learned distributed representations between different neural network layers and architectures. Using SVCCA we obtain novel insights into the learning dynamics and learned representations of common neural network architectures. These insights motivated a new Freeze Training technique which can reduce the number of flops required to train networks and potentially even increase generalization performance. We observe that CCA similarity can be a helpful tool for interpretability, with sensitivity to different classes reflecting their semantic properties. This technique also motivates a new algorithm for model compression. Finally, the "lower layers learn first" behavior was also observed for recurrent neural networks as shown in Figure App.6 in the Appendix. In the first pane, the maroon plot shows one of the highest activation neurons in the penultimate layer of a network trained on CIFAR-10, with the x-axis being (ordered) image ids and the y-axis being activation on that image. The green plots show two resulting distorted directions after this and two of the other top activation neurons are permuted, rotated and scaled. Pane two shows the result of applying CCA to the distorted directions and the original signal, which succeeds in recovering the original signal. Then looking at the canonical correlation coefficients of (A, B) and (A, C) will give the same result, both being 1 for 50 values and 0 for everything else. But these are two very different cases -the subspace B is indeed well represented by the 50 directions that are aligned with A. But the subspace C has 150 more useful directions. This distinction becomes particularly important when aggregating canonical correlation coefficients as a measure of similarity, as used in analysing network learning dynamics. However, by first applying SVD to determine the number of directions needed to explain 99% of the observed variance, we can distinguish between pathological cases like the one above.

## C Proof of Theorem 1

Here we provide the proofs for Lemma 1, Lemma 2, Theorem 2 and finally Theorem 1.

A preliminary note before we begin:

When we consider a (wlog) n by n channel c of a convolutional layer, we assume it has shape We see that the covariance matrix is dense. (b) We compute the covariance after applying DFT, but without augmenting the dataset with translations. Even without enforcing translation invariance, we see that the covariance in the DFT basis is approximately diagonal. (c) Same as (a), but the dataset is augmented to be fully translation invariant. The covariance in the pixel basis is still dense. (d) Same as (c), but with dataset augmented to be translation invariant. The covariance matrix is exactly diagonal for a translation invariant dataset in a DFT basis.

$    z z z 0,0 z z z 1,2 . . . z z z 0,n-1 z z z 1,0 z z z 2,2 . . . z z z 1,n-1 . . . . . . . . . . . . z z z n-1,0 z z z n-1,1 . . . z z z n-1,n-1     (a) (b) (c) (d)$Figure AppWhen computing the covariance matrix however, we vectorize c by stacking the columns under each other, and call the result vec(c):

$vec(c) =            z z z 0,0 z z z 1,0 . . . z z z n-1,0 z z z 0,1 . . . z z z n-1,n-1            :=            z z z 0 z z z 1 . . . z z z n-1 z z z n . . . z z z n 2 -1           $One useful identity when switching between these two notations (see e.g. [[8]](#b7)) is

$vec(AcB) = (B T ⊗ A)vec(c)$where A, B are matrices and ⊗ is the Kronecker product. A useful observation arising from this is:

Lemma 3. The CCA vectors of DF T (c i ), DF T (c j ) are the same (up to a rotation by F ) as the CCA of c i , c j .

Proof: From Section B we know that unitary transforms only rotate the CCA directions. But while DFT pre and postmultiplies by F, F T -unitary matrices, we cannot directly apply this as the result is for unitary transforms on vec(c i ). But, using the identity above, we see that vec(DF T (c i )) = vec(F c i F T ) = (F ⊗ F )vec(c i ), which is unitary as F is unitary. Applying the same identity to c j , we can thus conclude that the DFT preserves CCA (up to rotations).

As Theorem 1 preprocesses the neurons with DFT, it is important to note that by the Lemma above, we do not change the CCA vectors (except by a rotation).

## C.1 Proof of Lemma 1

Proof. Translation invariance is preserved We show inductively that any translation invariant input to a convolutional channel results in a translation invariant output: Suppose the input to channel c, (n by n) is translation invariant. It is sufficient to show that for inputs X i , X j and 0 ≤ a, b, ≤ n -1, c(X i ) + (a, b) mod n = c(X j ). But an (a, b) shift in neuron coordinates in c corresponds to a (height stride • a, width stride • b) shift in the input. And as X is translation invariant, there is some

$X j = X i + (height stride • a, width stride • b). cov(c) is circulant:$Let X be (by proof above) a translation invariant input to a channel c in some convolution or pooling layer. The empirical covariance, cov(c) is the n 2 by n 2 matrix computed by (assuming c is centered)

$1 |X| Xi∈X vec(c(X i )) • vec(c(X i )) T So, cov(c) ij = 1 |X| z z z T i z z z j = 1 |X| X l ∈X z z z T i (X l$)z z z j (X l ), i.e. the inner products of the neurons i and j.

The indexes i and j refer to the neurons in their vectorized order in vec(c). But in the matrix ordering of neurons in c, i and j correspond to some It follows that 1  |X| z z z T (a1,b1) z z z (a2,b2) = 1 |X| z z z T (a1+b,b1+b) z z z (a2+a,b2+b) , or, with vec(c) indexing

$1 |X| z z z T i z z z j = 1 |X| z z z T (i+an+b mod n 2 ) z z z (j+an+b mod n 2 )$This gives us the circulant structure of cov(c).

cov(c) is block circulant: Let z z z (i) be the ith column of c, and z z z (j) the jth. In vec(c), these correspond to z z z (i-1)n , . . . z z z in-1 and z z z (j-1)n , . . . z z z jn-1 , and the n by n submatrix at those row and column indexes of cov(vec(c)) corresponds to the covariance of column i, j. But then we see that the covariance of columns i+k, j +k, corresponding to the covariance of neurons z z z (i-1)n+k•n , . . . z z z in-1+k•n , and z z z (j-1)n+k•n , . . . z z z jn-1+k•n , which corresponds to the 2-d shift (1, 0), applied to every neuron.

So by an identical argument to above, we see that for all 0 ≤ k ≤ n -1 cov(z z z (i) , z z z (j) ) = cov(z z z (i+k) , z z z (j+k) )

In particular, cov(vec(c)) is block circulant.

An example cov(vec(c)) with c being 3 by 3 look like below:

$A 0 A 1 A 2 A 2 A 0 A 1 A 1 A 2 A 0$where each A i is itself a circulant matrix.

## C.2 Proof of Lemma 2

Proof. This is a standard result, following from expressing a circulant matrix A in terms of its diagonal form , i.e. A = V ΣV T with the columns of V being its eigenvectors. Noting that V = F , the DFT matrix, and that vectors of powers of ω k = exp( 2πik n ), ω j = exp( 2πik n ) are orthogonal gives the result.

## C.3 Proof of Theorem 2

Proof. Starting with (a), we need to show that cov(vec(DF T (c i )), vec(DF T (c i )) is diagonal. But by the identity above, this becomes:

$cov(vec(DF T (c i )), vec(DF T (c i )) = (F ⊗ F )vec(c i )vec(c i ) T (F ⊗ F ) * By Lemma 1, we see that cov(vec(c i )) = vec(c i )vec(c i ) T =     A 0 A 1 . . . A n-1 A n-1 A 0 . . . A n-2 . . . . . . . . . . . . A 1 A 2 . . . A 0     with each A i circulant.$And so cov(vec(DF T (c i )), vec(DF T (c i )) becomes

$    f 00 F f 01 F . . . f 0,n-1 F f 10 F f 11 F . . . f 1,n-1 F . . . . . . . . . . . . f n-1,0 F f n-1,1 F . . . f n-1,n-1 F         A 0 A 1 . . . A n-1 A n-1 A 0 . . . A n-2 . . . . . . . . . . . . A 1 A 2 . . . A 0         f * 00 F * f * 10 F * . . . f * n-1,0 F * f * 01 F * f * 11 F * . . . f * n-1,1 F * . . . . . . . . . . . . f * 0,n-1 F * f * 1,n-1 F * . . . f * n-1,n-1 F *    $From this, we see that the sjth entry has the form

$n-1 l=0 n-1 k=0 f sk F A l-k f * lj F * = k,l f sk f * lj F A l-k F * Letting [F A r F * ] the coefficient of the term F A r F * , we see that (addition being mod n) [F A r F * ] = n-1 k=0 f sk f * (k+r)j = k e 2πisk n • e -2πij(k+r) n = e -2πijr n n-1 k=0 e 2πik(s-j) n = e -2πijr n$• δ sj with the last step following by the fact that the sum of powers of non trivial roots of unity are 0.

In particular, we see that only the diagonal entries (of the n by n matrix of matrices) are non zero. The diagonal elements are linear combinations of terms of form F A r F * , and by Lemma 2 these are diagonal. So the covariance of the DFT is diagonal as desired.

Part (b) follows almost identically to part (a), but by first noting that exactly by the proof of Lemma 1, cov(c i , c j ) is also a circulant and block circulant matrix.

## C.4 Proof of Theorem 1

Proof. This Theorem now follows easily from the previous. Suppose we have a layer l, with channels c 1 , ..., c k . And let vec(DF T (c i )) have directions z z z

$(i) 0 , • • • z z z (i) n 2 -1$. By the previous theorem, we know that the covariance of all of these neurons only has non-zero terms cov(z z z

$(i) k , z z z (j)$k . So arranging the full covariance matrix to have row and column indexes being z z z

$(1) 0 , z z z (1) 0 , . . . z z z (k) 0 , z z z (1) 1 . . . z z z (k)$n 2 the nonzero terms all live in the n 2 k by k blocks down the diagonal of the matrix, proving the theorem.

## C.5 Computational Gains

As the covariance matrix is block diagonal, our more efficient algorithm for computation is as follows: take the DFT of every channel (n log n due to FFT) and then compute covariances according to blocks: partition the k n directions into the n 2 k by k matrices that are non-zero, and compute the covariance, inverses and square roots along these.

A rough computational budget for the covariance is therefore kn log n + n 2 k 2.5 , while the naive computation would be of order (kn 2 ) 2.5 , a polynomial difference. Furthermore, the DFT method also makes for easy parallelization as each of the n 2 blocks does not interact with any of the others.   

![Figure 2: Demonstration of (a) disproportionate importance of SVCCA directions, and (b) distributed natureof some of these directions. For both panes, we first find the top k SVCCA directions by training two conv nets on CIFAR-10 and comparing corresponding layers. (a) We project the output of the top three layers, pool1, fc1, fc2, onto this top-k subspace. We see accuracy rises rapidly with increasing k, with even k num neurons giving reasonable performance, with no retraining. Baselines of random k neuron subspaces and max activation neurons require larger k to perform as well. (b): after projecting onto top k subspace (like left), dotted lines then project again onto m neurons, chosen to correspond highly to the top k-SVCCA subspace. Many more neurons are needed than k for better performance, suggesting distributedness of SVCCA directions.]()

![Figure 3: The effect on the output of a latent representation being projected onto top SVCCA directions in the toy regression task. Representations of the penultimate layer are projected onto 2, 6, 15, 30 top SVCCA directions (from second pane). By 30, the output looks very similar to the full 200 neuron output (left).]()

![Figure App.2 in the Appendix. Below are key statements, with proofs in Appendix. Say a single channel image dataset X of images is translation invariant if for any (wlog n × n) image X i ∈ X, with pixel values {z z z 11 , ...z z z nn }, X (a,b) i = {z z z σa(1)σ b (1) , ...z z z σa(n)σ b (n) } is also in X, for all 0 ≤ a, b ≤ n -1, where σ a (i) = a + i mod n (and similarly for b).]()

![Figure 4: Learning dynamics plots for conv (top) and res (bottom) nets trained on CIFAR-10. Each pane is a matrix of size layers × layers, with each entry showing the SVCCA similarity ρ between the two layers.Note that learning broadly happens 'bottom up' -layers closer to the input seem to solidify into their final representations with the exception of the very top layers. Per layer plots are included in the Appendix. Other patterns are also visible -batch norm layers maintain nearly perfect similarity to the layer preceding them due to scaling invariance (with a slight reduction since batch norm changes the SVD directions which capture 99% of the variance). In the resnet plot, we see a stripe like pattern due to skip connections inducing high similarities to previous layers.]()

![Figure 5: Freeze Training reduces training cost and improves generalization. We apply Freeze Training to a convolutional network on CIFAR-10 and a residual network on CIFAR-10. As shown by the grey dotted lines (which indicate the timestep at which another layer is frozen), both networks have a 'linear' freezing regime: for the convolutional network, we freeze individual layers at evenly spaced timesteps throughout training. For the residual network, we freeze entire residual blocks at each freeze step. The curves were averaged over ten runs.]()

![Figure6: We plot the CCA similarity using the Discrete Fourier Transform between the logits of five classes and layers in the Imagenet Resnet. The classes are firetruck and two pairs of dog breeds (terriers and husky like dogs: husky and eskimo dog) that are chosen to be similar to each other. These semantic properties are captured in CCA similarity, where we see that the line corresponding to firetruck is clearly distinct from the two pairs of dog breeds, and the two lines in each pair are both very close to each other, reflecting the fact that each pair consists of visually similar looking images. Firetruck also appears to be easier for the network to learn, with greater sensitivity displayed much sooner.]()

![Figure App.1: This figure shows the ability of CCA to deal with orthogonal and scaling transforms.In the first pane, the maroon plot shows one of the highest activation neurons in the penultimate layer of a network trained on CIFAR-10, with the x-axis being (ordered) image ids and the y-axis being activation on that image. The green plots show two resulting distorted directions after this and two of the other top activation neurons are permuted, rotated and scaled. Pane two shows the result of applying CCA to the distorted directions and the original signal, which succeeds in recovering the original signal.]()

![suppose we have subspaces A, B, C, with A being 50 dimensions, B being 200 dimensions, 50 of which are perfectly aligned with A and the other 150 being noise, and C being 200 dimensions, 50 of which are aligned with A (and B) and the other 150 being useful, but different directions.]()

![Figure App.2: This figure visualizes the covariance matrix of one of the channels of a resnet trained on Imagenet. Black correspond to large values and white to small values. (a) we compute the covariance without a translation invariant dataset and without first preprocessing the images by DFT. We see that the covariance matrix is dense. (b) We compute the covariance after applying DFT, but without augmenting the dataset with translations. Even without enforcing translation invariance, we see that the covariance in the DFT basis is approximately diagonal. (c) Same as (a), but the dataset is augmented to be fully translation invariant. The covariance in the pixel basis is still dense. (d) Same as (c), but with dataset augmented to be translation invariant. The covariance matrix is exactly diagonal for a translation invariant dataset in a DFT basis.]()

![, b 1 ) and (a 2 , b 2 ). If we applied a translation (a, b), to both, we would get new neuron coordinates (a 1 + a, b 1 + b), (a 2 + a, b 2 + b) (all coordinates mod n) which would correspond to i + an + b mod n 2 and j + an + b mod n 2 , by our stacking of columns and reindexing. Let τ a,b be the translation in inputs corresponding to an (a, b) translation in c, i.e. τ a,b = (height stride•a, width stride•b). Then clearly z z z (a1,b1) (X i ) = z z z (a1+a,b1+b) (τ (a,b) (X i ), and similarly for z z z (a2,b2)]()

![Figure App.3: Learning dynamics per layer plots for conv (left pane) and res (right pane) nets trained on CIFAR-10. Each line plots the SVCCA similarity of each layer with its final representation, as a function of training step, for both the conv (left pane) and res (right pane) nets. Note the bottom up convergence of different layers D Per Layer Learning Dynamics Plots from Section 4.1]()

![Figure App.4: Comparing the converged representations of two different initializations of the same convolutional architecture. The results support findings in[12], where initial and final layers are found to be similar, with middle layers differing in representation similarity.]()

![Figure App.6: Learning dynamics of the different layers of a stacked LSTM trained on the Penn Tree Bank language modeling task. We observe a similar pattern to that of convolutional architectures trained on image data: lower layer converge faster than upper layers.]()

31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.

