# Hyena Hierarchy: Towards Larger Convolutional Language Models

## Abstract

## 

Recent advances in deep learning have relied heavily on the use of large Transformers due to their ability to learn at scale. However, the core building block of Transformers, the attention operator, exhibits quadratic cost in sequence length, limiting the amount of context accessible. Existing subquadratic methods based on low-rank and sparse approximations need to be combined with dense attention layers to match Transformers, indicating a gap in capability. In this work, we propose Hyena, a subquadratic drop-in replacement for attention constructed by interleaving implicitly parametrized long convolutions and data-controlled gating. In recall and reasoning tasks on sequences of thousands to hundreds of thousands of tokens, Hyena improves accuracy by more than 50 points over operators relying on statespaces and other implicit and explicit methods, matching attention-based models. We set a new state-ofthe-art for dense-attention-free architectures on language modeling in standard datasets (WikiText103 and The Pile), reaching Transformer quality with a 20% reduction in training compute required at sequence length 2K. Hyena operators are twice as fast as highly optimized attention at sequence length 8K, and 100× faster at sequence length 64K.

## Introduction

Large Transformers have enabled a number of breakthrough advances in modeling language, vision, audio, biology and numerous other domains [(Vaswani et al., 2017)](#b50), [(Dosovitskiy et al., 2020)](#b12), [(Radford et al., 2022)](#b39), [(Cramer, 2021)](#b6). Much of the success of Transformers, powered by the attention operator [(Vaswani et al., 2017)](#b50), relies on their scaling properties [(Hoffmann et al., 2022)](#b21) and the emergence of in-context learning [(Garg et al., 2022)](#b16), which allows them to generalize to unseen data and tasks given context as input. The Transformer block is a powerful tool for sequence modeling, but it is not without its limitations. One of the most notable is the computational cost, which grows rapidly as the length of the input sequence increases. Specifically, the cost scales quadratically with the length L of the sequence, which places a strict limit on the amount of context that can be considered by the model. Breaking the quadratic barrier is a key step towards new possibilities for deep learning, such as using entire textbooks as context, generating long-form music or processing gigapixel scale images.

Efforts to reduce the computational cost of attention in models primarily involve the use of linearized, low-rank, and sparse approximations [(Child et al., 2019;](#b5)[Wang et al., 2020;](#b52)[Kitaev et al., 2020;](#b23)[Zhai et al., 2021;](#b55)[Roy et al., 2021;](#b44)[Schlag et al., 2021;](#b45)[Tu et al., 2022)](#b49). These approaches introduce a trade-off between expressivity and speed, requiring hybridization with standard attention layers to reach Transformer quality [(Mehta et al., 2022;](#b30)[Dao et al., 2022c)](#).

A growing amount of evidence suggests that attention mechanisms only utilize a small portion of their quadratic capabilities for language processing [(Olsson et al., 2022;](#b33)[Dao et al., 2022c)](#), leading us to question its role as the gold-standard operator for deep learning at scale. Specifically, we ask:

Are there subquadratic operators that can match the quality of attention at scale?

Figure [1](#fig_2).1: The Hyena operator is defined as a recurrence of two efficient subquadratic primitives: an implicit long convolution h (i.e. Hyena filters parameterized by a feed-forward network) and multiplicative elementwise gating of the (projected) input. The depth of the recurrence specifies the size of the operator. Hyena can equivalently be expressed as a multiplication with data-controlled (conditioned by the input u) diagonal matrices D x and Toeplitz matrices S h . In addition, Hyena exhibits sublinear parameter scaling (in sequence length) and unrestricted context, similar to attention, while having lower time complexity.

We obtain a positive answer based on a composition of efficient subquadratic primitives, such as elementwise multiplication (gating) and long convolutions i.e., convolutions with filter sizes as long as the input. We rely on a set of targeted reasoning tasks, grounded in recent work on mechanistic interpretability [(Elhage et al., 2021;](#b13)[Power et al., 2022;](#b38)[Olsson et al., 2022;](#b33)[Zhang et al., 2022)](#b57) such as recall and induction, to distill three properties of attention correlated with its performance and the quality gap with existing subquadratic approaches:

a. Data control: Attention implements an expressive data-controlled [(Massaroli et al., 2020)](#b29) linear operator[foot_0](#foot_0) , encoding an entire family of linear functions in a single block.

b. Sublinear parameter scaling: Parameter counts of attention layers are decoupled from sequence length, allowing Transformers to allocate more parameters elsewhere e.g., the feed-forward neural networks (FFNs) between attention layers.

c. Unrestricted context: For a given input, attention has an unrestricted context i.e., it can approximate dependencies between any two inputs, without arbitrary restrictions such as locality (except in cases using masking such as autoregressive models).

The Hyena hierarchy Guided by these findings, we introduce the Hyena hierarchy, an operator defined by a recurrence of two efficient subquadratic primitives: a long convolution and element-wise multiplicative gating (see Figure [1](#fig_2).1). A specified depth (i.e., number of steps) of the recurrence controls the size of the operator. For short recurrences, existing models are recovered as special cases [(Mehta et al., 2022;](#b30)[Dao et al., 2022c)](#). By mapping each step in the Hyena recurrence to its corresponding matrix form, we reveal Hyena operators to be equivalently defined as a decomposition of a data-controlled matrix i.e., a matrix whose entries are functions of the input. Furthermore, we show how Hyena operators can be evaluated efficiently without materializing the full matrix, by leveraging fast convolution algorithms [(Selesnick and Burrus, 2017)](#b46). Empirically, Hyena operators are able to significantly shrink the quality gap with attention at scale, reaching similar perplexity and downstream performance with a smaller computational budget (Section 4.2) and without hybridization of attention.

Narrowing the capabilities gap The design of Hyena is motivated by a quality gap between standard dense attention and alternative subquadratic operators, which we identify by focusing on reasoning tasks correlated with language modeling performance at scale. We extend the suite of basic mechanistic interpretability benchmarks (induction and recall ) with additional tasks that probe how quickly model performance degrades when task complexity increases (e.g. vocabulary size grows). In addition, we investigate the optimal parameterization of long convolutions in Hyena. In the most challenging settings with hundreds of thousands of tokens, our implicit parameterization scheme improves over other operators leveraging state spaces [(Gu et al., 2021)](#b18), frequency-domain parametrizations [(Li et al., 2020)](#b27), or standard convolutions by over 50% accuracy.

Scaling in language and vision Next, we aim to verify whether rankings in our reasoning benchmark suite are predictive of quality at scale. We test Hyena on autoregressive language modeling at the sub-billion parameter scale, setting a new state-of-the-art for dense-attention-free architectures in standard datasets (WikiText103 and The Pile) and matching Transformer quality. On the The Pile at the 335M parameter scale, we match Transformer perplexity with a 20% reduction in the total count of floating point operations (FLOPs). As an extension, we investigate the generality of Hyena operators by testing on large-scale image recognition, replacing attention in the Vision Transformer (ViT) [(Dosovitskiy et al., 2020)](#b12). In image classification, Hyena is able to match attention in accuracy when training on ImageNet-1k from scratch.

Toward much longer context Finally, we benchmark the efficiency of Hyena on long sequences. We measure 5x speedups over dense self-attention at length 8192 -2x over highly optimized FlashAttention[foot_1](#foot_1)[(Dao et al., 2022b)](#) -and 100x speedup over FlashAttention at sequence lengths of 64k, where standard attention implementation in PyTorch runs out of memory.

## Preliminaries and Related Work

A discrete convolution is a function of two arguments: an input u signal of length L and a learnable filter h.

The linear (aperiodic) convolution of a (possibly infinitely long) measurable[foot_2](#foot_2) filter h with a length-L input signal u is defined as

$y t = (h * u) t = L-1 n=0 h t-n u n .(1)$Generally, u t ∈ R D where D is the width of the signal, or in deep learning parlance, the number of channels. Without loss of generality, we specialize our analysis to single input single output (SISO) layers, i.e. with D = 1. The multiple input multiple output (MIMO) case, canonical in standard convolutional layers, follows directly.

In this case, the input signal can be represented as a vector u ∈ R L and the convolution as a matrix-vector product between the input and the Toeplitz kernel matrix S h ∈ R L×L induced by the filter h:

$(h * u) =      h 0 h -1 • • • h -L+1 h 1 h 0 • • • h -L+2 . . . . . . . . . . . . h L-1 h L-2 • • • h 0           u 0 u 1 . . . u L-1      (2)$
## Explicit and Implicit Convolutions

Parametrizing and optimizing convolution filters h t is a standard procedure in deep learning and more broadly signal processing. The classical approach of convolutional neural networks (CNNs) [(Fukushima and Miyake, 1982;](#b14)[LeCun et al., 1998;](#b24)[Ronneberger et al., 2015;](#b43)[He et al., 2016)](#b19) is to optimize directly the values h t of the filter's response at M prescribed steps, a parametrization we call explicit. M is referred to as the filter size and is typically much shorter than the input sequence length M L. Such filters are denoted in signal processing as finite impulse response (FIR).

FIR filters are local and can capture dependencies between inputs separated at most by M steps. Their main advantage is their speed, with complexity O(M L). However, the number of parameters of FIR filters scales linearly with filter size, which can be computationally prohibitive. To disentangle the parameter count from the filter size, we can instead represent the filter h t as a parametric function of the time step t, i.e. h t = γ θ (t), where θ are the parameters of the function γ θ . This parametrization is called implicit. The class of functions γ θ is a design choice with a significant impact on the expressivity and computational complexity of the layer.

One choice of implicit parametrization is to select h as the response function of a linear state-space model (SSM) [(Chen, 1984)](#b4), described by the first-order difference equation:

x t+1 = Ax t + Bu t state equation y t = Cx t + Du t output equation Here, the convenient choice of x 0 = 0 renders the input-output map to a simple convolution

$y t = t n=0 CA t-n B + Dδ t-n u n$where δ t denotes the Kronecker delta. We can then identify the filter h as

$t → h t = 0 t < 0 CA t B + Dδ t t ≥ 0$where the entries of A, B, C and D are the learned parameters of the filter. In terms of layer design, the degrees of freedom of SSMs are the dimension of the state and the structure of the matrices. SSMs are a canonical example of how long convolutions with sub-linear parameter counts can improve deep learning models for long sequences [(Gu et al., 2020](#b17)[(Gu et al., , 2021))](#b18). Other implicit approaches include parametrizing filters as maps from (a positional encoding of) t to the filter response i.e. γ θ : t → h t = γ θ (t), for example with feed-forward neural networks [(Romero et al., 2021b,a)](#).

Long convolutions and memory: A crude proxy for memory of a single computational unit is how far in the past it can access information to produce the output at a certain step. This can be roughly quantified by the number of non-zero entries ∂y t /∂u t-n for n = 0, . . . , t. The memory of CNNs filters is equivalent to the filter size M since ∂y t /∂u t-n = h n . The total mnemonic capacity of an allconvolutions CNN therefore scales with the number of model's parameters. Implicit parametrizations, on the other hand, allow us to disentangle the memory of each filter from the parameter count and where the length of the filter is implicitly controlled by the learned parameters. In an SSM, ∂y t /∂u t-n = CA n B and the memory extent is solely determined by the spectral radius of A and can be finely tuned by the training process a . On the other hand, the number of parameters controls the expressivity of the memory unit, e.g. the number of basis functions forming h t .

a See e.g. [Gu et al. (2020](#b17)[Gu et al. ( , 2021) )](#b18) Fast Methods for Convolutions One of the first applications of the Cooley-Tukey fast Fourier transform (FFT) algorithm was to implement convolution faster than the direct evaluation of (1). At first glance (1) comes with O(L 2 ) an asymptotic time complexity. A common approach to achieve fast long convolutions in subquadratic time is through the FFT algorithm. The method first converts the aperiodic convolution into a circular convolution [Selesnick and Burrus (2017)](#b46) by appropriate zero-padding of input and filter sequences. The resulting kernel Ŝh is a circulant matrix and is diagonalized by the discrete Fourier basis

$Ŝh = W -1 D H W$where W is the DFT matrix, W tt = z -t , z = e i2πt /L and H is the DFT of the padded filter h, H = Wpad(h). Thus, the calculation of such convolutions is performed as

$pad(y) = Ŝh pad(u) = W -1 D H W pad(u) = iFFT(D H FFT(pad(u)))$where D H is the matrix with Wh on its diagonal. The above is known as the convolution theorem of DFT [(Oppenheim et al., 1997)](#b34). In this FFTConv form the convolution can be performed without materializing the operator S h with the same asymptotic cost O(L log 2 L) of FFT. 

## The Self-Attention Operator

At the heart of Transformers is the multi-head attention (MHA) mechanism. Given a length-L sequence u ∈ R L×D , each head of scaled self-attention [(Vaswani et al., 2017](#b50)) is a map from R L×D to R L×D which performs the following operations

$A(u) = SoftMax 1 √ D uM q M k u y = SelfAttention(u) = A(u)uM v ,(3)$where M q , M k , M v ∈ R D×D are learnable linear projections and SoftMax is intended to be applied row-wise. Attention parametrizes a family of dense linear operators and for an input u, indexes through it via projections of u i.e., A(u). We refer to operators of this type as data-controlled, as they encode a linear transformation u → y, that is, however, nonlinearly defined by u. This approach yields expressive nonlinear operators in u, and we hypothesize contributes, together with other mechanisms [(Olsson et al., 2022)](#b33), to the ability of certain operators to learn in-context i.e., to adapt to unseen tasks by leveraging context. In deep learning, the projections take on specific names: query q = uM q , key k = uM k and value v = uM v . We often rewrite the attention operator as y = A(q, k)v.

Remark 2.1. Similarly to implicit convolutions, SelfAttention does not entangle its ability to access distant information with the number of parameters: it looks at the whole sequence at the price of O(L 2 ) operations.

## Subquadratic Operators

Existing approaches to subquadratic alternatives to attention can be summarized by altering the way the data control is implemented i.e., how the operator is nonlinearly defined by u, and then applied to v. For example, a layer of Attention-Free Transformers (AFTs) [(Zhai et al., 2021)](#b55) constructs the operator through a combination of gating and SoftMax (AFT full) or gating and a single explicit convolution (AFT conv). Gated State Spaces (GSS) instead compose the operator via gating and a long convolution parametrized via SSMs. Taking this idea further, Hungry Hungry Hippo (H3) [(Dao et al., 2022c)](#), motivated by gaps of GSS on associative recall, extend the mechanism to include an additional gate and a short convolution obtained via a shift SSM. Hyena generalizes this body of work by introducing a recurrence of gates and implicit long convolutions, evaluated efficiently.

## Hyena: Definition and Properties

In this section, we define Hyena, a class of data-controlled operators consisting of a recurrence of multiplicative gating interactions and long convolutions. Instead of seeking an approximation to attention, we guide our design by intentionally incorporating key computational properties of attention, including the decoupling of sequence length and parameter counts.

## Hyena Recurrences

At a high level, Hyena consists of the following steps (setting D = 1 for clarity): i. Compute a set of N +1 linear projections of the input, similarly to attention. The number of projections (v t , x 1 t , . . . , x N t ) need not be three. One projection takes the role of value, such that a linear input-output function can be defined as y = H(u)v for some H(u).

ii. The matrix H(u) is defined by interleaving implicit long convolutions and element-wise multiplication with one projection x i at a time, until all projections are exhausted. Evaluation of H(u)v is done efficiently without materializing H(u). By doing so, we implicitly define a data-controlled operator as a factorization of a matrix. The long convolutions forming H(u) are parametrized implicitly to retain sublinear parameter scaling in sequence length.

Next, we formally define Hyena, starting with its computational model. We leave the analysis of its datacontrolled matrix form for the latter part of the section.

$Definition 3.1 (Order-N Hyena Operator). Let (v, x 1 , • • • , x N$) be projections of the input and let h 1 , . . . , h N be a set of learnable filters. The Hyena N operator is defined by the recurrence:

$z 1 t = v t z n+1 t = x n t (h n * z n ) t n = 1, . . . , N y t = z N +1 t (4) Remark 3.1. The time complexity of a Hyena recurrence is O(N L log 2 L). The input-output map can be rewritten as y = x N • (h N * (x N -1 • (h N -1 * (• • • ))))$where each convolution is performed through the Fourier domain in O(L log 2 L).

Interestingly, the element-wise product in time domain corresponds to convolution in frequency domain, i.e.

x t u t = (x * û) t , where x, û denote the DFT of x and u, respectively. Thus, Hyena is alternatively applying convolutions in the time and then the frequency domain (or alternatively applying element-wise products in the time and frequency domain). One potential explanation for the effectiveness of this procedure is that the convolution in the time domain (element-wise multiplication in the frequency domain) increases the memory length, allowing for a broader context to be taken into account. On the other hand, the element-wise multiplication in the time domain (convolution in the frequency domain) allows for more fine-grained selection of specific frequency components of the signal.

## Hyena Matrices

Hyena operators build on the H3 mechanism developed by [(Dao et al., 2022c)](#). For clarity of exposition, we once again consider the SISO case (D = 1). Let D q and D k be the L-by-L diagonal matrices whose respective main diagonal entries are the respective entries of q and k. H3 realizes a surrogate attention matrix with a data-controlled, parametrized decomposition in four terms:

$A(q, k) = D q S ψ D k S ϕ H3(q, k, v) = A(q, k)v(5)$where S ϕ , S ψ are the Toeplitz matrices of learnable causal filters ϕ, ψ parametrized via SSMs[foot_3](#foot_3) . Alongside the qkv-projections the filters constitute our degrees of freedom in the layer design. This decomposition allows evaluation of (8) in just O(L log 2 L) time (two FFT convolutions and two element-wise products), i.e.

$z t = k t (ϕ * v) t y t = q t (ψ * z) t (6)$Hyena represents a generalization of (8) for an arbitrary number of projections -not limited to three -and with implicit free-form long filters for the convolutions. The resulting recurrence (4) can be also represented in matrix form y = H(u)v. Let D n x = diag(x n ) ∈ R L×L and let S n h be the Toeplitz matrix corresponding to filter h n . The resulting Hyena recurrence is linear in v and can be rewritten in matrix form:

$y = H(u)v = D N x S N h • • • D 2 x S 2 h D 1 x S 1 h v Figure 2.1 visualizes an example decomposition. Sequence Length FFN(t) Sequence Length Window Sequence Length Window • FFN(t) Figure 3.1: [Top]:$Example of long convolution parametrization for Hyena operators, with a decay Window(t) = exp{-αt}. Parameter α is modified across the independent channels of Hyena to regularize filters to be of different lengths. In practice, we add a bias term to our window, so that the filters are not constrained to be zeros after a length determined by the decay rate.

Remark 3.2 (Hyena generalizes H3 and GSS.). The H3 mechanism [(Dao et al., 2022c)](#) corresponds to Hyena 2 and GSS [(Mehta et al., 2022)](#b30) is Hyena 1 , with a particular choice of parametrization for the long convolutions (SSMs).

Analysis of the H3 mechanism as a decomposition D q S ψ D k S ϕ of its surrogate attention matrix[foot_4](#foot_4) clarifies a connection to fast evaluation algorithms for matrix-vector multiplications. In particular, the generalization of ( [8](#)) to an arbitrary order is inspired by fast evaluation algorithms for structured dense matrices based on butterfly decompositions [(Li et al., 2015;](#b25)[Dao et al., 2019](#b8)[Dao et al., , 2022a))](#), with length of the decomposition closely tied to its expressivity (in the classes of matrices it can represent). The Hyena operator blends data control with a special case of butterfly decomposition.

Remark 3.3. Hyena operators have unbounded context. Namely, they are not artificially restricted by e.g., locality, and can learn long-range dependencies between any of the elements of v via long convolutions, which we discuss next.

## Hyena Filters

Here we provide details on the convolution parametrization. We represent the filters of each Hyena operator as a map from the time (or space) domain t to values h t , and learn it with a shallow feed-forward neural network (FFN):

$h t = Window(t) • (FFN • PositionalEncoding)(t)(7$) This approach builds on the neural implicit representation literature [(Mildenhall et al., 2021;](#b31)[Sitzmann et al., 2020)](#b47), which has found application in long convolution layers [(Romero et al., 2021b,a)](#). One advantage of ( [7](#formula_12)) is given by the decoupling of filter length and parameter cost.

## Specializing filters in Hyena

The window and positional encoding functions are used to specialize filters in Hyena operators, biasing them towards a specific type. Figure [3](#fig_4).1 provides an important example: we choose at least one of the convolutions in Hyena to be shaped towards exponential decay, mirroring the findings of [(Li et al., 2022)](#b26) in other applications. Interestingly, we find that long exponentially decaying filters display synergy with high-frequency filters, as they enable the operator to select specific inputs at specific steps[foot_5](#foot_5) . Similarly to [(Romero et al., 2021b)](#), we use high-frequency periodic activations (sine) in the FFN. This allows (7) to learn filters with high-frequency content, addressing the low-frequency bias of neural networks [(Basri et al., 2020)](#b1). Owing to the FFN, the parametrization in (7) can approximate filters obtained through other means, such as S4 [(Gu et al., 2020](#b17)[(Gu et al., , 2021))](#b18), CKConv [(Romero et al., 2021b)](#), SGConv [(Li et al., 2022)](#b26) and Fourier Neural Operator (FNO) [(Li et al., 2020)](#b27).

Preserving causality Causality is necessary to train autoregressive language models, in order for the output at a given position to depend only on the past. For example, Transformers mask the attention matrix to be lower triangular. In the case of Hyena, causality can be guaranteed by parametrizing causal convolutions: Proposition 3.1 (Causal Hyenas). If each filter h n , n = 1, . . . , N is causal, then the corresponding Hyena N operator is causal.

In practice, we need not constrain the learning of the filter (7) to ensure its numerical causality. If we use FFT-based convolution algorithms, all we need is to evaluate the filter at t = 0, . . . , L -1 and zero-pad the input and filter sequences to 2L -1 before taking FFT.

Efficiency One bottleneck of long convolution models can be their low utilization of hardware accelerators, especially when they involve iterative numerical methods to materialize the filter[foot_6](#foot_6) . Evaluation of 7 is fast, since it involves a single forward pass of an FFN, and can be performed in parallel across sequence length and all orders of an Hyena operator as displayed in Algorithm 2, increasing hardware utilization. An additional source of low utilization is the FFT, which is also shared by other long other convolutional layers. This bottleneck can be partially addressed by blocking [(Selesnick and Burrus, 2017)](#b46), and optimization of the underlying routines [(Dao et al., 2022c)](#). We benchmark runtime in Section 4.5.

## Hyena Algorithm

A forward pass of Hyena is summarized below.

## Algorithm 1 Projection

$Require: Input sequence u ∈ R L×D 1.$In parallel across L: ẑ = Linear(u), Linear : R D → R (N +1)D 2. In parallel across D: z = DepthwiseConv1d(h, ẑ), h is a short convolution filter 3. Reshape and split z into x 1 , . . . , x N , v. Dimensions of one element are

$x n ∈ R D×L Return x 1 , . . . , x N , v, x n$Algorithm 2 Hyena Filter Require: Sequence length L, positional embedding dimension D e 1. t = PositionalEncoding(L), t ∈ R L×De 2. In parallel across N, L: ĥ = FFN(t), FFN :

$R De → R N D , ĥ ∈ R L×N D 3. Reshape to ĥ ∈ R N ×D×L 4. h = ĥ • Window(t), h ∈ R N ×D×L 5. Split h into h 1 , . . . , h N Return h 1 , . . . , h N Algorithm 3 Forward pass of Hyena Require: Input sequence u ∈ R L×D , order N , model width D, sequence length L, positional embedding dimension D e 1. x 1 , . . . , x N , v = Projection(u) 2. h 1 , . . . , h N = HyenaFilter(L, D e ) for n = 1, . . . , N do 3. In parallel across D: v t ← x n t • FFTConv(h n , v) t end for Return y = v$Proposition 3.2 (Computational Complexity). The computational cost of processing an input u ∈ R L×D with an order-N Hyena operator is O(N DL(log 2 L + D))

2 7 2 9 2 11 2 13 2 15 0 20 40 60 80 100 Sequence Length Vocabulary Size: 10 2 7 2 9 2 11 2 13 2 15 Sequence Length Vocabulary Size: 20 2 7 2 9 2 11 2 13 2 15 Sequence Length Vocabulary Size: 30 2 7 2 9 2 11 2 13 2 15 Sequence Length Vocabulary Size: 40 Hyena CKConv Transfer Function H3 Conv1D FNO Associative Recall Figure 4.1: Benchmark of long convolution parametrizations in order 2 Hyena operators on associative recall (%). Our results show that implicit parametrizations scale more favorably in vocabulary size (number of possible values of tokens in the input) and length of the sequence.

## Experiments

## Shrinking the gap on in-context learning

We begin by empirically motivating the Hyena design, including the choice of long convolution parametrization. We consider the suite of tasks described in Table [4](#tab_1).1. Our evaluation is grounded in recent work on mechanistic interpretability of Transformers [(Elhage et al., 2021;](#b13)[Power et al., 2022;](#b38)[Olsson et al., 2022;](#b33)[Zhang et al., 2022)](#b57). Recently, associative recall, in particular, has been successfully used to guide the design of H3 [(Dao et al., 2022c)](#). We extend the suite of tasks from these works and include benchmarking more challenging versions of each task . For example, solving associative recall with a vocabulary size of only 10 reveals whether a model is structurally capable of performing recall. Testing on much longer sequences and larger vocabularies reveals additional gaps in performance that are otherwise hidden.

How to parametrize long convolutions We compare the performance of the following long convolution parametrizations for S 1 and S 2 in an order 2 Hyena:

• Conv1d: Explicit convolutions (regular convolution layers with fixed filter size).

• FNO: Filters parametrized explicitly in the frequency-domain [(Li et al., 2020)](#b27).

• H3: Implicit parametrization using state-space models (SSMs), in particular the standard S4 [(Gu et al., 2021)](#b18).

• TransferFunc: Implicit parametrization via transfer functions, a classical system-theoretic generalization of SSMs 8

• CKConv: Implicit parametrization using FFNs [(Romero et al., 2021b](#)).

8 Transfer functions roughly correspond to a frequency-domain representation of SSMs.  • Hyena: Combination of implicit parametrizations via FFNs (with exponential decay modulation as shown in Figure [3](#fig_4).1), and short explicit filters.

All models have the same width and 2 layers. Figure [4](#fig_5).1 shows implicit approaches based on FFNs outperform other long convolutions, with the gap widening on longer sequences and larger vocabulary sizes. We train a different model on each setting of sequence length and vocabulary size. The ranking is correlated with the ability to decouple sequence length from parameter count (Hyena, CKConv, TransferFunc, H3) and expressivity (Hyena, CKConv). We observe similar trends on the other tasks.

Pushing sequence length to the limit Next, we evaluate associative recall performance on extremely long sequences of length 131k. To the best of our knowledge, these represent the first empirical display of attention-free in-context learning on sequences of this length. The gap between parametrization schemes widens as shown in Appendix A, with Hyena outperforming CKConv by 80 points.

Comparing operators We repeat our associative recall experiment, this time benchmarking different 2 layer models rather than changing the convolution parametrization: an order 2 Hyena, GSS [(Mehta et al., 2022)](#b30), H3 [(Dao et al., 2022c)](#), AFT-conv [(Zhai et al., 2021)](#b55), RWKV [(Peng, 2021)](#b36), and a standard GPT [(Brown et al., 2020)](#b3) using FlashAttention [(Dao et al., 2022b)](#). As shown in Table [4](#tab_1).2, Hyena is the only operator able to solve the task. Our results challenge the observation that only Transformers are capable of challenging in-context learning. Surprisingly, rankings of model performance at a fixed sequence length on The Pile are consistent with rankings on aggregate scores on our synthetics (Appendix C).

Generality of Hyena operators and filters Hyena operators and filters can also applied successfully beyond language tasks. We experiment on sequential CIFAR, where pixels are flattened as a sequence, and use the same operator defined for language. We reach the accuracy of standard S4 [(Gu et al., 2021)](#b18) with same model size (91%). In Section 4.5 and Appendix A, we discuss larger-scale image classification experiments with Hyena.

## Language Modeling

Next, we verify the scaling of Hyena on autoregressive language modeling. We evaluate the perplexity on WikiText103 (Table [4](#tab_1).3) and The Pile (Table [4](#tab_1).4). On the The Pile, we train different models for 5, 10, 15 billion tokens (different runs), adjusting the learning rate scheduler. Hyena is the first attention-free, convolution architecture to match GPT quality with a 20%[foot_7](#foot_7) reduction in total FLOPs. Preliminary scaling laws are shown in Figure [4](#fig_5).2, collecting the training runs at 5, 10, 15 billion tokens. Each curve represents a different training run. In Appendix A, we provide results on the PG-19 long-range benchmark [(Rae et al., 2019)](#b40).

## Downstream Evaluation

We perform a downstream evaluation on SuperGLUE [(Wang et al., 2019)](#b51) tasks. We compare Hyena (trained for 137 billion tokens) with the best available pre-trained attention-free model, RWKV [(Peng, 2021)](#b36) (trained 1.3 1.6 2.6 3.2 3.9 4.9 •10 19 2.44 2.29 2.21 FLOPs Loss Data Scaling on The Pile, 355M parameters Hyena GPT Figure 4.2: Preliminary "scaling law" of language models on The Pile. Comparison of our approach (red) based on long convolutions and gating (Hyena) and a standard GPT (blue) (Brown et al., 2020). We reach perplexity of GPT with a smaller training FLOP budget. Table 4.3: Perplexity on WikiText103 (same tokenizer). * are results from (Dao et al., 2022c). Deeper and thinner models (Hyena-slim) achieve lower perplexity. Model Perplexity Transformer (125M) 18.6 Hybrid H3 (125M) 18.5 * Performer (125M) 26.8 * Reformer (125M) 25.6 * AFT-conv (125M) 28.2 Linear Attention (125M) 25.6 * Hyena-3 (125M) 18.6 Hyena-3-slim (125M) 18.5 Table 4.4: Perplexity on The Pile for models trained until a total number of tokens e.g., 5 billion (different runs for each token total). All models use the same tokenizer (GPT2). FLOP count is for the 15 billion token run. Model 5B 10B 15B FLOPs (10 19 ) GPT (125M) 13.3 11.9 11.2 1.88 Hyena-2 (153M) 13.3 11.8 11.1 1.87 GPT (355M) 11.4 9.8 9.1 4.77 Hyena-2 (355M) 11.3 9.8 9.2 3.93

for 332 billion tokens), and a reference GPTNeo [(Black et al., 2021)](#b2) (trained for 300 billion tokens) of the same size. Tables 4.5 and 4.6 summarize the results. Hyena performs similarly to other models despite having been trained on less than half the number of total tokens. We observe Hyena to display characteristic few-shot capabilities of standard Transformers, with some tasks e.g., MultiRC seeing a lift of more than 20% accuracy over zero-shot when the model is provided additional prompts as context. The improvements are more noticeable in generation tasks, where the additional prompts can instruct the model on how it should be responding to the questions. We report an additional downstream evaluation on the LAMBADA task [(Paperno et al., 2016)](#b35) in Appendix A.  

## Benchmarking

We benchmark runtime of an order 2 Hyena operator compared to attention and FlashAttention layers [(Dao et al., 2022b)](#). Hyena uses a fused CUDA kernel to perform FFTConv [(Dao et al., 2022c)](#). We set batch size to 64 and measure runtime (in milliseconds). Results are provided in Figure [4](#fig_5).3. Hyena speedups reach 100× at sequence length 64K. Crossover points for Hyena and attention is at length 2048, and for Hyena and FlashAttention is between 4096 and 8196. Despite the absolute reduction in FLOPs, speedups are achieved only on longer sequences when the gap grows sufficiently large. This occurs because hardware utilization of Hyena is lower than FlashAttention. We expect the gap between theoretical maximum speedup to shrink with improved implementations of FFTConv and specialized hardware.

## Large-Scale Image Classification

Finally, we demonstrate the potential of Hyena as a general deep learning operator by applying it to image classification. On ImageNet, we drop-in replace attention layers in the Vision Transformer (ViT) [(Dosovitskiy et al., 2020)](#b12) with the Hyena operator (without changes from its language counterpart) and match performance with ViT. We also show that using smaller image patches boosts performance in both attention and Hyena. Since this results in longer sequence lengths, we expect Hyena to outperform in speed as patches get more fine-grained approaching pixel-level. On CIFAR-2D, we test a 2D version of Hyena long convolution filters in a standard convolutional architecture, which improves on the 2D long convolutional model S4ND [(Nguyen et al., 2022)](#b32) in accuracy with a 8% speedup and 25% fewer parameters. See Appendix A.4 for additional vision architectures and training procedure details. 

## Discussion and Conclusion

In this work, we introduced an attention-free drop-in replacement to the core building block of many largescale language models. Hyena operators are a recurrence of gating and implicitly parametrized long convolutions, can be evaluated efficiently in subquadratic time, and can learn in-context on very long sequences. On The Pile, deep stacks of Hyena operators constitute one of the first attention-free, convolutional architectures to match perplexity and downstream performance of Transformers with a significant reduction in training compute. Our promising results at the sub-billion parameter scale suggest that attention may not be all we need, and that simpler subquadratic designs such as Hyena, informed by a set of simple guiding principles and evaluation on mechanistic interpretability benchmarks, may form the basis for efficient large models. We are excited about what new capabilities Hyena opens up as we scale and optimize the inference speed of these models.

## A Experimental Details

An implementation of Hyena can be found at this link.

## A.1 Mechanistic Design Synthetic Benchmarks

Our synthetic reasoning are inspired by mechanistic interpretability [(Elhage et al., 2021)](#b13), in-context learning (ICL) [(Garg et al., 2022)](#b16) and language model benchmarking [(Liang et al., 2022)](#b28) research. The evaluation revolves around 4 main tasks:

• Associative recall: Each string is produced by concatenating key-value tuples from a different random dictionary. This test verifies whether a model is able to extract right value given a key as prompt, effectively applying a data-controlled shift (delay).

• Majority voting and counting: Testing if a model can densely activate its data-controlled matrix i.e., through many non-zero entries (consider the string 'a a a a a a a a a a b → a').

• ICL of linear functions: Verifying whether a model can perform ICL on real-valued inputs. Prompts are generated as x 1 , w k x 1 , . . . , x n → w k x n , where both x k and w k ∈ R no are sampled from a normal distribution.

• Arithmetic: Basic capability check.

For each task, we train models using the hyperparameters shown in Table [A](#).1. We consider increasing settings of difficulty controlled by sequence length, spanning values [1024, 2048, 4098, 8196, 16392, 32784, 65568, 131136 and vocabulary sizes 10, 20, 30, 40.](#) For ICL of functions, we vary instead the dimension n o .

Note that for associative recall on longer sequences, multiple copies of key-value tuples appear in the prompt. To see this, consider how likely it is to sample multiple copies of a particular key-value pair with a vocabulary size of 40, in order to form a sequence of 100k characters. Models capable of looking further back in the sequence effectively see more data, and can solve challenging versions of the in-context learning task. Increasing the vocabulary size has the increasing the average distance between instances of the same key-value pair in each prompt, highlighting performance gaps between different approaches.

Table A.1: (Hyperparameter settings for reasoning and in-context learning tasks.). Optimizer AdamW Optimizer momentum β1, β2 = 0.9, 0.98 Base learning rate 0.0005 Weight decay 0.1 Dropout None Batch size 32 Training epochs 200 Num samples 2000 Learning rate schedule cosine decay Warmup epochs 10 Warmup schedule linear Number of layers 2 Width 64

Long convolution comparisons: We compare different convolution parametrizations, embedding them in an order 2 Hyena operator. All convolutions are applied separately to input channels (referred to as single-input single-output (SISO) in signal processing, or depthwise in other machine learning contexts).

• Conv1d: Explicit convolutions (regular convolution layers with fixed filter size). We use a fixed filter size of 64, to match parameters of the other approaches.

• FNO: Filters parametrized explicitly in the frequency-domain [(Li et al., 2020)](#b27). We set the number of modes to 64.

• H3: Implicit parametrization using state-space models (SSMs), and in particular the standard S4 [(Gu et al., 2021)](#b18). We set the state dimension to 64.

• TransferFunc: Implicit parametrization via transfer functions, a classical system-theoretic generalization of SSMs. Transfer functions are defined by a ratio of polynomials (we parametrize the coefficients, and evaluate the polynomials efficiently via FFTs). We set the order to 64.

• CKConv: Implicit parametrization using FFNs [(Romero et al., 2021b)](#).

• item Hyena: Combination of implicit parametrizations via FFNs (with exponential decay modulation as shown in Figure [3](#fig_4).1), and short explicit filters.

CKConv and Hyena use the same size of FFNs (width 32 to match in parameters).

In Table [A](#).1, we report additional results on the challenging setting of sequence length 131072 and vocabulary size 30. Implicit parametrizations of convolutions outperform explicit parametrizations on associative recall, with CKConv and Hyena greatly improving on the ability to extract the right key, value relations from different inputs. In Appendix C, we discuss how results on our synthetic tasks can be indicative of performance at a larger scale.

Table A.2: Test accuracy (%) in associative recall on sequences of length 131072, vocabulary size 30. Hyena CKConv TransferFunc H3 FNO Conv1d 97.2 14.3 0.5 0.6 0.3 0.5

Operator comparisons: We compare different models on the same associative recall task, using hyperparameters in Table [A](#).1. Hyena uses our filter parametrization with decay windowing for long convolutions, and short explicit convolutions of size 3 after the dense input projections. All other models use defaults from their largest scale experiment, while keeping the size to 2 layers and width 64.

A note on Transformer performance Transformers can solve associative recall tasks with longer sequences, provided the length does not prevent them from fitting in memory, and enough examples are present in the training data. In all our experiments, we keep the number of samples fixed (2000), a regime where Transformers struggle to find the generalizing solution (see Table [A](#).1).

For shorter sequences (see Appendix C), Transformers solve the task easily even with limited data, comparably to Hyena.

More broadly, these different properties of attention and attention-free token-mixing layers may explain improved performance when they are combined in hybrid architectures [(Dao et al., 2022c)](#). The focus on this work has been identifying an architecture capable of performing without attention, which is necessary to tackle domains where long sequences are common. However, when training with shorter sequences (up to 8k), if final downstream performance is the only metric of interest, improved results can be obtained by hybridizing our models similarly to H3 [(Dao et al., 2022c)](#).

## A.2 Language Modeling

WikiText103: We train 125M parameter models on WikiText103 and compare perplexity to Transformers, hybrid models such as H3 [(Dao et al., 2022c)](#), and other variants of subquadratic attention. All models use the same GPT2 tokenizer with vocabulary size 50257. We test order 3 Hyena with our proposed filter parametrization for two long convolutions, and a shorter explicit convolution on the third. We also consider Hyena (slim) that are 1.5x deeper than Transformers (12 versus 18 layers), with width multiplier of the FFNs set to 2. We find trading-off width for depth to be generally favourable. These modifications are made possible by the reduction in overall FLOPs of Hyena operators compared to self-attention, in particular non-parametric FLOPs which include materialization of the attention matrix, application of softmax, and matrix-value reduction.

And we can define the surrogate attention matrix A ψ ϕ (q, k)

$[A ψ ϕ (q, k))] t,t = q t L-1 m=0 ψ t-m k m ϕ m-t .(12)$Continuous Signals: We can also consider the case of continuous signals on a group G. In the continuous case, we can expand the convolutions in ( [8](#)) as

$(ϕ * v) t = G ϕ t-g v g dg, (ψ * z) t = G ψ t-g z g dg(13)$This allows us to rewrite (8) as

$y t = q t (ψ * k(ϕ * v)) t = q t G ψ t-g k g G ϕ g-τ v τ dτ dg = q t G G ψ t-g k g ϕ g-τ v τ dτ dg = q t G G ψ t-g k g ϕ g-τ v τ dg dτ Variable swap = G q t G ψ t-g k g ϕ g-τ v τ dg dτ Pull q t in τ integral = G q t G ψ t-g k g ϕ g-τ dg v τ dτ Pull v τ out of g integral. (14$$)$There is a linear operator A : v → y = Av which we interpret as the surrogate attention operator. A is conditioned on the query q, key k and filters ϕ and ψ, A = A ψ ϕ (q, k). The kernel K of the operator is given by

$K(t, t ) = q t G ψ t-g k g ϕ g-t dg(15)$Operator decomposition of the surrogate attention matrix We can decompose the linear map v → y; y = A ψ ϕ (q, k)v into a sequence of factors, each dependent on a projection of the input A ψ ϕ (q, k) = A ψ (q)A ϕ (k). Let D q and D k be the L-by-L diagonal matrices whose respective main diagonal entries are the respective entries of q and k. Then, we have that

$A ψ (q) = D q S ψ , D q = diag(q), A ϕ (k) = D k S ϕ , D k = diag(k).(16)$The matrix has been decomposed into two terms A ψ (q) and A ϕ (k) constructed by multiplying the diagonal matrices D q and D k with the Toeplitz matrices S ψ and S ϕ . S ψ and S ϕ are the kernels of the convolution operators with filter's impulse responses ψ and ϕ respectively. In the current applications of interest, ψ and ϕ are chosen to be causal, i.e. ψ[t] = 0 for t < 0 and ϕ[t] = 0 for t < 0. This results in S ψ and S ϕ to be lower triangular matrices

$S ψ =      ψ 0 0 • • • 0 ψ 1 ψ 0 • • • 0 . . . . . . . . . . . . ψ L-1 ψ L-2 • • • ψ 0      , S ϕ =      ϕ 0 0 • • • 0 ϕ 1 ϕ 0 • • • 0 . . . . . . . . . . . . ϕ L-1 ϕ L-2 • • • ϕ 0      . (17$$)$The surrogate attention matrix is then given by

$A ψ ϕ (q, k) = D q S ψ D k S ϕ(18)$We can expand the matrix multiplications in ( [16](#formula_21)) in the case of causal filters ϕ and ψ as

$D q         q 0 q 1 . . . q L-1         S ψ         ψ 0 ψ 1 ψ 0 . . . . . . . . . ψ L-1 ψ L-2 • • • ψ 0         D k         k 0 k 1 . . . k L-1         S ϕ         ϕ 0 ϕ 1 ϕ 0 . . . . . . . . . ϕ L-1 ϕ L-2 • • • ϕ 0         =      q 0 ψ 0 q 1 ψ 1 q 1 ψ 0 . . . . . . . . . q L-1 ψ L-1 q L-1 ψ L-2 • • • q L-1 ψ 0      A ψ (q)      k 0 ϕ 0 k 1 ϕ 1 k 1 ϕ 0 . . . . . . . . . k L-1 ϕ L-1 k L-1 ϕ L-2 • • • k L-1 ϕ 0      A ϕ (k)(19)$Fourier decomposition of convolution operators: The kernels of the convolution operators S ψ and S ϕ are diagonalized by the Fourier transform matrix W ∈ C L×L , W nm = z m , z = e j2πn/L . The Fourier transform of the convolution operator S ψ is given by

$S ψ = W * D Ψ W, S Φ = W * D Φ W($20) where D Ψ , D Φ ∈ C L×L are diagonal matrices constructed from the frequency responses (the discrete Fourier transform) Ψ = Wψ, Φ = Wϕ, respectively. This decomposition can be used to simplify the matrix multiplication in (19):

$A = D q S ψ D k S ϕ = D q W * D Ψ WD k W * D Φ W(21$) An important property of the above is the non-commutativity of D q and S k with W * . If the two operators commuted, we would obtain

$A = D q W * D Ψ WD k W * D Φ W = W * D q D Ψ D k D Φ W(22)$which reduces the entire layer to a simple convolution. The non-commutativity of the gating term acts as a non-linearity in chain of convolution operators.

## C Discussion and Additional Results

Vocabulary size scaling Table [C](#).1 showcases interesting correlation between associative recall performance for varying vocabulary sizes and loss on the The Pile. In this case, we fix sequence length for associative recall to be 2048, the same sequence length used to train all models on the The Pile.

We observe a similar phenomenon on other slices of tasks from our mechanistic design benchmarks, indicating that it may be possible to derive predictive laws for performance at scale, based on fast experimentation on synthetic tasks with models of 1 or 2 layers. Surprisingly, performance on our language synthetics appears to be further linked to performance as attention replacement in other domains (Appendix A.4 for results on image classification).

Table [C](#).1: Hyena Accuracy on associative recall with varying vocabulary size 10, 20, 30, 40 in relation to test loss on The Pile after 5 billion tokens. We notice a correlation between the two performance metrics, suggesting that slices of our mechanistic design synthetics may be potentially predictive of performance at scale.

## Model

Acc @ 10 Acc @ 20 Acc @ 30 Acc @ 40 Loss @ 5B on The Pile

Conv1d 32 11 10 8 4.21 AFT-conv 55 21 12 10 3.57 H3 92 60 13 10 2.69 Transformer 100 100 92 82 2.59 Hyena 100 100 98 85 2.59 D Samples and Visualizations D.1 Hyena Matrices We provide visualizations of attention and Hyena matrices activated by test strings. In D.1, D.2, we compare GPTNeo (Black et al., 2021) attention matrices with Hyena matrices extracted by our pre-trained small Hyena model. In D.3 and D.4, we provide additional Hyena matrices for the 355M model, activated by test strings of different length.

For attention, we visualize the raw post-softmax matrix. For Hyena matrices, we plot the (element-wise) absolute value of H(u):

$H(u) = D N x S N h • • • D 2 x S 2 h D 1 x S 1 h Ĥ(u) ij = |H(u) ij |$Since Hyena does not normalize the entries of its matrices with e.g., softmax, there are notable differences with attention: (1) the entries of H(u) can be either positive and negative, and (2) the magnitude is unconstrained.

We observe the magnitude of matrices in pre-trained Hyena models to be around 10 -3 .     

## D.4 Downstream Examples

MultiRC We report examples of downstream evaluation of small models on the MultiRC question-answering task. We report answers of small Hyena (153M, trained for 130B tokens on The Pile) and the public checkpoint RWKV-v4 (Peng, 2021) (169M, trained for 332B tokens on The Pile). We select randomized examples with indices being powers of 2. Alignment of Hyena's responses to the task format is greatly improved by providing few-shot examples in the prompt, which may be a promising sign for larger models based on the proposed attention-free architecture. Each example shows responses for specific examples in the validation set (example indices are listed at the beginning of each example).

MultiRC index: 2, 4

Passage: What causes a change in motion? The application of a force. Any time an object changes motion, a force has been applied. In what ways can this happen? Force can cause an object at rest to start moving. Forces can cause objects to speed up or slow down. Forces can cause a moving object to stop. Forces can also cause a change in direction. In short, forces cause changes in motion. The moving object may change its speed, its direction, or both. We know that changes in motion require a force. We know that the size of the force determines the change in motion. How much an object's motion changes when a force is applied depends on two things. It depends on the strength of the force. It also depends on the object's mass. Think about some simple tasks you may regularly do. You may pick up a baseball. This requires only a very small force.

Question: Based on the previous passage, Would the mass of a baseball affect how much force you have to use to pick it up? Is "Less the mass, less the force applied" a correct answer?

Answer: Yes RWKV zero-shot: The mass of a baseball depends on the force applied. if the mass of the baseball is small, the force applied is small.

Hyena zero-shot: Yes it is.

RWKV few-shot: The mass, less the force applied, is a more important force. it is the force that changes the mass of a baseball.

Hyena few-shot: Yes.

Question: Based on the previous passage, What do you apply to an object to make it move or stop? Is "Strength" a correct answer?

Answer: No RWKV zero-shot: The force applied to the object is the force applied to the object.

Hyena zero-shot: Yes.

RWKV few-shot: The force applied to a baseball is a force. it is a force that is applied to a baseball.

Hyena few-shot: Yes.

Passage: The film opens with Sunita, a medical student, and her friends working on a project about the human brain. She wants to investigate the curious case of Sanjay Singhania, a notable city businessman, who is reported to have anterograde amnesia. Her professor denies access to Sanjay's records as it is currently under criminal investigation. Sunita, nonetheless, decides to investigate the matter herself. Sanjay is introduced as he brutally murders a man. He takes a Polaroid picture of the man, and writes on it "done". It is revealed that Sanjay has anterograde amnesia where he loses his memory every 15 minutes. Sanjay uses a system of photographs, notes, and tattoos on his body to recover his memory after each cycle. It is revealed that Sanjay is ultimately out to avenge the death of his sweetheart Kalpana, and that he is systematically killing the people who were responsible for it. His main target is "Ghajini", a notable social personality in the city. Police Inspector Arjun Yadav, on the case of the serial murders, tracks Sanjay down to his flat and attacks and disables him. Yadav finds two diaries where Sanjay has chronicled the events of 2005 and 2006 . The film flashes back to 2005 as Yadav reads the diary. Sanjay Singhania is shown as the owner of the Air Voice mobile telephone company. In the course of his business, Sanjay sends his men to meet Kalpana, a struggling model, about putting up a billboard above her apartment. The owner of Kalpana's advertising firm misinterprets this as a romantic advance, and in view of a possible lucrative Air Voice ad campaign and other benefits, encourages Kalpana to accept the overture.

Question: Based on the previous passage, Why did Sanjay murder a man? Is "Sanjay" a correct answer?

Answer: Yes RWKV zero-shot: The answer is "Sanjay".

Hyena zero-shot: The answer is RWKV few-shot: The question is not about Sanjay's death.

Hyena few-shot: No.

Question: Based on the previous passage, Every 15 minutes, Sanjay goes through what process, Which frustrates his attempts to avenge the death of his sweetheart? Is "He forgets about facts" a correct answer?

Answer: Yes RWKV zero-shot: Yes, it is a correct answer..

Hyena zero-shot: The answer is.

RWKV few-shot: The answer is "yes".

Hyena few-shot: The answer is "yes.

Passage: In 1863, Alexander II re-convened the Diet of Finland and initiated several reforms increasing Finlandś autonomy from Russia including establishment of its own currency, the markka. Liberation of business led to increased foreign investment and industrial development. Finland also got its first railways, separately established under Finnish administration. Finally, the elevation of Finnish from a language of the common people to a national language equal to Swedish opened opportunities for a larger proportion of the society. Alexander II is still regarded as "The Good Tsar" in Finland. These reforms could be seen as results of a genuine belief that reforms were easier to test in an underpopulated, homogeneous country, than in the whole of Russia. They may also be seen as a reward for the loyalty of its relatively western-oriented population during the Crimean War and during the Polish uprising. Encouraging Finnish nationalism and language can also be seen as an attempt to dilute ties with Sweden.

Question: Based on the previous passage, Alexander II is considered what in Finland since 1863? Is "The good tsar" a correct answer?

Answer: Yes RWKV zero-shot: The correct answer is "yes".

Hyena zero-shot: Yes, the question is correct.

RWKV few-shot: The Finnish language is a language of the people.

Hyena few-shot: Yes.

![Figure 2.1: Comparison between data-controlled matrices: SelfAttention and Hyena.]()

![Figure 4.3: Benchmarking runtime of Hyena, Attention and FlashAttention with varying sequence lengths. Batch size is set to 64. The figure on the right is an inset showing a zoomed-in portion of the figure on the left.]()

![Figure D.1: Attention matrices from a GPTNeo small model. "We use the test string "Attention is all you need. Attention is".]()

![Figure D.2: Hyena matrices from a Hyena small (same model used for SuperGLUE downstream evaluations)."We use the test string "Attention is all you need. Attention is". We note that Hyena has a different data-controlled matrix for each channel i.e. for each dimension in its width, since it does not use heads.]()

![Figure D.3: Data-controlled Hyena matrices (355M model), activated by the string "When a doctor doctors a doctor, does the doctor doing the doctoring doctor as the doctor being doctored wants to be doctored or does the doctor doing the doctoring doctor as they want to doctor? ". Rows in the plot are matrices from different layers, columns are matrices from different channels. The operator shows characteristic patterns of attention matrices, without attention.]()

![Figure D.4: Data-controlled Hyena matrices (355M model), activated by the string "Mrs. Dursley, Mr. Dursley, Dudley Dursley", from Causal scrubbing: results on induction heads. Rows in the plot are matrices from different layers, columns are matrices from different channels.]()

![Figure D.5: [Top]: Long convolution Hyena filters at initialization (153M parameters, 18 layer model). [Bottom]: Filters after training for 130 billion tokens on The Pile.]()

![]()

![1: A selection of our mechanistic design benchmarks.]()

![2: Test accuracy (%) for associative recall on longer sequences, vocabulary size 30. The symbol is used to mark settings where the model does not fit in memory.]()

![5: Zero-shot accuracy (%) on SuperGLUE tasks for small models. Table4.6: Few-shot (3) accuracy (%) on SuperGLUE tasks for small models.]()

![7: Image classification top-1 accuracy.]()

Self-attention can be expressed as y = A(k, q)v where A is the attention matrix conditioned by linear projections k, q of the input and multiplied by v, another projection.

FlashAttention is already 2-4x faster than a standard attention implementation in PyTorch.

In the L 1 (Z) sense:∞ t=-∞ |ht| < ∞

For consistency with our discussion, we have swapped k and v compared to the notation in(Dao et al., 2022c).

Some of this analysis is reported in the Appendix.

This observation finds mirrors in the parametrization of the convolutions in H3(Dao et al., 2022c)  as a shift SSM and a diagonal SSM.

In contrast, deep learning primitives are designed for high GPU utilization, with FFNs and attention usually reaching 50 -70% or higher, if optimized.

The FLOP reduction consists in the non-parametric FLOPs of SelfAttention devoted to attention matrix computation. The ratio of parametric to non-parametric FLOPs (and hence the gains) depend on the ratio of model width D and sequence length L used in training.

