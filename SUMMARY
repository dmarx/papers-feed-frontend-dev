---
File: .github/workflows/1_store-sync.yml
---
name: Store Sync

on:
  issues:
    types: [reopened]
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'

jobs:
  process-updates:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'stored-object')
    permissions:
      issues: write
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          
      - name: Install dependencies
        run: pip install gh-store
          
      - name: Process Updates
        run: |
          python -m gh_store process-updates \
            --issue ${{ github.event.issue.number }} \
            --token ${{ secrets.GITHUB_TOKEN }} \
            --repo ${{ github.repository }}

  notify-deploy:
    needs: process-updates
    runs-on: ubuntu-latest
    steps:
      - name: Trigger frontend deploy
        run: |
          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/2_deploy-frontend.yml/dispatches \
            -d "{\"ref\":\"${{ github.ref }}\"}"



---
File: .github/workflows/2_deploy-frontend.yml
---
name: Deploy Frontend

on:
  workflow_dispatch:
  # push:
  #   paths:
  #     - 'data/papers/gh-store-snapshot.json'

concurrency:
  group: store-deploy
  cancel-in-progress: false

permissions:
  contents: write
  pages: write
  id-token: write
  actions: read

jobs:
  update-snapshot:
    runs-on: ubuntu-latest
    outputs:
      changes_detected: ${{ steps.commit-changes.outputs.changes_detected }}
    steps:
      - name: Wait for updates
        uses: actions/github-script@v7
        with:
          script: |
            while (true) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: '1_store-sync.yml',
              });
              
              const activeUpdates = runs.data.workflow_runs.filter(run => 
                (run.status === 'in_progress' || run.status === 'queued')
              );
              
              if (activeUpdates.length === 0) break;
              console.log(`Waiting for ${activeUpdates.length} active updates to complete...`);
              await new Promise(r => setTimeout(r, 10000));
            }

      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          
      # - name: Install dependencies
      #   run: pip install gh-store

      # - name: Update snapshot
      #   env:
      #     SNAPSHOT_PATH: data/papers/gh-store-snapshot.json
      #   run: |
      #     mkdir -p $(dirname ${{ env.SNAPSHOT_PATH }})
      #     python -m gh_store update-snapshot \
      #       --token ${{ secrets.GITHUB_TOKEN }} \
      #       --repo ${{ github.repository }} \
      #       --snapshot-path ${{ env.SNAPSHOT_PATH }}
      
      # - name: Convert data
      #   run: |
      #     python frontend/scripts/convert_store.py \
      #       --snapshot_path data/papers/gh-store-snapshot.json \
      #       --output_path data/papers/papers.json \
      #       --archive_path data/papers/papers-archive.json \
      #       --features_base data/papers

      - name: Upload papers.json
        uses: actions/upload-artifact@v4
        with:
          name: papers-json
          path: data/papers/papers.json

      - name: Commit changes
        id: commit-changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: Update store snapshot [${{ github.run_id }}]"
          file_pattern: 'data/papers/**'
      
  deploy:
    needs: update-snapshot
    if: github.event_name == 'workflow_dispatch' || needs.update-snapshot.outputs.changes_detected == 'true'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - name: Download papers.json
        uses: actions/download-artifact@v4
        with:
          name: papers-json
          path: data/papers/

      - name: Build web directory
        run: |
          # Create base directories
          mkdir -p web/{styles,js,data}
          
          # Copy static assets
          cp frontend/src/styles/*.css web/styles/
          cp frontend/src/js/*.js web/js/
          cp frontend/src/templates/index.html web/index.html
          cp data/papers/papers.json web/data/
          
          # Copy paper features maintaining directory structure
          cd data
          if [ -d "papers" ]; then
            # Create papers directory in web/data
            mkdir -p ../web/data/papers
            
            # Find all markdown files under papers/*/features
            # and copy them maintaining directory structure
            find papers -type f -name "*.md" -path "*/features/*" -exec cp --parents {} ../web/data/ \;
          fi
          cd ..
          
          touch web/.nojekyll

      - name: Get git info
        id: git-info
        run: |
          echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          echo "commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "repo=${GITHUB_REPOSITORY}" >> $GITHUB_OUTPUT

      - name: Create git info JSON
        run: |
          echo "{\"branch\": \"${{ steps.git-info.outputs.branch }}\", \"commit\": \"${{ steps.git-info.outputs.commit }}\", \"repo\": \"${{ steps.git-info.outputs.repo }}\"}" > web/data/git-info.json

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./web
          force_orphan: true



---
File: .github/workflows/ATTACK/refresh_pdfs.yaml
---
name: REFRESH ALL Markdown Conversions (grobid)

on:
  workflow_dispatch:
      # tag:
      #   description: 'Optional tag to append to the output filename'
      #   required: false
      #   default: ''

jobs:
  convert:
    runs-on: ubuntu-latest
    services:
      grobid:
        image: lfoppiano/grobid:latest-crf
        ports:
          - 8070:8070
        env:
          JAVA_OPTS: "-Xmx4g"
        volumes:
          - ${{ github.workspace }}:/opt/grobid/input
        options: "--init"
        
    steps:
      - uses: actions/checkout@v4
    
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
    
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install llamero lxml requests
    
      - name: Process PDF
        env:
          GROBID_HOST: localhost  # Use localhost since the service is mapped to that port
        run: |
          # Wait until Grobid is ready
          for i in {1..30}; do
            if curl -sSf http://localhost:8070/api/isalive > /dev/null; then
              echo "Grobid is ready!"
              break
            fi
            echo "Attempt $i: Service not ready yet, waiting..."
            sleep 10
          done
          python scripts/process_pdf.py flush_old_conversions --tag=""
          python scripts/process_pdf.py flush_old_conversions --tag="grobid"
          python scripts/process_pdf.py generate_missing_conversions
    
      # Commit and push the generated output back to the repository.
      - name: Commit and Push Output
        uses: EndBug/add-and-commit@v9
        with:
          # The 'add' value here could be the folder or file pattern where the output is created.
          # For example, if the PDF is in a subdirectory, you might want to commit changes in that folder.
          add: '.'
          message: "Add processed output for ${{ github.event.inputs.pdf_path }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



---
File: .github/workflows/ATTIC/DEPRECATED_pandoc_convert-markdown.yml
---
# .github/workflows/convert-markdown.yml
name: Convert Papers to Markdown

on:
  # schedule:
  #   - cron: '0 */12 * * *'  # Run every 12 hours
  workflow_dispatch:
  
concurrency:
  group: ${{ github.repository }}-event-processing
  cancel-in-progress: false
  
jobs:

  convert-markdown:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y pandoc texlive-base
          pandoc --version  # Verify installation
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install papers_feed
      
      - name: Convert to markdown
        run: |
          python -m papers_feed.asset_manager convert-markdown
          python -m papers_feed.asset_manager retry-failures
      
      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: Convert papers to markdown"
          file_pattern: |
            data/papers/**



---
File: .github/workflows/ATTIC/convert-markdown.yaml
---
name: Generate Missing Markdown Conversions (grobid)

on:
  schedule:
    - cron: '0 */12 * * *'  # Run every 12 hours
  workflow_dispatch:
  
concurrency:
  group: ${{ github.repository }}-event-processing
  cancel-in-progress: false

jobs:
  convert:
    runs-on: ubuntu-latest
    services:
      grobid:
        image: lfoppiano/grobid:latest-crf
        ports:
          - 8070:8070
        env:
          JAVA_OPTS: "-Xmx4g"
        volumes:
          - ${{ github.workspace }}:/opt/grobid/input
        options: "--init"
        
    steps:
      - uses: actions/checkout@v4
    
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
    
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install llamero lxml requests
    
      - name: Process PDF
        env:
          GROBID_HOST: localhost  # Use localhost since the service is mapped to that port
        run: |
          # Wait until Grobid is ready
          for i in {1..30}; do
            if curl -sSf http://localhost:8070/api/isalive > /dev/null; then
              echo "Grobid is ready!"
              break
            fi
            echo "Attempt $i: Service not ready yet, waiting..."
            sleep 10
          done
          python scripts/process_pdf.py generate_missing_conversions

      # Commit and push the generated output back to the repository.
      - name: Commit and Push Remaining Outputs (xml)
        uses: EndBug/add-and-commit@v9
        with:
          # The 'add' value here could be the folder or file pattern where the output is created.
          # For example, if the PDF is in a subdirectory, you might want to commit changes in that folder.
          add: '.'
          message: "Add tei xml's"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



---
File: .github/workflows/ATTIC/deploy_frontend.yaml
---
name: Deploy Paper Feed to GitHub Pages

on:
  push:
    paths:
      - 'data/papers/gh-store-snapshot.json'
      - '.github/workflows/deploy_frontend.yaml'
      - 'frontend/scripts/convert_store.py'
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight UTC

concurrency:
  group: ${{ github.repository }}-event-processing
  cancel-in-progress: false

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install fire loguru

      - name: Prepare web directory
        run: |
          mkdir -p web/{styles,js,data}
          cp frontend/src/styles/*.css web/styles/
          cp frontend/src/js/*.js web/js/
          cp frontend/src/templates/index.html web/index.html
          
      - name: Convert data
        run: |
          python frontend/scripts/convert_store.py \
            --snapshot_path data/papers/gh-store-snapshot.json \
            --output_path web/data/papers.json

      - name: Ensure presence of .nojekyll file
        run: touch web/.nojekyll

      - name: Get git info
        id: git-info
        run: |
          echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          echo "commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "repo=${GITHUB_REPOSITORY}" >> $GITHUB_OUTPUT

      - name: Create git info JSON
        run: |
          echo "{\"branch\": \"${{ steps.git-info.outputs.branch }}\", \"commit\": \"${{ steps.git-info.outputs.commit }}\", \"repo\": \"${{ steps.git-info.outputs.repo }}\"}" > web/data/git-info.json

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: web
  
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./web
          force_orphan: true



---
File: .github/workflows/ATTIC/download-papers.yml
---
# .github/workflows/download-papers.yml
name: Download Paper Files

on:
  # schedule:
  #   - cron: '0 */6 * * *'  # Run every 6 hours
  workflow_dispatch:
  
concurrency:
  group: ${{ github.repository }}-event-processing
  cancel-in-progress: false
  
jobs:
  download-files:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install papers_feed
      
      - name: Download PDFs (uncomment to download source)
        run: |
          python -m papers_feed.asset_manager download-pdfs
          #python -m papers_feed.asset_manager download-source
      
      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: Download paper files"
          file_pattern: |
            data/papers/**



---
File: .github/workflows/ATTIC/gh-store-snapshot.yml
---
# gh-store-snapshot.yml
name: Gh-Store Snapshot Management

on:
  issues:
    types: [reopened]
  # schedule:
  #   # Run daily at midnight UTC
  #   - cron: '0 0 * * *'
  workflow_dispatch:
    # Allow manual triggering
    inputs:
      force_new:
        description: 'Force creation of new snapshot'
        required: false
        type: boolean
        default: false

env:
  SNAPSHOT_PATH: data/papers/gh-store-snapshot.json

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  process-updates:
    if: contains(github.event.issue.labels.*.name, 'stored-object')
    uses: "dmarx/papers-feed/.github/workflows/ghstore-process-updates.yml@673d20a8da9003fa5f437ac66f613a2b869badc4"
  snapshot:
    needs: process-updates
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed for pushing snapshot changes

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install gh-store

      - name: Check for existing snapshot
        id: check_snapshot
        run: |
          if [ -f "${{ env.SNAPSHOT_PATH }}" ] && [ "${{ github.event.inputs.force_new }}" != "true" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create new snapshot
        if: steps.check_snapshot.outputs.exists == 'false'
        run: |
          # Ensure directory exists
          mkdir -p $(dirname ${{ env.SNAPSHOT_PATH }})
          
          # Create snapshot using CLI
          python -m gh_store snapshot \
            --token ${{ secrets.GITHUB_TOKEN }} \
            --repo ${{ github.repository }} \
            --output ${{ env.SNAPSHOT_PATH }}

      - name: Update existing snapshot
        if: steps.check_snapshot.outputs.exists == 'true'
        run: |
          python -m gh_store update-snapshot \
            --token ${{ secrets.GITHUB_TOKEN }} \
            --repo ${{ github.repository }} \
            --snapshot-path ${{ env.SNAPSHOT_PATH }}
            
      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "${{ steps.check_snapshot.outputs.exists == 'true' && 'chore: Update data store snapshot' || 'chore: Create initial data store snapshot' }}"
          file_pattern: "${{ env.SNAPSHOT_PATH }}"



---
File: .github/workflows/ATTIC/ghstore-process-updates.yml
---
# .github/workflows/ghstore-process-updates.yml

name: Process Object Updates

on:
  #issues:
  #  types: [reopened]
  workflow_call:

jobs:
  process-updates:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'stored-object')
    permissions:
      issues: write 
    steps:
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install gh-store
          
      - name: Process Updates
        run: |
          python -m gh_store process-updates \
            --issue ${{ github.event.issue.number }} \
            --token ${{ secrets.GITHUB_TOKEN }} \
            --repo ${{ github.repository }}



---
File: .github/workflows/ATTIC/hard-refresh.yml
---
# .github/workflows/hard-refresh.yml
name: Hard Refresh

on:
  workflow_dispatch:  # Manual trigger only
  
permissions:
  contents: write
  issues: write

jobs:

  refresh:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: true
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
      
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install PyGithub
        pip install papers_feed
    
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y pandoc texlive-base
    
    - name: Clear data directory and reopen issues
      run: |
        python - <<EOF
        import os
        import shutil
        from github import Github
        
        # Clear data directory
        data_dir = "data"
        if os.path.exists(data_dir):
            print(f"Removing {data_dir} directory...")
            shutil.rmtree(data_dir)
            os.makedirs(data_dir)
        
        # Reopen closed paper/reading issues
        g = Github(os.environ["GITHUB_TOKEN"])
        repo = g.get_repo(os.environ["GITHUB_REPOSITORY"])
        
        for issue in repo.get_issues(state="closed"):
            labels = [label.name for label in issue.labels]
            if "wontfix" in labels:
                continue
            if "paper" in labels or "reading-session" in labels:
                print(f"Reopening issue #{issue.number}")
                issue.edit(state="open")
        EOF
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Process events
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: python -m papers_feed.process_events
  
    - name: Download PDFs and Source
      run: |
        python -m papers_feed.asset_manager download-pdfs
        python -m papers_feed.asset_manager download-source

    - name: Convert to markdown
      run: |
        python -m papers_feed.asset_manager convert-markdown
        python -m papers_feed.asset_manager retry-failures
    
    - name: Commit and push if there are changes
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: "chore: Hard refresh"
        file_pattern: |
          data/**



---
File: .github/workflows/ATTIC/process-events.yml
---
# .github/workflows/process-events.yml
name: Process Paper Events
on:
  push:
    paths:
      - ".github/workflows/process-events.yml"
  issues:
    types: [opened]
    labels:
      - 'paper'
      - 'reading-session'
  # schedule:
  #   - cron: '0 * * * *'  # Run every hour
  workflow_call:
  workflow_dispatch:
  
concurrency:
  group: ${{ github.repository }}-event-processing
  cancel-in-progress: false
  
jobs:
  process-papers:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: write
      issues: write
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install papers_feed
      
      - name: Process Events
        id: process
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OUTPUT=$(python -m papers_feed.process_events)
          echo "Debug: Script output: $OUTPUT"
          if [[ "$OUTPUT" == *"Events processed."* ]]; then
            echo "SHOULD_TRIGGER=true" >> "$GITHUB_OUTPUT"
          else
            echo "SHOULD_TRIGGER=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Conditionally trigger frontend deploy
        if: ${{ steps.process.outputs.SHOULD_TRIGGER == 'true' }}
        run: |
          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/deploy_frontend.yaml/dispatches \
            -d '{"ref":"${{ github.ref }}"}'



---
File: .github/workflows/ATTIC/process_enrichments.yaml
---
name: Process Enrichments

on:
  issues:
    types: [opened, reopened]
  workflow_dispatch:  # Allow manual triggering
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight UTC

jobs:
  process-features:
    runs-on: ubuntu-latest
    
    # Only check for feature-node label if triggered by an issue event
    if: |
      github.event_name != 'issues' || 
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'feature-node'))
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install llamero PyGithub duckduckgo-search
        
    - name: Process feature requests
      run: python scripts/process_enrichments.py
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



---
File: .github/workflows/ATTIC/process_pdf.yml
---
name: Process PDF with Grobid

on:
  workflow_dispatch:
    inputs:
      pdf_path:
        description: 'Path to PDF file relative to repository root'
        required: true
        type: string
      output_format:
        description: 'Output format (markdown/tei)'
        required: true
        type: choice
        options:
          - markdown
          - tei
        default: 'markdown'
      tag:
        description: 'Optional tag to append to the output filename'
        required: false
        default: ''

jobs:
  convert:
    runs-on: ubuntu-latest
    services:
      grobid:
        image: lfoppiano/grobid:latest-crf
        ports:
          - 8070:8070
        env:
          JAVA_OPTS: "-Xmx4g"
        volumes:
          - ${{ github.workspace }}:/opt/grobid/input
        options: "--init"
        
    steps:
      - uses: actions/checkout@v4
    
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
    
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests loguru fire lxml
    
      - name: Process PDF
        env:
          GROBID_HOST: localhost  # Use localhost since the service is mapped to that port
        run: |
          # Wait until Grobid is ready
          for i in {1..30}; do
            if curl -sSf http://localhost:8070/api/isalive > /dev/null; then
              echo "Grobid is ready!"
              break
            fi
            echo "Attempt $i: Service not ready yet, waiting..."
            sleep 10
          done
          python scripts/process_pdf.py ${{ github.event.inputs.pdf_path }} --format ${{ github.event.inputs.output_format }} --tag "${{ github.event.inputs.tag }}"
    
      # Commit and push the generated output back to the repository.
      - name: Commit and Push Output
        uses: EndBug/add-and-commit@v9
        with:
          # The 'add' value here could be the folder or file pattern where the output is created.
          # For example, if the PDF is in a subdirectory, you might want to commit changes in that folder.
          add: '.'
          message: "Add processed output for ${{ github.event.inputs.pdf_path }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



---
File: .github/workflows/ATTIC/refresh_pdfs_via_tei.yaml
---
name: REFRESH ALL Markdown Conversions (grobid) - WITH TEI

on:
  workflow_dispatch:

jobs:
  convert:
    runs-on: ubuntu-latest
        
    steps:
      - uses: actions/checkout@v4
    
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
    
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install llamero lxml requests
    
      - name: Process PDF
        run: |
          python scripts/process_pdf.py flush_old_conversions --tag="grobid"
          python scripts/process_pdf.py generate_missing_conversions --regenerate-tei=False
    
      # Commit and push the generated output back to the repository.
      - name: Commit and Push Output
        uses: EndBug/add-and-commit@v9
        with:
          # The 'add' value here could be the folder or file pattern where the output is created.
          # For example, if the PDF is in a subdirectory, you might want to commit changes in that folder.
          add: '.'
          message: "Add processed output for ${{ github.event.inputs.pdf_path }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



---
File: .github/workflows/build-extension.yml
---
# .github/workflows/build-extension.yml
name: Build Extension

on:
  push:
    paths:
      - 'extension/**'
      - '.github/workflows/build-extension.yml'
    branches: [ main, ext-use-gh-store ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: extension

    steps:
    - uses: actions/checkout@v4
    
    # Generate package-lock.json if it doesn't exist
    # - name: Initialize npm
    #   run: |
    #     if [ ! -f "package-lock.json" ]; then
    #       npm install --package-lock-only --no-audit
    #     else
    #       echo "package-lock.json exists"
    #     fi
    
    # Regenerate package-lock.json to ensure it matches package.json
    - name: Regenerate package-lock.json
      run: |
        if [ -f "package-lock.json" ]; then
          rm -f package-lock.json
        fi
        npm install --package-lock-only --no-audit

    - name: Flush old build
      run: rm -rf dist/
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        #cache: 'npm'
        #cache-dependency-path: './extension/package-lock.json'
        
    - name: Install dependencies
      #run: npm ci --prefer-offline
      run: npm install --prefer-offline
        
      
    - name: Show environment info
      run: |
        echo "Node version:"
        node --version
        echo "NPM version:"
        npm --version
        echo "Directory structure:"
        ls -R
        echo "package.json contents:"
        cat package.json
        
    - name: Type check
      run: npm run type-check
        
    - name: Build extension
      run: |
        set -ex
        npm run build
        echo "Build output:"
        ls -la dist/

    # Debug output
    - name: Show build results
      if: always()
      run: |
        echo "Current directory:"
        pwd
        echo "Directory contents:"
        ls -lha
        echo "Dist directory contents (if exists):"
        ls -lha dist/ || echo "No dist directory"
        echo "Error logs (if any):"
        find . -name "*.log" -exec cat {} \;

    # Commit the built files
    - name: Commit bundled files
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: "chore: Update extension bundles"
        file_pattern: "extension/dist/*"
        #branch: ${{ github.ref }}



---
File: .github/workflows/build-new-frontend.yaml
---
# .github/workflows/deploy-frontend.yml
name: Build and Deploy Frontend
on:
  push:
    branches: [ main ]
  
  # Allow manual trigger
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write
  actions: read

jobs:
  build-and-deploy-frontend:
    runs-on: ubuntu-latest
        
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          #cache: 'npm'
          #cache-dependency-path: 'frontend-new/package-lock.json'
      
      - name: Install Dependencies
        run: |
          cd frontend-new
          npm ci || npm install
      
      - name: Run Tests
        run: |
          cd frontend-new
          npm test
      
      - name: Build
        run: |
          cd frontend-new
          npm run build

      - name: Prepare deployment
        run: |
          cd frontend-new
          # Ensure bundle.css exists, create an empty one if not
          if [ ! -f "public/bundle.css" ]; then
            touch public/bundle.css
          fi
          
          # Create data/ directory
          mkdir -p public/data
          
          # Copy papers.json to the public folder if it exists
          if [ -f "papers.json" ]; then
            cp web/data/papers.json public/data/papers.json
          fi

          
      # Configure GitHub Pages
      - name: Setup Pages
        uses: actions/configure-pages@v4
      
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./frontend-new/public
      
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



---
File: .github/workflows/ghstore-process-bulk.yml
---
# .github/workflows/ghstore-process-bulk.yml
name: Process Bulk Object Updates

on:
  workflow_dispatch:
    inputs:
      label:
        description: 'Label to process (default: stored-object)'
        required: true
        type: string
        default: 'stored-object'

jobs:
  process-updates:
    runs-on: ubuntu-latest
    permissions:
      issues: write 
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install gh-store rich loguru

      - name: Process Updates
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          LABEL: ${{ inputs.label }}
        run: |
          python - << 'EOF'
          import os
          from github import Github
          from gh_store.__main__ import CLI
          from loguru import logger
          from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn

          # Initialize GitHub client
          g = Github(os.environ["GITHUB_TOKEN"])
          repo = g.get_repo(os.environ["REPO"])
          label = os.environ["LABEL"]

          # Get all open issues with the specified label
          logger.info(f"Finding open issues with label: {label}")
          open_issues = list(repo.get_issues(state="open", labels=[label]))

          if not open_issues:
              logger.warning("No open issues found with specified label")
              exit(0)

          logger.info(f"Found {len(open_issues)} issues to process")

          # Initialize CLI
          cli = CLI()

          # Create progress bar
          with Progress(
              SpinnerColumn(),
              TextColumn("[bold blue]{task.description}"),
              BarColumn(),
              TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
          ) as progress:
              process_task = progress.add_task(
                  "Processing issues...",
                  total=len(open_issues)
              )

              for issue in open_issues:
                  logger.info(f"Processing issue #{issue.number}")
                  cli.process_updates(
                      issue=issue.number,
                      token=os.environ["GITHUB_TOKEN"],
                      repo=os.environ["REPO"]
                  )
                  progress.update(process_task, advance=1)

          logger.info("Bulk processing completed")
          EOF



---
File: .github/workflows/llamero-summarize.yaml
---
name: Llamero Summarization

on:
  # push:
  #   branches: [ main ]
  workflow_dispatch:

jobs:
  generate-summaries:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install llamero
      run: pip install llamero

    - name: Generate summaries
      run: llamero summarize all



---
File: .github/workflows/mirror-issues.yaml
---
# .github/workflows/mirror_repository.yml
name: Mirror GitHub Repository

on:
  workflow_dispatch:
    inputs:
      source_repo:
        description: 'Source repository (format: owner/repo)'
        required: true
        default: 'dmarx/papers-feed'
      target_repo:
        description: 'Target repository (format: owner/repo)'
        required: true
        default: 'dmarx/papers-feed-dev'
      clear_target_labels:
        description: 'Clear all labels from issues in target repository'
        required: true
        type: boolean
        default: false
      issue_range_start:
        description: 'Starting issue number to copy (optional)'
        required: false
      issue_range_end:
        description: 'Ending issue number to copy (optional)'
        required: false

jobs:
  mirror-repo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 1  # Shallow clone - only get the latest commit

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install PyGithub fire loguru

      - name: Run mirroring script
        env:
          DEV_REPO_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python scripts/github_repo_mirror.py mirror \
            --source-repo=${{ github.event.inputs.source_repo }} \
            --target-repo=${{ github.event.inputs.target_repo }} \
            --clear-target-labels=${{ github.event.inputs.clear_target_labels }} \
            ${{ github.event.inputs.issue_range_start != '' && format('--issue-range-start={0}', github.event.inputs.issue_range_start) || '' }} \
            ${{ github.event.inputs.issue_range_end != '' && format('--issue-range-end={0}', github.event.inputs.issue_range_end) || '' }}



---
File: .github/workflows/ops-misc.yml
---
# .github/workflows/ops-misc.yml
# General purpose utility operator for one-off operations
# Executes misc.sh and clears it after successful run

name: Miscellaneous Operations

on:
  push:
    paths:
      - 'ops/misc.sh'
      - '.github/workflows/ops-misc.yml'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  execute-misc:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Execute and clear misc script
        run: |
          cat ops/misc.sh
          . ops/misc.sh
          echo '#!/bin/bash' > ops/misc.sh

      - uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: executed miscellaneous operation"



---
File: .github/workflows/paper-enrichment.yml
---
# .github/workflows/paper-enrichment.yml

name: PDF Download and Enrichment

on:
  issues:
    types: [opened, reopened]
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:
  

concurrency:
  group: ${{ github.repository }}-event-processing
  cancel-in-progress: false

jobs:
  download-pdfs:
    runs-on: ubuntu-latest
    if: |
      github.event_name != 'issues' || 
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'feature-node'))
    permissions:
      contents: write
    outputs:
      has_changes: ${{ steps.commit.outputs.changes_detected }}
      
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install papers_feed
      
      - name: Download PDFs
        run: |
          python -m papers_feed.asset_manager download-pdfs
      
      - name: Commit changes
        id: commit
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: Download paper files"
          file_pattern: |
            data/papers/**

  convert-pdfs-to-markdown:
    runs-on: ubuntu-latest
    needs: download-pdfs
    if: github.event_name != 'issues' || needs.download-pdfs.outputs.has_changes == 'true'
    outputs:
      has_changes: ${{ steps.commit.outputs.changes_detected }}
    
    services:
      grobid:
        image: lfoppiano/grobid:latest-crf
        ports:
          - 8070:8070
        env:
          JAVA_OPTS: "-Xmx4g"
        volumes:
          - ${{ github.workspace }}:/opt/grobid/input
        options: "--init"
        
    steps:
      - uses: actions/checkout@v4
    
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
    
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install llamero lxml requests
    
      - name: Process PDF
        env:
          GROBID_HOST: localhost
        run: |
          for i in {1..30}; do
            if curl -sSf http://localhost:8070/api/isalive > /dev/null; then
              echo "Grobid is ready!"
              break
            fi
            echo "Attempt $i: Service not ready yet, waiting..."
            sleep 10
          done
          python scripts/process_pdf.py generate_missing_conversions

      - name: Commit and Push Conversions
        id: commit
        uses: EndBug/add-and-commit@v9
        with:
          add: '.'
          message: "Add tei xml's"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  process-enrichments:
    needs: convert-pdfs-to-markdown
    if: github.event_name != 'issues' || needs.convert-pdfs-to-markdown.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install llamero PyGithub duckduckgo-search
          
      - name: Process enrichments
        run: python scripts/process_enrichments.py
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



---
File: .github/workflows/process-issue-task.yaml
---
name: Process Task From Issue Trigger
on:
  issues:
    types: [opened, reopened]

jobs:
  process-search:
    if: contains(github.event.issue.labels.*.name, 'task')
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install gh-store duckduckgo_search
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          
      - name: Process Task
        run: |
          RESULT=$(python scripts/process_task.py --config "${{ github.event.issue.body }}")
          gh issue comment "$ISSUE_NUMBER" --body "$RESULT" --repo "$GITHUB_REPOSITORY"

          # TODO: use gh-store to update the issue state and be responsible for closing it
          gh issue close "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY"
          
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}



---
File: .github/workflows/toggle-issues.yml
---
# .github/workflows/toggle-issues.yaml
name: Toggle Issues

on:
  workflow_dispatch:
    inputs:
      label:
        description: 'toggle issues matching this label'
        required: true
        type: string
        default: 'stored-object'
      perform_close:
        description: 'Close matching open issues'
        required: true
        type: boolean
        default: true
      perform_reopen:
        description: 'Reopen issues closed during the `perform_close` step'
        required: true
        type: boolean
        default: true
      reopen_all_matching:
        description: 'Reopen all labeled issues (not just those closed in this run)'
        required: true
        type: boolean
        default: false

permissions:
  issues: write

jobs:
  toggle-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install fire loguru PyGithub requests rich

      - name: Run issue toggle script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          LABEL: ${{ inputs.label }}
          PERFORM_CLOSE: ${{ inputs.perform_close }}
          PERFORM_REOPEN: ${{ inputs.perform_reopen }}
          REOPEN_ALL_MATCHING: ${{ inputs.reopen_all_matching }}
        run: python scripts/toggle_issues.py



---
File: extension/background.ts
---
// background.ts
// Background script with simplified session tracking

import { GitHubStoreClient } from 'gh-store-client';
import { PaperManager } from './papers/manager';
import { SessionService } from './utils/session-service';
import { PopupManager } from './utils/popup-manager';
import { SourceIntegrationManager } from './source-integration/source-manager';
import { loguru } from './utils/logger';
import { PaperMetadata } from './papers/types';

// Import source plugins directly
import { arxivIntegration } from './source-integration/arxiv';
import { Message } from './source-integration/types';

const logger = loguru.getLogger('background');

// Global state
let githubToken = '';
let githubRepo = '';
let paperManager: PaperManager | null = null;
let sessionService: SessionService | null = null;
let popupManager: PopupManager | null = null;
let sourceManager: SourceIntegrationManager | null = null;

// Initialize sources
function initializeSources() {
  sourceManager = new SourceIntegrationManager();
  
  // Register built-in sources directly
  sourceManager.registerSource(arxivIntegration);
  
  logger.info('Source manager initialized');
  return sourceManager;
}

// Initialize everything
async function initialize() {
  try {
    // Initialize sources first
    initializeSources();
    
    // Load GitHub credentials
    const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);
    githubToken = items.githubToken || '';
    githubRepo = items.githubRepo || '';
    logger.info('Credentials loaded', { hasToken: !!githubToken, hasRepo: !!githubRepo });
    
    // Initialize paper manager if we have credentials
    if (githubToken && githubRepo) {
      const githubClient = new GitHubStoreClient(githubToken, githubRepo);
      
      // Pass the source manager to the paper manager
      paperManager = new PaperManager(githubClient, sourceManager!);
      logger.info('Paper manager initialized');
      
      // Initialize session service with paper manager
      sessionService = new SessionService(paperManager);
    } else {
      // Initialize session service without paper manager
      sessionService = new SessionService(null);
    }
    
    logger.info('Session service initialized');
    
    // Initialize popup manager
    popupManager = new PopupManager(
      () => sourceManager,
      () => paperManager
    );
    logger.info('Popup manager initialized');
    
    // Set up message listeners
    setupMessageListeners();
    
    // Initialize debug objects
    initializeDebugObjects();
  } catch (error) {
    logger.error('Initialization error', error);
  }
}

// Set up message listeners
function setupMessageListeners() {
  chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
    if (message.type === 'contentScriptReady' && sender.tab?.id) {
      logger.debug('Content script ready:', sender.tab.url);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'paperMetadata' && message.metadata) {
      // Store metadata received from content script
      handlePaperMetadata(message.metadata);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'getCurrentPaper') {
      const session = sessionService?.getCurrentSession();
      const paperMetadata = session 
        ? sessionService?.getPaperMetadata(session.sourceId, session.paperId)
        : null;
      
      logger.debug('Popup requested current paper', paperMetadata);
      sendResponse(paperMetadata);
      return true;
    }
    
    if (message.type === 'updateRating') {
      logger.debug('Rating update requested:', message.rating);
      handleUpdateRating(message.rating, sendResponse);
      return true; // Will respond asynchronously
    }
    
    if (message.type === 'startSession') {
      handleStartSession(message.sourceId, message.paperId);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'sessionHeartbeat') {
      handleSessionHeartbeat();
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'endSession') {
      handleEndSession(message.reason || 'user_action');
      sendResponse({ success: true });
      return true;
    }

    // New handler for manual paper logging from popup
    if (message.type === 'manualPaperLog' && message.metadata) {
      handleManualPaperLog(message.metadata)
        .then(() => sendResponse({ success: true }))
        .catch(error => {
          logger.error('Error handling manual paper log', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        });
      return true; // Will respond asynchronously
    }
    
    // Other message handlers are managed by PopupManager
    
    return false; // Not handled
  });
}

// Handle paper metadata from content script
async function handlePaperMetadata(metadata: PaperMetadata) {
  logger.info(`Received metadata for ${metadata.sourceId}:${metadata.paperId}`);
  
  try {
    // Store metadata in session service
    if (sessionService) {
      sessionService.storePaperMetadata(metadata);
    }
    
    // Store in GitHub if we have a paper manager
    if (paperManager) {
      await paperManager.getOrCreatePaper(metadata);
      logger.debug('Paper metadata stored in GitHub');
    }
  } catch (error) {
    logger.error('Error handling paper metadata', error);
  }
}

// Handle rating update
async function handleUpdateRating(rating: string, sendResponse: (response: any) => void) {
  if (!paperManager || !sessionService) {
    sendResponse({ success: false, error: 'Services not initialized' });
    return;
  }

  const session = sessionService.getCurrentSession();
  if (!session) {
    sendResponse({ success: false, error: 'No current session' });
    return;
  }

  const metadata = sessionService.getPaperMetadata();
  if (!metadata) {
    sendResponse({ success: false, error: 'No paper metadata available' });
    return;
  }

  try {
    await paperManager.updateRating(
      session.sourceId,
      session.paperId, 
      rating,
      metadata
    );
    
    // Update stored metadata with new rating
    metadata.rating = rating;
    
    sendResponse({ success: true });
  } catch (error) {
    logger.error('Error updating rating:', error);
    sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });
  }
}

// Handle session start request
function handleStartSession(sourceId: string, paperId: string) {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  // Get metadata if available
  const existingMetadata = sessionService.getPaperMetadata(sourceId, paperId);
  
  // Start the session
  sessionService.startSession(sourceId, paperId, existingMetadata);
  logger.info(`Started session for ${sourceId}:${paperId}`);
}

// Handle session heartbeat
function handleSessionHeartbeat() {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  sessionService.recordHeartbeat();
}

// Handle session end request
function handleEndSession(reason: string) {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  const session = sessionService.getCurrentSession();
  if (session) {
    logger.info(`Ending session: ${reason}`);
    sessionService.endSession();
  }
}

async function handleManualPaperLog(metadata: PaperMetadata): Promise<void> {
  logger.info(`Received manual paper log: ${metadata.sourceId}:${metadata.paperId}`);
  
  try {
    // Store metadata in session service
    if (sessionService) {
      sessionService.storePaperMetadata(metadata);
    }
    
    // Store in GitHub if we have a paper manager
    if (paperManager) {
      await paperManager.getOrCreatePaper(metadata);
      logger.debug('Manually logged paper stored in GitHub');
    }
  } catch (error) {
    logger.error('Error handling manual paper log', error);
    throw error;
  }
}

// Listen for credential changes
chrome.storage.onChanged.addListener(async (changes) => {
  logger.debug('Storage changes detected', Object.keys(changes));
  
  if (changes.githubToken) {
    githubToken = changes.githubToken.newValue;
  }
  if (changes.githubRepo) {
    githubRepo = changes.githubRepo.newValue;
  }
  
  // Reinitialize paper manager if credentials changed
  if (changes.githubToken || changes.githubRepo) {
    if (githubToken && githubRepo) {
      const githubClient = new GitHubStoreClient(githubToken, githubRepo);
      
      // Pass the source manager to the paper manager
      paperManager = new PaperManager(githubClient, sourceManager!);
      logger.info('Paper manager reinitialized');
      
      // Reinitialize session service with new paper manager
      sessionService = new SessionService(paperManager);
      logger.info('Session service reinitialized');
    }
  }
});

// Initialize debug objects in service worker scope
function initializeDebugObjects() {
  // @ts-ignore
  self.__DEBUG__ = {
    get paperManager() { return paperManager; },
    get sessionService() { return sessionService; },
    get popupManager() { return popupManager; },
    get sourceManager() { return sourceManager; },
    getGithubClient: () => paperManager ? paperManager.getClient() : null,
    getCurrentPaper: () => {
      const session = sessionService?.getCurrentSession();
      return session ? sessionService?.getPaperMetadata(session.sourceId, session.paperId) : null;
    },
    getSessionStats: () => sessionService?.getSessionStats(),
    getSources: () => sourceManager?.getAllSources(),
    forceEndSession: () => sessionService?.endSession()
  };

  logger.info('Debug objects registered');
}

// Initialize extension
initialize();



---
File: extension/config/session.ts
---
// config/session.ts
// Session configuration management

import { RawSessionConfig, SessionConfig } from './types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('session-config');

// Default configuration values
export const DEFAULT_CONFIG: RawSessionConfig = {
    idleThresholdMinutes: 5,
    minSessionDurationSeconds: 30,
    requireContinuousActivity: true,  // If true, resets timer on idle
    logPartialSessions: false,        // If true, logs sessions even if under minimum duration
    activityUpdateIntervalSeconds: 1  // How often to update active time
};

/**
 * Load session configuration from storage
 */
export async function loadSessionConfig(): Promise<RawSessionConfig> {
    try {
        const items = await chrome.storage.sync.get('sessionConfig');
        const config = { ...DEFAULT_CONFIG, ...items.sessionConfig };
        logger.debug('Loaded session config', config);
        return config;
    } catch (error) {
        logger.error('Error loading session config', error);
        return DEFAULT_CONFIG;
    }
}

/**
 * Save session configuration to storage
 */
export async function saveSessionConfig(config: RawSessionConfig): Promise<void> {
    try {
        // Ensure values are the correct type
        const sanitizedConfig: RawSessionConfig = {
            idleThresholdMinutes: Number(config.idleThresholdMinutes),
            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),
            requireContinuousActivity: Boolean(config.requireContinuousActivity),
            logPartialSessions: Boolean(config.logPartialSessions),
            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)
        };
        
        await chrome.storage.sync.set({ sessionConfig: sanitizedConfig });
        logger.debug('Saved session config', sanitizedConfig);
    } catch (error) {
        logger.error('Error saving session config', error);
        throw error;
    }
}

/**
 * Convert configuration to milliseconds for internal use
 */
export function getConfigurationInMs(config: RawSessionConfig): SessionConfig {
    return {
        idleThreshold: config.idleThresholdMinutes * 60 * 1000,
        minSessionDuration: config.minSessionDurationSeconds * 1000,
        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,
        requireContinuousActivity: config.requireContinuousActivity,
        logPartialSessions: config.logPartialSessions
    };
}



---
File: extension/config/types.ts
---
// config/types.ts
// Type definitions for configuration

export interface RawSessionConfig {
  // Time in minutes before considering user idle
  idleThresholdMinutes: number;
  
  // Minimum session duration in seconds to log
  minSessionDurationSeconds: number;
  
  // Whether to reset timer on idle
  requireContinuousActivity: boolean;
  
  // Whether to log sessions shorter than minimum duration
  logPartialSessions: boolean;
  
  // How often to update active time in seconds
  activityUpdateIntervalSeconds: number;
}

export interface SessionConfig {
  // Time in milliseconds before considering user idle
  idleThreshold: number;
  
  // Minimum session duration in milliseconds to log
  minSessionDuration: number;
  
  // Whether to reset timer on idle
  requireContinuousActivity: boolean;
  
  // Whether to log sessions shorter than minimum duration
  logPartialSessions: boolean;
  
  // How often to update active time in milliseconds
  activityUpdateInterval: number;
}

export interface StorageConfig {
  // GitHub access token
  githubToken: string;
  
  // GitHub repository (owner/repo)
  githubRepo: string;
  
  // Session tracking configuration
  sessionConfig: RawSessionConfig;
}



---
File: extension/content.ts
---
// content.ts
// Content script with simplified session tracking

import { LinkProcessor } from './source-integration/link-processor';
import { SourceIntegration, Message } from './source-integration/types';
import { PaperMetadata } from './papers/types';
import { loguru } from './utils/logger';
import { BaseSourceIntegration } from './source-integration/base-source';
import { generatePaperIdFromUrl } from './utils/metadata-extractor';

// Import source plugins directly
import { arxivIntegration } from './source-integration/arxiv';
//import { pdfIntegration } from './source-integration/pdf';

const logger = loguru.getLogger('content-script');

logger.info('Paper Tracker content script loaded');

// Available source integrations
const sourceIntegrations: SourceIntegration[] = [
  arxivIntegration,
  //pdfIntegration,
  // Add more sources as they become available
];

// Base source for fallback processing
const baseSource = new BaseSourceIntegration();

// Track active popup
let activePopup: HTMLElement | null = null;

// Heartbeat interval
let heartbeatInterval: number | null = null;
const HEARTBEAT_INTERVAL = 5000; // 5 seconds

// Track tab visibility
let isTabVisible = true;

// Track current session
let currentSession: { sourceId: string; paperId: string } | null = null;

// Create link processor
const linkProcessor = new LinkProcessor((sourceId, paperId, link) => {
  // Callback when link is found
  injectAnnotationButton(link, sourceId, paperId);
});

// Initialize sources
function initializeSources() {
  // Register each source with the link processor
  for (const source of sourceIntegrations) {
    logger.debug(`Initializing source: ${source.id}`);
    
    // Register patterns with link processor
    source.urlPatterns.forEach(pattern => {
      linkProcessor.registerPattern({
        sourceId: source.id,
        pattern,
        extractPaperId: (url: string) => source.extractPaperId(url)
      });
    });
  }
}

// Inject common styles
function injectStyles() {
  if (document.getElementById('paper-tracker-styles')) {
    return; // Already injected
  }
  
  const styles = `
  .paper-annotator {
    display: inline-block;
    margin-left: 4px;
    cursor: pointer;
    font-size: 0.9em;
    opacity: 0.7;
    transition: opacity 0.2s;
    vertical-align: baseline;
  }

  .paper-annotator:hover {
    opacity: 1;
  }

  .paper-popup-wrapper {
    position: fixed;
    z-index: 10000;
  }

  .paper-popup {
    position: relative;
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    width: 300px;
    box-sizing: border-box;
  }

  .paper-popup-header {
    font-weight: bold;
    margin-bottom: 8px;
    line-height: 1.4;
    font-size: 1em;
  }

  .paper-popup-meta {
    color: #666;
    font-size: 0.85em;
    margin-bottom: 12px;
    line-height: 1.4;
  }

  .paper-popup-buttons {
    display: flex;
    gap: 8px;
    margin: 8px 0;
  }

  .paper-popup button {
    padding: 6px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #f5f5f5;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9em;
  }

  .paper-popup button:hover {
    background: #e8e8e8;
    border-color: #ccc;
  }

  .paper-popup button.active {
    background: #e0e0e0;
    border-color: #aaa;
  }

  .paper-popup textarea {
    width: calc(100% - 16px);
    min-height: 80px;
    margin: 8px 0;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: vertical;
    font-family: inherit;
    font-size: 0.9em;
    line-height: 1.4;
    box-sizing: border-box;
  }

  .paper-popup textarea:focus {
    outline: none;
    border-color: #aaa;
  }

  .paper-popup-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 12px;
  }

  .paper-popup .save-button {
    background: #2563eb;
    color: white;
    border-color: #2563eb;
  }

  .paper-popup .save-button:hover {
    background: #1d4ed8;
    border-color: #1d4ed8;
  }
  `;
  
  const styleSheet = document.createElement('style');
  styleSheet.id = 'paper-tracker-styles';
  styleSheet.textContent = styles;
  document.head.appendChild(styleSheet);
  
  logger.debug('Injected styles');
}

// Add annotation button to link
function injectAnnotationButton(link: HTMLAnchorElement, sourceId: string, paperId: string): void {
  // Skip if already processed
  if (link.nextSibling && 
      link.nextSibling.nodeType === Node.ELEMENT_NODE &&
      (link.nextSibling as Element).classList.contains('paper-annotator')) {
    return;
  }
  
  // Create annotator button
  const annotator = document.createElement('span');
  annotator.className = 'paper-annotator';
  annotator.textContent = '📝';
  annotator.title = 'Add annotation';
  
  // Store data attributes
  annotator.dataset.sourceId = sourceId;
  annotator.dataset.paperId = paperId;
  
  // Add click handler
  annotator.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Send message to background script to show popup
    chrome.runtime.sendMessage({
      type: 'showAnnotationPopup',
      sourceId,
      paperId,
      position: {
        x: e.clientX,
        y: e.clientY
      }
    });
  });
  
  // Add to page next to link
  link.parentNode?.insertBefore(annotator, link.nextSibling);
}

// Get source that can handle a URL
function getSourceForUrl(url: string): SourceIntegration | null {
  for (const source of sourceIntegrations) {
    if (source.canHandleUrl(url)) {
      return source;
    }
  }
  return null;
}

// Set up click-outside handler for popups
document.addEventListener('click', (e) => {
  if (activePopup && 
      !activePopup.contains(e.target as Node) && 
      !(e.target as Element).classList.contains('paper-annotator')) {
    activePopup.parentElement?.remove();
    activePopup = null;
  }
});

// Start session tracking
function startSessionTracking(sourceId: string, paperId: string) {
  // Stop any existing heartbeat
  stopHeartbeat();
  
  // Only start tracking if tab is visible
  if (!isTabVisible) {
    logger.debug(`Not starting session for ${sourceId}:${paperId} because tab is not visible`);
    return;
  }
  
  // Update current session
  currentSession = { sourceId, paperId };
  
  // Tell background script to start a new session
  chrome.runtime.sendMessage({
    type: 'startSession',
    sourceId,
    paperId
  }, response => {
    if (response?.success) {
      logger.debug(`Started session for ${sourceId}:${paperId}`);
      
      // Start sending heartbeats
      startHeartbeat();
    } else {
      logger.error(`Failed to start session for ${sourceId}:${paperId}`, response?.error);
    }
  });
}

// Start sending heartbeats to background script
function startHeartbeat() {
  if (!currentSession) return;
  
  // Clear any existing interval
  stopHeartbeat();
  
  // Set new interval
  heartbeatInterval = window.setInterval(() => {
    if (!currentSession) return;
    
    chrome.runtime.sendMessage({
      type: 'sessionHeartbeat',
      sourceId: currentSession.sourceId,
      paperId: currentSession.paperId,
      timestamp: Date.now()
    });
  }, HEARTBEAT_INTERVAL);
  
  logger.debug(`Started heartbeat for ${currentSession.sourceId}:${currentSession.paperId}`);
}

// Stop sending heartbeats
function stopHeartbeat() {
  if (heartbeatInterval !== null) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
    logger.debug('Stopped heartbeat');
  }
}

// End the current session
function endCurrentSession(reason: string) {
  if (!currentSession) return;
  
  const { sourceId, paperId } = currentSession;
  
  // Stop heartbeat
  stopHeartbeat();
  
  // Send end session message
  chrome.runtime.sendMessage({
    type: 'endSession',
    sourceId,
    paperId,
    reason
  }, response => {
    logger.debug(`Ended session for ${sourceId}:${paperId}`, { reason });
  });
  
  // Clear current session
  currentSession = null;
}

// Process the current page
async function processCurrentPage(force: boolean = false): Promise<PaperMetadata | null> {
  const url = window.location.href;
  
  // Find a source that can handle this URL
  let source = getSourceForUrl(url);
  
  // If no source was found and force parameter is set, use base source
  if (!source && force) {
    logger.info(`No matching source found, but force parameter set. Using base source for: ${url}`);
    source = baseSource;
  }

  // If we still don't have a source, return null
  if (!source) {
    logger.debug(`No source found for URL: ${url}`);
    return null;
  }

  // Now that we have a source, extract the paperId
  const paperId = source.extractPaperId(url);
  if (!paperId) {
    logger.info(`Unable to determine a paperId for url: ${url}`);
    return null;
  }
  
  try {
    // Use source-specific extraction
    const metadata = await source.extractMetadata(document, paperId);
    
    if (metadata) {
      // Send metadata to background script
      chrome.runtime.sendMessage({
        type: 'paperMetadata',
        metadata
      });
      
      logger.debug(`Sent extracted metadata to background script for ${metadata.sourceId}:${metadata.paperId}`);
      
      // Start session tracking if tab is visible
      if (isTabVisible) {
        startSessionTracking(metadata.sourceId, metadata.paperId);
      }
      
      return metadata;
    }
  } catch (error) {
    logger.error(`Error extracting metadata for ${source.id}:${paperId}`, error);
  }
  
  return null;
}

// Visibility change listener
document.addEventListener('visibilitychange', () => {
  const wasVisible = isTabVisible;
  isTabVisible = document.visibilityState === 'visible';
  
  if (isTabVisible && !wasVisible) {
    // Tab has become visible again - restart session
    logger.info('Tab became visible again');
    
    // If we have a current session, restart it
    if (currentSession) {
      startSessionTracking(currentSession.sourceId, currentSession.paperId);
    } else {
      // Otherwise, try to process the page
      processCurrentPage();
    }
  } else if (!isTabVisible && wasVisible) {
    // Tab has become hidden - end current session
    logger.info('Tab hidden');
    if (currentSession) {
      endCurrentSession('tab_hidden');
    }
  }
});

// Focus/blur listeners
window.addEventListener('focus', () => {
  if (!isTabVisible) return; // Don't restart if tab is hidden
  
  logger.info('Window gained focus');
  
  // If we have a current session, restart it
  if (currentSession) {
    startSessionTracking(currentSession.sourceId, currentSession.paperId);
  } else {
    // Otherwise, try to process the page
    processCurrentPage();
  }
});

window.addEventListener('blur', () => {
  logger.info('Window lost focus');
  
  // End the current session
  if (currentSession) {
    endCurrentSession('window_blur');
  }
});

// Inform background when page is unloaded
window.addEventListener('beforeunload', () => {
  if (currentSession) {
    logger.info('Page unloading');
    endCurrentSession('page_unload');
  }
});

// Message handler for background script
chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
  logger.debug('Received message', message);

  if (message.type === 'extractPaperMetadata') {
    logger.debug('Received request to force paper metadata extraction');
    
    // Use processCurrentPage with force=true to enable fallback extraction
    processCurrentPage(true)
      .then(metadata => {
        if (metadata) {
          sendResponse({ success: true, metadata });
        } else {
          sendResponse({ success: false, error: 'Failed to extract metadata' });
        }
      })
      .catch(error => {
        logger.error('Error extracting metadata', error);
        sendResponse({ 
          success: false, 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      });
    return true; // Will respond asynchronously
  }
  
  if (message.type === 'showPopup') {
    // Remove existing popup
    if (activePopup) {
      activePopup.parentElement?.remove();
      activePopup = null;
    }
    
    // Create popup wrapper
    const wrapper = document.createElement('div');
    wrapper.className = 'paper-popup-wrapper';
    
    // Position near click or element
    if (message.position) {
      wrapper.style.left = `${message.position.x}px`;
      wrapper.style.top = `${message.position.y}px`;
    }
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'paper-popup';
    popup.innerHTML = message.html;
    
    // Add to page
    wrapper.appendChild(popup);
    document.body.appendChild(wrapper);
    
    // Set up event handlers
    if (message.handlers) {
      for (const handler of message.handlers) {
        const elements = popup.querySelectorAll(handler.selector);
        elements.forEach(element => {
          element.addEventListener(handler.event, () => {
            chrome.runtime.sendMessage({
              type: 'popupAction',
              action: handler.action,
              sourceId: message.sourceId,
              paperId: message.paperId,
              data: {
                value: element.tagName === 'TEXTAREA' ? 
                  (element as HTMLTextAreaElement).value : 
                  (element as HTMLElement).getAttribute('data-vote'),
                checked: element.tagName === 'INPUT' ? 
                  (element as HTMLInputElement).checked : undefined,
                id: (element as HTMLElement).id
              }
            });
          });
        });
      }
    }
    
    // Save reference
    activePopup = popup;
    
    sendResponse({ success: true });
    return true;
  }
  
  if (message.type === 'processPage') {
    // Re-process the entire page
    linkProcessor.processLinks(document);
    processCurrentPage();
    sendResponse({ success: true });
    return true;
  }
});

// Initialize
(async function initialize() {
  // Inject styles
  injectStyles();
  
  // Initialize sources
  initializeSources();
  
  // Process links
  linkProcessor.processLinks(document);
  
  // Start observing for new links
  linkProcessor.startObserving(document);
  
  // Set initial tab visibility
  isTabVisible = document.visibilityState === 'visible';
  
  // Process current page
  processCurrentPage();
  
  // Tell background script we're ready and what page we're on
  chrome.runtime.sendMessage(
    { 
      type: 'contentScriptReady', 
      url: window.location.href 
    },
    (response) => {
      if (response?.success) {
        logger.debug('Background script acknowledged ready status');
      }
    }
  );
})();

// Set up observer for URL changes (single page apps)
let lastUrl = location.href;
new MutationObserver(() => {
  const url = location.href;
  if (url !== lastUrl) {
    // End any current session
    if (currentSession) {
      endCurrentSession('url_change');
    }
    
    // Update URL and process new page
    lastUrl = url;
    processCurrentPage();
  }
}).observe(document, { subtree: true, childList: true });



---
File: extension/dist/background.bundle.js
---
var d=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[];}get(e){let s=this.cache.get(e);if(s){if(Date.now()-s.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return s.lastAccessed=Date.now(),this.updateAccessOrder(e),s.issueNumber}}set(e,s,t){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let r=this.accessOrder[this.accessOrder.length-1];r&&(this.cache.delete(r),this.removeFromAccessOrder(r));}this.cache.set(e,{issueNumber:s,lastAccessed:Date.now(),createdAt:t.createdAt,updatedAt:t.updatedAt}),this.updateAccessOrder(e);}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e);}clear(){this.cache.clear(),this.accessOrder=[];}getStats(){return {size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,s){let t=this.cache.get(e);return t?s>t.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e);}removeFromAccessOrder(e){let s=this.accessOrder.indexOf(e);s>-1&&this.accessOrder.splice(s,1);}};var l="0.3.2";var f=class{constructor(e,s,t={}){this.token=e,this.repo=s,this.config={baseLabel:t.baseLabel??"stored-object",uidPrefix:t.uidPrefix??"UID:",reactions:{processed:t.reactions?.processed??"+1",initialState:t.reactions?.initialState??"rocket"}},this.cache=new d(t.cache);}async fetchFromGitHub(e,s={}){let t=new URL(`https://api.github.com/repos/${this.repo}${e}`);s.params&&(Object.entries(s.params).forEach(([i,a])=>{t.searchParams.append(i,a);}),delete s.params);let r=await fetch(t.toString(),{...s,headers:{Authorization:`token ${this.token}`,Accept:"application/vnd.github.v3+json",...s.headers}});if(!r.ok)throw new Error(`GitHub API error: ${r.status}`);return r.json()}createCommentPayload(e,s){let t={_data:e,_meta:{client_version:l,timestamp:new Date().toISOString(),update_mode:"append"}};return s&&(t.type=s),t}async getObject(e){let s=this.cache.get(e),t;if(s)try{t=await this.fetchFromGitHub(`/issues/${s}`),this._verifyIssueLabels(t,e)||(this.cache.remove(e),t=void 0);}catch{this.cache.remove(e);}if(!t){let c=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"closed"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);t=c[0];}if(!t?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let r=JSON.parse(t.body),i=new Date(t.created_at),a=new Date(t.updated_at);return this.cache.set(e,t.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:i,updatedAt:a,version:await this._getVersion(t.number)},data:r}}async createObject(e,s){let t=`${this.config.uidPrefix}${e}`,r=await this.fetchFromGitHub("/issues",{method:"POST",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(s,null,2),labels:[this.config.baseLabel,t]})});this.cache.set(e,r.number,{createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at)});let i=this.createCommentPayload(s,"initial_state"),a=await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(i,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:"PATCH",body:JSON.stringify({state:"closed"})}),{meta:{objectId:e,label:t,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:1},data:s}}_verifyIssueLabels(e,s){let t=new Set([this.config.baseLabel,`${this.config.uidPrefix}${s}`]);return e.labels.some(r=>t.has(r.name))}async updateObject(e,s){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],i=this.createCommentPayload(s);return await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:"PATCH",body:JSON.stringify({state:"open"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed"}}),s={};for(let t of e)if(!t.labels.some(r=>r.name==="archived"))try{let r=this._getObjectIdFromLabels(t),i=JSON.parse(t.body),a={objectId:r,label:r,createdAt:new Date(t.created_at),updatedAt:new Date(t.updated_at),version:await this._getVersion(t.number)};s[r]={meta:a,data:i};}catch{continue}return s}async listUpdatedSince(e){let s=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed",since:e.toISOString()}}),t={};for(let r of s)if(!r.labels.some(i=>i.name==="archived"))try{let i=this._getObjectIdFromLabels(r),a=JSON.parse(r.body),n=new Date(r.updated_at);if(n>e){let c={objectId:i,label:i,createdAt:new Date(r.created_at),updatedAt:n,version:await this._getVersion(r.number)};t[i]={meta:c,data:a};}}catch{continue}return t}async getObjectHistory(e){let s=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!s||s.length===0)throw new Error(`No object found with ID: ${e}`);let t=s[0],r=await this.fetchFromGitHub(`/issues/${t.number}/comments`),i=[];for(let a of r)try{let n=JSON.parse(a.body),c="update",m,b={client_version:"legacy",timestamp:a.created_at,update_mode:"append"};typeof n=="object"?"_data"in n?(c=n.type||"update",m=n._data,b=n._meta||b):"type"in n&&n.type==="initial_state"?(c="initial_state",m=n.data):m=n:m=n,i.push({timestamp:a.created_at,type:c,data:m,commentId:a.id});}catch{continue}return i}async _getVersion(e){return (await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let s of e.labels)if(s.name!==this.config.baseLabel&&s.name.startsWith(this.config.uidPrefix))return s.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};

// extension/papers/types.ts
// Updated for heartbeat-based session tracking
/**
 * Type guard for interaction log
 */
function isInteractionLog(data) {
    const log = data;
    return (typeof log === 'object' &&
        log !== null &&
        typeof log.sourceId === 'string' &&
        typeof log.paperId === 'string' &&
        Array.isArray(log.interactions));
}

// utils/logger.ts
// Logging utility wrapping loguru
/**
 * Logger class for consistent logging throughout the extension
 */
class Logger {
    constructor(module) {
        this.module = module;
    }
    /**
     * Log debug message
     */
    debug(message, data) {
        console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log info message
     */
    info(message, data) {
        console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log warning message
     */
    warning(message, data) {
        console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log error message
     */
    error(message, data) {
        console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
}
/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
    /**
     * Get logger for a module
     */
    getLogger(module) {
        return new Logger(module);
    }
}
// Export singleton instance
const loguru = new LoguruMock();

const logger$7 = loguru.getLogger('paper-manager');
class PaperManager {
    constructor(client, sourceManager) {
        this.client = client;
        this.sourceManager = sourceManager;
        logger$7.debug('Paper manager initialized');
    }
    /**
     * Get paper by source and ID
     */
    async getPaper(sourceId, paperId) {
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            return obj.data;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                return null;
            }
            throw error;
        }
    }
    /**
     * Get or create paper metadata
     */
    async getOrCreatePaper(paperData) {
        const { sourceId, paperId } = paperData;
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            const data = obj.data;
            logger$7.debug(`Retrieved existing paper: ${paperIdentifier}`);
            return data;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                // Create new paper
                const defaultPaperData = {
                    ...paperData,
                    timestamp: new Date().toISOString(),
                    rating: paperData.rating || 'novote'
                };
                await this.client.createObject(objectId, defaultPaperData);
                logger$7.debug(`Created new paper: ${paperIdentifier}`);
                return defaultPaperData;
            }
            throw error;
        }
    }
    /**
     * Get or create interaction log for a paper
     */
    async getOrCreateInteractionLog(sourceId, paperId) {
        const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            const data = obj.data;
            if (isInteractionLog(data)) {
                return data;
            }
            throw new Error('Invalid interaction log format');
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                const newLog = {
                    sourceId,
                    paperId,
                    interactions: []
                };
                await this.client.createObject(objectId, newLog);
                logger$7.debug(`Created new interaction log: ${paperIdentifier}`);
                return newLog;
            }
            throw error;
        }
    }
    /**
     * Get GitHub client instance
     */
    getClient() {
        return this.client;
    }
    /**
     * Log a reading session
     */
    async logReadingSession(sourceId, paperId, session, paperData) {
        // Ensure paper exists
        if (paperData) {
            await this.getOrCreatePaper({
                sourceId,
                paperId,
                url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
                title: paperData.title || paperId,
                authors: paperData.authors || '',
                abstract: paperData.abstract || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: paperData.publishedDate || '',
                tags: paperData.tags || []
            });
        }
        // Log the session as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'reading_session',
            timestamp: new Date().toISOString(),
            data: session
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Logged reading session for ${paperIdentifier}`, { duration: session.duration_seconds });
    }
    /**
     * Log an annotation
     */
    async logAnnotation(sourceId, paperId, key, value, paperData) {
        // Ensure paper exists
        if (paperData) {
            await this.getOrCreatePaper({
                sourceId,
                paperId,
                url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
                title: paperData.title || paperId,
                authors: paperData.authors || '',
                abstract: paperData.abstract || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: paperData.publishedDate || '',
                tags: paperData.tags || []
            });
        }
        // Log the annotation as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'annotation',
            timestamp: new Date().toISOString(),
            data: { key, value }
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Logged annotation for ${paperIdentifier}`, { key });
    }
    /**
     * Update paper rating
     */
    async updateRating(sourceId, paperId, rating, paperData) {
        // Ensure paper exists and get current data
        const paper = await this.getOrCreatePaper({
            sourceId,
            paperId,
            url: paperData?.url || this.sourceManager.formatPaperId(sourceId, paperId),
            title: paperData?.title || paperId,
            authors: paperData?.authors || '',
            abstract: paperData?.abstract || '',
            timestamp: new Date().toISOString(),
            rating: 'novote',
            publishedDate: paperData?.publishedDate || '',
            tags: paperData?.tags || []
        });
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        // Update paper metadata with new rating
        await this.client.updateObject(objectId, {
            ...paper,
            rating
        });
        // Log rating change as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'rating',
            timestamp: new Date().toISOString(),
            data: { rating }
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Updated rating for ${paperIdentifier} to ${rating}`);
    }
    /**
     * Add interaction to log
     */
    async addInteraction(sourceId, paperId, interaction) {
        const log = await this.getOrCreateInteractionLog(sourceId, paperId);
        log.interactions.push(interaction);
        const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
        await this.client.updateObject(objectId, log);
    }
}

// session-service.ts
const logger$6 = loguru.getLogger('session-service');
/**
 * Session tracking service for paper reading sessions
 *
 * Manages session state, heartbeats, and persistence
 * Designed for use in the background script (Service Worker)
 */
class SessionService {
    /**
     * Create a new session service
     */
    constructor(paperManager) {
        this.paperManager = paperManager;
        this.activeSession = null;
        this.timeoutId = null;
        this.paperMetadata = new Map();
        // Configuration
        this.HEARTBEAT_TIMEOUT = 15000; // 15 seconds
        logger$6.debug('Session service initialized');
    }
    /**
     * Start a new session for a paper
     */
    startSession(sourceId, paperId, metadata) {
        // End any existing session
        this.endSession();
        // Create new session
        this.activeSession = {
            sourceId,
            paperId,
            startTime: new Date(),
            heartbeatCount: 0,
            lastHeartbeatTime: new Date()
        };
        // Store metadata if provided
        if (metadata) {
            const key = `${sourceId}:${paperId}`;
            this.paperMetadata.set(key, metadata);
            logger$6.debug(`Stored metadata for ${key}`);
        }
        // Start timeout check
        this.scheduleTimeoutCheck();
        logger$6.info(`Started session for ${sourceId}:${paperId}`);
    }
    /**
     * Record a heartbeat for the current session
     */
    recordHeartbeat() {
        if (!this.activeSession) {
            return false;
        }
        this.activeSession.heartbeatCount++;
        this.activeSession.lastHeartbeatTime = new Date();
        // Reschedule timeout
        this.scheduleTimeoutCheck();
        if (this.activeSession.heartbeatCount % 12 === 0) { // Log every minute (12 x 5sec heartbeats)
            logger$6.debug(`Session received ${this.activeSession.heartbeatCount} heartbeats`);
        }
        return true;
    }
    /**
     * Schedule a check for heartbeat timeout
     */
    scheduleTimeoutCheck() {
        // Clear existing timeout
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
        }
        // Set new timeout
        this.timeoutId = self.setTimeout(() => {
            this.checkTimeout();
        }, this.HEARTBEAT_TIMEOUT);
    }
    /**
     * Check if the session has timed out due to missing heartbeats
     */
    checkTimeout() {
        if (!this.activeSession)
            return;
        const now = Date.now();
        const lastTime = this.activeSession.lastHeartbeatTime.getTime();
        if ((now - lastTime) > this.HEARTBEAT_TIMEOUT) {
            logger$6.info('Session timeout detected');
            this.endSession();
        }
        else {
            this.scheduleTimeoutCheck();
        }
    }
    /**
     * End the current session and get the data
     */
    endSession() {
        if (!this.activeSession)
            return null;
        // Clear timeout
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        const { sourceId, paperId, startTime, heartbeatCount } = this.activeSession;
        const endTime = new Date();
        // Calculate duration (5 seconds per heartbeat)
        const duration = heartbeatCount * 5;
        // Calculate total elapsed time
        const totalElapsed = endTime.getTime() - startTime.getTime();
        const totalElapsedSeconds = Math.round(totalElapsed / 1000);
        // Set idle seconds to the difference (for backward compatibility)
        const idleSeconds = Math.max(0, totalElapsedSeconds - duration);
        // Create session data
        const sessionData = {
            session_id: `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            source_id: sourceId,
            paper_id: paperId,
            start_time: startTime.toISOString(),
            end_time: endTime.toISOString(),
            heartbeat_count: heartbeatCount,
            duration_seconds: duration,
            // Legacy fields
            idle_seconds: idleSeconds,
            total_elapsed_seconds: totalElapsedSeconds
        };
        // Store session if it was meaningful and we have a paper manager
        if (this.paperManager && heartbeatCount > 0) {
            const metadata = this.getPaperMetadata(sourceId, paperId);
            this.paperManager.logReadingSession(sourceId, paperId, sessionData, metadata)
                .catch(err => logger$6.error('Failed to store session', err));
        }
        logger$6.info(`Ended session for ${sourceId}:${paperId}`, {
            duration,
            heartbeats: heartbeatCount
        });
        // Clear active session
        this.activeSession = null;
        return sessionData;
    }
    /**
     * Check if a session is currently active
     */
    hasActiveSession() {
        return this.activeSession !== null;
    }
    /**
     * Get information about the current session
     */
    getCurrentSession() {
        if (!this.activeSession)
            return null;
        return {
            sourceId: this.activeSession.sourceId,
            paperId: this.activeSession.paperId
        };
    }
    /**
     * Get paper metadata for the current or specified session
     */
    getPaperMetadata(sourceId, paperId) {
        if (!sourceId || !paperId) {
            if (!this.activeSession)
                return undefined;
            sourceId = this.activeSession.sourceId;
            paperId = this.activeSession.paperId;
        }
        return this.paperMetadata.get(`${sourceId}:${paperId}`);
    }
    /**
     * Store paper metadata
     */
    storePaperMetadata(metadata) {
        const key = `${metadata.sourceId}:${metadata.paperId}`;
        this.paperMetadata.set(key, metadata);
    }
    /**
     * Get time since last heartbeat in milliseconds
     */
    getTimeSinceLastHeartbeat() {
        if (!this.activeSession) {
            return null;
        }
        return Date.now() - this.activeSession.lastHeartbeatTime.getTime();
    }
    /**
     * Get session statistics for debugging
     */
    getSessionStats() {
        if (!this.activeSession) {
            return { active: false };
        }
        return {
            active: true,
            sourceId: this.activeSession.sourceId,
            paperId: this.activeSession.paperId,
            startTime: this.activeSession.startTime.toISOString(),
            heartbeatCount: this.activeSession.heartbeatCount,
            lastHeartbeatTime: this.activeSession.lastHeartbeatTime.toISOString(),
            elapsedTime: Math.round((Date.now() - this.activeSession.startTime.getTime()) / 1000)
        };
    }
}

// extension/utils/popup-manager.ts
const logger$5 = loguru.getLogger('popup-manager');
/**
 * Manages all popup-related functionality
 */
class PopupManager {
    /**
     * Create a new popup manager
     */
    constructor(sourceManagerProvider, paperManagerProvider) {
        this.sourceManagerProvider = sourceManagerProvider;
        this.paperManagerProvider = paperManagerProvider;
        this.setupMessageListeners();
        logger$5.debug('Popup manager initialized');
    }
    /**
     * Set up message listeners for popup-related messages
     */
    setupMessageListeners() {
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            // Handle popup actions (ratings, notes, etc.)
            if (message.type === 'popupAction') {
                this.handlePopupAction(message.sourceId, message.paperId, message.action, message.data).then(() => {
                    sendResponse({ success: true });
                }).catch(error => {
                    logger$5.error('Error handling popup action', error);
                    sendResponse({
                        success: false,
                        error: error instanceof Error ? error.message : 'Unknown error'
                    });
                });
                return true; // Will respond asynchronously
            }
            // Handle request to show annotation popup
            if (message.type === 'showAnnotationPopup' && sender.tab?.id) {
                this.handleShowAnnotationPopup(sender.tab.id, message.sourceId, message.paperId, message.position).then(() => {
                    sendResponse({ success: true });
                }).catch(error => {
                    logger$5.error('Error showing popup', error);
                    sendResponse({
                        success: false,
                        error: error instanceof Error ? error.message : 'Unknown error'
                    });
                });
                return true; // Will respond asynchronously
            }
            return false; // Not handled
        });
    }
    /**
     * Handle a request to show an annotation popup
     */
    async handleShowAnnotationPopup(tabId, sourceId, paperId, position) {
        logger$5.debug(`Showing annotation popup for ${sourceId}:${paperId}`);
        // Check if we have source and paper manager
        const sourceManager = this.sourceManagerProvider();
        const paperManager = this.paperManagerProvider();
        if (!sourceManager) {
            throw new Error('Source manager not initialized');
        }
        if (!paperManager) {
            throw new Error('Paper manager not initialized');
        }
        try {
            // Get paper data
            const paper = await paperManager.getPaper(sourceId, paperId);
            // Create popup HTML
            const html = this.createPopupHtml(paper || {
                sourceId,
                paperId,
                title: paperId,
                authors: '',
                abstract: '',
                url: '',
                timestamp: new Date().toISOString(),
                publishedDate: '',
                tags: [],
                rating: 'novote'
            });
            // Get handlers
            const handlers = this.getStandardPopupHandlers();
            // Send message to content script to show popup
            const message = {
                type: 'showPopup',
                sourceId,
                paperId,
                html,
                handlers,
                position
            };
            await chrome.tabs.sendMessage(tabId, message);
            logger$5.debug(`Sent popup to content script for ${sourceId}:${paperId}`);
        }
        catch (error) {
            logger$5.error(`Error showing popup for ${sourceId}:${paperId}`, error);
            throw error;
        }
    }
    /**
     * Handle popup actions (ratings, notes, etc.)
     */
    async handlePopupAction(sourceId, paperId, action, data) {
        const paperManager = this.paperManagerProvider();
        if (!paperManager) {
            throw new Error('Paper manager not initialized');
        }
        logger$5.debug(`Handling popup action: ${action}`, { sourceId, paperId });
        try {
            if (action === 'rate') {
                await paperManager.updateRating(sourceId, paperId, data.value);
                logger$5.info(`Updated rating for ${sourceId}:${paperId} to ${data.value}`);
            }
            else if (action === 'saveNotes') {
                if (data.value) {
                    await paperManager.logAnnotation(sourceId, paperId, 'notes', data.value);
                    logger$5.info(`Saved notes for ${sourceId}:${paperId}`);
                }
            }
        }
        catch (error) {
            logger$5.error(`Error handling action ${action} for ${sourceId}:${paperId}`, error);
            throw error;
        }
    }
    /**
     * Create HTML for paper popup
     */
    createPopupHtml(paper) {
        return `
      <div class="paper-popup-header">${paper.title || paper.paperId}</div>
      <div class="paper-popup-meta">${paper.authors || ''}</div>
      
      <div class="paper-popup-buttons">
        <button class="vote-button" data-vote="thumbsup" id="btn-thumbsup" ${paper.rating === 'thumbsup' ? 'class="active"' : ''}>👍 Interesting</button>
        <button class="vote-button" data-vote="thumbsdown" id="btn-thumbsdown" ${paper.rating === 'thumbsdown' ? 'class="active"' : ''}>👎 Not Relevant</button>
      </div>
      
      <textarea placeholder="Add notes about this paper..." id="paper-notes"></textarea>
      
      <div class="paper-popup-actions">
        <button class="save-button" id="btn-save">Save</button>
      </div>
    `;
    }
    /**
     * Get standard popup event handlers
     */
    getStandardPopupHandlers() {
        return [
            { selector: '#btn-thumbsup', event: 'click', action: 'rate' },
            { selector: '#btn-thumbsdown', event: 'click', action: 'rate' },
            { selector: '#btn-save', event: 'click', action: 'saveNotes' }
        ];
    }
}

// extension/source-integration/source-manager.ts
const logger$4 = loguru.getLogger('source-manager');
/**
 * Manages source integrations
 */
class SourceIntegrationManager {
    constructor() {
        this.sources = new Map();
        logger$4.info('Source integration manager initialized');
    }
    /**
     * Register a source integration
     */
    registerSource(source) {
        if (this.sources.has(source.id)) {
            logger$4.warning(`Source with ID '${source.id}' already registered, overwriting`);
        }
        this.sources.set(source.id, source);
        logger$4.info(`Registered source: ${source.name} (${source.id})`);
    }
    /**
     * Get all registered sources
     */
    getAllSources() {
        return Array.from(this.sources.values());
    }
    /**
     * Get source that can handle a URL
     */
    getSourceForUrl(url) {
        for (const source of this.sources.values()) {
            if (source.canHandleUrl(url)) {
                logger$4.debug(`Found source for URL '${url}': ${source.id}`);
                return source;
            }
        }
        logger$4.debug(`No source found for URL: ${url}`);
        return null;
    }
    /**
     * Get source by ID
     */
    getSourceById(sourceId) {
        const source = this.sources.get(sourceId);
        return source || null;
    }
    /**
     * Extract paper ID from URL using appropriate source
     */
    extractPaperId(url) {
        for (const source of this.sources.values()) {
            if (source.canHandleUrl(url)) {
                const paperId = source.extractPaperId(url);
                if (paperId) {
                    logger$4.debug(`Extracted paper ID '${paperId}' from URL using ${source.id}`);
                    return { sourceId: source.id, paperId };
                }
            }
        }
        logger$4.debug(`Could not extract paper ID from URL: ${url}`);
        return null;
    }
    /**
     * Format a paper identifier using the appropriate source
     */
    formatPaperId(sourceId, paperId) {
        const source = this.sources.get(sourceId);
        if (source) {
            return source.formatPaperId(paperId);
        }
        // Fallback if source not found
        logger$4.warning(`Source '${sourceId}' not found, using default format for paper ID`);
        return `${sourceId}.${paperId}`;
    }
    /**
     * Format an object ID using the appropriate source
     */
    formatObjectId(type, sourceId, paperId) {
        const source = this.sources.get(sourceId);
        if (source) {
            return source.formatObjectId(type, paperId);
        }
        // Fallback if source not found
        logger$4.warning(`Source '${sourceId}' not found, using default format for object ID`);
        return `${type}:${sourceId}.${paperId}`;
    }
    /**
     * Get all content script match patterns
     */
    getAllContentScriptMatches() {
        const patterns = [];
        for (const source of this.sources.values()) {
            patterns.push(...source.contentScriptMatches);
        }
        return patterns;
    }
}

// extension/utils/metadata-extractor.ts
const logger$3 = loguru.getLogger('metadata-extractor');
// Constants for standard source types
const SOURCE_TYPES = {
    PDF: 'pdf',
    URL: 'url',
};
/**
 * Base class for metadata extraction with customizable extraction methods
 * Each method can be overridden to provide source-specific extraction
 */
class MetadataExtractor {
    /**
     * Create a new metadata extractor for a document
     */
    constructor(document) {
        this.document = document;
        this.url = document.location.href;
        logger$3.debug('Initialized metadata extractor for:', this.url);
    }
    /**
     * Helper method to get content from meta tags
     */
    getMetaContent(selector) {
        const element = this.document.querySelector(selector);
        return element ? element.getAttribute('content') || '' : '';
    }
    /**
     * Extract and return all metadata fields
     */
    extract() {
        logger$3.debug('Extracting metadata from page:', this.url);
        const metadata = {
            title: this.extractTitle(),
            authors: this.extractAuthors(),
            description: this.extractDescription(),
            publishedDate: this.extractPublishedDate(),
            doi: this.extractDoi(),
            journalName: this.extractJournalName(),
            tags: this.extractTags(),
            url: this.url
        };
        logger$3.debug('Metadata extraction complete:', metadata);
        return metadata;
    }
    /**
     * Extract title from document
     * Considers multiple metadata standards with priority order
     */
    extractTitle() {
        // Title extraction - priority order
        return (
        // Dublin Core
        this.getMetaContent('meta[name="DC.Title"]') ||
            // Citation
            this.getMetaContent('meta[name="citation_title"]') ||
            // Open Graph
            this.getMetaContent('meta[property="og:title"]') ||
            // Standard meta
            this.getMetaContent('meta[name="title"]') ||
            // Fallback to document title
            this.document.title);
    }
    /**
     * Extract authors from document
     * Handles multiple author formats and sources
     */
    extractAuthors() {
        // Get all citation authors (some pages have multiple citation_author tags)
        const citationAuthors = [];
        this.document.querySelectorAll('meta[name="citation_author"]').forEach(el => {
            const content = el.getAttribute('content');
            if (content)
                citationAuthors.push(content);
        });
        // Get all DC creators
        const dcCreators = [];
        this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach(el => {
            const content = el.getAttribute('content');
            if (content)
                dcCreators.push(content);
        });
        // Individual author elements
        const dcCreator = this.getMetaContent('meta[name="DC.Creator.PersonalName"]');
        const citationAuthor = this.getMetaContent('meta[name="citation_author"]');
        const ogAuthor = this.getMetaContent('meta[property="og:article:author"]') ||
            this.getMetaContent('meta[name="author"]');
        // Set authors with priority
        if (dcCreators.length > 0) {
            return dcCreators.join(', ');
        }
        else if (citationAuthors.length > 0) {
            return citationAuthors.join(', ');
        }
        else if (dcCreator) {
            return dcCreator;
        }
        else if (citationAuthor) {
            return citationAuthor;
        }
        else if (ogAuthor) {
            return ogAuthor;
        }
        return '';
    }
    /**
     * Extract description/abstract from document
     */
    extractDescription() {
        return (this.getMetaContent('meta[name="DC.Description"]') ||
            this.getMetaContent('meta[name="citation_abstract"]') ||
            this.getMetaContent('meta[property="og:description"]') ||
            this.getMetaContent('meta[name="description"]'));
    }
    /**
     * Extract publication date from document
     */
    extractPublishedDate() {
        return (this.getMetaContent('meta[name="DC.Date.issued"]') ||
            this.getMetaContent('meta[name="citation_date"]') ||
            this.getMetaContent('meta[property="article:published_time"]'));
    }
    /**
     * Extract DOI (Digital Object Identifier) from document
     */
    extractDoi() {
        return (this.getMetaContent('meta[name="DC.Identifier.DOI"]') ||
            this.getMetaContent('meta[name="citation_doi"]'));
    }
    /**
     * Extract journal name from document
     */
    extractJournalName() {
        return (this.getMetaContent('meta[name="DC.Source"]') ||
            this.getMetaContent('meta[name="citation_journal_title"]'));
    }
    /**
     * Extract keywords/tags from document
     */
    extractTags() {
        const keywords = this.getMetaContent('meta[name="keywords"]') ||
            this.getMetaContent('meta[name="DC.Subject"]');
        if (keywords) {
            return keywords.split(',').map(tag => tag.trim());
        }
        return [];
    }
    /**
     * Determine if the current URL is a PDF
     */
    isPdf() {
        return isPdfUrl(this.url);
    }
    /**
     * Get the source type (PDF or URL)
     */
    getSourceType() {
        return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;
    }
    /**
     * Generate a paper ID for the current URL
     */
    generatePaperId() {
        return generatePaperIdFromUrl(this.url);
    }
}
/**
 * Create a common metadata extractor for a document
 * Factory function for creating the default extractor
 */
function createMetadataExtractor(document) {
    return new MetadataExtractor(document);
}
/**
 * Generate a paper ID from a URL
 * Creates a consistent hash-based identifier
 */
function generatePaperIdFromUrl(url) {
    // Use a basic hash function to create an ID from the URL
    let hash = 0;
    for (let i = 0; i < url.length; i++) {
        const char = url.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    // Create a positive hexadecimal string
    const positiveHash = Math.abs(hash).toString(16).toUpperCase();
    // Use the first 8 characters as the ID
    return positiveHash.substring(0, 8);
}
/**
 * Determine if a URL is a PDF
 */
function isPdfUrl(url) {
    return url.toLowerCase().endsWith('.pdf');
}

// extension/source-integration/base-source.ts
const logger$2 = loguru.getLogger('base-source');
/**
 * Base class for source integrations
 * Provides default implementations for all methods
 * Specific sources can override as needed
 */
class BaseSourceIntegration {
    constructor() {
        // Default properties - set for generic web pages
        this.id = 'url';
        this.name = 'Web Page';
        this.urlPatterns = [
            /^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i // Match HTTP/HTTPS URLs that aren't PDFs
        ];
        this.contentScriptMatches = [];
    }
    /**
     * Check if this integration can handle the given URL
     * Default implementation checks against urlPatterns
     */
    canHandleUrl(url) {
        return this.urlPatterns.some(pattern => pattern.test(url));
    }
    /**
     * Extract paper ID from URL
     * Default implementation creates a hash from the URL
     */
    extractPaperId(url) {
        return generatePaperIdFromUrl(url);
    }
    /**
     * Create a metadata extractor for the given document
     * Override this method to provide a custom extractor for your source
     */
    createMetadataExtractor(document) {
        return createMetadataExtractor(document);
    }
    /**
     * Extract metadata from a page
     * Default implementation uses common metadata extraction
     */
    async extractMetadata(document, paperId) {
        try {
            logger$2.debug(`Extracting metadata using base extractor for ID: ${paperId}`);
            // Create a metadata extractor for this document
            const extractor = this.createMetadataExtractor(document);
            // Extract metadata
            const extracted = extractor.extract();
            const url = document.location.href;
            // Determine source type (PDF or URL)
            const sourceType = extractor.getSourceType();
            // Create PaperMetadata object
            return {
                sourceId: this.id,
                //paperId: this.formatPaperId(paperId),
                paperId: paperId,
                url: url,
                title: extracted.title || document.title || paperId,
                authors: extracted.authors || '',
                abstract: extracted.description || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: extracted.publishedDate || '',
                tags: extracted.tags || [],
                doi: extracted.doi,
                journalName: extracted.journalName,
                sourceType: sourceType // Store the source type for reference
            };
        }
        catch (error) {
            logger$2.error('Error extracting metadata with base extractor', error);
            return null;
        }
    }
    /**
     * Format a paper identifier for this source
     * Default implementation uses the format: sourceId.paperId
     */
    formatPaperId(paperId) {
        return `${this.id}.${paperId}`;
    }
    /**
     * Parse a paper identifier specific to this source
     * Default implementation handles source.paperId format and extracts paperId
     */
    parsePaperId(identifier) {
        const prefix = `${this.id}.`;
        if (identifier.startsWith(prefix)) {
            return identifier.substring(prefix.length);
        }
        // Try legacy format (sourceId:paperId)
        const legacyPrefix = `${this.id}:`;
        if (identifier.startsWith(legacyPrefix)) {
            logger$2.debug(`Parsed legacy format identifier: ${identifier}`);
            return identifier.substring(legacyPrefix.length);
        }
        return null;
    }
    /**
     * Format a storage object ID for this source
     * Default implementation uses the format: type:sourceId.paperId
     */
    formatObjectId(type, paperId) {
        return `${type}:${this.formatPaperId(paperId)}`;
    }
}

// extension/source-integration/arxiv/index.ts
const logger$1 = loguru.getLogger('arxiv-integration');
/**
 * ArXiv integration with custom metadata extraction
 */
class ArXivIntegration extends BaseSourceIntegration {
    constructor() {
        super(...arguments);
        this.id = 'arxiv';
        this.name = 'arXiv.org';
        // URL patterns for papers
        this.urlPatterns = [
            /arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,
            /arxiv\.org\/\w+\/([0-9.]+)/
        ];
        // Content script matches
        this.contentScriptMatches = [
            "*://*.arxiv.org/*"
        ];
    }
    /**
     * Extract paper ID from URL
     */
    extractPaperId(url) {
        for (const pattern of this.urlPatterns) {
            const match = url.match(pattern);
            if (match) {
                return match[2] || match[1]; // The capture group with the paper ID
            }
        }
        return null;
    }
    /**
     * Extract metadata from page or fetch from API
     * Override parent method to handle the API fallback
     */
    async extractMetadata(document, paperId) {
        logger$1.info(`Extracting metadata for arXiv ID: ${paperId}`);
        // Try to extract from page first using our custom extractor
        const pageMetadata = await super.extractMetadata(document, paperId);
        // if (pageMetadata && pageMetadata.title && pageMetadata.authors) {
        logger$1.debug('Extracted metadata from page');
        return pageMetadata;
        // }
    }
}
// Export a singleton instance that can be used by both background and content scripts
const arxivIntegration = new ArXivIntegration();

// background.ts
const logger = loguru.getLogger('background');
// Global state
let githubToken = '';
let githubRepo = '';
let paperManager = null;
let sessionService = null;
let popupManager = null;
let sourceManager = null;
// Initialize sources
function initializeSources() {
    sourceManager = new SourceIntegrationManager();
    // Register built-in sources directly
    sourceManager.registerSource(arxivIntegration);
    logger.info('Source manager initialized');
    return sourceManager;
}
// Initialize everything
async function initialize() {
    try {
        // Initialize sources first
        initializeSources();
        // Load GitHub credentials
        const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);
        githubToken = items.githubToken || '';
        githubRepo = items.githubRepo || '';
        logger.info('Credentials loaded', { hasToken: !!githubToken, hasRepo: !!githubRepo });
        // Initialize paper manager if we have credentials
        if (githubToken && githubRepo) {
            const githubClient = new f(githubToken, githubRepo);
            // Pass the source manager to the paper manager
            paperManager = new PaperManager(githubClient, sourceManager);
            logger.info('Paper manager initialized');
            // Initialize session service with paper manager
            sessionService = new SessionService(paperManager);
        }
        else {
            // Initialize session service without paper manager
            sessionService = new SessionService(null);
        }
        logger.info('Session service initialized');
        // Initialize popup manager
        popupManager = new PopupManager(() => sourceManager, () => paperManager);
        logger.info('Popup manager initialized');
        // Set up message listeners
        setupMessageListeners();
        // Initialize debug objects
        initializeDebugObjects();
    }
    catch (error) {
        logger.error('Initialization error', error);
    }
}
// Set up message listeners
function setupMessageListeners() {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.type === 'contentScriptReady' && sender.tab?.id) {
            logger.debug('Content script ready:', sender.tab.url);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'paperMetadata' && message.metadata) {
            // Store metadata received from content script
            handlePaperMetadata(message.metadata);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'getCurrentPaper') {
            const session = sessionService?.getCurrentSession();
            const paperMetadata = session
                ? sessionService?.getPaperMetadata(session.sourceId, session.paperId)
                : null;
            logger.debug('Popup requested current paper', paperMetadata);
            sendResponse(paperMetadata);
            return true;
        }
        if (message.type === 'updateRating') {
            logger.debug('Rating update requested:', message.rating);
            handleUpdateRating(message.rating, sendResponse);
            return true; // Will respond asynchronously
        }
        if (message.type === 'startSession') {
            handleStartSession(message.sourceId, message.paperId);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'sessionHeartbeat') {
            handleSessionHeartbeat();
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'endSession') {
            handleEndSession(message.reason || 'user_action');
            sendResponse({ success: true });
            return true;
        }
        // New handler for manual paper logging from popup
        if (message.type === 'manualPaperLog' && message.metadata) {
            handleManualPaperLog(message.metadata)
                .then(() => sendResponse({ success: true }))
                .catch(error => {
                logger.error('Error handling manual paper log', error);
                sendResponse({
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            });
            return true; // Will respond asynchronously
        }
        // Other message handlers are managed by PopupManager
        return false; // Not handled
    });
}
// Handle paper metadata from content script
async function handlePaperMetadata(metadata) {
    logger.info(`Received metadata for ${metadata.sourceId}:${metadata.paperId}`);
    try {
        // Store metadata in session service
        if (sessionService) {
            sessionService.storePaperMetadata(metadata);
        }
        // Store in GitHub if we have a paper manager
        if (paperManager) {
            await paperManager.getOrCreatePaper(metadata);
            logger.debug('Paper metadata stored in GitHub');
        }
    }
    catch (error) {
        logger.error('Error handling paper metadata', error);
    }
}
// Handle rating update
async function handleUpdateRating(rating, sendResponse) {
    if (!paperManager || !sessionService) {
        sendResponse({ success: false, error: 'Services not initialized' });
        return;
    }
    const session = sessionService.getCurrentSession();
    if (!session) {
        sendResponse({ success: false, error: 'No current session' });
        return;
    }
    const metadata = sessionService.getPaperMetadata();
    if (!metadata) {
        sendResponse({ success: false, error: 'No paper metadata available' });
        return;
    }
    try {
        await paperManager.updateRating(session.sourceId, session.paperId, rating, metadata);
        // Update stored metadata with new rating
        metadata.rating = rating;
        sendResponse({ success: true });
    }
    catch (error) {
        logger.error('Error updating rating:', error);
        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });
    }
}
// Handle session start request
function handleStartSession(sourceId, paperId) {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    // Get metadata if available
    const existingMetadata = sessionService.getPaperMetadata(sourceId, paperId);
    // Start the session
    sessionService.startSession(sourceId, paperId, existingMetadata);
    logger.info(`Started session for ${sourceId}:${paperId}`);
}
// Handle session heartbeat
function handleSessionHeartbeat() {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    sessionService.recordHeartbeat();
}
// Handle session end request
function handleEndSession(reason) {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    const session = sessionService.getCurrentSession();
    if (session) {
        logger.info(`Ending session: ${reason}`);
        sessionService.endSession();
    }
}
async function handleManualPaperLog(metadata) {
    logger.info(`Received manual paper log: ${metadata.sourceId}:${metadata.paperId}`);
    try {
        // Store metadata in session service
        if (sessionService) {
            sessionService.storePaperMetadata(metadata);
        }
        // Store in GitHub if we have a paper manager
        if (paperManager) {
            await paperManager.getOrCreatePaper(metadata);
            logger.debug('Manually logged paper stored in GitHub');
        }
    }
    catch (error) {
        logger.error('Error handling manual paper log', error);
        throw error;
    }
}
// Listen for credential changes
chrome.storage.onChanged.addListener(async (changes) => {
    logger.debug('Storage changes detected', Object.keys(changes));
    if (changes.githubToken) {
        githubToken = changes.githubToken.newValue;
    }
    if (changes.githubRepo) {
        githubRepo = changes.githubRepo.newValue;
    }
    // Reinitialize paper manager if credentials changed
    if (changes.githubToken || changes.githubRepo) {
        if (githubToken && githubRepo) {
            const githubClient = new f(githubToken, githubRepo);
            // Pass the source manager to the paper manager
            paperManager = new PaperManager(githubClient, sourceManager);
            logger.info('Paper manager reinitialized');
            // Reinitialize session service with new paper manager
            sessionService = new SessionService(paperManager);
            logger.info('Session service reinitialized');
        }
    }
});
// Initialize debug objects in service worker scope
function initializeDebugObjects() {
    // @ts-ignore
    self.__DEBUG__ = {
        get paperManager() { return paperManager; },
        get sessionService() { return sessionService; },
        get popupManager() { return popupManager; },
        get sourceManager() { return sourceManager; },
        getGithubClient: () => paperManager ? paperManager.getClient() : null,
        getCurrentPaper: () => {
            const session = sessionService?.getCurrentSession();
            return session ? sessionService?.getPaperMetadata(session.sourceId, session.paperId) : null;
        },
        getSessionStats: () => sessionService?.getSessionStats(),
        getSources: () => sourceManager?.getAllSources(),
        forceEndSession: () => sessionService?.endSession()
    };
    logger.info('Debug objects registered');
}
// Initialize extension
initialize();
//# sourceMappingURL=background.bundle.js.map



---
File: extension/dist/content-script.js
---
!function(){"use strict";class e{constructor(e){this.module=e}debug(e,t){console.debug(`[${this.module}] ${e}`,void 0!==t?t:"")}info(e,t){console.info(`[${this.module}] ${e}`,void 0!==t?t:"")}warning(e,t){console.warn(`[${this.module}] ${e}`,void 0!==t?t:"")}error(e,t){console.error(`[${this.module}] ${e}`,void 0!==t?t:"")}}const t=new class{getLogger(t){return new e(t)}},n=t.getLogger("link-processor");const r=t.getLogger("metadata-extractor"),a="pdf",o="url";class s{constructor(e){this.document=e,this.url=e.location.href,r.debug("Initialized metadata extractor for:",this.url)}getMetaContent(e){const t=this.document.querySelector(e);return t&&t.getAttribute("content")||""}extract(){r.debug("Extracting metadata from page:",this.url);const e={title:this.extractTitle(),authors:this.extractAuthors(),description:this.extractDescription(),publishedDate:this.extractPublishedDate(),doi:this.extractDoi(),journalName:this.extractJournalName(),tags:this.extractTags(),url:this.url};return r.debug("Metadata extraction complete:",e),e}extractTitle(){return this.getMetaContent('meta[name="DC.Title"]')||this.getMetaContent('meta[name="citation_title"]')||this.getMetaContent('meta[property="og:title"]')||this.getMetaContent('meta[name="title"]')||this.document.title}extractAuthors(){const e=[];this.document.querySelectorAll('meta[name="citation_author"]').forEach((t=>{const n=t.getAttribute("content");n&&e.push(n)}));const t=[];this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach((e=>{const n=e.getAttribute("content");n&&t.push(n)}));const n=this.getMetaContent('meta[name="DC.Creator.PersonalName"]'),r=this.getMetaContent('meta[name="citation_author"]'),a=this.getMetaContent('meta[property="og:article:author"]')||this.getMetaContent('meta[name="author"]');return t.length>0?t.join(", "):e.length>0?e.join(", "):n||(r||(a||""))}extractDescription(){return this.getMetaContent('meta[name="DC.Description"]')||this.getMetaContent('meta[name="citation_abstract"]')||this.getMetaContent('meta[property="og:description"]')||this.getMetaContent('meta[name="description"]')}extractPublishedDate(){return this.getMetaContent('meta[name="DC.Date.issued"]')||this.getMetaContent('meta[name="citation_date"]')||this.getMetaContent('meta[property="article:published_time"]')}extractDoi(){return this.getMetaContent('meta[name="DC.Identifier.DOI"]')||this.getMetaContent('meta[name="citation_doi"]')}extractJournalName(){return this.getMetaContent('meta[name="DC.Source"]')||this.getMetaContent('meta[name="citation_journal_title"]')}extractTags(){const e=this.getMetaContent('meta[name="keywords"]')||this.getMetaContent('meta[name="DC.Subject"]');return e?e.split(",").map((e=>e.trim())):[]}isPdf(){return this.url.toLowerCase().endsWith(".pdf")}getSourceType(){return this.isPdf()?a:o}generatePaperId(){return i(this.url)}}function i(e){let t=0;for(let n=0;n<e.length;n++){t=(t<<5)-t+e.charCodeAt(n),t|=0}return Math.abs(t).toString(16).toUpperCase().substring(0,8)}const c=t.getLogger("base-source");class d{constructor(){this.id="url",this.name="Web Page",this.urlPatterns=[/^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i],this.contentScriptMatches=[]}canHandleUrl(e){return this.urlPatterns.some((t=>t.test(e)))}extractPaperId(e){return i(e)}createMetadataExtractor(e){return function(e){return new s(e)}(e)}async extractMetadata(e,t){try{c.debug(`Extracting metadata using base extractor for ID: ${t}`);const n=this.createMetadataExtractor(e),r=n.extract(),a=e.location.href,o=n.getSourceType();return{sourceId:this.id,paperId:t,url:a,title:r.title||e.title||t,authors:r.authors||"",abstract:r.description||"",timestamp:(new Date).toISOString(),rating:"novote",publishedDate:r.publishedDate||"",tags:r.tags||[],doi:r.doi,journalName:r.journalName,sourceType:o}}catch(e){return c.error("Error extracting metadata with base extractor",e),null}}formatPaperId(e){return`${this.id}.${e}`}parsePaperId(e){const t=`${this.id}.`;if(e.startsWith(t))return e.substring(t.length);const n=`${this.id}:`;return e.startsWith(n)?(c.debug(`Parsed legacy format identifier: ${e}`),e.substring(n.length)):null}formatObjectId(e,t){return`${e}:${this.formatPaperId(t)}`}}const u=t.getLogger("arxiv-integration");const p=new class extends d{constructor(){super(...arguments),this.id="arxiv",this.name="arXiv.org",this.urlPatterns=[/arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,/arxiv\.org\/\w+\/([0-9.]+)/],this.contentScriptMatches=["*://*.arxiv.org/*"]}extractPaperId(e){for(const t of this.urlPatterns){const n=e.match(t);if(n)return n[2]||n[1]}return null}async extractMetadata(e,t){u.info(`Extracting metadata for arXiv ID: ${t}`);const n=await super.extractMetadata(e,t);return u.debug("Extracted metadata from page"),n}},l=t.getLogger("content-script");l.info("Paper Tracker content script loaded");const h=[p],g=new d;let m=null,b=null;let f=!0,x=null;const v=new class{constructor(e){this.patterns=[],this.observer=null,this.processedLinks=new Set,this.onLinkFound=e,n.debug("Link processor initialized")}registerPattern(e){this.patterns.push(e),n.debug(`Registered pattern for ${e.sourceId}`)}processLinks(e){e.querySelectorAll("a[href]").forEach((e=>{const t=this.getLinkId(e);if(!this.processedLinks.has(t)){this.processedLinks.add(t);for(const t of this.patterns)if(t.pattern.test(e.href)){const n=t.extractPaperId(e.href);if(n){this.onLinkFound(t.sourceId,n,e);break}}}}))}startObserving(e){this.observer&&this.observer.disconnect(),this.observer=new MutationObserver((t=>{let n=!1;t.forEach((e=>{e.addedNodes.forEach((e=>{if(e.nodeType===Node.ELEMENT_NODE){"A"===e.tagName&&(n=!0);e.querySelectorAll("a[href]").length>0&&(n=!0)}}))})),n&&this.processLinks(e)})),this.observer.observe(e.body,{childList:!0,subtree:!0}),n.debug("Started observing for DOM changes")}getLinkId(e){const t=this.getElementPath(e);return`${e.href}|${t}`}getElementPath(e){const t=[];let n=e;for(;n&&n!==document.body;){let e=n.tagName.toLowerCase();if(n.id)e+=`#${n.id}`;else{const t=Array.from(n.parentElement?.children||[]),r=t.indexOf(n)+1;t.length>1&&(e+=`:nth-child(${r})`)}t.unshift(e),n=n.parentElement}return t.join(" > ")}stopObserving(){this.observer&&(this.observer.disconnect(),this.observer=null,n.debug("Stopped observing DOM changes"))}}(((e,t,n)=>{!function(e,t,n){if(e.nextSibling&&e.nextSibling.nodeType===Node.ELEMENT_NODE&&e.nextSibling.classList.contains("paper-annotator"))return;const r=document.createElement("span");r.className="paper-annotator",r.textContent="📝",r.title="Add annotation",r.dataset.sourceId=t,r.dataset.paperId=n,r.addEventListener("click",(e=>{e.preventDefault(),e.stopPropagation(),chrome.runtime.sendMessage({type:"showAnnotationPopup",sourceId:t,paperId:n,position:{x:e.clientX,y:e.clientY}})})),e.parentNode?.insertBefore(r,e.nextSibling)}(n,e,t)}));function I(e,t){y(),f?(x={sourceId:e,paperId:t},chrome.runtime.sendMessage({type:"startSession",sourceId:e,paperId:t},(n=>{n?.success?(l.debug(`Started session for ${e}:${t}`),function(){if(!x)return;y(),b=window.setInterval((()=>{x&&chrome.runtime.sendMessage({type:"sessionHeartbeat",sourceId:x.sourceId,paperId:x.paperId,timestamp:Date.now()})}),5e3),l.debug(`Started heartbeat for ${x.sourceId}:${x.paperId}`)}()):l.error(`Failed to start session for ${e}:${t}`,n?.error)}))):l.debug(`Not starting session for ${e}:${t} because tab is not visible`)}function y(){null!==b&&(clearInterval(b),b=null,l.debug("Stopped heartbeat"))}function M(e){if(!x)return;const{sourceId:t,paperId:n}=x;y(),chrome.runtime.sendMessage({type:"endSession",sourceId:t,paperId:n,reason:e},(r=>{l.debug(`Ended session for ${t}:${n}`,{reason:e})})),x=null}async function w(e=!1){const t=window.location.href;let n=function(e){for(const t of h)if(t.canHandleUrl(e))return t;return null}(t);if(!n&&e&&(l.info(`No matching source found, but force parameter set. Using base source for: ${t}`),n=g),!n)return l.debug(`No source found for URL: ${t}`),null;const r=n.extractPaperId(t);if(!r)return l.info(`Unable to determine a paperId for url: ${t}`),null;try{const e=await n.extractMetadata(document,r);if(e)return chrome.runtime.sendMessage({type:"paperMetadata",metadata:e}),l.debug(`Sent extracted metadata to background script for ${e.sourceId}:${e.paperId}`),f&&I(e.sourceId,e.paperId),e}catch(e){l.error(`Error extracting metadata for ${n.id}:${r}`,e)}return null}document.addEventListener("click",(e=>{!m||m.contains(e.target)||e.target.classList.contains("paper-annotator")||(m.parentElement?.remove(),m=null)})),document.addEventListener("visibilitychange",(()=>{const e=f;f="visible"===document.visibilityState,f&&!e?(l.info("Tab became visible again"),x?I(x.sourceId,x.paperId):w()):!f&&e&&(l.info("Tab hidden"),x&&M("tab_hidden"))})),window.addEventListener("focus",(()=>{f&&(l.info("Window gained focus"),x?I(x.sourceId,x.paperId):w())})),window.addEventListener("blur",(()=>{l.info("Window lost focus"),x&&M("window_blur")})),window.addEventListener("beforeunload",(()=>{x&&(l.info("Page unloading"),M("page_unload"))})),chrome.runtime.onMessage.addListener(((e,t,n)=>{if(l.debug("Received message",e),"extractPaperMetadata"===e.type)return l.debug("Received request to force paper metadata extraction"),w(!0).then((e=>{n(e?{success:!0,metadata:e}:{success:!1,error:"Failed to extract metadata"})})).catch((e=>{l.error("Error extracting metadata",e),n({success:!1,error:e instanceof Error?e.message:"Unknown error"})})),!0;if("showPopup"===e.type){m&&(m.parentElement?.remove(),m=null);const t=document.createElement("div");t.className="paper-popup-wrapper",e.position&&(t.style.left=`${e.position.x}px`,t.style.top=`${e.position.y}px`);const r=document.createElement("div");if(r.className="paper-popup",r.innerHTML=e.html,t.appendChild(r),document.body.appendChild(t),e.handlers)for(const t of e.handlers){r.querySelectorAll(t.selector).forEach((n=>{n.addEventListener(t.event,(()=>{chrome.runtime.sendMessage({type:"popupAction",action:t.action,sourceId:e.sourceId,paperId:e.paperId,data:{value:"TEXTAREA"===n.tagName?n.value:n.getAttribute("data-vote"),checked:"INPUT"===n.tagName?n.checked:void 0,id:n.id}})}))}))}return m=r,n({success:!0}),!0}return"processPage"===e.type?(v.processLinks(document),w(),n({success:!0}),!0):void 0})),async function(){!function(){if(document.getElementById("paper-tracker-styles"))return;const e=document.createElement("style");e.id="paper-tracker-styles",e.textContent="\n  .paper-annotator {\n    display: inline-block;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    opacity: 0.7;\n    transition: opacity 0.2s;\n    vertical-align: baseline;\n  }\n\n  .paper-annotator:hover {\n    opacity: 1;\n  }\n\n  .paper-popup-wrapper {\n    position: fixed;\n    z-index: 10000;\n  }\n\n  .paper-popup {\n    position: relative;\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 12px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    width: 300px;\n    box-sizing: border-box;\n  }\n\n  .paper-popup-header {\n    font-weight: bold;\n    margin-bottom: 8px;\n    line-height: 1.4;\n    font-size: 1em;\n  }\n\n  .paper-popup-meta {\n    color: #666;\n    font-size: 0.85em;\n    margin-bottom: 12px;\n    line-height: 1.4;\n  }\n\n  .paper-popup-buttons {\n    display: flex;\n    gap: 8px;\n    margin: 8px 0;\n  }\n\n  .paper-popup button {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    background: #f5f5f5;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n  }\n\n  .paper-popup button:hover {\n    background: #e8e8e8;\n    border-color: #ccc;\n  }\n\n  .paper-popup button.active {\n    background: #e0e0e0;\n    border-color: #aaa;\n  }\n\n  .paper-popup textarea {\n    width: calc(100% - 16px);\n    min-height: 80px;\n    margin: 8px 0;\n    padding: 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 0.9em;\n    line-height: 1.4;\n    box-sizing: border-box;\n  }\n\n  .paper-popup textarea:focus {\n    outline: none;\n    border-color: #aaa;\n  }\n\n  .paper-popup-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n    margin-top: 12px;\n  }\n\n  .paper-popup .save-button {\n    background: #2563eb;\n    color: white;\n    border-color: #2563eb;\n  }\n\n  .paper-popup .save-button:hover {\n    background: #1d4ed8;\n    border-color: #1d4ed8;\n  }\n  ",document.head.appendChild(e),l.debug("Injected styles")}(),function(){for(const e of h)l.debug(`Initializing source: ${e.id}`),e.urlPatterns.forEach((t=>{v.registerPattern({sourceId:e.id,pattern:t,extractPaperId:t=>e.extractPaperId(t)})}))}(),v.processLinks(document),v.startObserving(document),f="visible"===document.visibilityState,w(),chrome.runtime.sendMessage({type:"contentScriptReady",url:window.location.href},(e=>{e?.success&&l.debug("Background script acknowledged ready status")}))}();let E=location.href;new MutationObserver((()=>{const e=location.href;e!==E&&(x&&M("url_change"),E=e,w())})).observe(document,{subtree:!0,childList:!0})}();
//# sourceMappingURL=content-script.js.map



---
File: extension/dist/options.bundle.js
---
// utils/logger.ts
// Logging utility wrapping loguru
/**
 * Logger class for consistent logging throughout the extension
 */
class Logger {
    constructor(module) {
        this.module = module;
    }
    /**
     * Log debug message
     */
    debug(message, data) {
        console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log info message
     */
    info(message, data) {
        console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log warning message
     */
    warning(message, data) {
        console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log error message
     */
    error(message, data) {
        console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
}
/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
    /**
     * Get logger for a module
     */
    getLogger(module) {
        return new Logger(module);
    }
}
// Export singleton instance
const loguru = new LoguruMock();

// config/session.ts
const logger = loguru.getLogger('session-config');
// Default configuration values
const DEFAULT_CONFIG = {
    idleThresholdMinutes: 5,
    minSessionDurationSeconds: 30,
    requireContinuousActivity: true, // If true, resets timer on idle
    logPartialSessions: false, // If true, logs sessions even if under minimum duration
    activityUpdateIntervalSeconds: 1 // How often to update active time
};
/**
 * Load session configuration from storage
 */
async function loadSessionConfig() {
    try {
        const items = await chrome.storage.sync.get('sessionConfig');
        const config = { ...DEFAULT_CONFIG, ...items.sessionConfig };
        logger.debug('Loaded session config', config);
        return config;
    }
    catch (error) {
        logger.error('Error loading session config', error);
        return DEFAULT_CONFIG;
    }
}
/**
 * Save session configuration to storage
 */
async function saveSessionConfig(config) {
    try {
        // Ensure values are the correct type
        const sanitizedConfig = {
            idleThresholdMinutes: Number(config.idleThresholdMinutes),
            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),
            requireContinuousActivity: Boolean(config.requireContinuousActivity),
            logPartialSessions: Boolean(config.logPartialSessions),
            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)
        };
        await chrome.storage.sync.set({ sessionConfig: sanitizedConfig });
        logger.debug('Saved session config', sanitizedConfig);
    }
    catch (error) {
        logger.error('Error saving session config', error);
        throw error;
    }
}

// options.ts
// Helper to set form values
function setFormValues(settings) {
    // GitHub settings
    if (settings.githubRepo) {
        document.getElementById('repo').value = settings.githubRepo;
    }
    if (settings.githubToken) {
        // Don't show the actual token, just indicate it's set
        document.getElementById('token').placeholder = '••••••••••••••••••••••';
    }
    // Session settings
    document.getElementById('idleThreshold').value =
        String(settings.sessionConfig?.idleThresholdMinutes ?? DEFAULT_CONFIG.idleThresholdMinutes);
    document.getElementById('minDuration').value =
        String(settings.sessionConfig?.minSessionDurationSeconds ?? DEFAULT_CONFIG.minSessionDurationSeconds);
    document.getElementById('requireContinuous').checked =
        settings.sessionConfig?.requireContinuousActivity ?? DEFAULT_CONFIG.requireContinuousActivity;
    document.getElementById('logPartial').checked =
        settings.sessionConfig?.logPartialSessions ?? DEFAULT_CONFIG.logPartialSessions;
}
// Helper to get form values
function getFormValues() {
    return {
        githubRepo: document.getElementById('repo').value.trim(),
        githubToken: document.getElementById('token').value.trim(),
        sessionConfig: {
            idleThresholdMinutes: Number(document.getElementById('idleThreshold').value),
            minSessionDurationSeconds: Number(document.getElementById('minDuration').value),
            requireContinuousActivity: document.getElementById('requireContinuous').checked,
            logPartialSessions: document.getElementById('logPartial').checked,
            activityUpdateIntervalSeconds: DEFAULT_CONFIG.activityUpdateIntervalSeconds // Keep default
        }
    };
}
// Display status message
function showStatus(message, isError = false) {
    const status = document.getElementById('status');
    if (!status)
        return;
    status.textContent = message;
    status.className = `status ${isError ? 'error' : 'success'}`;
    // Clear status after 3 seconds if it's a success message
    if (!isError) {
        setTimeout(() => {
            if (status) {
                status.textContent = '';
                status.className = 'status';
            }
        }, 3000);
    }
}
// Validate settings before saving
async function validateSettings(settings) {
    // Validate repository format
    if (!/^[\w-]+\/[\w-]+$/.test(settings.githubRepo)) {
        throw new Error('Invalid repository format. Use username/repository');
    }
    // Validate the token by making a test API call
    const response = await fetch(`https://api.github.com/repos/${settings.githubRepo}`, {
        headers: {
            'Authorization': `token ${settings.githubToken}`,
            'Accept': 'application/vnd.github.v3+json'
        }
    });
    if (!response.ok) {
        throw new Error('Invalid token or repository. Please check your credentials.');
    }
    // Validate session settings
    const { sessionConfig } = settings;
    if (sessionConfig.idleThresholdMinutes < 1 || sessionConfig.idleThresholdMinutes > 60) {
        throw new Error('Idle threshold must be between 1 and 60 minutes');
    }
    if (sessionConfig.minSessionDurationSeconds < 1 || sessionConfig.minSessionDurationSeconds > 300) {
        throw new Error('Minimum session duration must be between 10 and 300 seconds');
    }
}
// Save settings
async function saveSettings(settings) {
    await chrome.storage.sync.set({
        githubRepo: settings.githubRepo,
        githubToken: settings.githubToken
    });
    await saveSessionConfig(settings.sessionConfig);
}
// Initialize options page
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Load current settings
        const [storageItems, sessionConfig] = await Promise.all([
            chrome.storage.sync.get(['githubRepo', 'githubToken']),
            loadSessionConfig()
        ]);
        // Combine settings and display them
        setFormValues({
            ...storageItems,
            sessionConfig
        });
        // Add save button handler
        const saveButton = document.getElementById('save');
        if (saveButton) {
            saveButton.addEventListener('click', async () => {
                try {
                    const settings = getFormValues();
                    await validateSettings(settings);
                    await saveSettings(settings);
                    showStatus('Settings saved successfully!');
                }
                catch (error) {
                    showStatus(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
                }
            });
        }
    }
    catch (error) {
        showStatus(`Error loading settings: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
    }
});
//# sourceMappingURL=options.bundle.js.map



---
File: extension/dist/popup.bundle.js
---
// extension/popup.ts
// Popup script with refactored manual paper tracking
console.log('Popup script starting...');
// Function to get paper data from background script
async function getCurrentPaper() {
    return new Promise((resolve) => {
        chrome.runtime.sendMessage({ type: 'getCurrentPaper' }, (response) => {
            console.log('Got paper data from background:', response);
            resolve(response);
        });
    });
}
// Function to update UI with paper data
function updateUI(paperData) {
    const titleElement = document.getElementById('paperTitle');
    const authorsElement = document.getElementById('paperAuthors');
    const statusElement = document.getElementById('status');
    const manualLogSection = document.getElementById('manualLogSection');
    if (!titleElement || !authorsElement || !statusElement || !manualLogSection) {
        console.error('Required DOM elements not found');
        return;
    }
    if (paperData) {
        // Show detected paper data
        titleElement.textContent = paperData.title || paperData.paperId;
        authorsElement.textContent = paperData.authors;
        statusElement.textContent = 'Paper tracked! Issue created on GitHub.';
        // Enable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = false;
            thumbsDownButton.disabled = false;
            // Set active state on rating buttons
            thumbsUpButton.classList.toggle('active', paperData.rating === 'thumbsup');
            thumbsDownButton.classList.toggle('active', paperData.rating === 'thumbsdown');
        }
        // Hide manual log section
        manualLogSection.style.display = 'none';
    }
    else {
        // No paper detected - show manual log option
        titleElement.textContent = 'No paper detected';
        authorsElement.textContent = '';
        statusElement.textContent = 'Current page not recognized as a paper';
        // Disable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = true;
            thumbsDownButton.disabled = true;
        }
        // Show manual log section
        manualLogSection.style.display = 'block';
    }
}
// Function to log current page as a paper (using content script extraction)
async function logCurrentPage() {
    console.log("attempting to log paper");
    // Get the active tab
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tabs[0] || !tabs[0].id) {
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.textContent = 'Error: Could not access current tab';
        }
        return;
    }
    // Show loading state
    const statusElement = document.getElementById('status');
    if (statusElement) {
        statusElement.textContent = 'Extracting paper metadata...';
    }
    // Send message to content script requesting extraction
    chrome.tabs.sendMessage(tabs[0].id, {
        type: 'extractPaperMetadata'
    }, (response) => {
        if (chrome.runtime.lastError) {
            // Handle error
            if (statusElement) {
                statusElement.textContent = 'Error: ' + chrome.runtime.lastError.message;
            }
            return;
        }
        if (!response || !response.success || !response.metadata) {
            // Handle extraction failure
            if (statusElement) {
                statusElement.textContent = 'Error: ' + (response?.error || 'Failed to extract metadata');
            }
            return;
        }
        // Success - update UI
        updateUI(response.metadata);
        if (statusElement) {
            statusElement.textContent = 'Paper tracked successfully!';
        }
        // The content script has already:
        // 1. Sent metadata to background script
        // 2. Started a session if the tab is visible
        // Hide manual log section
        const manualLogSection = document.getElementById('manualLogSection');
        if (manualLogSection) {
            manualLogSection.style.display = 'none';
        }
        // Enable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = false;
            thumbsDownButton.disabled = false;
        }
    });
}
// Initialize popup
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Popup opened');
    // Get paper from the session tracker
    let paperData = null;
    let retries = 3;
    while (retries > 0 && !paperData) {
        paperData = await getCurrentPaper();
        if (!paperData) {
            await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
            retries--;
        }
    }
    updateUI(paperData);
    // Set up rating handlers
    const thumbsUpButton = document.getElementById('thumbsUp');
    if (thumbsUpButton) {
        thumbsUpButton.addEventListener('click', () => {
            chrome.runtime.sendMessage({
                type: 'updateRating',
                rating: 'thumbsup'
            }, (response) => {
                const statusElement = document.getElementById('status');
                const thumbsUpButton = document.getElementById('thumbsUp');
                const thumbsDownButton = document.getElementById('thumbsDown');
                if (!statusElement || !thumbsUpButton || !thumbsDownButton)
                    return;
                if (response && response.success) {
                    statusElement.textContent = 'Rating updated to: thumbs up';
                    thumbsUpButton.classList.add('active');
                    thumbsDownButton.classList.remove('active');
                    setTimeout(() => window.close(), 1500);
                }
                else {
                    statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
                }
            });
        });
    }
    const thumbsDownButton = document.getElementById('thumbsDown');
    if (thumbsDownButton) {
        thumbsDownButton.addEventListener('click', () => {
            chrome.runtime.sendMessage({
                type: 'updateRating',
                rating: 'thumbsdown'
            }, (response) => {
                const statusElement = document.getElementById('status');
                const thumbsUpButton = document.getElementById('thumbsUp');
                const thumbsDownButton = document.getElementById('thumbsDown');
                if (!statusElement || !thumbsUpButton || !thumbsDownButton)
                    return;
                if (response && response.success) {
                    statusElement.textContent = 'Rating updated to: thumbs down';
                    thumbsDownButton.classList.add('active');
                    thumbsUpButton.classList.remove('active');
                    setTimeout(() => window.close(), 1500);
                }
                else {
                    statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
                }
            });
        });
    }
    // Set up one-click logging button
    const logPageButton = document.getElementById('logPageButton');
    if (logPageButton) {
        console.log("Attaching logPageButton event listener...");
        logPageButton.addEventListener('click', () => {
            console.log("logPageButton clicked...");
            logCurrentPage();
        });
    }
});
//# sourceMappingURL=popup.bundle.js.map



---
File: extension/manifest.json
---
{
  "manifest_version": 3,
  "name": "Academic Paper Tracker",
  "version": "2.0",
  "description": "Track and annotate academic papers from various sources",
  "permissions": [
    "tabs",
    "storage",
    "webNavigation",
    "scripting",
    "activeTab"
  ],
  "host_permissions": [
    "*://*.arxiv.org/*", 
    "*://export.arxiv.org/*",
    "*://api.github.com/*",
    "<all_urls>"
  ],
  "background": {
    "service_worker": "dist/background.bundle.js",
    "type": "module"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["dist/content-script.js"],
    "run_at": "document_end",
    "type": "module"
  }],
  "action": {
    "default_popup": "popup.html"
  },
  "options_ui": {
    "page": "options.html",
    "open_in_tab": false
  }
}



---
File: extension/options.html
---
<!DOCTYPE html>
<html>
<head>
  <title>ArXiv Tracker Settings</title>
  <style>
    body {
      padding: 20px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .container {
      max-width: 500px;
      margin: 0 auto;
    }
    .field {
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    input[type="text"],
    input[type="password"],
    input[type="number"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }
    input[type="number"] {
      width: 100px;
    }
    .help-text {
      font-size: 0.9em;
      color: #666;
      margin-top: 4px;
    }
    .status {
      margin-top: 16px;
      padding: 8px;
      border-radius: 4px;
    }
    .success {
      background: #e6ffe6;
      color: #006600;
    }
    .error {
      background: #ffe6e6;
      color: #660000;
    }
    button {
      background: #0366d6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
    }
    button:hover {
      background: #0255b3;
    }
    .section {
      margin-bottom: 32px;
    }
    .section-title {
      font-size: 1.2em;
      font-weight: 600;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    .checkbox-field {
      margin-top: 12px;
    }
    .checkbox-field label {
      display: flex;
      align-items: center;
      font-weight: normal;
    }
    .checkbox-field input[type="checkbox"] {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ArXiv Tracker Settings</h2>
    
    <div class="section">
      <div class="section-title">GitHub Integration</div>
      <div class="field">
        <label for="repo">GitHub Repository</label>
        <input type="text" id="repo" placeholder="username/repository">
        <div class="help-text">Format: username/repository (e.g., johndoe/arxiv-tracker)</div>
      </div>

      <div class="field">
        <label for="token">GitHub Personal Access Token</label>
        <input type="password" id="token" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx">
        <div class="help-text">
          Token needs 'repo' scope for private repositories.<br>
          Never share this token with anyone.
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Reading Session Settings</div>
      
      <div class="field">
        <label for="idleThreshold">Idle Threshold (minutes)</label>
        <input type="number" id="idleThreshold" min="1" max="60" value="5">
        <div class="help-text">
          Time of inactivity before session is paused (1-60 minutes).<br>
          Default: 5 minutes
        </div>
      </div>

      <div class="field">
        <label for="minDuration">Minimum Session Duration (seconds)</label>
        <input type="number" id="minDuration" min="10" max="300" value="30">
        <div class="help-text">
          Minimum time required to log a reading session (10-300 seconds).<br>
          Default: 30 seconds
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="requireContinuous">
          Require Continuous Activity
        </label>
        <div class="help-text">
          When enabled, resets the session timer if you're idle for too long.<br>
          Default: Enabled
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="logPartial">
          Log Partial Sessions
        </label>
        <div class="help-text">
          When enabled, logs sessions even if they're shorter than the minimum duration.<br>
          Default: Disabled
        </div>
      </div>
    </div>

    <button id="save">Save Settings</button>
    <div id="status" class="status"></div>
  </div>
  <script type="module" src="dist/options.bundle.js"></script>
</body>
</html>



---
File: extension/options.ts
---
// options.ts
import { loadSessionConfig, DEFAULT_CONFIG, saveSessionConfig } from './config/session';
import { RawSessionConfig } from './config/types';

// Helper to set form values
function setFormValues(settings: {
  githubRepo?: string;
  githubToken?: string;
  sessionConfig?: RawSessionConfig;
}): void {
  // GitHub settings
  if (settings.githubRepo) {
    (document.getElementById('repo') as HTMLInputElement).value = settings.githubRepo;
  }
  if (settings.githubToken) {
    // Don't show the actual token, just indicate it's set
    (document.getElementById('token') as HTMLInputElement).placeholder = '••••••••••••••••••••••';
  }

  // Session settings
  (document.getElementById('idleThreshold') as HTMLInputElement).value = 
    String(settings.sessionConfig?.idleThresholdMinutes ?? DEFAULT_CONFIG.idleThresholdMinutes);
    
  (document.getElementById('minDuration') as HTMLInputElement).value = 
    String(settings.sessionConfig?.minSessionDurationSeconds ?? DEFAULT_CONFIG.minSessionDurationSeconds);
    
  (document.getElementById('requireContinuous') as HTMLInputElement).checked = 
    settings.sessionConfig?.requireContinuousActivity ?? DEFAULT_CONFIG.requireContinuousActivity;
    
  (document.getElementById('logPartial') as HTMLInputElement).checked = 
    settings.sessionConfig?.logPartialSessions ?? DEFAULT_CONFIG.logPartialSessions;
}

// Helper to get form values
function getFormValues(): {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
} {
  return {
    githubRepo: (document.getElementById('repo') as HTMLInputElement).value.trim(),
    githubToken: (document.getElementById('token') as HTMLInputElement).value.trim(),
    sessionConfig: {
      idleThresholdMinutes: Number((document.getElementById('idleThreshold') as HTMLInputElement).value),
      minSessionDurationSeconds: Number((document.getElementById('minDuration') as HTMLInputElement).value),
      requireContinuousActivity: (document.getElementById('requireContinuous') as HTMLInputElement).checked,
      logPartialSessions: (document.getElementById('logPartial') as HTMLInputElement).checked,
      activityUpdateIntervalSeconds: DEFAULT_CONFIG.activityUpdateIntervalSeconds // Keep default
    }
  };
}

// Display status message
function showStatus(message: string, isError = false): void {
  const status = document.getElementById('status');
  if (!status) return;
  
  status.textContent = message;
  status.className = `status ${isError ? 'error' : 'success'}`;

  // Clear status after 3 seconds if it's a success message
  if (!isError) {
    setTimeout(() => {
      if (status) {
        status.textContent = '';
        status.className = 'status';
      }
    }, 3000);
  }
}

// Validate settings before saving
async function validateSettings(settings: {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
}): Promise<void> {
  // Validate repository format
  if (!/^[\w-]+\/[\w-]+$/.test(settings.githubRepo)) {
    throw new Error('Invalid repository format. Use username/repository');
  }

  // Validate the token by making a test API call
  const response = await fetch(`https://api.github.com/repos/${settings.githubRepo}`, {
    headers: {
      'Authorization': `token ${settings.githubToken}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  if (!response.ok) {
    throw new Error('Invalid token or repository. Please check your credentials.');
  }

  // Validate session settings
  const { sessionConfig } = settings;
  if (sessionConfig.idleThresholdMinutes < 1 || sessionConfig.idleThresholdMinutes > 60) {
    throw new Error('Idle threshold must be between 1 and 60 minutes');
  }
  if (sessionConfig.minSessionDurationSeconds < 1 || sessionConfig.minSessionDurationSeconds > 300) {
    throw new Error('Minimum session duration must be between 10 and 300 seconds');
  }
}

// Save settings
async function saveSettings(settings: {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
}): Promise<void> {
  await chrome.storage.sync.set({
    githubRepo: settings.githubRepo,
    githubToken: settings.githubToken
  });

  await saveSessionConfig(settings.sessionConfig);
}

// Initialize options page
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Load current settings
    const [storageItems, sessionConfig] = await Promise.all([
      chrome.storage.sync.get(['githubRepo', 'githubToken']),
      loadSessionConfig()
    ]);

    // Combine settings and display them
    setFormValues({
      ...(storageItems as {
        githubRepo?: string;
        githubToken?: string;
      }),
      sessionConfig
    });

    // Add save button handler
    const saveButton = document.getElementById('save');
    if (saveButton) {
      saveButton.addEventListener('click', async () => {
        try {
          const settings = getFormValues();
          await validateSettings(settings);
          await saveSettings(settings);
          showStatus('Settings saved successfully!');
        } catch (error) {
          showStatus(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
        }
      });
    }

  } catch (error) {
    showStatus(`Error loading settings: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
  }
});



---
File: extension/package.json
---
{
  "name": "arxiv-tracker-extension",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "rollup -c",
    "watch": "rollup -c -w",
    "type-check": "tsc --noEmit",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write \"**/*.{ts,js}\"",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "gh-store-client": "^0.3.2"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^22.0.0",
    "@rollup/plugin-node-resolve": "^13.3.0",
    "@rollup/plugin-typescript": "^8.3.2",
    "@types/chrome": "^0.0.246",
    "@types/node": "^20.10.6",
    "@typescript-eslint/eslint-plugin": "^6.17.0",
    "@typescript-eslint/parser": "^6.17.0",
    "eslint": "^8.56.0",
    "prettier": "^3.1.1",
    "rollup": "^2.75.6",
    "rollup-plugin-terser": "^7.0.2",
    "tslib": "^2.4.0",
    "typescript": "^5.3.3"
  }
}



---
File: extension/papers/debug.d.ts
---
// extension/papers/debug.d.ts
import { GitHubStoreClient } from 'gh-store-client';
import { PaperManager } from './manager';

declare global {
    const __DEBUG__: {
        paperManager: PaperManager | null;
        getGithubClient: () => GitHubStoreClient | undefined;
        getCurrentPaper: () => any;
        getCurrentSession: () => any;
        getConfig: () => any;
    }
}



---
File: extension/papers/manager.ts
---
// extension/papers/manager.ts
import { GitHubStoreClient } from 'gh-store-client';
import type { Json } from 'gh-store-client';
import { 
  type PaperMetadata, 
  type InteractionLog, 
  type Interaction,
  type ReadingSessionData,
  isInteractionLog
} from './types';
import { SourceManager } from '../source-integration/types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('paper-manager');

export class PaperManager {
  constructor(
    private client: GitHubStoreClient,
    private sourceManager: SourceManager
  ) {
    logger.debug('Paper manager initialized');
  }
  
  /**
   * Get paper by source and ID
   */
  async getPaper(sourceId: string, paperId: string): Promise<PaperMetadata | null> {
    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      return obj.data as PaperMetadata;
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        return null;
      }
      throw error;
    }
  }
  
  /**
   * Get or create paper metadata
   */
  async getOrCreatePaper(paperData: PaperMetadata): Promise<PaperMetadata> {
    const { sourceId, paperId } = paperData;
    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      const data = obj.data as PaperMetadata;
      logger.debug(`Retrieved existing paper: ${paperIdentifier}`);
      return data;
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        // Create new paper
        const defaultPaperData: PaperMetadata = {
          ...paperData,
          timestamp: new Date().toISOString(),
          rating: paperData.rating || 'novote'
        };

        await this.client.createObject(objectId, defaultPaperData);
        logger.debug(`Created new paper: ${paperIdentifier}`);
        return defaultPaperData;
      }
      throw error;
    }
  }

  /**
   * Get or create interaction log for a paper
   */
  private async getOrCreateInteractionLog(sourceId: string, paperId: string): Promise<InteractionLog> {
    const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      const data = obj.data as unknown;
      if (isInteractionLog(data)) {
        return data;
      }
      throw new Error('Invalid interaction log format');
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        const newLog: InteractionLog = {
          sourceId,
          paperId,
          interactions: []
        };
        await this.client.createObject(objectId, newLog as unknown as { [key: string]: Json });
        logger.debug(`Created new interaction log: ${paperIdentifier}`);
        return newLog;
      }
      throw error;
    }
  }
  
  /**
   * Get GitHub client instance
   */
  getClient(): GitHubStoreClient {
    return this.client;
  }
  
  /**
   * Log a reading session
   */
  async logReadingSession(
    sourceId: string,
    paperId: string,
    session: ReadingSessionData,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists
    if (paperData) {
      await this.getOrCreatePaper({
        sourceId,
        paperId,
        url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
        title: paperData.title || paperId,
        authors: paperData.authors || '',
        abstract: paperData.abstract || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: paperData.publishedDate || '',
        tags: paperData.tags || []
      });
    }

    // Log the session as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'reading_session',
      timestamp: new Date().toISOString(),
      data: session as unknown as { [key: string]: Json }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Logged reading session for ${paperIdentifier}`, { duration: session.duration_seconds });
  }

  /**
   * Log an annotation
   */
  async logAnnotation(
    sourceId: string,
    paperId: string,
    key: string,
    value: Json,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists
    if (paperData) {
      await this.getOrCreatePaper({
        sourceId,
        paperId,
        url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
        title: paperData.title || paperId,
        authors: paperData.authors || '',
        abstract: paperData.abstract || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: paperData.publishedDate || '',
        tags: paperData.tags || []
      });
    }

    // Log the annotation as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'annotation',
      timestamp: new Date().toISOString(),
      data: { key, value }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Logged annotation for ${paperIdentifier}`, { key });
  }

  /**
   * Update paper rating
   */
  async updateRating(
    sourceId: string,
    paperId: string,
    rating: string,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists and get current data
    const paper = await this.getOrCreatePaper({
      sourceId,
      paperId,
      url: paperData?.url || this.sourceManager.formatPaperId(sourceId, paperId),
      title: paperData?.title || paperId,
      authors: paperData?.authors || '',
      abstract: paperData?.abstract || '',
      timestamp: new Date().toISOString(),
      rating: 'novote',
      publishedDate: paperData?.publishedDate || '',
      tags: paperData?.tags || []
    });

    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    
    // Update paper metadata with new rating
    await this.client.updateObject(objectId, { 
      ...paper,
      rating 
    });

    // Log rating change as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'rating',
      timestamp: new Date().toISOString(),
      data: { rating }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Updated rating for ${paperIdentifier} to ${rating}`);
  }

  /**
   * Add interaction to log
   */
  private async addInteraction(sourceId: string, paperId: string, interaction: Interaction): Promise<void> {
    const log = await this.getOrCreateInteractionLog(sourceId, paperId);
    log.interactions.push(interaction);
    
    const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
    await this.client.updateObject(objectId, log as unknown as { [key: string]: Json });
  }
}



---
File: extension/papers/types.ts
---
// extension/papers/types.ts
// Updated for heartbeat-based session tracking

import type { Json } from 'gh-store-client';

/**
 * Paper metadata from any source
 */
export interface PaperMetadata {
  // Source identifier
  sourceId: string;
  
  // Paper identifier within the source
  paperId: string;
  
  // Full URL to the paper
  url: string;
  
  // Paper title
  title: string;
  
  // Authors (comma-separated)
  authors: string;
  
  // Abstract or summary
  abstract: string;
  
  // When this paper was first added
  timestamp: string;
  
  // Publication date
  publishedDate: string;
  
  // Tags or categories
  tags: string[];
  
  // User-assigned rating (novote, thumbsup, thumbsdown)
  rating: string;
  
  // Allow additional source-specific properties
  [key: string]: any;
}

/**
 * Reading session data - updated for heartbeat tracking
 */
export interface ReadingSessionData {
  // Session identifier
  session_id: string;
  
  // Paper identifiers
  source_id?: string;
  paper_id?: string;
  
  // Session timing
  start_time: string;
  end_time: string;
  
  // Heartbeat data
  heartbeat_count: number;
  
  // Duration in seconds (derived from heartbeat count)
  duration_seconds: number;
  
  // Legacy properties for backward compatibility
  idle_seconds?: number;
  total_elapsed_seconds?: number;
}

/**
 * Interaction data
 */
export interface Interaction {
  // Type of interaction (reading_session, annotation, rating)
  type: string;
  
  // When interaction occurred
  timestamp: string;
  
  // Additional data
  data: Json;
}

/**
 * Interaction log
 */
export interface InteractionLog {
  // Source identifier
  sourceId: string;
  
  // Paper identifier within the source
  paperId: string;
  
  // List of interactions
  interactions: Interaction[];

  // Index signature to make it compatible with Json type
  [key: string]: string | Interaction[] | any;
}

/**
 * Type guard for interaction log
 */
export function isInteractionLog(data: unknown): data is InteractionLog {
  const log = data as InteractionLog;
  return (
    typeof log === 'object' &&
    log !== null &&
    typeof log.sourceId === 'string' &&
    typeof log.paperId === 'string' &&
    Array.isArray(log.interactions)
  );
}



---
File: extension/popup.html
---
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      width: 400px;
      padding: 15px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .paper-info {
      margin-bottom: 15px;
    }
    .paper-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }
    .paper-authors {
      font-size: 12px;
      color: #666;
      margin-bottom: 12px;
      line-height: 1.4;
    }
    .rating-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    button {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f5f5f5;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:not(:disabled):hover {
      background: #e5e5e5;
    }
    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #666;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 4px;
      text-align: center;
    }
    /* New styles for manual logging UI */
    .manual-log-section {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #eee;
      display: none; /* Hidden by default, shown when no paper detected */
    }
    .manual-log-section h3 {
      font-size: 14px;
      margin-top: 0;
      margin-bottom: 10px;
    }
    .log-button {
      width: 100%;
      padding: 10px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      margin-bottom: 10px;
    }
    .log-button:hover {
      background: #1d4ed8;
    }
  </style>
</head>
<body>
  <div id="currentPaper" class="paper-info">
    <div id="paperTitle" class="paper-title">Loading...</div>
    <div id="paperAuthors" class="paper-authors"></div>
    <div class="rating-buttons">
      <button id="thumbsUp" disabled>👍 Interesting</button>
      <button id="thumbsDown" disabled>👎 Not Relevant</button>
    </div>
    <div id="status" class="status">Loading paper details...</div>
  </div>
  
  <!-- New section for manually logging a paper with one-click -->
  <div id="manualLogSection" class="manual-log-section">
    <h3>This page is not tracked as a paper</h3>
    <button id="logPageButton" class="log-button">Track This Page</button>
  </div>
  
  <script src="dist/popup.bundle.js"></script>
</body>
</html>



---
File: extension/popup.ts
---
// extension/popup.ts
// Popup script with refactored manual paper tracking

import { PaperMetadata } from './papers/types';

console.log('Popup script starting...');

// Function to get paper data from background script
async function getCurrentPaper(): Promise<PaperMetadata | null> {
  return new Promise((resolve) => {
    chrome.runtime.sendMessage({type: 'getCurrentPaper'}, (response) => {
      console.log('Got paper data from background:', response);
      resolve(response as PaperMetadata | null);
    });
  });
}

// Interface for message response
interface MessageResponse {
  success: boolean;
  error?: string;
  metadata?: PaperMetadata;
}

// Function to update UI with paper data
function updateUI(paperData: PaperMetadata | null): void {
  const titleElement = document.getElementById('paperTitle');
  const authorsElement = document.getElementById('paperAuthors');
  const statusElement = document.getElementById('status');
  const manualLogSection = document.getElementById('manualLogSection');

  if (!titleElement || !authorsElement || !statusElement || !manualLogSection) {
    console.error('Required DOM elements not found');
    return;
  }

  if (paperData) {
    // Show detected paper data
    titleElement.textContent = paperData.title || paperData.paperId;
    authorsElement.textContent = paperData.authors;
    statusElement.textContent = 'Paper tracked! Issue created on GitHub.';
    
    // Enable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = false;
      thumbsDownButton.disabled = false;
      
      // Set active state on rating buttons
      thumbsUpButton.classList.toggle('active', paperData.rating === 'thumbsup');
      thumbsDownButton.classList.toggle('active', paperData.rating === 'thumbsdown');
    }
    
    // Hide manual log section
    manualLogSection.style.display = 'none';
  } else {
    // No paper detected - show manual log option
    titleElement.textContent = 'No paper detected';
    authorsElement.textContent = '';
    statusElement.textContent = 'Current page not recognized as a paper';
    
    // Disable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = true;
      thumbsDownButton.disabled = true;
    }
    
    // Show manual log section
    manualLogSection.style.display = 'block';
  }
}

// Function to log current page as a paper (using content script extraction)
async function logCurrentPage(): Promise<void> {
  console.log("attempting to log paper");
  
  // Get the active tab
  const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
  if (!tabs[0] || !tabs[0].id) {
    const statusElement = document.getElementById('status');
    if (statusElement) {
      statusElement.textContent = 'Error: Could not access current tab';
    }
    return;
  }
  
  // Show loading state
  const statusElement = document.getElementById('status');
  if (statusElement) {
    statusElement.textContent = 'Extracting paper metadata...';
  }
  
  // Send message to content script requesting extraction
  chrome.tabs.sendMessage(tabs[0].id, { 
    type: 'extractPaperMetadata' 
  }, (response: MessageResponse) => {
    if (chrome.runtime.lastError) {
      // Handle error
      if (statusElement) {
        statusElement.textContent = 'Error: ' + chrome.runtime.lastError.message;
      }
      return;
    }
    
    if (!response || !response.success || !response.metadata) {
      // Handle extraction failure
      if (statusElement) {
        statusElement.textContent = 'Error: ' + (response?.error || 'Failed to extract metadata');
      }
      return;
    }
    
    // Success - update UI
    updateUI(response.metadata);
    if (statusElement) {
      statusElement.textContent = 'Paper tracked successfully!';
    }
    
    // The content script has already:
    // 1. Sent metadata to background script
    // 2. Started a session if the tab is visible
    
    // Hide manual log section
    const manualLogSection = document.getElementById('manualLogSection');
    if (manualLogSection) {
      manualLogSection.style.display = 'none';
    }
    
    // Enable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = false;
      thumbsDownButton.disabled = false;
    }
  });
}

// Initialize popup
document.addEventListener('DOMContentLoaded', async () => {
  console.log('Popup opened');
  
  // Get paper from the session tracker
  let paperData: PaperMetadata | null = null;
  let retries = 3;
  
  while (retries > 0 && !paperData) {
    paperData = await getCurrentPaper();
    if (!paperData) {
      await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
      retries--;
    }
  }
  
  updateUI(paperData);
  
  // Set up rating handlers
  const thumbsUpButton = document.getElementById('thumbsUp');
  if (thumbsUpButton) {
    thumbsUpButton.addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsup'
      }, (response: MessageResponse) => {
        const statusElement = document.getElementById('status');
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        
        if (!statusElement || !thumbsUpButton || !thumbsDownButton) return;
        
        if (response && response.success) {
          statusElement.textContent = 'Rating updated to: thumbs up';
          thumbsUpButton.classList.add('active');
          thumbsDownButton.classList.remove('active');
          setTimeout(() => window.close(), 1500);
        } else {
          statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
        }
      });
    });
  }
  
  const thumbsDownButton = document.getElementById('thumbsDown');
  if (thumbsDownButton) {
    thumbsDownButton.addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsdown'
      }, (response: MessageResponse) => {
        const statusElement = document.getElementById('status');
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        
        if (!statusElement || !thumbsUpButton || !thumbsDownButton) return;
        
        if (response && response.success) {
          statusElement.textContent = 'Rating updated to: thumbs down';
          thumbsDownButton.classList.add('active');
          thumbsUpButton.classList.remove('active');
          setTimeout(() => window.close(), 1500);
        } else {
          statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
        }
      });
    });
  }
  
  // Set up one-click logging button
  const logPageButton = document.getElementById('logPageButton');
  if (logPageButton) {
    console.log("Attaching logPageButton event listener...");
    logPageButton.addEventListener('click', () => {
      console.log("logPageButton clicked...");
      logCurrentPage();
    });
  }
});



---
File: extension/rollup.config.js
---
// rollup.config.js
import typescript from '@rollup/plugin-typescript';
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import { terser } from 'rollup-plugin-terser';

export default [
  // Background script as ESM (module)
  {
    input: 'background.ts',
    output: {
      file: 'dist/background.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  },
  // Content script as IIFE (non-module)
  {
    input: 'content.ts',
    output: {
      file: 'dist/content-script.js',
      format: 'iife', // Immediately-invoked function expression - no imports needed
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs(),
      terser() // Minify for production (optional)
    ]
  },
  // Options script
  {
    input: 'options.ts',
    output: {
      file: 'dist/options.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  },
  // Popup script - converted to TypeScript
  {
    input: 'popup.ts',
    output: {
      file: 'dist/popup.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  }
];



---
File: extension/source-integration/arxiv/index.ts
---
// extension/source-integration/arxiv/index.ts
// ArXiv integration with custom metadata extractor

import { BaseSourceIntegration } from '../base-source';
import { PaperMetadata } from '../../papers/types';
import { MetadataExtractor, createMetadataExtractor } from '../../utils/metadata-extractor';
import { loguru } from '../../utils/logger';

const logger = loguru.getLogger('arxiv-integration');


/**
 * ArXiv integration with custom metadata extraction
 */
export class ArXivIntegration extends BaseSourceIntegration {
  readonly id = 'arxiv';
  readonly name = 'arXiv.org';
  
  // URL patterns for papers
  readonly urlPatterns = [
    /arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,
    /arxiv\.org\/\w+\/([0-9.]+)/
  ];
  
  // Content script matches
  readonly contentScriptMatches = [
    "*://*.arxiv.org/*"
  ];

  /**
   * Extract paper ID from URL
   */
  extractPaperId(url: string): string | null {
    for (const pattern of this.urlPatterns) {
      const match = url.match(pattern);
      if (match) {
        return match[2] || match[1]; // The capture group with the paper ID
      }
    }
    return null;
  }

  /**
   * Extract metadata from page or fetch from API
   * Override parent method to handle the API fallback
   */
  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {
    logger.info(`Extracting metadata for arXiv ID: ${paperId}`);
    
    // Try to extract from page first using our custom extractor
    const pageMetadata = await super.extractMetadata(document, paperId);
    
    // if (pageMetadata && pageMetadata.title && pageMetadata.authors) {
    logger.debug('Extracted metadata from page');
    return pageMetadata;
    // }
    
  }
}

// Export a singleton instance that can be used by both background and content scripts
export const arxivIntegration = new ArXivIntegration();



---
File: extension/source-integration/base-source.ts
---
// extension/source-integration/base-source.ts
// Base class for source integrations with default identifier formatting
// and metadata extraction capability

import { SourceIntegration } from './types';
import { PaperMetadata } from '../papers/types';
import { loguru } from '../utils/logger';
import { 
  MetadataExtractor, 
  createMetadataExtractor,
  generatePaperIdFromUrl
} from '../utils/metadata-extractor';

const logger = loguru.getLogger('base-source');

/**
 * Base class for source integrations
 * Provides default implementations for all methods
 * Specific sources can override as needed
 */
export class BaseSourceIntegration implements SourceIntegration {
  // Default properties - set for generic web pages
  readonly id: string = 'url';
  readonly name: string = 'Web Page';
  readonly urlPatterns: RegExp[] = [
    /^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i  // Match HTTP/HTTPS URLs that aren't PDFs
  ];
  readonly contentScriptMatches: string[] = [];

  /**
   * Check if this integration can handle the given URL
   * Default implementation checks against urlPatterns
   */
  canHandleUrl(url: string): boolean {
    return this.urlPatterns.some(pattern => pattern.test(url));
  }

  /**
   * Extract paper ID from URL
   * Default implementation creates a hash from the URL
   */
  extractPaperId(url: string): string | null {
    return generatePaperIdFromUrl(url);
  }
  
  /**
   * Create a metadata extractor for the given document
   * Override this method to provide a custom extractor for your source
   */
  protected createMetadataExtractor(document: Document): MetadataExtractor {
    return createMetadataExtractor(document);
  }
  
  /**
   * Extract metadata from a page
   * Default implementation uses common metadata extraction
   */
  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {
    try {
      logger.debug(`Extracting metadata using base extractor for ID: ${paperId}`);
      
      // Create a metadata extractor for this document
      const extractor = this.createMetadataExtractor(document);
      
      // Extract metadata
      const extracted = extractor.extract();
      const url = document.location.href;
      
      // Determine source type (PDF or URL)
      const sourceType = extractor.getSourceType();
      
      // Create PaperMetadata object
      return {
        sourceId: this.id,
        //paperId: this.formatPaperId(paperId),
        paperId: paperId,
        url: url,
        title: extracted.title || document.title || paperId,
        authors: extracted.authors || '',
        abstract: extracted.description || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: extracted.publishedDate || '',
        tags: extracted.tags || [],
        doi: extracted.doi,
        journalName: extracted.journalName,
        sourceType: sourceType // Store the source type for reference
      };
    } catch (error) {
      logger.error('Error extracting metadata with base extractor', error);
      return null;
    }
  }
  
  /**
   * Format a paper identifier for this source
   * Default implementation uses the format: sourceId.paperId
   */
  formatPaperId(paperId: string): string {
    return `${this.id}.${paperId}`;
  }
  
  /**
   * Parse a paper identifier specific to this source
   * Default implementation handles source.paperId format and extracts paperId
   */
  parsePaperId(identifier: string): string | null {
    const prefix = `${this.id}.`;
    
    if (identifier.startsWith(prefix)) {
      return identifier.substring(prefix.length);
    }
    
    // Try legacy format (sourceId:paperId)
    const legacyPrefix = `${this.id}:`;
    if (identifier.startsWith(legacyPrefix)) {
      logger.debug(`Parsed legacy format identifier: ${identifier}`);
      return identifier.substring(legacyPrefix.length);
    }
    
    return null;
  }
  
  /**
   * Format a storage object ID for this source
   * Default implementation uses the format: type:sourceId.paperId
   */
  formatObjectId(type: string, paperId: string): string {
    return `${type}:${this.formatPaperId(paperId)}`;
  }
}



---
File: extension/source-integration/index.ts
---
// extension/source-integration/index.ts
// Create a barrel file to export all source integrations

import { arxivIntegration } from './arxiv';

// Export all available integrations
export const availableIntegrations = [
  arxivIntegration,
];

// Export individual integrations
export {
  arxivIntegration,
};



---
File: extension/source-integration/link-processor.ts
---
// extension/source-integration/link-processor.ts
// Generic link detection and processing module

import { loguru } from '../utils/logger';

const logger = loguru.getLogger('link-processor');

interface LinkPattern {
  // Source integration ID
  sourceId: string;
  
  // Regular expression to match URLs
  pattern: RegExp;
  
  // Function to extract paper ID from URL
  extractPaperId: (url: string) => string | null;
}

export class LinkProcessor {
  private patterns: LinkPattern[] = [];
  private observer: MutationObserver | null = null;
  private processedLinks = new Set<string>();
  private onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void;
  
  constructor(onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void) {
    this.onLinkFound = onLinkFound;
    logger.debug('Link processor initialized');
  }
  
  /**
   * Register a new link pattern
   */
  registerPattern(pattern: LinkPattern): void {
    this.patterns.push(pattern);
    logger.debug(`Registered pattern for ${pattern.sourceId}`);
  }
  
  /**
   * Process all links in the document
   */
  processLinks(document: Document): void {
    // Process all links in the document
    const links = document.querySelectorAll<HTMLAnchorElement>('a[href]');
    
    links.forEach(link => {
      // Use a unique identifier for this link
      const linkId = this.getLinkId(link);
      
      // Skip if already processed
      if (this.processedLinks.has(linkId)) {
        return;
      }
      
      this.processedLinks.add(linkId);
      
      // Check each pattern
      for (const pattern of this.patterns) {
        if (pattern.pattern.test(link.href)) {
          const paperId = pattern.extractPaperId(link.href);
          
          if (paperId) {
            // Call the callback
            this.onLinkFound(pattern.sourceId, paperId, link);
            break; // Stop after first match
          }
        }
      }
    });
  }
  
  /**
   * Start observing for DOM changes
   */
  startObserving(document: Document): void {
    if (this.observer) {
      this.observer.disconnect();
    }
    
    this.observer = new MutationObserver((mutations) => {
      let newLinks = false;
      
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // If this is an anchor tag, check it
            if ((node as Element).tagName === 'A') {
              newLinks = true;
            }
            
            // Check for any anchor tags within this element
            const links = (node as Element).querySelectorAll('a[href]');
            if (links.length > 0) {
              newLinks = true;
            }
          }
        });
      });
      
      if (newLinks) {
        this.processLinks(document);
      }
    });
    
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    logger.debug('Started observing for DOM changes');
  }
  
  /**
   * Create a unique ID for a link
   */
  private getLinkId(link: HTMLAnchorElement): string {
    // Use href and position in document to create a unique ID
    const path = this.getElementPath(link);
    return `${link.href}|${path}`;
  }
  
  /**
   * Get element path in DOM for identification
   */
  private getElementPath(element: Element): string {
    const path: string[] = [];
    let current: Element | null = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.id) {
        selector += `#${current.id}`;
      } else {
        const siblings = Array.from(current.parentElement?.children || []);
        const index = siblings.indexOf(current) + 1;
        if (siblings.length > 1) {
          selector += `:nth-child(${index})`;
        }
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    return path.join(' > ');
  }
  
  /**
   * Stop observing DOM changes
   */
  stopObserving(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
      logger.debug('Stopped observing DOM changes');
    }
  }
}



---
File: extension/source-integration/source-manager.ts
---
// extension/source-integration/source-manager.ts
// Updated SourceIntegrationManager to use source-specific identifier formatting

import { SourceIntegration, SourceManager } from './types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('source-manager');

/**
 * Manages source integrations
 */
export class SourceIntegrationManager implements SourceManager {
  private sources: Map<string, SourceIntegration> = new Map();
  
  constructor() {
    logger.info('Source integration manager initialized');
  }
  
  /**
   * Register a source integration
   */
  registerSource(source: SourceIntegration): void {
    if (this.sources.has(source.id)) {
      logger.warning(`Source with ID '${source.id}' already registered, overwriting`);
    }
    
    this.sources.set(source.id, source);
    logger.info(`Registered source: ${source.name} (${source.id})`);
  }
  
  /**
   * Get all registered sources
   */
  getAllSources(): SourceIntegration[] {
    return Array.from(this.sources.values());
  }
  
  /**
   * Get source that can handle a URL
   */
  getSourceForUrl(url: string): SourceIntegration | null {
    for (const source of this.sources.values()) {
      if (source.canHandleUrl(url)) {
        logger.debug(`Found source for URL '${url}': ${source.id}`);
        return source;
      }
    }
    
    logger.debug(`No source found for URL: ${url}`);
    return null;
  }
  
  /**
   * Get source by ID
   */
  getSourceById(sourceId: string): SourceIntegration | null {
    const source = this.sources.get(sourceId);
    return source || null;
  }
  
  /**
   * Extract paper ID from URL using appropriate source
   */
  extractPaperId(url: string): { sourceId: string, paperId: string } | null {
    for (const source of this.sources.values()) {
      if (source.canHandleUrl(url)) {
        const paperId = source.extractPaperId(url);
        if (paperId) {
          logger.debug(`Extracted paper ID '${paperId}' from URL using ${source.id}`);
          return { sourceId: source.id, paperId };
        }
      }
    }
    
    logger.debug(`Could not extract paper ID from URL: ${url}`);
    return null;
  }
  
  /**
   * Format a paper identifier using the appropriate source
   */
  formatPaperId(sourceId: string, paperId: string): string {
    const source = this.sources.get(sourceId);
    
    if (source) {
      return source.formatPaperId(paperId);
    }
    
    // Fallback if source not found
    logger.warning(`Source '${sourceId}' not found, using default format for paper ID`);
    return `${sourceId}.${paperId}`;
  }
  
  /**
   * Format an object ID using the appropriate source
   */
  formatObjectId(type: string, sourceId: string, paperId: string): string {
    const source = this.sources.get(sourceId);
    
    if (source) {
      return source.formatObjectId(type, paperId);
    }
    
    // Fallback if source not found
    logger.warning(`Source '${sourceId}' not found, using default format for object ID`);
    return `${type}:${sourceId}.${paperId}`;
  }
  
  /**
   * Get all content script match patterns
   */
  getAllContentScriptMatches(): string[] {
    const patterns: string[] = [];
    
    for (const source of this.sources.values()) {
      patterns.push(...source.contentScriptMatches);
    }
    
    return patterns;
  }
}



---
File: extension/source-integration/types.ts
---
// extension/source-integration/types.ts
// Updated SourceIntegration interface with identifier formatting methods

import type { Json } from 'gh-store-client';
import type { PaperMetadata } from '../papers/types';

/**
 * Source integration interface
 * Implementations should be importable by both background and content scripts
 */
export interface SourceIntegration {
  // Unique identifier
  readonly id: string;
  
  // Human-readable name
  readonly name: string;
  
  // URL patterns for matching papers from this source (as RegExp patterns)
  readonly urlPatterns: RegExp[];
  
  // Domain match patterns for content script registration
  readonly contentScriptMatches: string[];
  
  // Check if URL is from this source
  canHandleUrl(url: string): boolean;
  
  // Extract paper ID from URL
  extractPaperId(url: string): string | null;
  
  // Extract metadata from page or API
  extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null>;
  
  // Format a paper identifier (sourceId + paperId) for this source
  formatPaperId(paperId: string): string;
  
  // Parse a paper identifier specific to this source
  parsePaperId(identifier: string): string | null;
  
  // Format a storage object ID for this source
  formatObjectId(type: string, paperId: string): string;
}

/**
 * Manager interface for source integrations
 */
export interface SourceManager {
  // Register a source integration
  registerSource(source: SourceIntegration): void;
  
  // Get all registered sources
  getAllSources(): SourceIntegration[];
  
  // Get source for a given URL
  getSourceForUrl(url: string): SourceIntegration | null;
  
  // Extract paper ID from URL using appropriate source
  extractPaperId(url: string): { sourceId: string, paperId: string } | null;
  
  // Format a paper identifier using the appropriate source
  formatPaperId(sourceId: string, paperId: string): string;
  
  // Format an object ID using the appropriate source
  formatObjectId(type: string, sourceId: string, paperId: string): string;
}

// Other existing types...
// Message types for communication between background and content scripts

// Content script ready notification
export interface ContentScriptReadyMessage {
  type: 'contentScriptReady';
  url: string;
}

// Paper metadata message
export interface PaperMetadataMessage {
  type: 'paperMetadata';
  metadata: PaperMetadata;
}

// Start session message (new)
export interface StartSessionMessage {
  type: 'startSession';
  sourceId: string;
  paperId: string;
}

// Session heartbeat message (new)
export interface SessionHeartbeatMessage {
  type: 'sessionHeartbeat';
  sourceId: string;
  paperId: string;
  timestamp: number;
}

// End session message (new)
export interface EndSessionMessage {
  type: 'endSession';
  sourceId: string;
  paperId: string;
  reason?: string;
}

// Show annotation popup request
export interface ShowAnnotationPopupMessage {
  type: 'showAnnotationPopup';
  sourceId: string;
  paperId: string;
  position: { x: number, y: number };
}

// Popup action message
export interface PopupActionMessage {
  type: 'popupAction';
  action: string;
  sourceId: string;
  paperId: string;
  data: any;
}

// Show popup message
export interface ShowPopupMessage {
  type: 'showPopup';
  sourceId: string;
  paperId: string;
  html: string;
  handlers: Array<{
    selector: string;
    event: string;
    action: string;
  }>;
  position?: { x: number, y: number };
}

// Process page message
export interface ProcessPageMessage {
  type: 'processPage';
}

// Get current paper message
export interface GetCurrentPaperMessage {
  type: 'getCurrentPaper';
}

// Update rating message
export interface UpdateRatingMessage {
  type: 'updateRating';
  rating: string;
}

// Union type for all message types
export type Message = 
  | ContentScriptReadyMessage
  | PaperMetadataMessage
  | StartSessionMessage
  | SessionHeartbeatMessage
  | EndSessionMessage
  | ShowAnnotationPopupMessage
  | PopupActionMessage
  | ShowPopupMessage
  | ProcessPageMessage
  | GetCurrentPaperMessage
  | UpdateRatingMessage;



---
File: extension/tsconfig.json
---
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2020", "DOM"],
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "types": ["chrome", "@types/node"],
    "outDir": "dist",
    "baseUrl": "."
  },
  "include": [
    "**/*.ts",
    "background.js",
    "content.js",
    "popup.js",
    "options.js"
  ],
  "exclude": ["node_modules", "dist"]
}



---
File: extension/utils/logger.ts
---
// utils/logger.ts
// Logging utility wrapping loguru

/**
 * Logger class for consistent logging throughout the extension
 */
export class Logger {
  constructor(private module: string) {}
  
  /**
   * Log debug message
   */
  debug(message: string, data?: any): void {
    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log info message
   */
  info(message: string, data?: any): void {
    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log warning message
   */
  warning(message: string, data?: any): void {
    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log error message
   */
  error(message: string, data?: any): void {
    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
}

/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
  /**
   * Get logger for a module
   */
  getLogger(module: string): Logger {
    return new Logger(module);
  }
}

// Export singleton instance
export const loguru = new LoguruMock();



---
File: extension/utils/metadata-extractor.ts
---
// extension/utils/metadata-extractor.ts
// Object-oriented metadata extraction system with customizable extraction methods

import { loguru } from './logger';

const logger = loguru.getLogger('metadata-extractor');

export interface ExtractedMetadata {
  title: string;
  authors: string;
  description: string;
  publishedDate: string;
  doi?: string;
  journalName?: string;
  tags?: string[];
  url?: string;
}

// Constants for standard source types
export const SOURCE_TYPES = {
  PDF: 'pdf',
  URL: 'url',
} as const;

export type SourceType = typeof SOURCE_TYPES[keyof typeof SOURCE_TYPES];

/**
 * Base class for metadata extraction with customizable extraction methods
 * Each method can be overridden to provide source-specific extraction
 */
export class MetadataExtractor {
  protected document: Document;
  protected url: string;
  
  /**
   * Create a new metadata extractor for a document
   */
  constructor(document: Document) {
    this.document = document;
    this.url = document.location.href;
    logger.debug('Initialized metadata extractor for:', this.url);
  }
  
  /**
   * Helper method to get content from meta tags
   */
  protected getMetaContent(selector: string): string {
    const element = this.document.querySelector(selector);
    return element ? element.getAttribute('content') || '' : '';
  }
  
  /**
   * Extract and return all metadata fields
   */
  public extract(): ExtractedMetadata {
    logger.debug('Extracting metadata from page:', this.url);
    
    const metadata: ExtractedMetadata = {
      title: this.extractTitle(),
      authors: this.extractAuthors(),
      description: this.extractDescription(),
      publishedDate: this.extractPublishedDate(),
      doi: this.extractDoi(),
      journalName: this.extractJournalName(),
      tags: this.extractTags(),
      url: this.url
    };
    
    logger.debug('Metadata extraction complete:', metadata);
    return metadata;
  }
  
  /**
   * Extract title from document
   * Considers multiple metadata standards with priority order
   */
  protected extractTitle(): string {
    // Title extraction - priority order
    return (
      // Dublin Core
      this.getMetaContent('meta[name="DC.Title"]') ||
      // Citation
      this.getMetaContent('meta[name="citation_title"]') ||
      // Open Graph
      this.getMetaContent('meta[property="og:title"]') ||
      // Standard meta
      this.getMetaContent('meta[name="title"]') ||
      // Fallback to document title
      this.document.title
    );
  }
  
  /**
   * Extract authors from document
   * Handles multiple author formats and sources
   */
  protected extractAuthors(): string {
    // Get all citation authors (some pages have multiple citation_author tags)
    const citationAuthors: string[] = [];
    this.document.querySelectorAll('meta[name="citation_author"]').forEach(el => {
      const content = el.getAttribute('content');
      if (content) citationAuthors.push(content);
    });
    
    // Get all DC creators
    const dcCreators: string[] = [];
    this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach(el => {
      const content = el.getAttribute('content');
      if (content) dcCreators.push(content);
    });
    
    // Individual author elements
    const dcCreator = this.getMetaContent('meta[name="DC.Creator.PersonalName"]');
    const citationAuthor = this.getMetaContent('meta[name="citation_author"]');
    const ogAuthor = this.getMetaContent('meta[property="og:article:author"]') ||
                    this.getMetaContent('meta[name="author"]');
    
    // Set authors with priority
    if (dcCreators.length > 0) {
      return dcCreators.join(', ');
    } else if (citationAuthors.length > 0) {
      return citationAuthors.join(', ');
    } else if (dcCreator) {
      return dcCreator;
    } else if (citationAuthor) {
      return citationAuthor;
    } else if (ogAuthor) {
      return ogAuthor;
    }
    
    return '';
  }
  
  /**
   * Extract description/abstract from document
   */
  protected extractDescription(): string {
    return (
      this.getMetaContent('meta[name="DC.Description"]') ||
      this.getMetaContent('meta[name="citation_abstract"]') ||
      this.getMetaContent('meta[property="og:description"]') ||
      this.getMetaContent('meta[name="description"]')
    );
  }
  
  /**
   * Extract publication date from document
   */
  protected extractPublishedDate(): string {
    return (
      this.getMetaContent('meta[name="DC.Date.issued"]') ||
      this.getMetaContent('meta[name="citation_date"]') ||
      this.getMetaContent('meta[property="article:published_time"]')
    );
  }
  
  /**
   * Extract DOI (Digital Object Identifier) from document
   */
  protected extractDoi(): string {
    return (
      this.getMetaContent('meta[name="DC.Identifier.DOI"]') ||
      this.getMetaContent('meta[name="citation_doi"]')
    );
  }
  
  /**
   * Extract journal name from document
   */
  protected extractJournalName(): string {
    return (
      this.getMetaContent('meta[name="DC.Source"]') ||
      this.getMetaContent('meta[name="citation_journal_title"]')
    );
  }
  
  /**
   * Extract keywords/tags from document
   */
  protected extractTags(): string[] {
    const keywords = this.getMetaContent('meta[name="keywords"]') ||
                    this.getMetaContent('meta[name="DC.Subject"]');
    
    if (keywords) {
      return keywords.split(',').map(tag => tag.trim());
    }
    
    return [];
  }
  
  /**
   * Determine if the current URL is a PDF
   */
  public isPdf(): boolean {
    return isPdfUrl(this.url);
  }
  
  /**
   * Get the source type (PDF or URL)
   */
  public getSourceType(): SourceType {
    return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;
  }
  
  /**
   * Generate a paper ID for the current URL
   */
  public generatePaperId(): string {
    return generatePaperIdFromUrl(this.url);
  }
}

/**
 * Create a common metadata extractor for a document
 * Factory function for creating the default extractor
 */
export function createMetadataExtractor(document: Document): MetadataExtractor {
  return new MetadataExtractor(document);
}

/**
 * Extract common metadata from a document
 * Convenience function for quick extraction
 */
export function extractCommonMetadata(document: Document): ExtractedMetadata {
  return createMetadataExtractor(document).extract();
}

/**
 * Generate a paper ID from a URL
 * Creates a consistent hash-based identifier
 */
export function generatePaperIdFromUrl(url: string): string {
  // Use a basic hash function to create an ID from the URL
  let hash = 0;
  for (let i = 0; i < url.length; i++) {
    const char = url.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Create a positive hexadecimal string
  const positiveHash = Math.abs(hash).toString(16).toUpperCase();
  
  // Use the first 8 characters as the ID
  return positiveHash.substring(0, 8);
}

/**
 * Determine if a URL is a PDF
 */
export function isPdfUrl(url: string): boolean {
  return url.toLowerCase().endsWith('.pdf');
}



---
File: extension/utils/popup-manager.ts
---
// extension/utils/popup-manager.ts
// Popup management system integrated with source manager

import { SourceManager } from '../source-integration/types';
import { PaperManager } from '../papers/manager';
import { PaperMetadata } from '../papers/types';
import { loguru } from './logger';

const logger = loguru.getLogger('popup-manager');

/**
 * Popup handler information
 */
interface PopupHandler {
  selector: string;
  event: string;
  action: string;
}

/**
 * Popup message type
 */
interface ShowPopupMessage {
  type: 'showPopup';
  sourceId: string;
  paperId: string;
  html: string;
  handlers: PopupHandler[];
  position?: { x: number, y: number };
}

/**
 * Manages all popup-related functionality
 */
export class PopupManager {
  // Source manager and paper manager
  private sourceManagerProvider: () => SourceManager | null;
  private paperManagerProvider: () => PaperManager | null;
  
  /**
   * Create a new popup manager
   */
  constructor(
    sourceManagerProvider: () => SourceManager | null,
    paperManagerProvider: () => PaperManager | null
  ) {
    this.sourceManagerProvider = sourceManagerProvider;
    this.paperManagerProvider = paperManagerProvider;
    
    this.setupMessageListeners();
    logger.debug('Popup manager initialized');
  }
  
  /**
   * Set up message listeners for popup-related messages
   */
  private setupMessageListeners(): void {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Handle popup actions (ratings, notes, etc.)
      if (message.type === 'popupAction') {
        this.handlePopupAction(
          message.sourceId,
          message.paperId,
          message.action,
          message.data
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error handling popup action', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      // Handle request to show annotation popup
      if (message.type === 'showAnnotationPopup' && sender.tab?.id) {
        this.handleShowAnnotationPopup(
          sender.tab.id,
          message.sourceId,
          message.paperId,
          message.position
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error showing popup', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      return false; // Not handled
    });
  }
  
  /**
   * Handle a request to show an annotation popup
   */
  private async handleShowAnnotationPopup(
    tabId: number,
    sourceId: string,
    paperId: string,
    position: { x: number, y: number }
  ): Promise<void> {
    logger.debug(`Showing annotation popup for ${sourceId}:${paperId}`);
    
    // Check if we have source and paper manager
    const sourceManager = this.sourceManagerProvider();
    const paperManager = this.paperManagerProvider();
    
    if (!sourceManager) {
      throw new Error('Source manager not initialized');
    }
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    try {
      // Get paper data
      const paper = await paperManager.getPaper(sourceId, paperId);
      
      // Create popup HTML
      const html = this.createPopupHtml(paper || { 
        sourceId, 
        paperId,
        title: paperId,
        authors: '',
        abstract: '',
        url: '',
        timestamp: new Date().toISOString(),
        publishedDate: '',
        tags: [],
        rating: 'novote'
      });
      
      // Get handlers
      const handlers = this.getStandardPopupHandlers();
      
      // Send message to content script to show popup
      const message: ShowPopupMessage = {
        type: 'showPopup',
        sourceId,
        paperId,
        html,
        handlers,
        position
      };
      
      await chrome.tabs.sendMessage(tabId, message);
      
      logger.debug(`Sent popup to content script for ${sourceId}:${paperId}`);
    } catch (error) {
      logger.error(`Error showing popup for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Handle popup actions (ratings, notes, etc.)
   */
  private async handlePopupAction(
    sourceId: string,
    paperId: string,
    action: string,
    data: any
  ): Promise<void> {
    const paperManager = this.paperManagerProvider();
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    logger.debug(`Handling popup action: ${action}`, { sourceId, paperId });
    
    try {
      if (action === 'rate') {
        await paperManager.updateRating(sourceId, paperId, data.value);
        logger.info(`Updated rating for ${sourceId}:${paperId} to ${data.value}`);
      } 
      else if (action === 'saveNotes') {
        if (data.value) {
          await paperManager.logAnnotation(sourceId, paperId, 'notes', data.value);
          logger.info(`Saved notes for ${sourceId}:${paperId}`);
        }
      }
    } catch (error) {
      logger.error(`Error handling action ${action} for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Create HTML for paper popup
   */
  private createPopupHtml(paper: PaperMetadata): string {
    return `
      <div class="paper-popup-header">${paper.title || paper.paperId}</div>
      <div class="paper-popup-meta">${paper.authors || ''}</div>
      
      <div class="paper-popup-buttons">
        <button class="vote-button" data-vote="thumbsup" id="btn-thumbsup" ${paper.rating === 'thumbsup' ? 'class="active"' : ''}>👍 Interesting</button>
        <button class="vote-button" data-vote="thumbsdown" id="btn-thumbsdown" ${paper.rating === 'thumbsdown' ? 'class="active"' : ''}>👎 Not Relevant</button>
      </div>
      
      <textarea placeholder="Add notes about this paper..." id="paper-notes"></textarea>
      
      <div class="paper-popup-actions">
        <button class="save-button" id="btn-save">Save</button>
      </div>
    `;
  }
  
  /**
   * Get standard popup event handlers
   */
  private getStandardPopupHandlers(): PopupHandler[] {
    return [
      { selector: '#btn-thumbsup', event: 'click', action: 'rate' },
      { selector: '#btn-thumbsdown', event: 'click', action: 'rate' },
      { selector: '#btn-save', event: 'click', action: 'saveNotes' }
    ];
  }
}



---
File: extension/utils/session-service.ts
---
// session-service.ts
// Simplified session tracking service for background script

import { loguru } from './logger';
import { PaperManager } from '../papers/manager';
import { ReadingSessionData, PaperMetadata } from '../papers/types';

const logger = loguru.getLogger('session-service');

/**
 * Session tracking service for paper reading sessions
 * 
 * Manages session state, heartbeats, and persistence
 * Designed for use in the background script (Service Worker)
 */
export class SessionService {
  private activeSession: {
    sourceId: string;
    paperId: string;
    startTime: Date;
    heartbeatCount: number;
    lastHeartbeatTime: Date;
  } | null = null;
  
  private timeoutId: number | null = null;
  private paperMetadata: Map<string, PaperMetadata> = new Map();
  
  // Configuration
  private readonly HEARTBEAT_TIMEOUT = 15000; // 15 seconds
  
  /**
   * Create a new session service
   */
  constructor(private paperManager: PaperManager | null) {
    logger.debug('Session service initialized');
  }
  
  /**
   * Start a new session for a paper
   */
  startSession(sourceId: string, paperId: string, metadata?: PaperMetadata): void {
    // End any existing session
    this.endSession();
    
    // Create new session
    this.activeSession = {
      sourceId,
      paperId,
      startTime: new Date(),
      heartbeatCount: 0,
      lastHeartbeatTime: new Date()
    };
    
    // Store metadata if provided
    if (metadata) {
      const key = `${sourceId}:${paperId}`;
      this.paperMetadata.set(key, metadata);
      logger.debug(`Stored metadata for ${key}`);
    }
    
    // Start timeout check
    this.scheduleTimeoutCheck();
    
    logger.info(`Started session for ${sourceId}:${paperId}`);
  }
  
  /**
   * Record a heartbeat for the current session
   */
  recordHeartbeat(): boolean {
    if (!this.activeSession) {
      return false;
    }
    
    this.activeSession.heartbeatCount++;
    this.activeSession.lastHeartbeatTime = new Date();
    
    // Reschedule timeout
    this.scheduleTimeoutCheck();
    
    if (this.activeSession.heartbeatCount % 12 === 0) { // Log every minute (12 x 5sec heartbeats)
      logger.debug(`Session received ${this.activeSession.heartbeatCount} heartbeats`);
    }
    
    return true;
  }
  
  /**
   * Schedule a check for heartbeat timeout
   */
  private scheduleTimeoutCheck(): void {
    // Clear existing timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
    }
    
    // Set new timeout
    this.timeoutId = self.setTimeout(() => {
      this.checkTimeout();
    }, this.HEARTBEAT_TIMEOUT);
  }
  
  /**
   * Check if the session has timed out due to missing heartbeats
   */
  private checkTimeout(): void {
    if (!this.activeSession) return;
    
    const now = Date.now();
    const lastTime = this.activeSession.lastHeartbeatTime.getTime();
    
    if ((now - lastTime) > this.HEARTBEAT_TIMEOUT) {
      logger.info('Session timeout detected');
      this.endSession();
    } else {
      this.scheduleTimeoutCheck();
    }
  }
  
  /**
   * End the current session and get the data
   */
  endSession(): ReadingSessionData | null {
    if (!this.activeSession) return null;
    
    // Clear timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    
    const { sourceId, paperId, startTime, heartbeatCount } = this.activeSession;
    const endTime = new Date();
    
    // Calculate duration (5 seconds per heartbeat)
    const duration = heartbeatCount * 5;
    
    // Calculate total elapsed time
    const totalElapsed = endTime.getTime() - startTime.getTime();
    const totalElapsedSeconds = Math.round(totalElapsed / 1000);
    
    // Set idle seconds to the difference (for backward compatibility)
    const idleSeconds = Math.max(0, totalElapsedSeconds - duration);
    
    // Create session data
    const sessionData: ReadingSessionData = {
      session_id: `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      source_id: sourceId,
      paper_id: paperId,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      heartbeat_count: heartbeatCount,
      duration_seconds: duration,
      // Legacy fields
      idle_seconds: idleSeconds,
      total_elapsed_seconds: totalElapsedSeconds
    };
    
    // Store session if it was meaningful and we have a paper manager
    if (this.paperManager && heartbeatCount > 0) {
      const metadata = this.getPaperMetadata(sourceId, paperId);
      
      this.paperManager.logReadingSession(sourceId, paperId, sessionData, metadata)
        .catch(err => logger.error('Failed to store session', err));
    }
    
    logger.info(`Ended session for ${sourceId}:${paperId}`, {
      duration,
      heartbeats: heartbeatCount
    });
    
    // Clear active session
    this.activeSession = null;
    
    return sessionData;
  }
  
  /**
   * Check if a session is currently active
   */
  hasActiveSession(): boolean {
    return this.activeSession !== null;
  }
  
  /**
   * Get information about the current session
   */
  getCurrentSession(): { sourceId: string, paperId: string } | null {
    if (!this.activeSession) return null;
    
    return {
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId
    };
  }
  
  /**
   * Get paper metadata for the current or specified session
   */
  getPaperMetadata(sourceId?: string, paperId?: string): PaperMetadata | undefined {
    if (!sourceId || !paperId) {
      if (!this.activeSession) return undefined;
      sourceId = this.activeSession.sourceId;
      paperId = this.activeSession.paperId;
    }
    
    return this.paperMetadata.get(`${sourceId}:${paperId}`);
  }
  
  /**
   * Store paper metadata
   */
  storePaperMetadata(metadata: PaperMetadata): void {
    const key = `${metadata.sourceId}:${metadata.paperId}`;
    this.paperMetadata.set(key, metadata);
  }
  
  /**
   * Get time since last heartbeat in milliseconds
   */
  getTimeSinceLastHeartbeat(): number | null {
    if (!this.activeSession) {
      return null;
    }
    
    return Date.now() - this.activeSession.lastHeartbeatTime.getTime();
  }
  
  /**
   * Get session statistics for debugging
   */
  getSessionStats(): any {
    if (!this.activeSession) {
      return { active: false };
    }
    
    return {
      active: true,
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId,
      startTime: this.activeSession.startTime.toISOString(),
      heartbeatCount: this.activeSession.heartbeatCount,
      lastHeartbeatTime: this.activeSession.lastHeartbeatTime.toISOString(),
      elapsedTime: Math.round((Date.now() - this.activeSession.startTime.getTime()) / 1000)
    };
  }
}



---
File: frontend/scripts/convert_data.py
---
# frontend/scripts/convert_data.py
"""Convert papers YAML to JSON for web consumption."""

import yaml
import json
from pathlib import Path
import fire

def format_authors(authors: str | list[str]) -> str:
    """Format author list consistently."""
    if isinstance(authors, str):
        author_list = [a.strip() for a in authors.split(',')]
    elif isinstance(authors, list):
        author_list = authors
    else:
        return 'Unknown authors'
    
    if len(author_list) > 4:
        return f"{', '.join(author_list[:3])} and {len(author_list) - 3} others"
    return ', '.join(author_list)

def scan_features(paper_id: str, features_base: Path) -> dict[str, str]:
    """
    Scan for available features for a paper.
    
    Args:
        paper_id: Paper ID to scan features for
        features_base: Base directory containing paper data
        
    Returns:
        Dictionary mapping feature types to their content paths
    """
    paper_dir = features_base / paper_id
    features_dir = paper_dir / "features"
    
    if not features_dir.exists():
        return {}
    
    features = {}
    for feature_dir in features_dir.iterdir():
        if not feature_dir.is_dir():
            continue
            
        # Look for markdown file matching paper ID
        feature_files = list(feature_dir.glob(f"{paper_id}*.md"))
        if feature_files:
            # Use relative path from web root
            rel_path = feature_files[0].relative_to(features_base.parent)
            features[feature_dir.name] = str(rel_path)
            
    return features

def convert_data(
    yaml_path: str,
    json_path: str,
    features_base: str = "data/papers"
) -> None:
    """Convert YAML data file to JSON.
    
    Args:
        yaml_path: Path to input YAML file
        json_path: Path where JSON should be written
        features_base: Base directory containing paper data and features
    """
    yaml_path = Path(yaml_path)
    json_path = Path(json_path)
    features_base = Path(features_base)
    
    # Create output directory if needed
    json_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Read and parse YAML
    with open(yaml_path, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)
    
    # Preprocess data for frontend consumption
    processed_data = {}
    for paper_id, paper in data.items():
        if paper.get('last_read') or paper.get('last_visited'):
            # Get feature paths for this paper
            features_path = scan_features(paper_id, features_base)
            
            processed_data[paper_id] = {
                'id': paper_id,
                'title': paper.get('title', '').replace('\n', ' '),
                'authors': format_authors(paper.get('authors', [])),
                'abstract': paper.get('abstract', '').replace('\n', ' '),
                'url': paper.get('url', ''),
                'arxivId': paper.get('arxivId', ''),
                'last_visited': paper.get('last_visited', ''),
                'last_read': paper.get('last_read', ''),
                'total_reading_time_seconds': paper.get('total_reading_time_seconds', 0),
                'published_date': paper.get('published_date', ''),
                'arxiv_tags': paper.get('arxiv_tags', []),
                'features_path': features_path or None  # Only include if features exist
            }
    
    # Write JSON
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(processed_data, f, indent=2, ensure_ascii=False)

if __name__ == '__main__':
    fire.Fire(convert_data)



---
File: frontend/scripts/convert_store.py
---
# frontend/scripts/convert_store.py
"""Convert gh-store snapshot to frontend JSON format."""

import json
from pathlib import Path
import fire
from loguru import logger
from typing import Any

def format_authors(authors: str) -> str:
    """Format author list consistently."""
    author_list = [a.strip() for a in authors.split(',')]
    
    if len(author_list) > 4:
        return f"{', '.join(author_list[:3])} and {len(author_list) - 3} others"
    return ', '.join(author_list)

def get_reading_time(interactions: list[dict[str, Any]]) -> int:
    """Calculate total reading time from interaction records."""
    total_seconds = 0
    for interaction in interactions:
        if interaction['type'] == 'reading_session':
            if isinstance(interaction['data'], dict):
                total_seconds += interaction['data'].get('duration_seconds', 0)
    return total_seconds

def scan_features(paper_id: str, features_base: Path) -> dict[str, str]:
    """
    Scan for available features for a paper and ensure paper directory exists.
    
    Args:
        paper_id: Paper ID to scan features for
        features_base: Base directory containing paper data
        
    Returns:
        Dictionary mapping feature types to their content paths
    """
    paper_dir = features_base / paper_id
    # Ensure paper directory exists and has a .gitkeep file
    paper_dir.mkdir(parents=True, exist_ok=True)
    gitkeep_path = paper_dir / ".gitkeep"
    if not gitkeep_path.exists():
        gitkeep_path.touch()
    
    features_dir = paper_dir / "features"
    
    if not features_dir.exists():
        return {}
    
    features = {}
    for feature_dir in features_dir.iterdir():
        if not feature_dir.is_dir():
            continue
            
        # Look for markdown file matching paper ID
        feature_files = list(feature_dir.glob(f"{paper_id}*.md"))
        if feature_files:
            # Generate path relative to web root - should be like:
            # data/papers/<paper_id>/features/<feature_type>/<paper_id>.md
            rel_path = f"data/papers/{paper_id}/features/{feature_dir.name}/{feature_files[0].name}"
            features[feature_dir.name] = rel_path
            
    return features

def process_paper(
    paper_id: str, 
    paper_data: dict[str, Any], 
    interactions: list[dict[str, Any]],
    features_base: Path
) -> dict[str, Any]:
    """Process single paper data into frontend format."""
    # Get feature paths
    features_path = scan_features(paper_id, features_base)
    
    return {
        'id': paper_id,
        'title': paper_data.get('title', '').replace('\n', ' '),
        'authors': format_authors(paper_data.get('authors', '')),
        'abstract': paper_data.get('abstract', '').replace('\n', ' '),
        'url': paper_data.get('url', ''),
        'arxivId': paper_data.get('arxivId', ''),
        'last_visited': paper_data.get('timestamp', ''),
        'last_read': paper_data.get('timestamp', ''),  # Using same timestamp for now
        'total_reading_time_seconds': get_reading_time(interactions),
        'published_date': paper_data.get('published_date', ''),
        'arxiv_tags': paper_data.get('arxiv_tags', []),
        'features_path': features_path or None  # Only include if features exist
    }

def convert_store(
    snapshot_path: str,
    output_path: str,
    archive_path: str | None = None,
    features_base: str = "data/papers"
) -> None:
    """Convert gh-store snapshot to frontend JSON format.
    
    Args:
        snapshot_path: Path to gh-store snapshot JSON
        output_path: Path where frontend JSON should be written
        archive_path: Optional path to archive JSON to merge with
        features_base: Base directory containing paper data and features
    """
    snapshot_path = Path(snapshot_path)
    output_path = Path(output_path)
    features_base = Path(features_base)
    
    # Create output directory
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Read snapshot
    logger.info(f"Reading snapshot from {snapshot_path}")
    with open(snapshot_path, 'r', encoding='utf-8') as f:
        snapshot = json.load(f)
    
    # Process papers
    papers = {}
    interaction_data = {}
    
    # First pass - collect interaction data
    for obj_id, obj in snapshot['objects'].items():
        if obj_id.startswith('interactions:'):
            paper_id = obj_id.split(':', 1)[1]
            interaction_data[paper_id] = obj['data']['interactions']
    
    # Second pass - process papers with their interactions
    for obj_id, obj in snapshot['objects'].items():
        if not obj_id.startswith('paper:'):
            continue
            
        paper_id = obj_id.split(':', 1)[1]
        paper_data = obj['data']
        interactions = interaction_data.get(paper_id, [])
        papers[paper_id] = process_paper(
            paper_id, 
            paper_data, 
            interactions,
            features_base
        )
    
    # Backpopulate from archive if provided
    logger.info(f"Loaded {len(papers)} from snapshot")
    if archive_path:
        logger.info(f"Reading archive from {archive_path}")
        with open(archive_path, 'r', encoding='utf-8') as f:
            archive = json.load(f)
        logger.info(f"Loaded {len(archive)} from archive")
        
        # Update archived papers with new feature paths
        for paper_id, paper in archive.items():
            new_features = scan_features(paper_id, features_base)
            if new_features:
                paper['features_path'] = new_features
                
        archive.update(papers)
        papers = archive
            
    # Write output
    logger.info(f"Writing {len(papers)} papers to {output_path}")
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(papers, f, indent=2, ensure_ascii=False)

if __name__ == '__main__':
    fire.Fire(convert_store)



---
File: frontend/src/js/controls.js
---
/* frontend/src/js/controls.js */

const initializeControls = () => {
    // Initialize filter mode buttons
    const filterButtons = document.querySelectorAll('.mode-button');
    if (filterButtons) {
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.mode-button').forEach(b => 
                    b.classList.remove('active'));
                button.classList.add('active');
                window.filterState.mode = button.dataset.mode;
                applyFilters();
            });
        });
    }

    // Initialize clear filters button
    const clearFilters = document.getElementById('clear-filters');
    if (clearFilters) {
        clearFilters.addEventListener('click', () => {
            window.filterState.activeTags.clear();
            document.querySelectorAll('.tag-pill').forEach(pill => 
                pill.classList.remove('active'));
            applyFilters();
        });
    }

    // Initialize select all button
    const selectAll = document.getElementById('select-all');
    if (selectAll) {
        selectAll.addEventListener('click', () => {
            document.querySelectorAll('.tag-pill').forEach(pill => {
                const tag = pill.dataset.tag;
                window.filterState.activeTags.add(tag);
                pill.classList.add('active');
            });
            applyFilters();
        });
    }

    // Initialize color controls
    const coloringToggle = document.getElementById('coloringToggle');
    if (coloringToggle) {
        // Load saved preferences
        const savedColoring = localStorage.getItem('coloringEnabled');
        if (savedColoring !== null) {
            coloringToggle.checked = savedColoring === 'true';
        }
        
        const savedColorBy = localStorage.getItem('colorBy');
        if (savedColorBy) {
            const radio = document.querySelector(`input[name="colorBy"][value="${savedColorBy}"]`);
            if (radio) radio.checked = true;
        }
        
        // Add listeners
        coloringToggle.addEventListener('change', () => {
            localStorage.setItem('coloringEnabled', coloringToggle.checked);
            if (typeof renderPapers === 'function') {
                renderPapers();
            }
        });
        
        document.querySelectorAll('input[name="colorBy"]').forEach(radio => {
            radio.addEventListener('change', () => {
                localStorage.setItem('colorBy', radio.value);
                if (typeof renderPapers === 'function') {
                    renderPapers();
                }
            });
        });
    }
};



---
File: frontend/src/js/features.js
---
/* frontend/src/js/features.js */

// Global state for feature preferences
window.featureState = {
    // Map of feature IDs to their enabled state
    enabledFeatures: JSON.parse(localStorage.getItem('enabledFeatures') || '{}')
};

// Initialize features based on what's available in the data
function initializeFeatures() {
    if (!window.yamlData) {
        console.warn('yamlData not available yet');
        return;
    }

    // Discover all unique feature types across all papers
    const features = new Set();
    
    // Scan papers for available features
    Object.values(window.yamlData).forEach(paper => {
        if (paper.features_path) {
            Object.keys(paper.features_path).forEach(feature => {
                features.add(feature);
            });
        }
    });
    
    // Initialize enabled state for discovered features
    features.forEach(feature => {
        if (!(feature in window.featureState.enabledFeatures)) {
            window.featureState.enabledFeatures[feature] = true; // Enable by default
        }
    });
    
    // Save to localStorage
    localStorage.setItem('enabledFeatures', 
        JSON.stringify(window.featureState.enabledFeatures));
}

// Format feature name for display (also used in papers.js)
function formatFeatureName(featureType) {
    return featureType
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

// Initialize features when page loads
document.addEventListener('DOMContentLoaded', () => {
    // Wait for yamlData to be available
    if (window.yamlData) {
        initializeFeatures();
    }
});



---
File: frontend/src/js/filters.js
---
/* frontend/src/js/filters.js */

// Global filter state
window.filterState = {
    mode: 'any',
    activeTags: new Set()
};

const renderTagCloud = () => {
    const tags = new Map();
    
    // Collect tags and counts
    Object.values(window.yamlData).forEach(paper => {
        if (paper.arxiv_tags) {
            paper.arxiv_tags.forEach(tag => {
                const count = tags.get(tag) || 0;
                tags.set(tag, count + 1);
            });
        }
    });

    // Sort tags by count
    const sortedTags = Array.from(tags.entries())
        .sort(([, a], [, b]) => b - a);

    // Render tag cloud
    const tagCloud = document.getElementById('tag-cloud');
    if (!tagCloud) return;
    
    tagCloud.innerHTML = sortedTags.map(([tag, count]) => {
        const { name, color } = getCategoryInfo(tag);
        return `
            <button class="tag-pill" data-tag="${tag}" style="background-color: ${color}">
                <span class="tag-name">${tag}</span>
                <span class="tag-count">${count}</span>
                <span class="tooltip">${name}</span>
            </button>
        `;
    }).join('');

    // Re-add click handlers
    document.querySelectorAll('.tag-pill').forEach(pill => {
        pill.addEventListener('click', () => {
            const tag = pill.dataset.tag;
            if (window.filterState.activeTags.has(tag)) {
                window.filterState.activeTags.delete(tag);
                pill.classList.remove('active');
            } else {
                window.filterState.activeTags.add(tag);
                pill.classList.add('active');
            }
            applyFilters();
        });
    });
};

const applyFilters = () => {
    const { mode, activeTags } = window.filterState;
    let visibleCount = 0;

    document.querySelectorAll('tr[data-paper-id]').forEach(row => {
        const paperId = row.dataset.paperId;
        const paper = window.yamlData[paperId];
        const paperTags = new Set(paper.arxiv_tags || []);

        let visible = true;
        if (activeTags.size > 0) {
            if (mode === 'any') {
                visible = Array.from(activeTags).some(tag => 
                    paperTags.has(tag));
            } else if (mode === 'all') {
                visible = Array.from(activeTags).every(tag => 
                    paperTags.has(tag));
            } else if (mode === 'none') {
                visible = Array.from(activeTags).every(tag => 
                    !paperTags.has(tag));
            }
        }

        row.classList.toggle('filtered', !visible);
        if (visible) visibleCount++;
    });

    // Update counters
    const filteredCount = document.getElementById('filtered-count');
    const totalCount = document.getElementById('total-count');
    if (filteredCount) filteredCount.textContent = visibleCount;
    if (totalCount) totalCount.textContent = Object.keys(window.yamlData).length;
};

const initializeFilters = () => {
    // Initialize filter state
    window.filterState = {
        mode: 'any',
        activeTags: new Set()
    };

    // Initial render of tag cloud and counters
    renderTagCloud();
    const totalCount = document.getElementById('total-count');
    if (totalCount) {
        totalCount.textContent = Object.keys(window.yamlData).length;
    }
};



---
File: frontend/src/js/main.js
---
/* frontend/src/js/main.js */

async function loadGitInfo() {
    try {
        const response = await fetch('data/git-info.json');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const gitInfo = await response.json();
        
        // Update the footer elements
        document.querySelector('.git-info-repo').textContent = gitInfo.repo;
        document.querySelector('.git-info-branch').textContent = gitInfo.branch;
        document.querySelector('.git-info-commit').textContent = gitInfo.commit;
    } catch (error) {
        console.error('Failed to load git info:', error);
        document.querySelector('.git-info').style.display = 'none';
    }
}

async function loadPaperData() {
    const response = await fetch('data/papers.json');
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Process feature data
    Object.values(data).forEach(paper => {
        // Look for features directory in paper data
        if (paper.features_path) {
            try {
                // Attempt to load features for this paper
                paper.features = {};
                Object.entries(paper.features_path).forEach(([featureType, path]) => {
                    fetch(path)
                        .then(response => response.text())
                        .then(content => {
                            paper.features[featureType] = content;
                            // Re-render if this paper is currently expanded
                            const paperCard = document.querySelector(`.paper-card[data-paper-id="${paper.id}"]`);
                            if (paperCard?.classList.contains('expanded')) {
                                renderPapers();
                            }
                        })
                        .catch(error => {
                            console.error(`Failed to load feature ${featureType} for paper ${paper.id}:`, error);
                        });
                });
            } catch (error) {
                console.error(`Failed to process features for paper ${paper.id}:`, error);
            }
        }
    });
    
    return data;
}

// Update the initializeApp function to call this new function
async function initializeApp() {
    try {
        // Load paper data and git info in parallel
        const [data] = await Promise.all([
            loadPaperData(),
            loadGitInfo()
        ]);
        
        // Store data globally
        window.yamlData = data;
        
        // Initialize all components
        initializeControls();
        initializeFilters();
        initializeFeatures(); // New initialization for features
        
        // Add this line to initialize search (if available)
        if (typeof window.searchModule?.initializeSearch === 'function') {
            window.searchModule.initializeSearch();
        }
        
        // Add this line to initialize share button
        initializeShareButton();
        
        renderPapers();
        applyFilters();
        
    } catch (error) {
        console.error('Failed to initialize app:', error);
        document.getElementById('papers-container').innerHTML = `
            <div class="error-message">
                Failed to load papers data. Please try refreshing the page.
                <br>
                Error: ${error.message}
            </div>
        `;
    }
}

// Function to check if features are loaded for a paper
function areFeaturesLoaded(paper) {
    if (!paper.features_path) return true;
    return Object.keys(paper.features_path).every(
        featureType => paper.features?.[featureType]
    );
}

// Function to retry loading papers periodically until features are loaded
function waitForFeatures(timeout = 30000, interval = 1000) {
    const startTime = Date.now();
    
    function checkFeatures() {
        if (!window.yamlData) return false;
        
        // Check if all papers have their features loaded
        return Object.values(window.yamlData).every(areFeaturesLoaded);
    }
    
    return new Promise((resolve, reject) => {
        const check = () => {
            if (checkFeatures()) {
                resolve();
            } else if (Date.now() - startTime > timeout) {
                reject(new Error('Timeout waiting for features to load'));
            } else {
                setTimeout(check, interval);
            }
        };
        check();
    });
}

function initializeShareButton() {
    const shareButton = document.getElementById('share-button');
    const shareTooltip = document.getElementById('share-tooltip');
    
    if (!shareButton || !shareTooltip) return;
    
    shareButton.addEventListener('click', async () => {
        if (!window.urlStateManager) {
            console.error('URL State Manager not available');
            return;
        }
        
        // Copy URL to clipboard
        const success = await window.urlStateManager.copyShareableUrl();
        
        if (success) {
            // Show tooltip
            shareTooltip.classList.add('visible');
            
            // Hide tooltip after 2 seconds
            setTimeout(() => {
                shareTooltip.classList.remove('visible');
            }, 2000);
        } else {
            // Show error in tooltip
            shareTooltip.textContent = 'Failed to copy URL';
            shareTooltip.classList.add('visible');
            
            setTimeout(() => {
                shareTooltip.classList.remove('visible');
                shareTooltip.textContent = 'URL copied to clipboard!';
            }, 2000);
        }
    });
}

// Start the app when the document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}

// Export for use in other modules
window.papersApp = {
    renderPapers,
    applyFilters,
    waitForFeatures
};



---
File: frontend/src/js/papers.js
---
/* frontend/src/js/papers.js */

// Track active paper
let activePaperId = null;

const calculateColor = (paper, coloringEnabled = true) => {
    if (!coloringEnabled) return 'rgb(255, 255, 255)';
    
    const colorBy = document.querySelector('input[name="colorBy"]:checked').value;
    
    if (colorBy === 'freshness') {
        if (!paper.last_visited || !paper.published_date) return 'rgb(255, 255, 255)';
        
        const visitDate = new Date(paper.last_visited);
        const pubDate = new Date(paper.published_date);
        const diffDays = Math.floor((visitDate - pubDate) / (1000 * 60 * 60 * 24));
        
        const maxAge = 365;
        const freshness = Math.max(0, Math.min(1, 1 - (diffDays / maxAge)));
        const value = Math.round(255 - (freshness * 55));
        return `rgb(${value}, 255, ${value})`; // Green gradient
    } else {
        // Reading time coloring
        const readingTime = paper.total_reading_time_seconds || 0;
        const maxReadingTime = 300; // 5 minutes
        const intensity = Math.max(0, Math.min(1, readingTime / maxReadingTime));
        const value = Math.round(255 - (intensity * 55));
        return `rgb(255, ${value}, ${value})`; // Red gradient
    }
};

const setActivePaper = (paperId) => {
    // Remove active class from previous paper
    const previousActive = document.querySelector('tr.active');
    if (previousActive) {
        previousActive.classList.remove('active');
    }

    // Set new active paper
    activePaperId = paperId;
    const paperRow = document.querySelector(`tr[data-paper-id="${paperId}"]`);
    if (paperRow) {
        paperRow.classList.add('active');
    }

    // Show paper details
    updatePaperDetails(paperId);
};

// Load collapsed items state
const loadCollapsedState = () => {
    try {
        return JSON.parse(localStorage.getItem('collapsedItems')) || {};
    } catch (e) {
        return {};
    }
};

// Save collapsed items state
const saveCollapsedState = (state) => {
    localStorage.setItem('collapsedItems', JSON.stringify(state));
};

// Create a collapsible item
const createCollapsibleItem = (id, title, content, isHtml = false) => {
    const collapsedState = loadCollapsedState();
    const isCollapsed = collapsedState[id] || false;
    
    return `
        <div class="collapsible-item ${isCollapsed ? 'collapsed' : ''}" data-item-id="${id}">
            <div class="collapsible-header">
                <h4 class="collapsible-title">${title}</h4>
                <span class="collapsible-toggle">▼</span>
            </div>
            <div class="collapsible-content">
                <div class="collapsible-inner">
                    ${isHtml ? content : `<p class="metadata-value">${content}</p>`}
                </div>
            </div>
        </div>
    `;
};

const updatePaperDetails = async (paperId) => {
    const detailsPanel = document.getElementById('paperDetails');
    const paper = window.yamlData[paperId];

    if (!paper) {
        detailsPanel.classList.remove('visible');
        return;
    }

    // Update title
    const titleEl = detailsPanel.querySelector('.paper-details-title');
    titleEl.textContent = paper.title;

    // Update metadata section
    const metadataEl = detailsPanel.querySelector('.metadata-content');
    const metadataItems = [
        {
            id: `${paperId}-authors`,
            title: 'Authors',
            content: paper.authors
        },
        {
            id: `${paperId}-published`,
            title: 'Published',
            content: new Date(paper.published_date).toLocaleDateString()
        },
        {
            id: `${paperId}-arxiv`,
            title: 'arXiv ID',
            content: `<a href="${paper.url}" target="_blank">${paper.arxivId}</a>`,
            isHtml: true
        },
        {
            id: `${paperId}-categories`,
            title: 'Categories',
            content: paper.arxiv_tags.join(', ')
        },
        {
            id: `${paperId}-abstract`,
            title: 'Abstract',
            content: paper.abstract
        }
    ];

    metadataEl.innerHTML = `
        <div class="details-section">
            <div class="details-section-header">Paper Information</div>
            ${metadataItems.map(item => 
                createCollapsibleItem(item.id, item.title, item.content, item.isHtml)
            ).join('')}
        </div>
    `;

    // Update features section
    const featuresEl = detailsPanel.querySelector('.features-content');
    if (paper.features_path) {
        const features = await Promise.all(
            Object.entries(paper.features_path).map(async ([type, path]) => {
                try {
                    const response = await fetch(path);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const content = await response.text();
                    return {
                        id: `${paperId}-feature-${type}`,
                        title: formatFeatureName(type),
                        content: `<div class="feature-content markdown-body">${marked.parse(content)}</div>`,
                        isHtml: true
                    };
                } catch (error) {
                    console.error(`Error loading feature ${type}:`, error);
                    return {
                        id: `${paperId}-feature-${type}`,
                        title: formatFeatureName(type),
                        content: `<div class="feature-content error">Error loading feature content</div>`,
                        isHtml: true
                    };
                }
            })
        );

        featuresEl.innerHTML = `
            <div class="details-section">
                <div class="details-section-header">Features</div>
                ${features.map(feature => 
                    createCollapsibleItem(feature.id, feature.title, feature.content, feature.isHtml)
                ).join('')}
            </div>
        `;
    } else {
        featuresEl.innerHTML = '<p class="no-features">No features available for this paper</p>';
    }

    // Add event listeners for collapsible items
    detailsPanel.querySelectorAll('.collapsible-header').forEach(header => {
        header.addEventListener('click', () => {
            const item = header.closest('.collapsible-item');
            const itemId = item.dataset.itemId;
            const collapsedState = loadCollapsedState();
            
            item.classList.toggle('collapsed');
            collapsedState[itemId] = item.classList.contains('collapsed');
            saveCollapsedState(collapsedState);
        });
    });

    // Show panel
    detailsPanel.classList.add('visible');
};

const renderPaperRow = (paper) => {
    const readingTime = paper.total_reading_time_seconds 
        ? `${Math.round(paper.total_reading_time_seconds / 60)} min`
        : '—';

    const coloringEnabled = document.getElementById('coloringToggle')?.checked ?? true;
    const bgColor = calculateColor(paper, coloringEnabled);
    
    const categories = paper.arxiv_tags?.slice(0, 2).join(', ') || '';
    const hasMoreCategories = paper.arxiv_tags?.length > 2 ? '...' : '';

    // Truncate authors to a reasonable length
    const authorsList = paper.authors.split(', ');
    const displayAuthors = authorsList.length > 2 
        ? `${authorsList[0]}, ${authorsList[1]}...`
        : paper.authors;

    // Check if this is the active paper
    const isActive = paper.id === activePaperId;
    
    return `
        <tr class="${isActive ? 'active' : ''}" data-paper-id="${paper.id}">
            <td class="col-arxiv-id">
                <a href="${paper.url}" class="arxiv-id" onclick="event.stopPropagation()" 
                   style="background-color: ${bgColor}">
                    ${paper.arxivId || paper.id}
                </a>
            </td>
            <td class="col-title" title="${paper.title}">${paper.title}</td>
            <td class="col-authors" title="${paper.authors}">${displayAuthors}</td>
            <td class="col-categories" title="${paper.arxiv_tags?.join(', ')}">
                <span class="paper-categories">${categories}${hasMoreCategories}</span>
            </td>
            <td class="col-read-time">
                <span class="read-time">${readingTime}</span>
            </td>
        </tr>
    `;
};

const renderPapers = () => {
    const container = document.getElementById('papers-container');
    container.innerHTML = '';
    const collapsedDays = JSON.parse(localStorage.getItem('collapsedDays') || '{}');
    
    if (!window.yamlData || Object.keys(window.yamlData).length === 0) {
        container.innerHTML = '<div class="no-papers">No papers available</div>';
        return;
    }
    
    const papersByDay = {};
    Object.entries(window.yamlData)
        .sort(([_, a], [__, b]) => new Date(b.last_visited) - new Date(a.last_visited))
        .forEach(([id, paper]) => {
            const date = paper.last_visited.split('T')[0];
            if (!papersByDay[date]) papersByDay[date] = [];
            papersByDay[date].push({ ...paper, id });
        });

    Object.entries(papersByDay).forEach(([date, papers]) => {
        const dayGroup = document.createElement('section');
        dayGroup.className = `day-group ${collapsedDays[date] ? 'collapsed' : ''}`;
        dayGroup.dataset.date = date;

        const dayHeader = document.createElement('div');
        dayHeader.className = 'day-header';
        dayHeader.onclick = () => toggleDayGroup(dayHeader);
        dayHeader.innerHTML = `
            <span class="day-title">${formatDate(date, 'group')}</span>
            <span class="paper-count">${papers.length} paper${papers.length !== 1 ? 's' : ''}</span>
        `;

        const papersContainer = document.createElement('div');
        papersContainer.className = 'papers-container';

        const papersContainerInner = document.createElement('div');
        papersContainerInner.className = 'papers-container-inner';
        papersContainerInner.innerHTML = `
            <table class="papers-table">
                <tbody>
                    ${papers.map(paper => renderPaperRow(paper)).join('')}
                </tbody>
            </table>
        `;

        papersContainer.appendChild(papersContainerInner);
        dayGroup.appendChild(dayHeader);
        dayGroup.appendChild(papersContainer);
        container.appendChild(dayGroup);

        // Add handlers to this day's papers
        addPaperHandlers(papersContainerInner);
    });
};

// Format feature names
function formatFeatureName(featureType) {
    return featureType
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

function addPaperHandlers(container) {
    // Add click handlers for paper rows
    container.querySelectorAll('tr[data-paper-id]').forEach(row => {
        row.addEventListener('click', (e) => {
            // Don't trigger on links
            if (e.target.closest('a')) return;
            
            const paperId = row.dataset.paperId;
            setActivePaper(paperId);
        });
    });
}

const toggleDayGroup = (element) => {
    const group = element.closest('.day-group');
    group.classList.toggle('collapsed');
    const date = group.dataset.date;
    const collapsedDays = JSON.parse(localStorage.getItem('collapsedDays') || '{}');
    collapsedDays[date] = group.classList.contains('collapsed');
    localStorage.setItem('collapsedDays', JSON.stringify(collapsedDays));
};

// Initialize close button handler
document.addEventListener('DOMContentLoaded', () => {
    const closeButton = document.getElementById('closeDetails');
    if (closeButton) {
        closeButton.addEventListener('click', () => {
            const detailsPanel = document.getElementById('paperDetails');
            detailsPanel.classList.remove('visible');
            // Clear active paper
            const activeRow = document.querySelector('tr.active');
            if (activeRow) {
                activeRow.classList.remove('active');
            }
            activePaperId = null;
        });
    }
});



---
File: frontend/src/js/search-worker.js
---
/* frontend/src/js/search-worker.js */

// This file handles pre-computing search indices in a web worker
// to prevent blocking the main UI thread

importScripts('https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.6.2/fuse.min.js');

// Listen for messages from the main thread
self.addEventListener('message', function(e) {
    const { action, data } = e.data;
    
    if (action === 'createIndices') {
        try {
            const papers = data.papers;
            const indices = createIndices(papers);
            
            // Send the indices back to the main thread
            self.postMessage({
                status: 'success',
                indices: indices
            });
        } catch (error) {
            self.postMessage({
                status: 'error',
                message: error.message
            });
        }
    }
});

// Create search indices for all fields
function createIndices(papers) {
    // Define configurations for each field
    const fieldConfigs = {
        title: { threshold: 0.3 },
        authors: { threshold: 0.4 },
        abstract: { threshold: 0.3 },
        arxivId: { threshold: 0.2 },
        arxiv_tags: { 
            threshold: 0.2,
            // For tags, we need to process the array structure
            getFn: (obj, path) => {
                return obj.arxiv_tags ? obj.arxiv_tags.join(' ') : '';
            }
        }
    };
    
    // Store serialized indices
    const indices = {};
    
    // Create an index for each field
    Object.entries(fieldConfigs).forEach(([field, config]) => {
        const options = {
            includeScore: true,
            keys: [field],
            threshold: config.threshold
        };
        
        // Add getFn if specified
        if (config.getFn) {
            options.getFn = config.getFn;
        }
        
        // Create and serialize index
        const fuse = new Fuse(papers, options);
        indices[field] = fuse.getIndex();
    });
    
    // Create a combined index for all fields
    const allOptions = {
        includeScore: true,
        threshold: 0.3,
        keys: [
            { name: 'title', weight: 2.0 },
            { name: 'authors', weight: 1.0 },
            { name: 'abstract', weight: 1.0 },
            { name: 'arxivId', weight: 1.5 },
            { name: 'arxiv_tags', weight: 1.2 }
        ]
    };
    
    const allFuse = new Fuse(papers, allOptions);
    indices.all = allFuse.getIndex();
    
    return indices;
}



---
File: frontend/src/js/search.js
---
/* frontend/src/js/search.js */

// Global search state
window.searchState = {
    query: '',
    activeFields: new Set(['title', 'authors', 'abstract', 'arxivId']), // Default fields to search
    fuseInstances: {}, // Separate Fuse instance for each field
    indexReady: false,
    worker: null
};

// Initialize Fuse.js search with field-specific indices
function initializeSearch() {
    if (!window.yamlData) {
        console.warn('yamlData not available yet');
        return;
    }
    
    const searchContainer = document.getElementById('search-container');
    if (!searchContainer) return;

    // Load saved field preferences
    loadFieldPreferences();
    
    // Start precomputing indices in worker
    startIndexWorker();
    
    // Set up event listener for the search input
    const searchInput = document.getElementById('search-input');
    if (searchInput) {
        searchInput.addEventListener('input', debounce((e) => {
            window.searchState.query = e.target.value.trim();
            searchPapers();
        }, 150));
        
        // Clear button
        const clearSearchBtn = document.getElementById('clear-search');
        if (clearSearchBtn) {
            clearSearchBtn.addEventListener('click', () => {
                searchInput.value = '';
                window.searchState.query = '';
                searchPapers();
            });
        }
    }
    
    // Set up field filter checkboxes
    setupFieldFilters();
    
    // Set up select/clear all buttons
    setupFieldActions();
}

// Start the worker for precomputing indices
function startIndexWorker() {
    if (typeof Worker === 'undefined') {
        console.warn('Web Workers not supported, using fallback');
        createSearchIndicesSync();
        return;
    }
    
    try {
        // Create a new worker
        window.searchState.worker = new Worker('js/search-worker.js');
        
        // Listen for messages from the worker
        window.searchState.worker.onmessage = function(e) {
            if (e.data.status === 'success') {
                // Create Fuse instances from the serialized indices
                createFuseFromIndices(e.data.indices);
                console.log('Search indices created by worker');
            } else {
                console.error('Worker error:', e.data.message);
                // Fallback to synchronous creation
                createSearchIndicesSync();
            }
        };
        
        // Start the worker with paper data
        window.searchState.worker.postMessage({
            action: 'createIndices',
            data: {
                papers: Object.values(window.yamlData)
            }
        });
    } catch (error) {
        console.error('Error starting worker:', error);
        // Fallback to synchronous creation
        createSearchIndicesSync();
    }
}

// Create Fuse instances from serialized indices
function createFuseFromIndices(indices) {
    const papers = Object.values(window.yamlData);
    
    // Create instances for each field
    Object.entries(indices).forEach(([field, index]) => {
        window.searchState.fuseInstances[field] = new Fuse(papers, {
            includeScore: true
        });
        
        // Import the pre-computed index
        window.searchState.fuseInstances[field].setIndex(index);
    });
    
    window.searchState.indexReady = true;
}

// Fallback synchronous index creation
function createSearchIndicesSync() {
    const papers = Object.values(window.yamlData);
    
    // Define configurations for each field
    const fieldConfigs = {
        title: { threshold: 0.3 },
        authors: { threshold: 0.4 },
        abstract: { threshold: 0.3 },
        arxivId: { threshold: 0.2 },
        arxiv_tags: { 
            threshold: 0.2,
            // For tags, we need to process the array structure
            getFn: (obj, path) => {
                return obj.arxiv_tags ? obj.arxiv_tags.join(' ') : '';
            }
        }
    };
    
    // Create a Fuse instance for each field
    Object.entries(fieldConfigs).forEach(([field, config]) => {
        const options = {
            includeScore: true,
            keys: [field],
            threshold: config.threshold
        };
        
        // Add getFn if specified
        if (config.getFn) {
            options.getFn = config.getFn;
        }
        
        window.searchState.fuseInstances[field] = new Fuse(papers, options);
    });
    
    // Create a combined instance for searching all fields at once
    window.searchState.fuseInstances.all = new Fuse(papers, {
        includeScore: true,
        threshold: 0.3,
        keys: [
            { name: 'title', weight: 2.0 },
            { name: 'authors', weight: 1.0 },
            { name: 'abstract', weight: 1.0 },
            { name: 'arxivId', weight: 1.5 },
            { name: 'arxiv_tags', weight: 1.2 }
        ]
    });
    
    window.searchState.indexReady = true;
    console.log('Search indices created synchronously');
}

// Set up the field filter checkboxes
function setupFieldFilters() {
    const fieldFilters = document.getElementById('field-filters');
    if (!fieldFilters) return;
    
    // Define fields and their display names
    const fields = [
        { id: 'title', label: 'Title' },
        { id: 'authors', label: 'Authors' },
        { id: 'abstract', label: 'Abstract' },
        { id: 'arxivId', label: 'ArXiv ID' },
        { id: 'arxiv_tags', label: 'Categories' }
    ];
    
    // Create checkboxes for each field
    fieldFilters.innerHTML = fields.map(field => `
        <label class="field-filter">
            <input type="checkbox" class="field-checkbox" 
                   data-field="${field.id}" 
                   ${window.searchState.activeFields.has(field.id) ? 'checked' : ''}>
            ${field.label}
        </label>
    `).join('');
    
    // Add event listeners to checkboxes
    document.querySelectorAll('.field-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            const field = checkbox.dataset.field;
            if (checkbox.checked) {
                window.searchState.activeFields.add(field);
            } else {
                window.searchState.activeFields.delete(field);
            }
            
            // Save field preferences
            localStorage.setItem('searchFields', JSON.stringify([...window.searchState.activeFields]));
            
            // Re-run search if query exists
            if (window.searchState.query) {
                searchPapers();
            }
        });
    });
}

// Set up select all / clear all buttons
function setupFieldActions() {
    const selectAllBtn = document.getElementById('select-all-fields');
    const clearAllBtn = document.getElementById('clear-all-fields');
    
    if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
            document.querySelectorAll('.field-checkbox').forEach(checkbox => {
                checkbox.checked = true;
                window.searchState.activeFields.add(checkbox.dataset.field);
            });
            
            // Save field preferences
            localStorage.setItem('searchFields', JSON.stringify([...window.searchState.activeFields]));
            
            // Re-run search if query exists
            if (window.searchState.query) {
                searchPapers();
            }
        });
    }
    
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', () => {
            document.querySelectorAll('.field-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            window.searchState.activeFields.clear();
            
            // Save field preferences
            localStorage.setItem('searchFields', JSON.stringify([]));
            
            // Re-run search if query exists
            if (window.searchState.query) {
                searchPapers();
            }
        });
    }
}

// Load saved field preferences
function loadFieldPreferences() {
    try {
        const savedFields = JSON.parse(localStorage.getItem('searchFields'));
        if (savedFields && Array.isArray(savedFields)) {
            window.searchState.activeFields = new Set(savedFields);
        }
    } catch (e) {
        console.error('Error loading saved search fields', e);
    }
}

// Simple debounce function to limit search frequency
function debounce(func, wait) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            func.apply(context, args);
        }, wait);
    };
}

// Search papers with the current query across selected fields
function searchPapers() {
    const { query, activeFields, fuseInstances, indexReady } = window.searchState;
    
    // Clear all search filtering
    document.querySelectorAll('tr[data-paper-id]').forEach(row => {
        row.classList.remove('search-filtered');
    });
    
    if (!query || !indexReady || activeFields.size === 0) {
        // reset empty day status when query is empty
        document.querySelectorAll('.day-group').forEach(dayGroup => {
            dayGroup.classList.remove('empty-day');
        });
        updateSearchStats();
        return;
    }
    
    let matchingIds = new Set();
    
    // Get results from each active field and combine them
    activeFields.forEach(field => {
        const instance = fuseInstances[field];
        if (!instance) return;
        
        const results = instance.search(query);
        results.forEach(result => {
            matchingIds.add(result.item.id);
        });
    });
    
    // If we have no results and query is substantial, try a fallback search
    if (matchingIds.size === 0 && query.length > 2) {
        const fallbackResults = fuseInstances.all.search(query, { limit: 20 });
        fallbackResults.forEach(result => {
            matchingIds.add(result.item.id);
        });
    }
    
    // Hide papers that don't match
    let visibleCount = 0;
    document.querySelectorAll('tr[data-paper-id]').forEach(row => {
        const paperId = row.dataset.paperId;
        const isMatch = matchingIds.has(paperId);
        
        row.classList.toggle('search-filtered', !isMatch);
        
        if (isMatch && !row.classList.contains('filtered')) {
            visibleCount++;
        }
    });
    
    hideEmptyDayGroups();
    // Update search stats
    updateSearchStats(visibleCount);
}

// Update search result statistics
function updateSearchStats(matchCount, totalVisible) {
    const searchStats = document.getElementById('search-stats');
    if (!searchStats) return;
    
    if (!window.searchState.query) {
        searchStats.innerHTML = '';
        return;
    }
    
    if (!totalVisible) {
        totalVisible = document.querySelectorAll('tr[data-paper-id]:not(.filtered)').length;
    }
    
    if (matchCount === undefined) {
        matchCount = totalVisible;
    }
    
    // Show how many papers remain visible instead of how many are filtered
    searchStats.innerHTML = `
        <span class="search-visible-count">Showing ${matchCount} of ${totalVisible} papers</span>
    `;
}

// Apply both search and tag filters
function applyAllFilters() {
    // First apply the tag filters
    if (typeof window.applyFilters === 'function') {
        window.applyFilters();
    }
    
    // Then apply search filters on top
    searchPapers();
}

// Export functions for use in other modules
window.searchModule = {
    initializeSearch,
    searchPapers,
    applyAllFilters,
    precomputeIndices: function() {
        if (window.searchState.indexReady) return;
        createSearchIndicesSync();
    }
};

// Hide day groups that have no visible papers
function hideEmptyDayGroups() {
    // Process each day group
    document.querySelectorAll('.day-group').forEach(dayGroup => {
        // Check if the day group has any visible paper rows
        const visiblePapers = dayGroup.querySelectorAll('tr[data-paper-id]:not(.search-filtered):not(.filtered)');
        
        // Add or remove the 'empty-day' class based on whether there are visible papers
        if (visiblePapers.length === 0) {
            dayGroup.classList.add('empty-day');
        } else {
            dayGroup.classList.remove('empty-day');
        }
    });
}

// Override the existing filter function to also apply search
const originalApplyFilters = window.applyFilters;
if (originalApplyFilters) {
    window.applyFilters = function() {
        originalApplyFilters();
        searchPapers();
        hideEmptyDayGroups();
    };
}

// Initialize the search module when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    // Wait for yamlData to be available before initializing
    if (window.yamlData) {
        initializeSearch();
    }
});



---
File: frontend/src/js/url-state.js
---
/* frontend/src/js/url-state.js */

// URL State Manager
// Handles saving and restoring application state via URL parameters
// for shareable search and filter configurations

// Global URL state manager
window.urlStateManager = {
    // Last saved state, used to avoid unnecessary URL updates
    lastState: {},
    
    // Initialize the URL state manager
    init() {
        // Set up event listener for state changes
        window.addEventListener('popstate', this.handlePopState.bind(this));
        
        // Process URL parameters on initial load
        this.loadStateFromUrl();
        
        // Set up periodic state capture
        this.startStateTracking();
    },
    
    // Start tracking state changes to update URL
    startStateTracking() {
        // Check and update state every 1 second
        setInterval(() => {
            this.captureAndUpdateState();
        }, 1000);
    },
    
    // Capture current app state and update URL if needed
    captureAndUpdateState() {
        const currentState = this.captureState();
        
        // Only update URL if state has changed
        if (!this.isEqualState(currentState, this.lastState)) {
            this.updateUrl(currentState);
            this.lastState = currentState;
        }
    },
    
    // Capture the current application state
    captureState() {
        const state = {};
        
        // Capture search state
        if (window.searchState) {
            if (window.searchState.query) {
                state.q = window.searchState.query;
            }
            
            if (window.searchState.activeFields && window.searchState.activeFields.size > 0) {
                state.fields = [...window.searchState.activeFields].join(',');
            }
        }
        
        // Capture filter state
        if (window.filterState) {
            if (window.filterState.mode) {
                state.mode = window.filterState.mode;
            }
            
            if (window.filterState.activeTags && window.filterState.activeTags.size > 0) {
                state.tags = [...window.filterState.activeTags].join(',');
            }
        }
        
        return state;
    },
    
    // Update URL with current state without causing navigation
    updateUrl(state) {
        // Skip if no state to represent
        if (Object.keys(state).length === 0) {
            return;
        }
        
        // Build query string
        const queryParams = new URLSearchParams();
        Object.entries(state).forEach(([key, value]) => {
            queryParams.set(key, value);
        });
        
        // Update URL using History API without causing navigation
        const newUrl = `${window.location.pathname}?${queryParams.toString()}`;
        window.history.replaceState(state, '', newUrl);
    },
    
    // Handle browser back/forward navigation
    handlePopState(event) {
        if (event.state) {
            this.applyState(event.state);
        } else {
            // If no state, treat as a reset
            this.resetState();
        }
    },
    
    // Load state from URL parameters on page load
    loadStateFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const state = {};
        
        // Convert URL parameters to state object
        for (const [key, value] of urlParams.entries()) {
            state[key] = value;
        }
        
        // Apply the state if there are parameters
        if (Object.keys(state).length > 0) {
            this.applyState(state);
        }
    },
    
    // Apply a state object to the application
    applyState(state) {
        // Apply search query
        if (state.q) {
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.value = state.q;
                if (window.searchState) {
                    window.searchState.query = state.q;
                }
            }
        }
        
        // Apply search fields
        if (state.fields && window.searchState) {
            const fields = state.fields.split(',');
            window.searchState.activeFields = new Set(fields);
            
            // Update checkboxes
            document.querySelectorAll('.field-checkbox').forEach(checkbox => {
                const field = checkbox.dataset.field;
                checkbox.checked = fields.includes(field);
            });
        }
        
        // Apply filter mode
        if (state.mode && window.filterState) {
            window.filterState.mode = state.mode;
            
            // Update mode buttons
            document.querySelectorAll('.mode-button').forEach(button => {
                button.classList.toggle('active', button.dataset.mode === state.mode);
            });
        }
        
        // Apply active tags
        if (state.tags && window.filterState) {
            const tags = state.tags.split(',');
            window.filterState.activeTags = new Set(tags);
            
            // Update tag pills
            document.querySelectorAll('.tag-pill').forEach(pill => {
                const tag = pill.dataset.tag;
                pill.classList.toggle('active', tags.includes(tag));
            });
        }
        
        // Apply all filters
        if (typeof window.applyFilters === 'function') {
            window.applyFilters();
        }
        
        // Apply search
        if (typeof window.searchModule?.searchPapers === 'function') {
            window.searchModule.searchPapers();
        }
    },
    
    // Reset all state to defaults
    resetState() {
        // Clear search
        const searchInput = document.getElementById('search-input');
        if (searchInput) {
            searchInput.value = '';
        }
        
        if (window.searchState) {
            window.searchState.query = '';
        }
        
        // Reset filter mode
        if (window.filterState) {
            window.filterState.mode = 'any';
            window.filterState.activeTags.clear();
        }
        
        // Update UI
        document.querySelectorAll('.mode-button').forEach(button => {
            button.classList.toggle('active', button.dataset.mode === 'any');
        });
        
        document.querySelectorAll('.tag-pill').forEach(pill => {
            pill.classList.remove('active');
        });
        
        // Apply filters
        if (typeof window.applyFilters === 'function') {
            window.applyFilters();
        }
    },
    
    // Generate a shareable URL with the current state
    generateShareableUrl() {
        const currentState = this.captureState();
        
        // Build query string
        const queryParams = new URLSearchParams();
        Object.entries(currentState).forEach(([key, value]) => {
            queryParams.set(key, value);
        });
        
        // Get full URL (absolute)
        const url = new URL(window.location.pathname, window.location.origin);
        url.search = queryParams.toString();
        
        return url.toString();
    },
    
    // Copy current state URL to clipboard
    copyShareableUrl() {
        const url = this.generateShareableUrl();
        
        // Use clipboard API if available
        if (navigator.clipboard && navigator.clipboard.writeText) {
            return navigator.clipboard.writeText(url)
                .then(() => true)
                .catch(() => false);
        } else {
            // Fallback method
            const textarea = document.createElement('textarea');
            textarea.value = url;
            textarea.style.position = 'fixed';  // Avoid scrolling to bottom
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                const success = document.execCommand('copy');
                document.body.removeChild(textarea);
                return Promise.resolve(success);
            } catch (err) {
                document.body.removeChild(textarea);
                return Promise.resolve(false);
            }
        }
    },
    
    // Check if two state objects are equal
    isEqualState(state1, state2) {
        // Check if both are objects
        if (typeof state1 !== 'object' || typeof state2 !== 'object' || 
            state1 === null || state2 === null) {
            return false;
        }
        
        const keys1 = Object.keys(state1);
        const keys2 = Object.keys(state2);
        
        if (keys1.length !== keys2.length) {
            return false;
        }
        
        return keys1.every(key => 
            state2.hasOwnProperty(key) && state1[key] === state2[key]
        );
    }
};

// Initialize the URL state manager when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.urlStateManager.init();
});



---
File: frontend/src/js/utils.js
---
/* frontend/src/js/utils.js */

const formatDate = (dateString, format = 'full') => {
    const date = new Date(dateString);
    if (format === 'full') {
        return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });
    } else if (format === 'group') {
        return date.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
    }
};

const getCategoryInfo = (tag) => {
    // Get the parent category (everything before the dot)
    const parentCategory = tag.split('.')[0];
    
    // Using ColorBrewer Set3 qualitative palette, optimized for colorblind accessibility
    const parentCategoryMap = {
        'cs': { color: '#8dd3c7', category: 'Computer Science' },
        'stat': { color: '#ffffb3', category: 'Statistics' },
        'math': { color: '#bebada', category: 'Mathematics' },
        'physics': { color: '#fb8072', category: 'Physics' },
        'q-bio': { color: '#80b1d3', category: 'Quantitative Biology' },
        'q-fin': { color: '#fdb462', category: 'Quantitative Finance' }
    };
    
    // Map of specific subcategory names
    const subcategoryMap = {
        // Computer Science
        'cs.AI': 'Artificial Intelligence',
        'cs.LG': 'Machine Learning',
        'cs.CL': 'Computation and Language',
        'cs.CV': 'Computer Vision and Pattern Recognition',
        'cs.RO': 'Robotics',
        'cs.NE': 'Neural and Evolutionary Computing',
        'cs.IR': 'Information Retrieval',
        'cs.HC': 'Human-Computer Interaction',
        'cs.SI': 'Social and Information Networks',
        'cs.DB': 'Databases',
        
        // Statistics
        'stat.ML': 'Machine Learning (Statistics)',
        'stat.ME': 'Methodology',
        'stat.TH': 'Statistics Theory',
        
        // Mathematics
        'math.ST': 'Statistics Theory',
        'math.PR': 'Probability',
        'math.OC': 'Optimization',
        
        // Physics
        'physics.data-an': 'Data Analysis',
        'physics.soc-ph': 'Social Physics',
        
        // Quantitative Biology
        'q-bio.NC': 'Neurons and Cognition',
        'q-bio.QM': 'Quantitative Methods',
        
        // Quantitative Finance
        'q-fin.ST': 'Statistical Finance',
        'q-fin.PM': 'Portfolio Management'
    };
    
    const parentInfo = parentCategoryMap[parentCategory] || { color: '#f5f5f5', category: 'Other' };
    const name = subcategoryMap[tag] || tag;
    
    return {
        name: name,
        color: parentInfo.color
    };
};



---
File: frontend/src/styles/base.css
---
/* frontend/src/styles/base.css */
:root {
    /* Theme variables */
    --panel-bg: #ffffff;
    --panel-shadow: rgba(0, 0, 0, 0.1);
    --panel-border: #e2e8f0;
    --button-hover: #f8fafc;
    --bg-color: #f8fafc;
    --card-bg: #ffffff;
    --text-color: #1e293b;
    --secondary-text: #64748b;
    --border-color: #e2e8f0;
    --accent-bg: #f1f5f9;
    --link-color: #2563eb;
    --hover-bg: #f8fafc;
}

body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background: var(--bg-color);
    margin: 0;
    min-height: 100vh;
}

/* Layout */
.layout-container {
    display: flex;
    gap: 2rem;
    max-width: 1600px;
    margin: 0 auto;
    padding: 2rem 1rem;
}

/* Paper Details Panel */
.paper-details {
    position: sticky;
    top: 2rem;
    width: 600px;
    min-width: 600px;
    max-height: calc(100vh - 4rem);
    overflow-y: auto;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px var(--panel-shadow);
    visibility: hidden;
    opacity: 0;
    transition: visibility 0.3s, opacity 0.3s;
}

.paper-details.visible {
    visibility: visible;
    opacity: 1;
}

.paper-details-content {
    padding: 1.5rem;
}

.paper-details-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--panel-border);
}

.paper-details-title {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0;
    padding-right: 1rem;
}

.close-details {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: var(--secondary-text);
    cursor: pointer;
    padding: 0.25rem;
}

.close-details:hover {
    color: var(--text-color);
}

/* Details Section Styles */
.details-section {
    margin-bottom: 1.5rem;
}

.details-section-header {
    font-size: 0.75rem;
    text-transform: uppercase;
    color: var(--secondary-text);
    letter-spacing: 0.05em;
    margin-bottom: 0.75rem;
}

/* Collapsible Items */
.collapsible-item {
    border: 1px solid var(--panel-border);
    border-radius: 0.375rem;
    margin-bottom: 0.5rem;
    overflow: hidden;
}

.collapsible-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    background: var(--accent-bg);
    cursor: pointer;
    user-select: none;
}

.collapsible-header:hover {
    background: var(--hover-bg);
}

.collapsible-title {
    font-weight: 500;
    color: var(--text-color);
    margin: 0;
    font-size: 0.875rem;
}

.collapsible-toggle {
    color: var(--secondary-text);
    transition: transform 0.3s ease;
    font-size: 0.75rem;
}

.collapsible-item.collapsed .collapsible-toggle {
    transform: rotate(-90deg);
}

.collapsible-content {
    display: grid;
    grid-template-rows: 1fr;
    transition: grid-template-rows 0.3s ease-out;
}

.collapsible-item.collapsed .collapsible-content {
    grid-template-rows: 0fr;
}

.collapsible-inner {
    padding: 0.75rem 1rem;
    overflow: hidden;
    color: var(--secondary-text);
    font-size: 0.875rem;
}

.metadata-value {
    margin: 0;
}

.metadata-value a {
    color: var(--link-color);
    text-decoration: none;
}

.metadata-value a:hover {
    text-decoration: underline;
}

/* Main Content Area */
.main-content {
    flex: 1;
    min-width: 0;
}

header {
    margin-bottom: 2rem;
    text-align: center;
}

h1 {
    font-size: 2.25rem;
    font-weight: 800;
    margin-bottom: 1rem;
}

.header-desc {
    color: var(--secondary-text);
    font-size: 1.125rem;
}

/* Paper Controls */
.paper-controls {
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: 0.5rem;
    padding: 1.5rem;
    margin-bottom: 2rem;
}

.control-group {
    margin-bottom: 1.5rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--panel-border);
}

.control-group:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

/* Coloring Controls */
.coloring-controls {
    display: flex;
    gap: 2rem;
    align-items: center;
}

.toggle-switch {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.toggle-label {
    font-size: 0.875rem;
    color: var(--text-color);
    font-weight: 500;
}

.switch {
    position: relative;
    display: inline-block;
    width: 36px;
    height: 20px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--secondary-text);
    transition: .4s;
    border-radius: 20px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: var(--link-color);
}

input:checked + .slider:before {
    transform: translateX(16px);
}

.radio-options {
    display: flex;
    gap: 1.5rem;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--text-color);
    cursor: pointer;
    font-size: 0.875rem;
}

.radio-option input {
    cursor: pointer;
}

/* Filter Controls */
.filter-mode {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.mode-button {
    padding: 0.375rem 1rem;
    border: 1px solid var(--border-color);
    border-radius: 1rem;
    background: var(--bg-color);
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
}

.mode-button.active {
    background: var(--link-color);
    color: white;
    border-color: var(--link-color);
}

.filter-stats {
    font-size: 0.875rem;
    color: var(--secondary-text);
    margin-bottom: 1rem;
}

.tag-cloud {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    background: var(--bg-color);
}

.filter-actions {
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
}

.filter-action {
    padding: 0.375rem 1rem;
    border: 1px solid var(--border-color);
    border-radius: 0.375rem;
    background: var(--bg-color);
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
}

.filter-action:hover {
    background: var(--button-hover);
}

/* Links */
a {
    color: var(--link-color);
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

/* Footer */
footer {
    margin-top: 2rem;
    padding: 1rem;
    text-align: center;
    color: var(--secondary-text);
    font-size: 0.875rem;
    border-top: 1px solid var(--border-color);
}

.git-info {
    display: inline-flex;
    gap: 0.5rem;
    align-items: center;
    padding: 0.25rem 0.75rem;
    background: var(--accent-bg);
    border-radius: 1rem;
    font-family: ui-monospace, SFMono-Regular, Monaco, monospace;
}

.git-info-separator {
    color: var(--border-color);
}

/* Responsive Layout */
@media (max-width: 1400px) {
    .layout-container {
        flex-direction: column;
    }

    .paper-details {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        max-width: 600px;
        max-height: 100vh;
        border-radius: 0;
        transform: translateX(100%);
        transition: transform 0.3s ease;
    }

    .paper-details.visible {
        transform: translateX(0);
    }

    .coloring-controls {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
    }
}

@media (max-width: 640px) {
    body {
        padding: 0;
    }

    .paper-details {
        max-width: 100%;
    }

    .paper-controls {
        border-radius: 0;
        margin: -1rem -1rem 1rem -1rem;
    }
}



---
File: frontend/src/styles/features.css
---
/* frontend/src/styles/features.css */

/* Feature toggles in control panel */
.feature-toggles {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin: 0.75rem 0;
}

.feature-toggle {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    background: white;
    border-radius: 0.375rem;
    border: 1px solid var(--border-color);
}

.feature-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 1;
}

/* Toggle switch container */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 36px;
    height: 20px;
    min-width: 36px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
    margin: 0;
}

.toggle-switch .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 20px;
}

.toggle-switch .slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

.toggle-switch input:checked + .slider {
    background-color: var(--link-color);
}

.toggle-switch input:checked + .slider:before {
    transform: translateX(16px);
}

/* Feature content styling */
.feature-section {
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
}

.feature-section:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.feature-section h4 {
    font-size: 1rem;
    font-weight: 600;
    margin: 0 0 1rem 0;
    color: var(--text-color);
}

.feature-content {
    font-size: 0.875rem;
    line-height: 1.6;
    color: var(--text-color);
}

.feature-content.error {
    color: #ef4444;
    font-style: italic;
}

/* No features message */
.no-features {
    text-align: center;
    padding: 1rem;
    color: var(--secondary-text);
    font-size: 0.875rem;
    border: 1px dashed var(--border-color);
    border-radius: 0.375rem;
    background: var(--accent-bg);
}

/* Feature help text */
.feature-help {
    margin-top: 0.75rem;
    padding: 0.75rem;
    background: var(--accent-bg);
    border-radius: 0.375rem;
    font-size: 0.875rem;
    color: var(--secondary-text);
}

/* Loading states */
.feature-content:empty::before {
    content: 'Loading...';
    display: block;
    text-align: center;
    color: var(--secondary-text);
    font-style: italic;
    padding: 1rem;
}



---
File: frontend/src/styles/header.css
---
/* frontend/src/styles/header.css */

.site-header {
    position: sticky;
    top: 0;
    left: 0;
    width: 100%;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    padding: 12px 16px;
}

.header-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* Media query for larger screens */
@media (min-width: 768px) {
    .header-content {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
    }
    
    .header-title {
        flex: 1;
    }
    
    .search-container {
        flex: 1;
        max-width: 500px;
    }
}

.header-title h1 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 600;
}

.header-desc {
    margin: 4px 0 0;
    font-size: 0.9rem;
    color: #666;
}

/* Update search container styles for header placement */
.search-container {
    margin-bottom: 0;
}

/* Adjust main content to account for fixed header */
.main-content {
    padding-top: 16px;
    max-width: 1200px;
    margin: 0 auto;
}

/* Adjust paper-controls for better spacing */
.paper-controls {
    margin-top: 0;
}

/* Adjust layout container for the new structure */
.layout-container {
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: auto 1fr;
    min-height: 100vh;
}

/* When paper details panel is visible */
.paper-details.visible + .main-content {
    width: calc(100% - 400px);
}

/* Responsive adjustments */
@media (max-width: 767px) {
    .site-header {
        padding: 8px 12px;
    }
    
    .header-title h1 {
        font-size: 1.2rem;
    }
    
    .paper-details.visible + .main-content {
        width: 100%;
    }
}



---
File: frontend/src/styles/papers.css
---
/* frontend/src/styles/papers.css */
.day-group {
    margin-bottom: 1.5rem;
}

.day-header {
    background: var(--accent-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 0.75rem 1rem;
    margin-bottom: 0.5rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.875rem;
}

.day-header:hover {
    background: var(--hover-bg);
}

.papers-container {
    display: grid;
    grid-template-rows: 1fr;
    transition: grid-template-rows 0.3s ease-out;
}

.papers-container-inner {
    overflow: hidden;
}

.collapsed .papers-container {
    grid-template-rows: 0fr;
}

/* Table Layout */
.papers-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    font-size: 0.875rem;
}

.papers-table tr {
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.papers-table tr:hover {
    background-color: var(--hover-bg);
}

.papers-table tr.active {
    background-color: var(--accent-bg);
}

.papers-table td {
    padding: 0.5rem;
    border-bottom: 1px solid var(--border-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.papers-table td:first-child {
    padding-left: 1rem;
}

.papers-table td:last-child {
    padding-right: 1rem;
}

/* Column specific styles */
.col-arxiv-id {
    width: 100px;
    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
}

.col-title {
    max-width: 400px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.col-authors {
    max-width: 200px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.col-categories {
    width: 150px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.col-read-time {
    width: 80px;
    text-align: right;
}

.arxiv-id {
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.8rem;
    text-decoration: none;
    color: var(--link-color);
}

.arxiv-id:hover {
    text-decoration: underline;
}

.paper-categories {
    color: var(--secondary-text);
    font-size: 0.8rem;
}

.read-time {
    color: var(--secondary-text);
    font-size: 0.8rem;
}

/* Hide papers that don't match the filter */
tr.filtered {
    display: none;
}

/* Empty state */
.no-papers {
    text-align: center;
    padding: 2rem;
    color: var(--secondary-text);
    font-style: italic;
}

/* Responsive adjustments */
@media (max-width: 1024px) {
    .col-authors, .col-read-time {
        display: none;
    }
}

@media (max-width: 640px) {
    .col-categories {
        display: none;
    }
    
    .papers-table td {
        padding: 0.5rem 0.25rem;
    }
}



---
File: frontend/src/styles/search.css
---
/* frontend/src/styles/search.css */

/* Hide day groups with no visible papers */
.day-group.empty-day {
    display: none;
}

.search-container {
    width: 100%;
}

.search-input-container {
    position: relative;
    flex-grow: 1;
}

.search-input {
    width: 100%;
    padding: 8px 32px 8px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    transition: all 0.2s ease;
}

.search-input:focus {
    outline: none;
    border-color: #4a89dc;
    box-shadow: 0 0 0 2px rgba(74, 137, 220, 0.2);
}

.clear-search {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #999;
    cursor: pointer;
    font-size: 16px;
    padding: 0;
    line-height: 1;
}

.clear-search:hover {
    color: #333;
}

.search-stats {
    margin-top: 4px;
    font-size: 12px;
    color: #666;
    display: block;
    text-align: right;
}

.search-visible-count {
    color: #4a89dc;
    font-weight: 500;
}

/* Field filters */
.field-filters-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
    font-size: 12px;
}

.field-filter {
    display: flex;
    align-items: center;
    background-color: #f5f5f5;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    user-select: none;
}

.field-filter:hover {
    background-color: #e0e0e0;
}

.field-checkbox {
    margin-right: 4px;
}

/* Hide papers that don't match the search - important to use display: none */
tr.search-filtered {
    display: none !important;
}

/* Highlight search matches */
.search-highlight {
    background-color: rgba(255, 235, 59, 0.4);
    padding: 0 2px;
    border-radius: 2px;
}

/* Responsive adjustments */
@media (min-width: 768px) {
    .search-stats {
        margin-top: 0;
        margin-left: 10px;
        text-align: left;
    }
}



---
File: frontend/src/styles/share.css
---
/* frontend/src/styles/share.css */

.share-controls {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    position: relative;
}

.share-button {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    background-color: #4a89dc;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
}

.share-button:hover {
    background-color: #3d7bc8;
}

.share-button svg {
    stroke: white;
}

.share-tooltip {
    position: absolute;
    top: -40px;
    right: 0;
    background-color: #333;
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.3s, transform 0.3s;
    transform: translateY(10px);
    pointer-events: none;
    white-space: nowrap;
}

.share-tooltip:after {
    content: '';
    position: absolute;
    bottom: -6px;
    right: 10px;
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 6px solid #333;
}

.share-tooltip.visible {
    opacity: 1;
    transform: translateY(0);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .share-controls {
        justify-content: flex-start;
        margin-top: 10px;
    }
    
    .share-tooltip {
        right: auto;
        left: 0;
    }
    
    .share-tooltip:after {
        right: auto;
        left: 10px;
    }
}



---
File: frontend/src/styles/tags.css
---
/* frontend/src/styles/tags.css */
.filter-container {
    margin-bottom: 2rem;
    padding: 1rem;
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
}

.filter-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

.filter-mode {
    display: flex;
    gap: 0.5rem;
}

.mode-button {
    padding: 0.25rem 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 1rem;
    background: var(--bg-color);
    cursor: pointer;
    font-size: 0.875rem;
}

.mode-button.active {
    background: var(--link-color);
    color: white;
    border-color: var(--link-color);
}

.filter-stats {
    font-size: 0.875rem;
    color: var(--secondary-text);
}

.tag-cloud {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1rem;
    max-height: 200px;
    overflow-y: auto;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
}

.filter-actions {
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
}

.filter-action {
    padding: 0.25rem 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 0.25rem;
    background: var(--bg-color);
    cursor: pointer;
    font-size: 0.875rem;
}

.filter-action:hover {
    background: var(--button-hover);
}

.tag-pill {
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    border: 1px solid transparent;
    cursor: pointer;
    font-size: 0.875rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: all 0.2s ease;
    position: relative;
}

.tag-pill:hover {
    filter: brightness(0.95);
}

.tag-pill.active {
    border: 1px solid rgba(0, 0, 0, 0.2);
    filter: brightness(0.9);
}

.tag-count {
    background: rgba(0, 0, 0, 0.1);
    padding: 0.125rem 0.375rem;
    border-radius: 1rem;
    font-size: 0.75rem;
}

.tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 0.5rem;
    background: var(--text-color);
    color: white;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    margin-bottom: 0.5rem;
    z-index: 1000;
}

.tag-pill:hover .tooltip {
    opacity: 1;
}



---
File: frontend/src/templates/index.html
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArXiv Paper Feed</title>
    <link rel="stylesheet" href="styles/header.css">
    <link rel="stylesheet" href="styles/search.css">
    <link rel="stylesheet" href="styles/share.css">
    <link rel="stylesheet" href="styles/base.css">
    <link rel="stylesheet" href="styles/papers.css">
    <link rel="stylesheet" href="styles/tags.css">
    <link rel="stylesheet" href="styles/features.css">
</head>
<body>
    <!-- Main Layout -->
    <div class="layout-container">
        <!-- Paper Details Panel -->
        <aside id="paperDetails" class="paper-details">
            <div class="paper-details-content">
                <div class="paper-details-header">
                    <h2 class="paper-details-title">Select a paper to view details</h2>
                    <button class="close-details" id="closeDetails">×</button>
                </div>
                <div class="paper-details-body">
                    <div class="metadata-content"></div>
                    <div class="features-content"></div>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            
            <header class="site-header">
                <div class="header-content">
                    <div class="header-title">
                        <h1>ArXiv Paper Feed</h1>
                        <p class="header-desc">Papers recently visited by <a href="https://bsky.app/profile/digthatdata.bsky.social">@DigThatData</a></p>
                    </div>
                    
                    <div class="search-container" id="search-container">
                        <div class="search-input-container">
                            <input type="text" id="search-input" class="search-input" placeholder="Search papers (title, authors, abstract, ID)...">
                            <button id="clear-search" class="clear-search" title="Clear search">×</button>
                        </div>
                        <div id="search-stats" class="search-stats"></div>
                    </div>
                </div>
            </header>
            
            <!-- Integrated Controls -->
            <div class="paper-controls">
                <!-- Coloring Controls -->
                <div class="control-group coloring-controls">
                    <div class="toggle-switch">
                        <span class="toggle-label">ID coloring:</span>
                        <label class="switch">
                            <input type="checkbox" id="coloringToggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="radio-options">
                        <label class="radio-option">
                            <input type="radio" name="colorBy" value="freshness" checked>
                            Freshness
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="colorBy" value="readingTime">
                            Reading Time
                        </label>
                    </div>
                </div>

                <!-- Category Filters -->
                <div class="control-group filter-controls">
                    <div class="filter-mode">
                        <button class="mode-button active" data-mode="any">ANY</button>
                        <button class="mode-button" data-mode="all">ALL</button>
                        <button class="mode-button" data-mode="none">NONE</button>
                    </div>
                    <div class="filter-stats">
                        Showing <span id="filtered-count">0</span> of <span id="total-count">0</span> papers
                    </div>
                    <div class="tag-cloud" id="tag-cloud">
                        <!-- Tags will be inserted here -->
                    </div>
                    <div class="filter-actions">
                        <button class="filter-action" id="clear-filters">Clear</button>
                        <button class="filter-action" id="select-all">Select All</button>
                    </div>
                </div>

                                <!-- Add this to the paper-controls div, after the filter-controls div -->
                <div class="control-group share-controls">
                    <button id="share-button" class="share-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="18" cy="5" r="3"></circle>
                            <circle cx="6" cy="12" r="3"></circle>
                            <circle cx="18" cy="19" r="3"></circle>
                            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                        </svg>
                        <span>Share View</span>
                    </button>
                    <div id="share-tooltip" class="share-tooltip">
                        URL copied to clipboard!
                    </div>
                </div>
                
            </div>

            <div id="papers-container">
                <!-- Papers will be inserted here -->
            </div>
        </main>
    </div>

    <footer>
        <span class="git-info">
            Built from <span class="git-info-repo"></span>
            <span class="git-info-separator">•</span>
            <span class="git-info-branch"></span>
            <span class="git-info-separator">•</span>
            <span class="git-info-commit"></span>
        </span>
    </footer>

    <!-- for markdown rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/11.1.1/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.6.2/fuse.min.js"></script>
    <script src="js/utils.js" defer></script>
    <script src="js/papers.js" defer></script>
    <script src="js/filters.js" defer></script>
    <script src="js/controls.js" defer></script>
    <script src="js/features.js" defer></script>
    <script src="js/main.js" defer></script>
    <script src="js/search.js" defer></script>
    <script src="js/url-state.js" defer></script>
</body>
</html>



---
File: frontend-new/package.json
---
{
  "name": "hello-world-mantine",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "rollup -c -w",
    "build": "rollup -c",
    "test": "echo \"No tests yet\""
  },
  "dependencies": {
    "@mantine/core": "^7.5.0",
    "@mantine/hooks": "^7.5.0",
    "@mantine/notifications": "^7.5.0",
    "@tabler/icons-react": "^2.42.0",
    "@tanstack/react-query": "^5.22.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^25.0.7",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-replace": "^5.0.5",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^11.1.6",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "rollup": "^4.9.6",
    "rollup-plugin-livereload": "^2.0.5",
    "rollup-plugin-postcss": "^4.0.2",
    "rollup-plugin-serve": "^2.0.2",
    "@rollup/plugin-babel": "^6.0.4",
    "@babel/core": "^7.23.7",
    "@babel/preset-env": "^7.23.8",
    "@babel/preset-react": "^7.23.3",
    "@babel/preset-typescript": "^7.23.3",
    "tslib": "^2.6.2",
    "typescript": "^5.3.0"
  }
}



---
File: frontend-new/public/index.html
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ArXiv Papers Feed</title>
  <base href="/papers-feed-frontend-dev/">
  <!-- Ensure CSS is loaded with correct path -->
  <link rel="stylesheet" href="bundle.css">
  <!-- Load React from CDN for better performance -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Load @tabler/icons-react from CDN -->
  <script src="https://unpkg.com/@tabler/icons-react@2.42.0/dist/index.umd.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script src="bundle.js"></script>
</body>
</html>



---
File: frontend-new/rollup.config.js
---
// frontend-new/rollup.config.js
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import replace from '@rollup/plugin-replace';
import babel from '@rollup/plugin-babel';
import terser from '@rollup/plugin-terser';
import typescript from '@rollup/plugin-typescript';
import postcss from 'rollup-plugin-postcss';
import serve from 'rollup-plugin-serve';
import livereload from 'rollup-plugin-livereload';

const production = !process.env.ROLLUP_WATCH;
// For GitHub Pages deployment, set the base path
const basePath = production ? '/papers-feed-frontend-dev/' : '/';

export default {
  input: 'src/main.tsx',
  output: {
    file: 'public/bundle.js',
    format: 'iife', // For browser compatibility
    name: 'app',
    sourcemap: !production,
    globals: {
      'react': 'React',
      'react-dom': 'ReactDOM',
      '@tabler/icons-react': 'TablerIconsReact'
    }
  },
  plugins: [
    // Replace environment variables
    replace({
      'process.env.NODE_ENV': JSON.stringify(production ? 'production' : 'development'),
      'process.env.BASE_PATH': JSON.stringify(basePath),
      preventAssignment: true
    }),
    
    // Process CSS with extraction to a separate file
    postcss({
      extract: true,
      modules: true, // Enable CSS modules
      namedExports: true,
      minimize: production,
      extensions: ['.css']
    }),
    
    // TypeScript support
    typescript({
      tsconfig: './tsconfig.json',
      sourceMap: !production,
      inlineSources: !production
    }),
    
    // Babel for JSX and modern JavaScript features
    babel({
      babelHelpers: 'bundled',
      presets: [
        '@babel/preset-env',
        '@babel/preset-react',
        '@babel/preset-typescript'
      ],
      extensions: ['.js', '.jsx', '.ts', '.tsx'],
      exclude: 'node_modules/**'
    }),
    
    // Resolve node modules
    resolve({
      browser: true,
      extensions: ['.js', '.jsx', '.ts', '.tsx'],
      dedupe: ['react', 'react-dom', '@mantine/core']
    }),
    
    // Convert CommonJS modules to ES6
    commonjs({
      include: 'node_modules/**',
      transformMixedEsModules: true
    }),
    
    // Minify for production
    production && terser(),
    
    // Development server
    !production && serve({
      contentBase: ['public'],
      host: 'localhost',
      port: 3000
    }),
    
    // Auto-reload during development
    !production && livereload('public')
  ].filter(Boolean),
  
  // External dependencies already available in the global scope
  external: ['react', 'react-dom', '@tabler/icons-react'],
  
  // Watch settings
  watch: {
    clearScreen: false
  }
};



---
File: frontend-new/src/App.tsx
---
// frontend-new/src/App.tsx
import React from 'react';
import { MantineProvider, createTheme } from '@mantine/core';
import { Notifications } from '@mantine/notifications';
import { Home } from './pages/Home';
//import './index.css';

const App: React.FC = () => {
  // Create basic Mantine theme
  const theme = createTheme({
    primaryColor: 'blue',
    defaultRadius: 'md'
  });
  
  return (
    <MantineProvider theme={theme}>
      <Notifications position="top-right" />
      <Home />
    </MantineProvider>
  );
};

export default App;



---
File: frontend-new/src/api.ts
---
// frontend-new/src/api.ts
import { Paper } from './types';

export interface MessageResponse {
  message: string;
}

export const fetchMessage = async (): Promise<MessageResponse> => {
  // In a real app, this would be an API call
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({ 
        message: "Configuration successful! Your Mantine UI + React Query + Rollup app is working correctly!"
      });
    }, 500);
  });
};

export const fetchPapers = async (): Promise<Paper[]> => {
  try {
    const response = await fetch('/web/data/papers.json');
    if (!response.ok) {
      throw new Error('Failed to fetch papers');
    }
    const data = await response.json();
    return Object.values(data) as Paper[];
  } catch (error) {
    console.error('Error fetching papers:', error);
    return [];
  }
};



---
File: frontend-new/src/components/PapersTable.module.css
---
.th {
  padding: 0;
}

.control {
  width: 100%;
  padding: var(--mantine-spacing-xs) var(--mantine-spacing-md);
}

.icon {
  width: 21px;
  height: 21px;
  border-radius: 21px;
}

.clickable {
  cursor: pointer;
}

.truncate {
  max-width: 250px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.paperTitle {
  font-weight: 500;
  line-height: 1.3;
}



---
File: frontend-new/src/components/PapersTable.tsx
---
// frontend-new/src/components/PapersTable.tsx
import React, { useState, useMemo } from 'react';
import { 
  Table, 
  TextInput, 
  Group, 
  Text, 
  Badge, 
  ScrollArea, 
  Center,
  Anchor,
  UnstyledButton,
  Tooltip
} from '@mantine/core';
import { IconSearch, IconSelector, IconChevronDown, IconChevronUp, IconCalendar, IconClock } from '@tabler/icons-react';
import { Paper } from '../types';
import classes from './PapersTable.module.css';

interface PapersTableProps {
  data: Paper[];
  isLoading: boolean;
}

interface ThProps {
  children: React.ReactNode;
  sortKey?: keyof Paper;
  sortBy: keyof Paper | null;
  reverseSortDirection: boolean;
  onSort: (key: keyof Paper) => void;
}

function Th({ children, sortKey, sortBy, reverseSortDirection, onSort }: ThProps) {
  const sorted = sortBy === sortKey;
  const Icon = sorted 
    ? (reverseSortDirection ? IconChevronUp : IconChevronDown) 
    : IconSelector;

  if (!sortKey) {
    return <Table.Th>{children}</Table.Th>;
  }

  return (
    <Table.Th className={classes.th}>
      <UnstyledButton onClick={() => onSort(sortKey)} className={classes.control}>
        <Group justify="space-between">
          <Text fw={500} fz="sm">
            {children}
          </Text>
          <Center className={classes.icon}>
            <Icon size={16} stroke={1.5} />
          </Center>
        </Group>
      </UnstyledButton>
    </Table.Th>
  );
}

function filterData(data: Paper[], search: string) {
  if (!search.trim()) {
    return data;
  }

  const query = search.toLowerCase().trim();
  return data.filter((paper) => 
    paper.title.toLowerCase().includes(query) ||
    paper.authors.toLowerCase().includes(query) ||
    paper.abstract.toLowerCase().includes(query) ||
    paper.arxivId.toLowerCase().includes(query) ||
    paper.arxiv_tags.some(tag => tag.toLowerCase().includes(query))
  );
}

function sortData(
  data: Paper[],
  payload: { sortBy: keyof Paper | null; reversed: boolean; search: string }
) {
  const { sortBy } = payload;

  if (!sortBy) {
    return filterData(data, payload.search);
  }

  return filterData(
    [...data].sort((a, b) => {
      const aValue = a[sortBy];
      const bValue = b[sortBy];

      if (typeof aValue === 'string' && typeof bValue === 'string') {
        return payload.reversed
          ? bValue.localeCompare(aValue)
          : aValue.localeCompare(bValue);
      }

      if (typeof aValue === 'number' && typeof bValue === 'number') {
        return payload.reversed ? bValue - aValue : aValue - bValue;
      }

      // Handle date strings
      if (
        sortBy === 'published_date' || 
        sortBy === 'last_visited' || 
        sortBy === 'last_read'
      ) {
        const aDate = new Date(aValue as string).getTime();
        const bDate = new Date(bValue as string).getTime();
        return payload.reversed ? bDate - aDate : aDate - bDate;
      }

      return 0;
    }),
    payload.search
  );
}

export function PapersTable({ data, isLoading }: PapersTableProps) {
  const [search, setSearch] = useState('');
  const [sortBy, setSortBy] = useState<keyof Paper | null>('published_date');
  const [reverseSortDirection, setReverseSortDirection] = useState(true);

  const setSorting = (field: keyof Paper) => {
    const reversed = field === sortBy ? !reverseSortDirection : false;
    setReverseSortDirection(reversed);
    setSortBy(field);
  };

  const handleSearchChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setSearch(event.currentTarget.value);
  };

  const sortedData = useMemo(() => {
    return sortData(data, { 
      sortBy, 
      reversed: reverseSortDirection, 
      search
    });
  }, [data, sortBy, reverseSortDirection, search]);

  // Format date for display
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };

  // Format reading time
  const formatReadingTime = (seconds: number) => {
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    return `${minutes}m`;
  };

  const rows = sortedData.map((paper) => (
    <Table.Tr key={paper.id}>
      <Table.Td>
        <Anchor 
          href={paper.url} 
          target="_blank" 
          rel="noopener noreferrer"
          size="sm"
        >
          {paper.arxivId}
        </Anchor>
      </Table.Td>
      
      <Table.Td>
        <Tooltip label={paper.title} multiline width={300}>
          <Anchor 
            href={paper.url} 
            target="_blank" 
            rel="noopener noreferrer"
            className={classes.paperTitle}
            lineClamp={2}
          >
            {paper.title}
          </Anchor>
        </Tooltip>
      </Table.Td>
      
      <Table.Td>
        <Text size="sm" lineClamp={1} className={classes.truncate}>
          {paper.authors}
        </Text>
      </Table.Td>
      
      <Table.Td>
        <Group gap={5} wrap="nowrap">
          <IconCalendar size={14} stroke={1.5} />
          <Text size="sm">
            {formatDate(paper.published_date)}
          </Text>
        </Group>
      </Table.Td>
      
      <Table.Td>
        <Group gap={5} wrap="nowrap">
          <IconClock size={14} stroke={1.5} />
          <Text size="sm">
            {formatReadingTime(paper.total_reading_time_seconds)}
          </Text>
        </Group>
      </Table.Td>
      
      <Table.Td>
        <Group gap={5} wrap="wrap">
          {paper.arxiv_tags.map((tag) => (
            <Badge key={tag} size="sm" variant="light">
              {tag}
            </Badge>
          ))}
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <TextInput
        placeholder="Search papers by title, author, abstract, ID, or tags..."
        mb="md"
        leftSection={<IconSearch size={16} stroke={1.5} />}
        value={search}
        onChange={handleSearchChange}
      />
      
      <ScrollArea h={500}>
        <Table horizontalSpacing="md" verticalSpacing="xs" miw={800} layout="fixed">
          <Table.Thead>
            <Table.Tr>
              <Th 
                sortKey="arxivId"
                sortBy={sortBy}
                reverseSortDirection={reverseSortDirection}
                onSort={setSorting}
              >
                ID
              </Th>
              
              <Th 
                sortKey="title"
                sortBy={sortBy}
                reverseSortDirection={reverseSortDirection}
                onSort={setSorting}
              >
                Title
              </Th>
              
              <Th 
                sortKey="authors"
                sortBy={sortBy}
                reverseSortDirection={reverseSortDirection}
                onSort={setSorting}
              >
                Authors
              </Th>
              
              <Th 
                sortKey="published_date"
                sortBy={sortBy}
                reverseSortDirection={reverseSortDirection}
                onSort={setSorting}
              >
                Published
              </Th>
              
              <Th 
                sortKey="total_reading_time_seconds"
                sortBy={sortBy}
                reverseSortDirection={reverseSortDirection}
                onSort={setSorting}
              >
                Read Time
              </Th>
              
              <Th
                onSort={() => {}}
              >
                Tags
              </Th>
            </Table.Tr>
          </Table.Thead>
          
          <Table.Tbody>
            {isLoading ? (
              <Table.Tr>
                <Table.Td colSpan={6}>
                  <Text fw={500} ta="center">Loading papers...</Text>
                </Table.Td>
              </Table.Tr>
            ) : rows.length === 0 ? (
              <Table.Tr>
                <Table.Td colSpan={6}>
                  <Text fw={500} ta="center">No matching papers found</Text>
                </Table.Td>
              </Table.Tr>
            ) : (
              rows
            )}
          </Table.Tbody>
        </Table>
      </ScrollArea>
    </>
  );
}



---
File: frontend-new/src/index.css
---
/* src/index.css */
body {
  margin: 0;
}

/* Markdown styling */
.markdown-body {
  font-size: 0.875rem;
  line-height: 1.6;
}

.markdown-body pre {
  max-height: 300px;
  overflow: auto;
}

.markdown-body img {
  max-width: 100%;
  height: auto;
}

/* Paper ID styling */
.paper-id {
  font-family: monospace;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.875rem;
}

/* Table styles */
.clickable-row {
  cursor: pointer;
}

/* Show ellipsis for truncated text */
.truncate {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
}



---
File: frontend-new/src/index.tsx
---
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import 'github-markdown-css/github-markdown.css';

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



---
File: frontend-new/src/lib/queryClient.ts
---
// frontend-new/src/lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 30 * 60 * 1000, // 30 minutes (renamed from cacheTime in v5)
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});



---
File: frontend-new/src/main.tsx
---
// frontend-new/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from './lib/queryClient';
import App from './App';

// Import Mantine styles
import '@mantine/core/styles.css';
import '@mantine/notifications/styles.css';

// Render the app
const rootElement = document.getElementById('root');
if (!rootElement) throw new Error('Root element not found');

const root = createRoot(rootElement);
root.render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>
);



---
File: frontend-new/src/pages/Home.tsx
---
// frontend-new/src/pages/Home.tsx
import React from 'react';
import { Container, Title, Text, Stack, Tabs, Alert, Paper } from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import { useQuery } from '@tanstack/react-query';
import { fetchPapers } from '../api';
import { PapersTable } from '../components/PapersTable';

export const Home: React.FC = () => {
  const { data: papers = [], isLoading, isError, error } = useQuery({
    queryKey: ['papers'],
    queryFn: fetchPapers,
    retry: 1
  });

  return (
    <Container size="xl" py="xl">
      <Stack gap="md">
        <Title order={1} ta="center">ArXiv Papers Feed</Title>
        
        <Text ta="center" c="dimmed" mb="xl">
          Browse and search through your collection of ArXiv papers
        </Text>
        
        {isError ? (
          <Alert 
            icon={<IconAlertCircle size={16} />} 
            title="Data loading error" 
            color="red"
            variant="filled"
          >
            {error instanceof Error ? error.message : 'Failed to load papers. Make sure the papers.json file is available at /web/data/papers.json'}
          </Alert>
        ) : (
          <Paper p="md" shadow="sm" radius="md">
            <Tabs defaultValue="all">
              <Tabs.List>
                <Tabs.Tab value="all">All Papers ({papers.length})</Tabs.Tab>
                <Tabs.Tab value="recent">Recently Visited ({Math.min(papers.length, 10)})</Tabs.Tab>
              </Tabs.List>

              <Tabs.Panel value="all" pt="md">
                <PapersTable data={papers} isLoading={isLoading} />
              </Tabs.Panel>
              
              <Tabs.Panel value="recent" pt="md">
                <PapersTable 
                  data={papers.slice()
                    .sort((a, b) => new Date(b.last_visited).getTime() - new Date(a.last_visited).getTime())
                    .slice(0, 10)
                  } 
                  isLoading={isLoading} 
                />
              </Tabs.Panel>
            </Tabs>
          </Paper>
        )}
      </Stack>
    </Container>
  );
};



---
File: frontend-new/src/types/index.ts
---
export interface Paper {
  id: string;
  title: string;
  authors: string;
  abstract: string;
  url: string;
  arxivId: string;
  last_visited: string;
  last_read: string;
  total_reading_time_seconds: number;
  published_date: string;
  arxiv_tags: string[];
}

export type SortDirection = 'asc' | 'desc';

export interface SortState {
  field: keyof Paper | null;
  direction: SortDirection;
}

export interface GroupedPapers {
  [date: string]: Paper[];
}

export interface FilterState {
  mode: 'any' | 'all' | 'none';
  activeTags: string[];
}

export interface UrlState {
  q?: string;
  fields?: string;
  mode?: 'any' | 'all' | 'none';
  tags?: string;
}

export interface CategoryInfo {
  name: string;
  color: string;
}

export interface GitInfo {
  repo: string;
  branch: string;
  commit: string;
}

export interface AppSettings {
  coloringEnabled: boolean;
  colorBy: 'freshness' | 'readingTime';
  enabledFeatures: Record<string, boolean>;
}



---
File: frontend-new/src/vite-env.d.ts
---
// frontend-new/src/vite-env.d.ts
/// <reference types="react" />
/// <reference types="react-dom" />

declare module '*.css' {
  const classes: { [key: string]: string };
  export default classes;
}

declare module '*.svg' {
  import * as React from 'react';

  export const ReactComponent: React.FunctionComponent<
    React.SVGProps<SVGSVGElement>
  >;

  const src: string;
  export default src;
}

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string;
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



---
File: frontend-new/tsconfig.json
---
{
  "compilerOptions": {
    "target": "es2020",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "sourceMap": true,
    "declaration": false,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": [
    "src"
  ]
}



---
File: ops/rm.txt
---



---
File: pyproject.toml
---
[project]
name = "dmarx/papers-feed"
version = "0.1.0"
description = ""
requires-python = ">=3.11"
dependencies = [
   "papers_feed"
]
readme = "README.md"
license = {file = "LICENSE"}


[tool.summary]
max_file_size_kb = 500  # Skip files larger than 1MB

# File patterns to exclude
exclude_patterns = [
    '.git',
    '.gitignore',
    '.pytest_cache',
    '__pycache__',
    'SUMMARY',
    '.coverage',
    '.env',
    '.venv',
    '.idea',
    '.vscode',
    'README.md',
    'README_LLM.md',
    'package-lock.json',
    'REGISTRY.md',
    'research.yaml',
    'registry.yaml',
    'bibliography',
    '.bibtex',
    'metadata.json',
    'events.log',
    'papers.yaml'
]

# File extensions to include
include_extensions = [
    '.py',
    '.md',
    '.txt',
    '.yml',
    '.yaml',
    '.toml',
    '.json',
    '.html',
    '.css',
    '.js',
    '.ts',
    '.tsx',
    '.j2'
]

# Directories to exclude
exclude_directories = [
    '.git',
    '__pycache__',
    '.pytest_cache',
    '.venv',
    '.idea',
    '.vscode',
    'data',
    'extension/dist/'
]



---
File: scripts/github_repo_mirror.py
---
#!/usr/bin/env python3
# github_repo_mirror.py

"""
Utility to copy issues, comments, labels and reactions from one GitHub repository to another,
or to clean labels from all issues in a repository.
"""

import os
import sys
from typing import Dict, List, Optional

import fire
from github import Github, GithubException
from github.Issue import Issue
from github.Label import Label
from github.Repository import Repository
from loguru import logger

# Set up logging
logger.remove()
logger.add(sys.stderr, format="{time} {level} {message}", level="INFO")


class GitHubRepoMirror:
    """Class to mirror issues and related data between GitHub repositories."""
    
    def __init__(
        self, 
        token: str,
        source_repo: str = "dmarx/papers-feed",
        target_repo: str = "dmarx/papers-feed-dev",
    ):
        """
        Initialize with GitHub credentials and repository info.
        
        Args:
            token: GitHub personal access token
            source_repo: Source repository in format "owner/repo"
            target_repo: Target repository in format "owner/repo"
        """
        self.source_repo_name = source_repo
        self.target_repo_name = target_repo
        
        # Initialize GitHub client
        self.github = Github(
            token, 
            per_page=100,
            retry=3
        )
        
        # Get repository objects
        self.source_repo = self.github.get_repo(source_repo)
        self.target_repo = self.github.get_repo(target_repo)
        
        # Label cache to avoid creating duplicate labels
        self.label_cache: Dict[str, Label] = {}

    def _create_label_if_not_exists(self, label_name: str, label_color: str, 
                                    label_description: str = "") -> Label:
        """
        Create a label in the target repo if it doesn't already exist.
        
        Args:
            label_name: Name of the label
            label_color: Color of the label (hex code without #)
            label_description: Description of the label
            
        Returns:
            The label object
        """
        # Check cache first
        if label_name in self.label_cache:
            return self.label_cache[label_name]
        
        # Try to get existing label
        try:
            label = self.target_repo.get_label(label_name)
            self.label_cache[label_name] = label
            return label
        except GithubException:
            # Label doesn't exist, create it
            logger.info(f"Creating label '{label_name}' in target repository")
            label = self.target_repo.create_label(
                name=label_name,
                color=label_color,
                description=label_description
            )
            self.label_cache[label_name] = label
            return label

    def _copy_reactions(self, source_obj, target_obj):
        """
        Copy reactions from source to target object.
        
        Args:
            source_obj: Source object with reactions (Issue or IssueComment)
            target_obj: Target object to add reactions to
        """
        # Get all reactions from source
        try:
            reactions = source_obj.get_reactions()
            
            # Add each reaction type to target
            reaction_counts = {}
            for reaction in reactions:
                reaction_type = reaction.content
                reaction_counts[reaction_type] = reaction_counts.get(reaction_type, 0) + 1
            
            # Create reactions on target
            for reaction_type, count in reaction_counts.items():
                logger.debug(f"Adding {count} '{reaction_type}' reactions")
                for _ in range(count):
                    try:
                        target_obj.create_reaction(reaction_type)
                    except GithubException as e:
                        # Creating the same reaction twice will fail
                        if e.status == 422:
                            logger.debug(f"Duplicate reaction '{reaction_type}' - skipping")
                        else:
                            raise
        except GithubException as e:
            logger.warning(f"Could not copy reactions: {str(e)}")

    def clear_all_issue_labels(self, repo_name: str = None):
        """
        Remove all labels from all issues in a repository.
        
        Args:
            repo_name: Repository to clean (defaults to target repo)
        """
        repo = self.target_repo
        if repo_name:
            repo = self.github.get_repo(repo_name)
            
        logger.info(f"Removing all labels from all issues in {repo.full_name}")
        
        # Get all issues (open and closed)
        issues = repo.get_issues(state="all")
        
        # Track progress
        count = 0
        processed = 0
        
        # Process each issue
        for issue in issues:
            processed += 1
            
            # Skip issues with no labels
            if not list(issue.labels):
                continue
            
            logger.info(f"Clearing labels from issue #{issue.number}: {issue.title}")
            
            # Remove all labels
            issue.set_labels()  # Empty list clears all labels
            count += 1
            
            # Log progress occasionally
            if processed % 10 == 0:
                logger.info(f"Processed {processed} issues so far")
        
        logger.info(f"Completed! Removed labels from {count} issues out of {processed} total issues.")
        return count

    def copy_labels(self) -> int:
        """
        Copy all labels from source repository to target repository.
        
        Returns:
            Number of labels created
        """
        logger.info(f"Copying labels from {self.source_repo_name} to {self.target_repo_name}")
        
        created = 0
        
        # Get existing target labels
        target_labels = {label.name: label for label in self.target_repo.get_labels()}
        
        # Copy labels from source to target
        for source_label in self.source_repo.get_labels():
            if source_label.name in target_labels:
                logger.debug(f"Label already exists: {source_label.name}")
                # Cache the label for later use
                self.label_cache[source_label.name] = target_labels[source_label.name]
            else:
                # Create new label
                logger.info(f"Creating new label: {source_label.name}")
                new_label = self.target_repo.create_label(
                    name=source_label.name,
                    color=source_label.color,
                    description=source_label.description or ""
                )
                # Cache the label for later use
                self.label_cache[source_label.name] = new_label
                created += 1
        
        logger.info(f"Label copy completed: {created} created")
        return created

    def copy_issue(self, issue_number: int) -> Issue:
        """
        Copy a single issue and all its comments from source to target repository.
        
        Args:
            issue_number: The issue number in the source repository
            
        Returns:
            The newly created issue in the target repository
        """
        logger.info(f"Copying issue #{issue_number} from {self.source_repo_name}")
        
        # Get source issue
        source_issue = self.source_repo.get_issue(issue_number)
        
        # Create issue in target repo - exact copy of title and body
        target_issue = self.target_repo.create_issue(
            title=source_issue.title,
            body=source_issue.body
        )
        logger.info(f"Created issue #{target_issue.number} at target from source #{source_issue.number}")
        
        # Copy labels
        for label in source_issue.labels:
            target_label = self._create_label_if_not_exists(
                label_name=label.name,
                label_color=label.color,
                label_description=label.description or ""
            )
            target_issue.add_to_labels(target_label)
            
        # Copy state (open/closed)
        if source_issue.state == "closed":
            target_issue.edit(state="closed")
            
        # Copy comments - exact copies without modifications
        for comment in source_issue.get_comments():
            target_comment = target_issue.create_comment(comment.body)
            
            # Copy reactions from comment
            self._copy_reactions(comment, target_comment)
            
        # Copy reactions to the issue itself
        self._copy_reactions(source_issue, target_issue)
        
        return target_issue

    def copy_all_issues(self, issue_range_start: int = None, issue_range_end: int = None) -> List[Issue]:
        """
        Copy all issues from source to target repository, optionally within a specific issue number range.
        
        Args:
            issue_range_start: Optional starting issue number to copy (inclusive)
            issue_range_end: Optional ending issue number to copy (inclusive)
            
        Returns:
            List of created issues in the target repository
        """
        created_issues = []
        
        # First, make sure all labels exist in the target repo
        self.copy_labels()
        
        # Get all issues from source repo with filters, sorted by creation date ascending
        source_issues = self.source_repo.get_issues(state="all", sort="created", direction="asc")
        logger.info(f"Fetching issues from source repository (sorted by creation date)...")
        
        # Process each issue
        for source_issue in source_issues:
            # Skip issues outside the specified range if ranges are provided
            if issue_range_start is not None and source_issue.number < issue_range_start:
                logger.debug(f"Skipping issue #{source_issue.number}: Below range start.")
                continue
                
            if issue_range_end is not None and source_issue.number > issue_range_end:
                logger.info(f"Reached end of specified issue range (#{issue_range_end}), exiting.")
                break
                
            if source_issue.pull_request is not None:
                logger.info(f"Skipping issue #{source_issue.number}: PR.")
                continue
                
            if not source_issue.body:
                logger.info(f"Skipping issue #{source_issue.number}: empty issue body.")
                continue
                
            created_issue = self.copy_issue(source_issue.number)
            created_issues.append(created_issue)
            
            # Log progress occasionally
            if len(created_issues) % 5 == 0:
                logger.info(f"Copied {len(created_issues)} issues so far")
                    
        logger.info(f"Created {len(created_issues)} issues in the target repository")
        return created_issues


def mirror_repository(
    clear_target_labels: bool = False,
    token: str = None,
    source_repo: str = "dmarx/papers-feed",
    target_repo: str = "dmarx/papers-feed-dev",
    issue_range_start: int = None,
    issue_range_end: int = None,
):
    """
    Mirror issues, comments, labels and reactions from source to target repository.
    Can also clear all labels from issues in the target repository.
    
    Args:
        clear_target_labels: If True, remove all labels from all issues in target repository first
        token: GitHub token (or use DEV_REPO_TOKEN environment variable)
        source_repo: Source repository in format "owner/repo"
        target_repo: Target repository in format "owner/repo"
        issue_range_start: Optional starting issue number to copy (inclusive)
        issue_range_end: Optional ending issue number to copy (inclusive)
    """
    # Use provided token or get from environment
    token = token or os.environ.get("DEV_REPO_TOKEN")
    
    if not token:
        logger.error("GitHub token not provided. Use --token or set DEV_REPO_TOKEN environment variable.")
        sys.exit(1)
        
    if source_repo == target_repo:
        logger.error("Source and target repositories must be different.")
        sys.exit(1)
        
    # Create and run the mirroring tool
    mirror = GitHubRepoMirror(
        token=token,
        source_repo=source_repo,
        target_repo=target_repo
    )
    
    # Clear all labels from issues in target repo if requested
    if clear_target_labels:
        logger.info("Clearing all labels from issues in target repository")
        mirror.clear_all_issue_labels()
    
    # Copy all issues from source to target, with optional range limits
    range_info = ""
    if issue_range_start is not None or issue_range_end is not None:
        range_info = f" (issues {issue_range_start or 'start'} to {issue_range_end or 'end'})"
    
    logger.info(f"Mirroring from {source_repo} to {target_repo}{range_info}")
    mirror.copy_all_issues(issue_range_start, issue_range_end)
    logger.info("Repository mirroring completed.")


def clear_issue_labels(
    token: str = None,
    repo_name: str = "dmarx/papers-feed-dev"
):
    """
    Simple function to clear all labels from all issues in a repository.
    
    Args:
        token: GitHub token (or use DEV_REPO_TOKEN environment variable)
        repo_name: Repository in format "owner/repo"
    """
    # Use provided token or get from environment
    token = token or os.environ.get("DEV_REPO_TOKEN")
    
    if not token:
        logger.error("GitHub token not provided. Use --token or set DEV_REPO_TOKEN environment variable.")
        sys.exit(1)
        
    # Create the tool and clear labels
    mirror = GitHubRepoMirror(token=token)
    mirror.clear_all_issue_labels(repo_name)


if __name__ == "__main__":
    fire.Fire({
        'mirror': mirror_repository,
        'clear_labels': clear_issue_labels
    })



---
File: scripts/process_enrichments.py
---
# scripts/process_enrichments.py
"""
Creates new paper features based on GitHub issue specifications.
"""
import ast
from dataclasses import dataclass
import json
import os
from pathlib import Path
from typing import Iterator

from github import Github
from loguru import logger
from duckduckgo_search import DDGS
from llamero.utils import commit_and_push

@dataclass
class Paper:
    """
    Represents an arXiv paper with its associated features.
    
    Args:
        arxiv_id: The arXiv ID of the paper
        data_dir: Root directory containing paper data (default: data/papers)
    """
    arxiv_id: str
    data_dir: Path = Path("data/papers")
    
    def __post_init__(self):
        self.paper_dir = self.data_dir / self.arxiv_id
        self.features_dir = self.paper_dir / "features"
        
    @property
    def pdf_path(self) -> Path:
        """Path to the paper's PDF file."""
        return self.paper_dir / f"{self.arxiv_id}.pdf"
    
    @property
    def available_features(self) -> set[str]:
        """Returns set of available feature types for this paper."""
        if not self.features_dir.exists():
            return set()
            
        return {
            d.name for d in self.features_dir.iterdir() 
            if d.is_dir() and any(d.iterdir())
        }
        
    def has_feature(self, feature_name: str) -> bool:
        """Check if a specific feature is available."""
        return feature_name in self.available_features
        
    def feature_path(self, feature_type: str) -> Path | None:
        """
        Get path to a specific feature file if it exists.
        
        Args:
            feature_type: Name of the feature directory (e.g., 'markdown-grobid')
            
        Returns:
            Path to the feature file, or None if not found
        """
        feature_dir = self.features_dir / feature_type
        if not feature_dir.exists():
            return None
            
        # Look for any file with matching arxiv_id prefix
        for file in feature_dir.iterdir():
            if file.stem == self.arxiv_id:
                return file
                
        return None
        
    def __str__(self) -> str:
        features = ", ".join(sorted(self.available_features)) or "none"
        return f"Paper({self.arxiv_id}, features: {features})"
        
    @classmethod
    def iter_papers(cls, data_dir: Path | str = "data/papers") -> Iterator["Paper"]:
        """
        Yields Paper objects for all papers in the project.
        
        Args:
            data_dir: Root directory containing paper data
        """
        data_dir = Path(data_dir)
        if not data_dir.exists():
            return
            
        for paper_dir in data_dir.iterdir():
            if paper_dir.is_dir():
                yield cls(arxiv_id=paper_dir.name, data_dir=data_dir)


@dataclass
class FeatureRequest:
    """Represents a request to create a new feature."""
    name: str
    inputs: dict[str, str]
    prompt: str
    max_len: int = 20000
    commit_cadence: int = 5
    
    def __post_init__(self):
        if '/' in self.name:
            raise ValueError("Feature name cannot contain '/'")
        if not all(isinstance(v, str) for v in self.inputs.values()):
            raise ValueError("All input mappings must be strings")
    
    @classmethod
    def from_issue(cls, issue_body: str) -> 'FeatureRequest':
        """Creates a FeatureRequest from a GitHub issue body."""
        try:
            # First try standard JSON parsing
            # try:
            #     data = json.loads(issue_body)
            # except json.JSONDecodeError:
            #     # If that fails, try replacing single quotes with double quotes
            #     # but only for the outermost quotes and dict keys
            #     fixed_body = (
            #         issue_body
            #         .replace("{'", '{"')
            #         .replace("'}", '"}')
            #         .replace("':", '":')
            #         .replace("',", '",')
            #     )
            #     data = json.loads(fixed_body)
            data = ast.literal_eval(issue_body)
            
            return cls(
                name=data['name'],
                inputs=data['inputs'],
                prompt=data['prompt'],
                max_len=data.get('max_len', 20000),
                commit_cadence=data.get('commit_cadence', 10),
            )
        except (json.JSONDecodeError, KeyError) as e:
            raise ValueError(f"Invalid feature request format: {e}")


def get_github_context() -> tuple[str, str, str]:
    """
    Gets GitHub repository context from Actions environment.
    
    Returns:
        Tuple of (owner, repo, token)
    """
    repo = os.getenv("GITHUB_REPOSITORY")
    if not repo:
        raise RuntimeError("Must be run in GitHub Actions environment")
    
    token = os.getenv("GITHUB_TOKEN")
    if not token:
        raise RuntimeError("GitHub token not available")
        
    owner, repo = repo.split("/")
    return owner, repo, token


def get_feature_requests(
    owner: str,
    repo: str,
    label: str = "feature-node",
    feature_name: str | None = None,
    token: str | None = None
) -> Iterator[tuple[FeatureRequest, "Issue"]]:
    """
    Yields FeatureRequest objects from labeled GitHub issues.
    
    Args:
        owner: Repository owner
        repo: Repository name
        label: Base label to filter issues
        feature_name: If provided, also filter by feature:<name> label
        token: GitHub token
    """
    g = Github(token) if token else Github()
    repository = g.get_repo(f"{owner}/{repo}")
    
    labels = [label]
    if feature_name:
        labels.append(f"feature:{feature_name}")
    
    for issue in repository.get_issues(labels=labels, state="all"):
        try:
            yield FeatureRequest.from_issue(issue.body), issue
        except ValueError as e:
            logger.warning(f"Skipping issue {issue.number}: {e}")
            continue


def handle_missing_features(
    owner: str,
    repo: str,
    missing_features: set[str],
    token: str | None = None
) -> None:
    """
    Reopens feature creation issues for missing features.
    
    Args:
        owner: Repository owner
        repo: Repository name
        missing_features: Set of feature names that need to be created
        token: GitHub token
    """
    g = Github(token) if token else Github()
    repository = g.get_repo(f"{owner}/{repo}")
    
    # Track which features we've handled to avoid duplicate reopens
    handled_features = set()
    
    for feature in missing_features:
        if feature in handled_features:
            continue
            
        # Find the feature creation issue
        for request, issue in get_feature_requests(
            owner, repo, feature_name=feature, token=token
        ):
            if issue.state == "closed":
                logger.info(f"Reopening issue for feature: {feature}")
                issue.edit(state="open")
                handled_features.add(feature)
                break
        else:
            logger.warning(f"No creation issue found for feature: {feature}")


def create_feature(
    paper: Paper,
    request: FeatureRequest,
    owner: str,
    repo: str,
    token: str | None = None,
    reopen_dependencies: bool = True
) -> bool:
    """
    Creates a new feature for a paper based on the feature request.
    
    Args:
        paper: Paper object to create feature for
        request: Feature request specification
        owner: Repository owner (for dependency reopening)
        repo: Repository name (for dependency reopening)
        token: GitHub token (for dependency reopening)
        reopen_dependencies: Whether to reopen issues for missing dependencies
        
    Returns:
        True if feature was created successfully
    """
    missing_features = set()
    
    # Check if all required input features exist
    for feature_path in request.inputs:
        feature_type = feature_path.split('/')[1]
        if not paper.has_feature(feature_type):
            missing_features.add(feature_type)
            
    if missing_features and reopen_dependencies:
        handle_missing_features(owner, repo, missing_features, token)
        return 
    elif missing_features:
        logger.warning(
            f"Paper {paper.arxiv_id} missing required features: {missing_features}"
        )
        return 
            
    # Create feature directory
    feature_dir = paper.features_dir / request.name
    feature_dir.mkdir(parents=True, exist_ok=True)
    
    # Read input features and format prompt
    input_contents = {}
    for feature_path, var_name in request.inputs.items():
        feature_type = feature_path.split('/')[1]
        path = paper.feature_path(feature_type)
        if path and path.exists():
            content = path.read_text()
            # Truncate content if needed
            if request.max_len > 0:
                available_len = request.max_len - len(request.prompt)
                if len(content) > available_len:
                    logger.warning(
                        f"Truncating content for {paper.arxiv_id} "
                        f"from {len(content)} to {available_len} chars"
                    )
                content = content[:available_len]
            input_contents[var_name] = content
    
    # Format prompt with input contents
    formatted_prompt = request.prompt.format(**input_contents)
    
    # Send to DuckDuckGo chat
    ddg = DDGS()
    try:
        response = ddg.chat(formatted_prompt)
        output_path = feature_dir / f"{paper.arxiv_id}.md"
        output_path.write_text(response)
        logger.info(f"Created {request.name} feature for {paper.arxiv_id}")
        return str(output_path.absolute())
    except Exception as e:
        logger.error(f"Chat API error for {paper.arxiv_id}: {e}")
        return 


def process_feature_requests(
    data_dir: Path | str = "data/papers"
) -> None:
    """
    Process all open feature requests for all papers.
    """
    owner, repo, token = get_github_context()
    requests = []
    for request, _ in get_feature_requests(owner, repo, token=token):
        requests.append(request)
    logger.info(f"Found {len(requests)} feature requests")

    to_commit=[]
    for i, paper in enumerate(Paper.iter_papers(data_dir)):
        for request in requests:
            if paper.has_feature(request.name):
                logger.debug(f"{request.name} feature for paper {paper.arxiv_id} already previously generated. Skipping.")
                continue        

            output_path = create_feature(paper, request, owner, repo, token)
            if output_path:
                to_commit.append(output_path)
        #if i % request.commit_cadence == 0: # per-request commit cadences though... hmmm
        if to_commit and ((len(to_commit) % request.commit_cadence) == 0):
            commit_and_push(to_commit)
            to_commit=[]
    if to_commit:
        commit_and_push(to_commit)


if __name__ == "__main__":
    from fire import Fire
    
    def main(data_dir: str = "data/papers"):
        """CLI entry point to process feature requests."""
        process_feature_requests(data_dir)
        
    Fire(main)



---
File: scripts/process_pdf.py
---
# .github/scripts/process_pdf.py

import os
from pathlib import Path
from typing import Literal

import fire
import requests
from loguru import logger
from lxml import etree
from llamero.utils import commit_and_push

OutputFormat = Literal['markdown', 'tei']

def remove_extra_whitespace(text: str)->str:
    while '\n\n\n' in text:
        text = text.replace('\n\n\n', '\n\n')
    return text

def remove_gibberish(
    text: str,
    cutoff=2000
)->str:
    good_lines = []
    for line in text.split('\n'):
        _line = line[:]
        if _line.startswith("$"):
            _line = _line[1:-1]
        n_tok = len(_line)
        n_space = _line.count(" ")
        # I think this might remove some formulas if we use cutoff=0
        token_sparsity=1
        if n_tok:
            token_sparsity = n_space/n_tok
        
        _line = line[:]
        _line = _line.replace(" ","")

        skip=False
        if (abs(token_sparsity - .5) < .01) and (len(line) > cutoff):
            skip=True
        if "texitsha1_base64" in _line:
            skip=True
        if "texit>" in _line:
            skip=True
        if skip:
            logger.info(f"removing gibberish")
            logger.info(line)
            continue
        good_lines.append(line)
    return '\n'.join(good_lines)

def sanitize_markdown(text: str)->str:
    text=remove_extra_whitespace(text)
    text=remove_gibberish(text)
    return text

def get_feature_path(base_path: Path, feature_type: str, paper_id: str, ext: str) -> Path:
    """Create feature directory if it doesn't exist and return the full path."""
    feature_dir = base_path / 'features' / feature_type
    feature_dir.mkdir(parents=True, exist_ok=True)
    return feature_dir / f"{paper_id}{ext}"

def process_pdf_grobid(
    pdf_path: str, 
    format: OutputFormat = 'markdown', 
    tag: str = "grobid",
    output_path: str | None = None,
    regenerate_tei: bool = True,
) -> None:
    """
    Process a PDF file using Grobid and convert to the specified format.
    
    Output files will be saved in feature-specific directories:
    - TEI XML files go to features/tei-xml-grobid/
    - Markdown files go to features/markdown-grobid/
    
    Args:
        pdf_path: Path to the PDF file relative to the repository root.
        format: Output format, either 'markdown' or 'tei'.
        tag: Optional tag to append to the output filename (default: "grobid").
        output_path: Optional path where the output file should be saved. If provided,
            this overrides the default feature directory behavior.
        regenerate_tei: Whether to regenerate TEI XML even if it exists.
    """
    pdf_path = Path(pdf_path)
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")

    # Get paper directory
    paper_dir = pdf_path.parent

    # Generate paper ID from PDF filename
    paper_id = pdf_path.stem

    # Determine output paths
    if output_path:
        output_path = Path(output_path)
        tei_path = output_path.with_suffix('.tei.xml')
        md_path = output_path.with_suffix('.md')
    else:
        # Use feature directory structure
        tei_path = get_feature_path(paper_dir, f'tei-xml-{tag}', paper_id, '.xml')
        md_path = get_feature_path(paper_dir, f'markdown-{tag}', paper_id, '.md')
    
    logger.info(f"Processing {pdf_path}")
    logger.info(f"TEI output will go to {tei_path}")
    logger.info(f"Markdown output will go to {md_path}")

    if regenerate_tei or (not tei_path.exists()):
        grobid_host = os.environ.get('GROBID_HOST', 'localhost')
        base_url = f"http://{grobid_host}:8070"
        
        # Call Grobid to process the PDF into TEI XML
        with open(pdf_path, 'rb') as f:
            files = {'input': (pdf_path.name, f, 'application/pdf')}
            resp = requests.post(
                f"{base_url}/api/processFulltextDocument",
                files=files,
                headers={'Accept': 'application/xml'},
                timeout=300  # 5 minute timeout
            )
        
        if resp.status_code != 200:
            raise RuntimeError(f"Grobid processing failed: {resp.status_code}")
        
        # Ensure the feature directory exists and save the TEI output
        tei_path.parent.mkdir(parents=True, exist_ok=True)
        tei_path.write_text(resp.text)
        logger.info(f"Saved TEI XML to {tei_path}")
    
    if format == 'markdown':
        # Convert TEI to Markdown using XSLT
        xslt_path = Path(__file__).parent / 'tei2md.xslt'
        if not xslt_path.exists():
            raise FileNotFoundError(f"XSLT stylesheet not found: {xslt_path}")
        
        xslt = etree.parse(str(xslt_path))
        transform = etree.XSLT(xslt)
        
        tei_doc = etree.parse(str(tei_path))
        markdown = str(transform(tei_doc))
        markdown = sanitize_markdown(markdown)
        
        # Ensure the feature directory exists and save Markdown output
        md_path.parent.mkdir(parents=True, exist_ok=True)
        md_path.write_text(markdown)
        logger.info(f"Saved Markdown to {md_path}")
    else:
        logger.info(f"Output TEI XML saved at {tei_path}")

process_pdf = process_pdf_grobid

# Files to ignore during operations
ignore_files = [
    "gh-store-snapshot.json",
    "papers-archive.json",
    "papers.json",
    "papers.yaml"
]

# def flush_old_conversions(data_path: str = "data/papers", tag: str = "grobid"):
#     """
#     Remove all previous conversions with the specified tag from feature directories.
#     """
#     base_path = Path(data_path).parent
#     tei_dir = base_path / 'features' / f'tei-xml-{tag}'
#     md_dir = base_path / 'features' / f'markdown-{tag}'
    
#     if tei_dir.exists():
#         for fpath in tei_dir.glob("*.xml"):
#             fpath.unlink()
#         tei_dir.rmdir()
    
#     if md_dir.exists():
#         for fpath in md_dir.glob("*.md"):
#             fpath.unlink()
#         md_dir.rmdir()

def generate_missing_conversions(
    data_path: str = "data/papers",
    tag: str = "grobid",
    checkpoint_cadence=5,
    regenerate_tei: bool = True,
):
    """
    Generate missing conversions for PDFs, saving outputs to feature directories.
    """
    data_path = Path(data_path)
    modified_files = []
    
    for i, pdf_fpath in enumerate(data_path.rglob("*.pdf")):
        # Skip PDFs in source directories
        if "source" in str(pdf_fpath):
            continue
            
        # Determine feature paths
        #base_dir = pdf_fpath.parent.parent
        paper_dir = pdf_fpath.parent
        paper_id = pdf_fpath.stem
        md_path = get_feature_path(paper_dir, f'markdown-{tag}', paper_id, '.md')
        
        if not md_path.exists():
            process_pdf_grobid(pdf_fpath, regenerate_tei=regenerate_tei)
            # Add both markdown and TEI paths
            tei_path = get_feature_path(paper_dir, f'tei-xml-{tag}', paper_id, '.xml')
            modified_files.extend([md_path, tei_path])
            logger.info(f"Generated conversions for {pdf_fpath.name}")
            
        if (i % checkpoint_cadence) == 0 and modified_files:
            msg = "Persisting feature conversions"
            commit_and_push(files_to_commit=modified_files, message=msg)
            modified_files = []
            
    if modified_files:
        commit_and_push(files_to_commit=modified_files, message="Persisting remaining feature conversions")

if __name__ == '__main__':
    fire.Fire({
        "process_pdf": process_pdf,
        "generate_missing_conversions": generate_missing_conversions,
        #"flush_old_conversions": flush_old_conversions,
    })



---
File: scripts/process_task.py
---
# scripts/process_task.py
from dataclasses import dataclass
import json
from pathlib import Path

from duckduckgo_search import DDGS
import fire
#from gh_store.core.access import AccessControl
from loguru import logger

ddg = DDGS()

#access_control = AccessControl(self.repo)

# #TODO: access validation as gh-store CLI capability
# issue = self.repo.get_issue(issue_number)
# if not self.access_control.validate_issue_creator(issue):

def with_prompt(
  target: str|Path,
  prompt: str="summarize the following:\n\n {content}",
  max_len: int=1024,
):
  with Path(target).open() as f:
    content = f.read()
  if max_len > 0:
    content=content[:(max_len-len(prompt))]
  msg = prompt.format(content=content) # should probably chunk somehow and iterate over chunks
  logger.info(msg)
  response = ddg.chat(msg)
  return response
  

# ... should just use locals...
OPERATORS={
    "ddg.chat": ddg.chat,
    "with_prompt": with_prompt,
}

@dataclass
class TaskConfig:
    operator: str
    kwargs: dict


def main(config: dict):
    logger.info(config)
    if not isinstance(config, dict):
      config = json.loads(config)
    config = TaskConfig(**config)
    logger.info(config)
    op = OPERATORS[config.operator]
    result = op(**config.kwargs)
    logger.info(result)
    return result

fire.Fire(main)



---
File: scripts/toggle_issues.py
---
# scripts/toggle_issues.py
import os
import requests
from github import Github
from loguru import logger
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeRemainingColumn

logger.info("Starting issue toggle process")

# Initialize GitHub client
g = Github(os.environ["GITHUB_TOKEN"])
repo = g.get_repo(os.environ["REPO"])
label = os.environ["LABEL"]
perform_close = os.environ["PERFORM_CLOSE"].lower() == "true"
perform_reopen = os.environ["PERFORM_REOPEN"].lower() == "true"
reopen_all_matching = os.environ["REOPEN_ALL_MATCHING"].lower() == "true"

# Setup for direct API calls that will trigger webhooks
api_headers = {
    "Accept": "application/vnd.github.v3+json",
    "Authorization": f"token {os.environ['GITHUB_TOKEN']}",
    # This header is crucial - it tells GitHub to trigger webhooks
    "X-GitHub-Api-Version": "2022-11-28"
}
api_base_url = f"https://api.github.com/repos/{os.environ['REPO']}/issues"

def reopen_issue_with_webhook(issue_number: int) -> None:
    """Reopen an issue using the REST API to ensure webhook triggering."""
    response = requests.patch(
        f"{api_base_url}/{issue_number}",
        headers=api_headers,
        json={"state": "open"}
    )
    response.raise_for_status()

# Track which issues we close for potential reopening
closed_issue_numbers = []

# Create a progress instance with custom columns
progress = Progress(
    SpinnerColumn(),
    TextColumn("[bold blue]{task.description}"),
    BarColumn(),
    TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
    TimeRemainingColumn(),
    expand=True
)

with progress:
    if perform_close:
        # Get all open issues with the specified label
        logger.info(f"Finding open issues with label: {label}")
        open_issues = list(repo.get_issues(state="open", labels=[label]))

        if not open_issues:
            logger.warning("No open issues found with specified label")
        else:
            # Close all matching issues while recording their numbers
            logger.info(f"Found {len(open_issues)} issues to close")
            close_task = progress.add_task(
                "[red]Closing issues...", 
                total=len(open_issues)
            )
            
            for issue in open_issues:
                logger.info(f"Closing issue #{issue.number}")
                issue.edit(state="closed")
                closed_issue_numbers.append(issue.number)
                progress.update(close_task, advance=1)
    else:
        logger.info("Skipping close step")

    if perform_reopen:
        if reopen_all_matching:
            # Get all closed issues with the specified label
            logger.info(f"Finding all closed issues with label: {label}")
            closed_issues = list(repo.get_issues(state="closed", labels=[label]))
            
            if not closed_issues:
                logger.warning("No closed issues found with specified label")
            else:
                logger.info(f"Found {len(closed_issues)} issues to reopen")
                reopen_task = progress.add_task(
                    "[green]Reopening all matching issues...", 
                    total=len(closed_issues)
                )
                
                for issue in closed_issues:
                    logger.info(f"Reopening issue #{issue.number}")
                    reopen_issue_with_webhook(issue.number)
                    progress.update(reopen_task, advance=1)
        
        elif closed_issue_numbers:
            # Reopen only issues we just closed
            logger.info("Reopening previously closed issues")
            reopen_task = progress.add_task(
                "[green]Reopening issues from this run...", 
                total=len(closed_issue_numbers)
            )
            
            for number in closed_issue_numbers:
                logger.info(f"Reopening issue #{number}")
                reopen_issue_with_webhook(number)
                progress.update(reopen_task, advance=1)
        else:
            logger.info("No issues to reopen")
    else:
        logger.info("Skipping reopen step")

logger.info("Issue toggle process completed")


