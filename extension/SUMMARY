---
File: extension/background.ts
---
// background.ts
// Background script with simplified session tracking

import { GitHubStoreClient } from 'gh-store-client';
import { PaperManager } from './papers/manager';
import { SessionService } from './utils/session-service';
import { PopupManager } from './utils/popup-manager';
import { SourceIntegrationManager } from './source-integration/source-manager';
import { loguru } from './utils/logger';
import { PaperMetadata } from './papers/types';

// Import source plugins directly
import { arxivIntegration } from './source-integration/arxiv';
import { Message } from './source-integration/types';

const logger = loguru.getLogger('background');

// Global state
let githubToken = '';
let githubRepo = '';
let paperManager: PaperManager | null = null;
let sessionService: SessionService | null = null;
let popupManager: PopupManager | null = null;
let sourceManager: SourceIntegrationManager | null = null;

// Initialize sources
function initializeSources() {
  sourceManager = new SourceIntegrationManager();
  
  // Register built-in sources directly
  sourceManager.registerSource(arxivIntegration);
  
  logger.info('Source manager initialized');
  return sourceManager;
}

// Initialize everything
async function initialize() {
  try {
    // Initialize sources first
    initializeSources();
    
    // Load GitHub credentials
    const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);
    githubToken = items.githubToken || '';
    githubRepo = items.githubRepo || '';
    logger.info('Credentials loaded', { hasToken: !!githubToken, hasRepo: !!githubRepo });
    
    // Initialize paper manager if we have credentials
    if (githubToken && githubRepo) {
      const githubClient = new GitHubStoreClient(githubToken, githubRepo);
      
      // Pass the source manager to the paper manager
      paperManager = new PaperManager(githubClient, sourceManager!);
      logger.info('Paper manager initialized');
      
      // Initialize session service with paper manager
      sessionService = new SessionService(paperManager);
    } else {
      // Initialize session service without paper manager
      sessionService = new SessionService(null);
    }
    
    logger.info('Session service initialized');
    
    // Initialize popup manager
    popupManager = new PopupManager(
      () => sourceManager,
      () => paperManager
    );
    logger.info('Popup manager initialized');
    
    // Set up message listeners
    setupMessageListeners();
    
    // Initialize debug objects
    initializeDebugObjects();
  } catch (error) {
    logger.error('Initialization error', error);
  }
}

// Set up message listeners
function setupMessageListeners() {
  chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
    if (message.type === 'contentScriptReady' && sender.tab?.id) {
      logger.debug('Content script ready:', sender.tab.url);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'paperMetadata' && message.metadata) {
      // Store metadata received from content script
      handlePaperMetadata(message.metadata);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'getCurrentPaper') {
      const session = sessionService?.getCurrentSession();
      const paperMetadata = session 
        ? sessionService?.getPaperMetadata(session.sourceId, session.paperId)
        : null;
      
      logger.debug('Popup requested current paper', paperMetadata);
      sendResponse(paperMetadata);
      return true;
    }
    
    if (message.type === 'updateRating') {
      logger.debug('Rating update requested:', message.rating);
      handleUpdateRating(message.rating, sendResponse);
      return true; // Will respond asynchronously
    }
    
    if (message.type === 'startSession') {
      handleStartSession(message.sourceId, message.paperId);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'sessionHeartbeat') {
      handleSessionHeartbeat();
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'endSession') {
      handleEndSession(message.reason || 'user_action');
      sendResponse({ success: true });
      return true;
    }

    // New handler for manual paper logging from popup
    if (message.type === 'manualPaperLog' && message.metadata) {
      handleManualPaperLog(message.metadata)
        .then(() => sendResponse({ success: true }))
        .catch(error => {
          logger.error('Error handling manual paper log', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        });
      return true; // Will respond asynchronously
    }
    
    // Other message handlers are managed by PopupManager
    
    return false; // Not handled
  });
}

// Handle paper metadata from content script
async function handlePaperMetadata(metadata: PaperMetadata) {
  logger.info(`Received metadata for ${metadata.sourceId}:${metadata.paperId}`);
  
  try {
    // Store metadata in session service
    if (sessionService) {
      sessionService.storePaperMetadata(metadata);
    }
    
    // Store in GitHub if we have a paper manager
    if (paperManager) {
      await paperManager.getOrCreatePaper(metadata);
      logger.debug('Paper metadata stored in GitHub');
    }
  } catch (error) {
    logger.error('Error handling paper metadata', error);
  }
}

// Handle rating update
async function handleUpdateRating(rating: string, sendResponse: (response: any) => void) {
  if (!paperManager || !sessionService) {
    sendResponse({ success: false, error: 'Services not initialized' });
    return;
  }

  const session = sessionService.getCurrentSession();
  if (!session) {
    sendResponse({ success: false, error: 'No current session' });
    return;
  }

  const metadata = sessionService.getPaperMetadata();
  if (!metadata) {
    sendResponse({ success: false, error: 'No paper metadata available' });
    return;
  }

  try {
    await paperManager.updateRating(
      session.sourceId,
      session.paperId, 
      rating,
      metadata
    );
    
    // Update stored metadata with new rating
    metadata.rating = rating;
    
    sendResponse({ success: true });
  } catch (error) {
    logger.error('Error updating rating:', error);
    sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });
  }
}

// Handle session start request
function handleStartSession(sourceId: string, paperId: string) {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  // Get metadata if available
  const existingMetadata = sessionService.getPaperMetadata(sourceId, paperId);
  
  // Start the session
  sessionService.startSession(sourceId, paperId, existingMetadata);
  logger.info(`Started session for ${sourceId}:${paperId}`);
}

// Handle session heartbeat
function handleSessionHeartbeat() {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  sessionService.recordHeartbeat();
}

// Handle session end request
function handleEndSession(reason: string) {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  const session = sessionService.getCurrentSession();
  if (session) {
    logger.info(`Ending session: ${reason}`);
    sessionService.endSession();
  }
}

async function handleManualPaperLog(metadata: PaperMetadata): Promise<void> {
  logger.info(`Received manual paper log: ${metadata.sourceId}:${metadata.paperId}`);
  
  try {
    // Store metadata in session service
    if (sessionService) {
      sessionService.storePaperMetadata(metadata);
    }
    
    // Store in GitHub if we have a paper manager
    if (paperManager) {
      await paperManager.getOrCreatePaper(metadata);
      logger.debug('Manually logged paper stored in GitHub');
    }
  } catch (error) {
    logger.error('Error handling manual paper log', error);
    throw error;
  }
}

// Listen for credential changes
chrome.storage.onChanged.addListener(async (changes) => {
  logger.debug('Storage changes detected', Object.keys(changes));
  
  if (changes.githubToken) {
    githubToken = changes.githubToken.newValue;
  }
  if (changes.githubRepo) {
    githubRepo = changes.githubRepo.newValue;
  }
  
  // Reinitialize paper manager if credentials changed
  if (changes.githubToken || changes.githubRepo) {
    if (githubToken && githubRepo) {
      const githubClient = new GitHubStoreClient(githubToken, githubRepo);
      
      // Pass the source manager to the paper manager
      paperManager = new PaperManager(githubClient, sourceManager!);
      logger.info('Paper manager reinitialized');
      
      // Reinitialize session service with new paper manager
      sessionService = new SessionService(paperManager);
      logger.info('Session service reinitialized');
    }
  }
});

// Initialize debug objects in service worker scope
function initializeDebugObjects() {
  // @ts-ignore
  self.__DEBUG__ = {
    get paperManager() { return paperManager; },
    get sessionService() { return sessionService; },
    get popupManager() { return popupManager; },
    get sourceManager() { return sourceManager; },
    getGithubClient: () => paperManager ? paperManager.getClient() : null,
    getCurrentPaper: () => {
      const session = sessionService?.getCurrentSession();
      return session ? sessionService?.getPaperMetadata(session.sourceId, session.paperId) : null;
    },
    getSessionStats: () => sessionService?.getSessionStats(),
    getSources: () => sourceManager?.getAllSources(),
    forceEndSession: () => sessionService?.endSession()
  };

  logger.info('Debug objects registered');
}

// Initialize extension
initialize();



---
File: extension/config/session.ts
---
// config/session.ts
// Session configuration management

import { RawSessionConfig, SessionConfig } from './types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('session-config');

// Default configuration values
export const DEFAULT_CONFIG: RawSessionConfig = {
    idleThresholdMinutes: 5,
    minSessionDurationSeconds: 30,
    requireContinuousActivity: true,  // If true, resets timer on idle
    logPartialSessions: false,        // If true, logs sessions even if under minimum duration
    activityUpdateIntervalSeconds: 1  // How often to update active time
};

/**
 * Load session configuration from storage
 */
export async function loadSessionConfig(): Promise<RawSessionConfig> {
    try {
        const items = await chrome.storage.sync.get('sessionConfig');
        const config = { ...DEFAULT_CONFIG, ...items.sessionConfig };
        logger.debug('Loaded session config', config);
        return config;
    } catch (error) {
        logger.error('Error loading session config', error);
        return DEFAULT_CONFIG;
    }
}

/**
 * Save session configuration to storage
 */
export async function saveSessionConfig(config: RawSessionConfig): Promise<void> {
    try {
        // Ensure values are the correct type
        const sanitizedConfig: RawSessionConfig = {
            idleThresholdMinutes: Number(config.idleThresholdMinutes),
            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),
            requireContinuousActivity: Boolean(config.requireContinuousActivity),
            logPartialSessions: Boolean(config.logPartialSessions),
            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)
        };
        
        await chrome.storage.sync.set({ sessionConfig: sanitizedConfig });
        logger.debug('Saved session config', sanitizedConfig);
    } catch (error) {
        logger.error('Error saving session config', error);
        throw error;
    }
}

/**
 * Convert configuration to milliseconds for internal use
 */
export function getConfigurationInMs(config: RawSessionConfig): SessionConfig {
    return {
        idleThreshold: config.idleThresholdMinutes * 60 * 1000,
        minSessionDuration: config.minSessionDurationSeconds * 1000,
        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,
        requireContinuousActivity: config.requireContinuousActivity,
        logPartialSessions: config.logPartialSessions
    };
}



---
File: extension/config/types.ts
---
// config/types.ts
// Type definitions for configuration

export interface RawSessionConfig {
  // Time in minutes before considering user idle
  idleThresholdMinutes: number;
  
  // Minimum session duration in seconds to log
  minSessionDurationSeconds: number;
  
  // Whether to reset timer on idle
  requireContinuousActivity: boolean;
  
  // Whether to log sessions shorter than minimum duration
  logPartialSessions: boolean;
  
  // How often to update active time in seconds
  activityUpdateIntervalSeconds: number;
}

export interface SessionConfig {
  // Time in milliseconds before considering user idle
  idleThreshold: number;
  
  // Minimum session duration in milliseconds to log
  minSessionDuration: number;
  
  // Whether to reset timer on idle
  requireContinuousActivity: boolean;
  
  // Whether to log sessions shorter than minimum duration
  logPartialSessions: boolean;
  
  // How often to update active time in milliseconds
  activityUpdateInterval: number;
}

export interface StorageConfig {
  // GitHub access token
  githubToken: string;
  
  // GitHub repository (owner/repo)
  githubRepo: string;
  
  // Session tracking configuration
  sessionConfig: RawSessionConfig;
}



---
File: extension/content.ts
---
// content.ts
// Content script with simplified session tracking

import { LinkProcessor } from './source-integration/link-processor';
import { SourceIntegration, Message } from './source-integration/types';
import { PaperMetadata } from './papers/types';
import { loguru } from './utils/logger';
import { BaseSourceIntegration } from './source-integration/base-source';
import { generatePaperIdFromUrl } from './utils/metadata-extractor';

// Import source plugins directly
import { arxivIntegration } from './source-integration/arxiv';
//import { pdfIntegration } from './source-integration/pdf';

const logger = loguru.getLogger('content-script');

logger.info('Paper Tracker content script loaded');

// Available source integrations
const sourceIntegrations: SourceIntegration[] = [
  arxivIntegration,
  //pdfIntegration,
  // Add more sources as they become available
];

// Base source for fallback processing
const baseSource = new BaseSourceIntegration();

// Track active popup
let activePopup: HTMLElement | null = null;

// Heartbeat interval
let heartbeatInterval: number | null = null;
const HEARTBEAT_INTERVAL = 5000; // 5 seconds

// Track tab visibility
let isTabVisible = true;

// Track current session
let currentSession: { sourceId: string; paperId: string } | null = null;

// Create link processor
const linkProcessor = new LinkProcessor((sourceId, paperId, link) => {
  // Callback when link is found
  injectAnnotationButton(link, sourceId, paperId);
});

// Initialize sources
function initializeSources() {
  // Register each source with the link processor
  for (const source of sourceIntegrations) {
    logger.debug(`Initializing source: ${source.id}`);
    
    // Register patterns with link processor
    source.urlPatterns.forEach(pattern => {
      linkProcessor.registerPattern({
        sourceId: source.id,
        pattern,
        extractPaperId: (url: string) => source.extractPaperId(url)
      });
    });
  }
}

// Inject common styles
function injectStyles() {
  if (document.getElementById('paper-tracker-styles')) {
    return; // Already injected
  }
  
  const styles = `
  .paper-annotator {
    display: inline-block;
    margin-left: 4px;
    cursor: pointer;
    font-size: 0.9em;
    opacity: 0.7;
    transition: opacity 0.2s;
    vertical-align: baseline;
  }

  .paper-annotator:hover {
    opacity: 1;
  }

  .paper-popup-wrapper {
    position: fixed;
    z-index: 10000;
  }

  .paper-popup {
    position: relative;
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    width: 300px;
    box-sizing: border-box;
  }

  .paper-popup-header {
    font-weight: bold;
    margin-bottom: 8px;
    line-height: 1.4;
    font-size: 1em;
  }

  .paper-popup-meta {
    color: #666;
    font-size: 0.85em;
    margin-bottom: 12px;
    line-height: 1.4;
  }

  .paper-popup-buttons {
    display: flex;
    gap: 8px;
    margin: 8px 0;
  }

  .paper-popup button {
    padding: 6px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #f5f5f5;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9em;
  }

  .paper-popup button:hover {
    background: #e8e8e8;
    border-color: #ccc;
  }

  .paper-popup button.active {
    background: #e0e0e0;
    border-color: #aaa;
  }

  .paper-popup textarea {
    width: calc(100% - 16px);
    min-height: 80px;
    margin: 8px 0;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: vertical;
    font-family: inherit;
    font-size: 0.9em;
    line-height: 1.4;
    box-sizing: border-box;
  }

  .paper-popup textarea:focus {
    outline: none;
    border-color: #aaa;
  }

  .paper-popup-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 12px;
  }

  .paper-popup .save-button {
    background: #2563eb;
    color: white;
    border-color: #2563eb;
  }

  .paper-popup .save-button:hover {
    background: #1d4ed8;
    border-color: #1d4ed8;
  }
  `;
  
  const styleSheet = document.createElement('style');
  styleSheet.id = 'paper-tracker-styles';
  styleSheet.textContent = styles;
  document.head.appendChild(styleSheet);
  
  logger.debug('Injected styles');
}

// Add annotation button to link
function injectAnnotationButton(link: HTMLAnchorElement, sourceId: string, paperId: string): void {
  // Skip if already processed
  if (link.nextSibling && 
      link.nextSibling.nodeType === Node.ELEMENT_NODE &&
      (link.nextSibling as Element).classList.contains('paper-annotator')) {
    return;
  }
  
  // Create annotator button
  const annotator = document.createElement('span');
  annotator.className = 'paper-annotator';
  annotator.textContent = 'ðŸ“';
  annotator.title = 'Add annotation';
  
  // Store data attributes
  annotator.dataset.sourceId = sourceId;
  annotator.dataset.paperId = paperId;
  
  // Add click handler
  annotator.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Send message to background script to show popup
    chrome.runtime.sendMessage({
      type: 'showAnnotationPopup',
      sourceId,
      paperId,
      position: {
        x: e.clientX,
        y: e.clientY
      }
    });
  });
  
  // Add to page next to link
  link.parentNode?.insertBefore(annotator, link.nextSibling);
}

// Get source that can handle a URL
function getSourceForUrl(url: string): SourceIntegration | null {
  for (const source of sourceIntegrations) {
    if (source.canHandleUrl(url)) {
      return source;
    }
  }
  return null;
}

// Set up click-outside handler for popups
document.addEventListener('click', (e) => {
  if (activePopup && 
      !activePopup.contains(e.target as Node) && 
      !(e.target as Element).classList.contains('paper-annotator')) {
    activePopup.parentElement?.remove();
    activePopup = null;
  }
});

// Start session tracking
function startSessionTracking(sourceId: string, paperId: string) {
  // Stop any existing heartbeat
  stopHeartbeat();
  
  // Only start tracking if tab is visible
  if (!isTabVisible) {
    logger.debug(`Not starting session for ${sourceId}:${paperId} because tab is not visible`);
    return;
  }
  
  // Update current session
  currentSession = { sourceId, paperId };
  
  // Tell background script to start a new session
  chrome.runtime.sendMessage({
    type: 'startSession',
    sourceId,
    paperId
  }, response => {
    if (response?.success) {
      logger.debug(`Started session for ${sourceId}:${paperId}`);
      
      // Start sending heartbeats
      startHeartbeat();
    } else {
      logger.error(`Failed to start session for ${sourceId}:${paperId}`, response?.error);
    }
  });
}

// Start sending heartbeats to background script
function startHeartbeat() {
  if (!currentSession) return;
  
  // Clear any existing interval
  stopHeartbeat();
  
  // Set new interval
  heartbeatInterval = window.setInterval(() => {
    if (!currentSession) return;
    
    chrome.runtime.sendMessage({
      type: 'sessionHeartbeat',
      sourceId: currentSession.sourceId,
      paperId: currentSession.paperId,
      timestamp: Date.now()
    });
  }, HEARTBEAT_INTERVAL);
  
  logger.debug(`Started heartbeat for ${currentSession.sourceId}:${currentSession.paperId}`);
}

// Stop sending heartbeats
function stopHeartbeat() {
  if (heartbeatInterval !== null) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
    logger.debug('Stopped heartbeat');
  }
}

// End the current session
function endCurrentSession(reason: string) {
  if (!currentSession) return;
  
  const { sourceId, paperId } = currentSession;
  
  // Stop heartbeat
  stopHeartbeat();
  
  // Send end session message
  chrome.runtime.sendMessage({
    type: 'endSession',
    sourceId,
    paperId,
    reason
  }, response => {
    logger.debug(`Ended session for ${sourceId}:${paperId}`, { reason });
  });
  
  // Clear current session
  currentSession = null;
}

// Process the current page
async function processCurrentPage(force: boolean = false): Promise<PaperMetadata | null> {
  const url = window.location.href;
  
  // Find a source that can handle this URL
  let source = getSourceForUrl(url);
  
  // If no source was found and force parameter is set, use base source
  if (!source && force) {
    logger.info(`No matching source found, but force parameter set. Using base source for: ${url}`);
    source = baseSource;
  }

  // If we still don't have a source, return null
  if (!source) {
    logger.debug(`No source found for URL: ${url}`);
    return null;
  }

  // Now that we have a source, extract the paperId
  const paperId = source.extractPaperId(url);
  if (!paperId) {
    logger.info(`Unable to determine a paperId for url: ${url}`);
    return null;
  }
  
  try {
    // Use source-specific extraction
    const metadata = await source.extractMetadata(document, paperId);
    
    if (metadata) {
      // Send metadata to background script
      chrome.runtime.sendMessage({
        type: 'paperMetadata',
        metadata
      });
      
      logger.debug(`Sent extracted metadata to background script for ${metadata.sourceId}:${metadata.paperId}`);
      
      // Start session tracking if tab is visible
      if (isTabVisible) {
        startSessionTracking(metadata.sourceId, metadata.paperId);
      }
      
      return metadata;
    }
  } catch (error) {
    logger.error(`Error extracting metadata for ${source.id}:${paperId}`, error);
  }
  
  return null;
}

// Visibility change listener
document.addEventListener('visibilitychange', () => {
  const wasVisible = isTabVisible;
  isTabVisible = document.visibilityState === 'visible';
  
  if (isTabVisible && !wasVisible) {
    // Tab has become visible again - restart session
    logger.info('Tab became visible again');
    
    // If we have a current session, restart it
    if (currentSession) {
      startSessionTracking(currentSession.sourceId, currentSession.paperId);
    } else {
      // Otherwise, try to process the page
      processCurrentPage();
    }
  } else if (!isTabVisible && wasVisible) {
    // Tab has become hidden - end current session
    logger.info('Tab hidden');
    if (currentSession) {
      endCurrentSession('tab_hidden');
    }
  }
});

// Focus/blur listeners
window.addEventListener('focus', () => {
  if (!isTabVisible) return; // Don't restart if tab is hidden
  
  logger.info('Window gained focus');
  
  // If we have a current session, restart it
  if (currentSession) {
    startSessionTracking(currentSession.sourceId, currentSession.paperId);
  } else {
    // Otherwise, try to process the page
    processCurrentPage();
  }
});

window.addEventListener('blur', () => {
  logger.info('Window lost focus');
  
  // End the current session
  if (currentSession) {
    endCurrentSession('window_blur');
  }
});

// Inform background when page is unloaded
window.addEventListener('beforeunload', () => {
  if (currentSession) {
    logger.info('Page unloading');
    endCurrentSession('page_unload');
  }
});

// Message handler for background script
chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
  logger.debug('Received message', message);

  if (message.type === 'extractPaperMetadata') {
    logger.debug('Received request to force paper metadata extraction');
    
    // Use processCurrentPage with force=true to enable fallback extraction
    processCurrentPage(true)
      .then(metadata => {
        if (metadata) {
          sendResponse({ success: true, metadata });
        } else {
          sendResponse({ success: false, error: 'Failed to extract metadata' });
        }
      })
      .catch(error => {
        logger.error('Error extracting metadata', error);
        sendResponse({ 
          success: false, 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      });
    return true; // Will respond asynchronously
  }
  
  if (message.type === 'showPopup') {
    // Remove existing popup
    if (activePopup) {
      activePopup.parentElement?.remove();
      activePopup = null;
    }
    
    // Create popup wrapper
    const wrapper = document.createElement('div');
    wrapper.className = 'paper-popup-wrapper';
    
    // Position near click or element
    if (message.position) {
      wrapper.style.left = `${message.position.x}px`;
      wrapper.style.top = `${message.position.y}px`;
    }
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'paper-popup';
    popup.innerHTML = message.html;
    
    // Add to page
    wrapper.appendChild(popup);
    document.body.appendChild(wrapper);
    
    // Set up event handlers
    if (message.handlers) {
      for (const handler of message.handlers) {
        const elements = popup.querySelectorAll(handler.selector);
        elements.forEach(element => {
          element.addEventListener(handler.event, () => {
            chrome.runtime.sendMessage({
              type: 'popupAction',
              action: handler.action,
              sourceId: message.sourceId,
              paperId: message.paperId,
              data: {
                value: element.tagName === 'TEXTAREA' ? 
                  (element as HTMLTextAreaElement).value : 
                  (element as HTMLElement).getAttribute('data-vote'),
                checked: element.tagName === 'INPUT' ? 
                  (element as HTMLInputElement).checked : undefined,
                id: (element as HTMLElement).id
              }
            });
          });
        });
      }
    }
    
    // Save reference
    activePopup = popup;
    
    sendResponse({ success: true });
    return true;
  }
  
  if (message.type === 'processPage') {
    // Re-process the entire page
    linkProcessor.processLinks(document);
    processCurrentPage();
    sendResponse({ success: true });
    return true;
  }
});

// Initialize
(async function initialize() {
  // Inject styles
  injectStyles();
  
  // Initialize sources
  initializeSources();
  
  // Process links
  linkProcessor.processLinks(document);
  
  // Start observing for new links
  linkProcessor.startObserving(document);
  
  // Set initial tab visibility
  isTabVisible = document.visibilityState === 'visible';
  
  // Process current page
  processCurrentPage();
  
  // Tell background script we're ready and what page we're on
  chrome.runtime.sendMessage(
    { 
      type: 'contentScriptReady', 
      url: window.location.href 
    },
    (response) => {
      if (response?.success) {
        logger.debug('Background script acknowledged ready status');
      }
    }
  );
})();

// Set up observer for URL changes (single page apps)
let lastUrl = location.href;
new MutationObserver(() => {
  const url = location.href;
  if (url !== lastUrl) {
    // End any current session
    if (currentSession) {
      endCurrentSession('url_change');
    }
    
    // Update URL and process new page
    lastUrl = url;
    processCurrentPage();
  }
}).observe(document, { subtree: true, childList: true });



---
File: extension/dist/background.bundle.js
---
var d=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[];}get(e){let s=this.cache.get(e);if(s){if(Date.now()-s.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return s.lastAccessed=Date.now(),this.updateAccessOrder(e),s.issueNumber}}set(e,s,t){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let r=this.accessOrder[this.accessOrder.length-1];r&&(this.cache.delete(r),this.removeFromAccessOrder(r));}this.cache.set(e,{issueNumber:s,lastAccessed:Date.now(),createdAt:t.createdAt,updatedAt:t.updatedAt}),this.updateAccessOrder(e);}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e);}clear(){this.cache.clear(),this.accessOrder=[];}getStats(){return {size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,s){let t=this.cache.get(e);return t?s>t.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e);}removeFromAccessOrder(e){let s=this.accessOrder.indexOf(e);s>-1&&this.accessOrder.splice(s,1);}};var l="0.3.2";var f=class{constructor(e,s,t={}){this.token=e,this.repo=s,this.config={baseLabel:t.baseLabel??"stored-object",uidPrefix:t.uidPrefix??"UID:",reactions:{processed:t.reactions?.processed??"+1",initialState:t.reactions?.initialState??"rocket"}},this.cache=new d(t.cache);}async fetchFromGitHub(e,s={}){let t=new URL(`https://api.github.com/repos/${this.repo}${e}`);s.params&&(Object.entries(s.params).forEach(([i,a])=>{t.searchParams.append(i,a);}),delete s.params);let r=await fetch(t.toString(),{...s,headers:{Authorization:`token ${this.token}`,Accept:"application/vnd.github.v3+json",...s.headers}});if(!r.ok)throw new Error(`GitHub API error: ${r.status}`);return r.json()}createCommentPayload(e,s){let t={_data:e,_meta:{client_version:l,timestamp:new Date().toISOString(),update_mode:"append"}};return s&&(t.type=s),t}async getObject(e){let s=this.cache.get(e),t;if(s)try{t=await this.fetchFromGitHub(`/issues/${s}`),this._verifyIssueLabels(t,e)||(this.cache.remove(e),t=void 0);}catch{this.cache.remove(e);}if(!t){let c=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"closed"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);t=c[0];}if(!t?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let r=JSON.parse(t.body),i=new Date(t.created_at),a=new Date(t.updated_at);return this.cache.set(e,t.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,createdAt:i,updatedAt:a,version:await this._getVersion(t.number)},data:r}}async createObject(e,s){let t=`${this.config.uidPrefix}${e}`,r=await this.fetchFromGitHub("/issues",{method:"POST",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(s,null,2),labels:[this.config.baseLabel,t]})});this.cache.set(e,r.number,{createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at)});let i=this.createCommentPayload(s,"initial_state"),a=await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(i,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${a.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:"PATCH",body:JSON.stringify({state:"closed"})}),{meta:{objectId:e,label:t,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:1},data:s}}_verifyIssueLabels(e,s){let t=new Set([this.config.baseLabel,`${this.config.uidPrefix}${s}`]);return e.labels.some(r=>t.has(r.name))}async updateObject(e,s){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],i=this.createCommentPayload(s);return await this.fetchFromGitHub(`/issues/${r.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${r.number}`,{method:"PATCH",body:JSON.stringify({state:"open"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed"}}),s={};for(let t of e)if(!t.labels.some(r=>r.name==="archived"))try{let r=this._getObjectIdFromLabels(t),i=JSON.parse(t.body),a={objectId:r,label:r,createdAt:new Date(t.created_at),updatedAt:new Date(t.updated_at),version:await this._getVersion(t.number)};s[r]={meta:a,data:i};}catch{continue}return s}async listUpdatedSince(e){let s=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed",since:e.toISOString()}}),t={};for(let r of s)if(!r.labels.some(i=>i.name==="archived"))try{let i=this._getObjectIdFromLabels(r),a=JSON.parse(r.body),n=new Date(r.updated_at);if(n>e){let c={objectId:i,label:i,createdAt:new Date(r.created_at),updatedAt:n,version:await this._getVersion(r.number)};t[i]={meta:c,data:a};}}catch{continue}return t}async getObjectHistory(e){let s=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!s||s.length===0)throw new Error(`No object found with ID: ${e}`);let t=s[0],r=await this.fetchFromGitHub(`/issues/${t.number}/comments`),i=[];for(let a of r)try{let n=JSON.parse(a.body),c="update",m,b={client_version:"legacy",timestamp:a.created_at,update_mode:"append"};typeof n=="object"?"_data"in n?(c=n.type||"update",m=n._data,b=n._meta||b):"type"in n&&n.type==="initial_state"?(c="initial_state",m=n.data):m=n:m=n,i.push({timestamp:a.created_at,type:c,data:m,commentId:a.id});}catch{continue}return i}async _getVersion(e){return (await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let s of e.labels)if(s.name!==this.config.baseLabel&&s.name.startsWith(this.config.uidPrefix))return s.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};

// extension/papers/types.ts
// Updated for heartbeat-based session tracking
/**
 * Type guard for interaction log
 */
function isInteractionLog(data) {
    const log = data;
    return (typeof log === 'object' &&
        log !== null &&
        typeof log.sourceId === 'string' &&
        typeof log.paperId === 'string' &&
        Array.isArray(log.interactions));
}

// utils/logger.ts
// Logging utility wrapping loguru
/**
 * Logger class for consistent logging throughout the extension
 */
class Logger {
    constructor(module) {
        this.module = module;
    }
    /**
     * Log debug message
     */
    debug(message, data) {
        console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log info message
     */
    info(message, data) {
        console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log warning message
     */
    warning(message, data) {
        console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log error message
     */
    error(message, data) {
        console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
}
/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
    /**
     * Get logger for a module
     */
    getLogger(module) {
        return new Logger(module);
    }
}
// Export singleton instance
const loguru = new LoguruMock();

const logger$7 = loguru.getLogger('paper-manager');
class PaperManager {
    constructor(client, sourceManager) {
        this.client = client;
        this.sourceManager = sourceManager;
        logger$7.debug('Paper manager initialized');
    }
    /**
     * Get paper by source and ID
     */
    async getPaper(sourceId, paperId) {
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            return obj.data;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                return null;
            }
            throw error;
        }
    }
    /**
     * Get or create paper metadata
     */
    async getOrCreatePaper(paperData) {
        const { sourceId, paperId } = paperData;
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            const data = obj.data;
            logger$7.debug(`Retrieved existing paper: ${paperIdentifier}`);
            return data;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                // Create new paper
                const defaultPaperData = {
                    ...paperData,
                    timestamp: new Date().toISOString(),
                    rating: paperData.rating || 'novote'
                };
                await this.client.createObject(objectId, defaultPaperData);
                logger$7.debug(`Created new paper: ${paperIdentifier}`);
                return defaultPaperData;
            }
            throw error;
        }
    }
    /**
     * Get or create interaction log for a paper
     */
    async getOrCreateInteractionLog(sourceId, paperId) {
        const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            const data = obj.data;
            if (isInteractionLog(data)) {
                return data;
            }
            throw new Error('Invalid interaction log format');
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                const newLog = {
                    sourceId,
                    paperId,
                    interactions: []
                };
                await this.client.createObject(objectId, newLog);
                logger$7.debug(`Created new interaction log: ${paperIdentifier}`);
                return newLog;
            }
            throw error;
        }
    }
    /**
     * Get GitHub client instance
     */
    getClient() {
        return this.client;
    }
    /**
     * Log a reading session
     */
    async logReadingSession(sourceId, paperId, session, paperData) {
        // Ensure paper exists
        if (paperData) {
            await this.getOrCreatePaper({
                sourceId,
                paperId,
                url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
                title: paperData.title || paperId,
                authors: paperData.authors || '',
                abstract: paperData.abstract || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: paperData.publishedDate || '',
                tags: paperData.tags || []
            });
        }
        // Log the session as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'reading_session',
            timestamp: new Date().toISOString(),
            data: session
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Logged reading session for ${paperIdentifier}`, { duration: session.duration_seconds });
    }
    /**
     * Log an annotation
     */
    async logAnnotation(sourceId, paperId, key, value, paperData) {
        // Ensure paper exists
        if (paperData) {
            await this.getOrCreatePaper({
                sourceId,
                paperId,
                url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
                title: paperData.title || paperId,
                authors: paperData.authors || '',
                abstract: paperData.abstract || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: paperData.publishedDate || '',
                tags: paperData.tags || []
            });
        }
        // Log the annotation as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'annotation',
            timestamp: new Date().toISOString(),
            data: { key, value }
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Logged annotation for ${paperIdentifier}`, { key });
    }
    /**
     * Update paper rating
     */
    async updateRating(sourceId, paperId, rating, paperData) {
        // Ensure paper exists and get current data
        const paper = await this.getOrCreatePaper({
            sourceId,
            paperId,
            url: paperData?.url || this.sourceManager.formatPaperId(sourceId, paperId),
            title: paperData?.title || paperId,
            authors: paperData?.authors || '',
            abstract: paperData?.abstract || '',
            timestamp: new Date().toISOString(),
            rating: 'novote',
            publishedDate: paperData?.publishedDate || '',
            tags: paperData?.tags || []
        });
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        // Update paper metadata with new rating
        await this.client.updateObject(objectId, {
            ...paper,
            rating
        });
        // Log rating change as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'rating',
            timestamp: new Date().toISOString(),
            data: { rating }
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Updated rating for ${paperIdentifier} to ${rating}`);
    }
    /**
     * Add interaction to log
     */
    async addInteraction(sourceId, paperId, interaction) {
        const log = await this.getOrCreateInteractionLog(sourceId, paperId);
        log.interactions.push(interaction);
        const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
        await this.client.updateObject(objectId, log);
    }
}

// session-service.ts
const logger$6 = loguru.getLogger('session-service');
/**
 * Session tracking service for paper reading sessions
 *
 * Manages session state, heartbeats, and persistence
 * Designed for use in the background script (Service Worker)
 */
class SessionService {
    /**
     * Create a new session service
     */
    constructor(paperManager) {
        this.paperManager = paperManager;
        this.activeSession = null;
        this.timeoutId = null;
        this.paperMetadata = new Map();
        // Configuration
        this.HEARTBEAT_TIMEOUT = 15000; // 15 seconds
        logger$6.debug('Session service initialized');
    }
    /**
     * Start a new session for a paper
     */
    startSession(sourceId, paperId, metadata) {
        // End any existing session
        this.endSession();
        // Create new session
        this.activeSession = {
            sourceId,
            paperId,
            startTime: new Date(),
            heartbeatCount: 0,
            lastHeartbeatTime: new Date()
        };
        // Store metadata if provided
        if (metadata) {
            const key = `${sourceId}:${paperId}`;
            this.paperMetadata.set(key, metadata);
            logger$6.debug(`Stored metadata for ${key}`);
        }
        // Start timeout check
        this.scheduleTimeoutCheck();
        logger$6.info(`Started session for ${sourceId}:${paperId}`);
    }
    /**
     * Record a heartbeat for the current session
     */
    recordHeartbeat() {
        if (!this.activeSession) {
            return false;
        }
        this.activeSession.heartbeatCount++;
        this.activeSession.lastHeartbeatTime = new Date();
        // Reschedule timeout
        this.scheduleTimeoutCheck();
        if (this.activeSession.heartbeatCount % 12 === 0) { // Log every minute (12 x 5sec heartbeats)
            logger$6.debug(`Session received ${this.activeSession.heartbeatCount} heartbeats`);
        }
        return true;
    }
    /**
     * Schedule a check for heartbeat timeout
     */
    scheduleTimeoutCheck() {
        // Clear existing timeout
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
        }
        // Set new timeout
        this.timeoutId = self.setTimeout(() => {
            this.checkTimeout();
        }, this.HEARTBEAT_TIMEOUT);
    }
    /**
     * Check if the session has timed out due to missing heartbeats
     */
    checkTimeout() {
        if (!this.activeSession)
            return;
        const now = Date.now();
        const lastTime = this.activeSession.lastHeartbeatTime.getTime();
        if ((now - lastTime) > this.HEARTBEAT_TIMEOUT) {
            logger$6.info('Session timeout detected');
            this.endSession();
        }
        else {
            this.scheduleTimeoutCheck();
        }
    }
    /**
     * End the current session and get the data
     */
    endSession() {
        if (!this.activeSession)
            return null;
        // Clear timeout
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        const { sourceId, paperId, startTime, heartbeatCount } = this.activeSession;
        const endTime = new Date();
        // Calculate duration (5 seconds per heartbeat)
        const duration = heartbeatCount * 5;
        // Calculate total elapsed time
        const totalElapsed = endTime.getTime() - startTime.getTime();
        const totalElapsedSeconds = Math.round(totalElapsed / 1000);
        // Set idle seconds to the difference (for backward compatibility)
        const idleSeconds = Math.max(0, totalElapsedSeconds - duration);
        // Create session data
        const sessionData = {
            session_id: `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            source_id: sourceId,
            paper_id: paperId,
            start_time: startTime.toISOString(),
            end_time: endTime.toISOString(),
            heartbeat_count: heartbeatCount,
            duration_seconds: duration,
            // Legacy fields
            idle_seconds: idleSeconds,
            total_elapsed_seconds: totalElapsedSeconds
        };
        // Store session if it was meaningful and we have a paper manager
        if (this.paperManager && heartbeatCount > 0) {
            const metadata = this.getPaperMetadata(sourceId, paperId);
            this.paperManager.logReadingSession(sourceId, paperId, sessionData, metadata)
                .catch(err => logger$6.error('Failed to store session', err));
        }
        logger$6.info(`Ended session for ${sourceId}:${paperId}`, {
            duration,
            heartbeats: heartbeatCount
        });
        // Clear active session
        this.activeSession = null;
        return sessionData;
    }
    /**
     * Check if a session is currently active
     */
    hasActiveSession() {
        return this.activeSession !== null;
    }
    /**
     * Get information about the current session
     */
    getCurrentSession() {
        if (!this.activeSession)
            return null;
        return {
            sourceId: this.activeSession.sourceId,
            paperId: this.activeSession.paperId
        };
    }
    /**
     * Get paper metadata for the current or specified session
     */
    getPaperMetadata(sourceId, paperId) {
        if (!sourceId || !paperId) {
            if (!this.activeSession)
                return undefined;
            sourceId = this.activeSession.sourceId;
            paperId = this.activeSession.paperId;
        }
        return this.paperMetadata.get(`${sourceId}:${paperId}`);
    }
    /**
     * Store paper metadata
     */
    storePaperMetadata(metadata) {
        const key = `${metadata.sourceId}:${metadata.paperId}`;
        this.paperMetadata.set(key, metadata);
    }
    /**
     * Get time since last heartbeat in milliseconds
     */
    getTimeSinceLastHeartbeat() {
        if (!this.activeSession) {
            return null;
        }
        return Date.now() - this.activeSession.lastHeartbeatTime.getTime();
    }
    /**
     * Get session statistics for debugging
     */
    getSessionStats() {
        if (!this.activeSession) {
            return { active: false };
        }
        return {
            active: true,
            sourceId: this.activeSession.sourceId,
            paperId: this.activeSession.paperId,
            startTime: this.activeSession.startTime.toISOString(),
            heartbeatCount: this.activeSession.heartbeatCount,
            lastHeartbeatTime: this.activeSession.lastHeartbeatTime.toISOString(),
            elapsedTime: Math.round((Date.now() - this.activeSession.startTime.getTime()) / 1000)
        };
    }
}

// extension/utils/popup-manager.ts
const logger$5 = loguru.getLogger('popup-manager');
/**
 * Manages all popup-related functionality
 */
class PopupManager {
    /**
     * Create a new popup manager
     */
    constructor(sourceManagerProvider, paperManagerProvider) {
        this.sourceManagerProvider = sourceManagerProvider;
        this.paperManagerProvider = paperManagerProvider;
        this.setupMessageListeners();
        logger$5.debug('Popup manager initialized');
    }
    /**
     * Set up message listeners for popup-related messages
     */
    setupMessageListeners() {
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            // Handle popup actions (ratings, notes, etc.)
            if (message.type === 'popupAction') {
                this.handlePopupAction(message.sourceId, message.paperId, message.action, message.data).then(() => {
                    sendResponse({ success: true });
                }).catch(error => {
                    logger$5.error('Error handling popup action', error);
                    sendResponse({
                        success: false,
                        error: error instanceof Error ? error.message : 'Unknown error'
                    });
                });
                return true; // Will respond asynchronously
            }
            // Handle request to show annotation popup
            if (message.type === 'showAnnotationPopup' && sender.tab?.id) {
                this.handleShowAnnotationPopup(sender.tab.id, message.sourceId, message.paperId, message.position).then(() => {
                    sendResponse({ success: true });
                }).catch(error => {
                    logger$5.error('Error showing popup', error);
                    sendResponse({
                        success: false,
                        error: error instanceof Error ? error.message : 'Unknown error'
                    });
                });
                return true; // Will respond asynchronously
            }
            return false; // Not handled
        });
    }
    /**
     * Handle a request to show an annotation popup
     */
    async handleShowAnnotationPopup(tabId, sourceId, paperId, position) {
        logger$5.debug(`Showing annotation popup for ${sourceId}:${paperId}`);
        // Check if we have source and paper manager
        const sourceManager = this.sourceManagerProvider();
        const paperManager = this.paperManagerProvider();
        if (!sourceManager) {
            throw new Error('Source manager not initialized');
        }
        if (!paperManager) {
            throw new Error('Paper manager not initialized');
        }
        try {
            // Get paper data
            const paper = await paperManager.getPaper(sourceId, paperId);
            // Create popup HTML
            const html = this.createPopupHtml(paper || {
                sourceId,
                paperId,
                title: paperId,
                authors: '',
                abstract: '',
                url: '',
                timestamp: new Date().toISOString(),
                publishedDate: '',
                tags: [],
                rating: 'novote'
            });
            // Get handlers
            const handlers = this.getStandardPopupHandlers();
            // Send message to content script to show popup
            const message = {
                type: 'showPopup',
                sourceId,
                paperId,
                html,
                handlers,
                position
            };
            await chrome.tabs.sendMessage(tabId, message);
            logger$5.debug(`Sent popup to content script for ${sourceId}:${paperId}`);
        }
        catch (error) {
            logger$5.error(`Error showing popup for ${sourceId}:${paperId}`, error);
            throw error;
        }
    }
    /**
     * Handle popup actions (ratings, notes, etc.)
     */
    async handlePopupAction(sourceId, paperId, action, data) {
        const paperManager = this.paperManagerProvider();
        if (!paperManager) {
            throw new Error('Paper manager not initialized');
        }
        logger$5.debug(`Handling popup action: ${action}`, { sourceId, paperId });
        try {
            if (action === 'rate') {
                await paperManager.updateRating(sourceId, paperId, data.value);
                logger$5.info(`Updated rating for ${sourceId}:${paperId} to ${data.value}`);
            }
            else if (action === 'saveNotes') {
                if (data.value) {
                    await paperManager.logAnnotation(sourceId, paperId, 'notes', data.value);
                    logger$5.info(`Saved notes for ${sourceId}:${paperId}`);
                }
            }
        }
        catch (error) {
            logger$5.error(`Error handling action ${action} for ${sourceId}:${paperId}`, error);
            throw error;
        }
    }
    /**
     * Create HTML for paper popup
     */
    createPopupHtml(paper) {
        return `
      <div class="paper-popup-header">${paper.title || paper.paperId}</div>
      <div class="paper-popup-meta">${paper.authors || ''}</div>
      
      <div class="paper-popup-buttons">
        <button class="vote-button" data-vote="thumbsup" id="btn-thumbsup" ${paper.rating === 'thumbsup' ? 'class="active"' : ''}>ðŸ‘ Interesting</button>
        <button class="vote-button" data-vote="thumbsdown" id="btn-thumbsdown" ${paper.rating === 'thumbsdown' ? 'class="active"' : ''}>ðŸ‘Ž Not Relevant</button>
      </div>
      
      <textarea placeholder="Add notes about this paper..." id="paper-notes"></textarea>
      
      <div class="paper-popup-actions">
        <button class="save-button" id="btn-save">Save</button>
      </div>
    `;
    }
    /**
     * Get standard popup event handlers
     */
    getStandardPopupHandlers() {
        return [
            { selector: '#btn-thumbsup', event: 'click', action: 'rate' },
            { selector: '#btn-thumbsdown', event: 'click', action: 'rate' },
            { selector: '#btn-save', event: 'click', action: 'saveNotes' }
        ];
    }
}

// extension/source-integration/source-manager.ts
const logger$4 = loguru.getLogger('source-manager');
/**
 * Manages source integrations
 */
class SourceIntegrationManager {
    constructor() {
        this.sources = new Map();
        logger$4.info('Source integration manager initialized');
    }
    /**
     * Register a source integration
     */
    registerSource(source) {
        if (this.sources.has(source.id)) {
            logger$4.warning(`Source with ID '${source.id}' already registered, overwriting`);
        }
        this.sources.set(source.id, source);
        logger$4.info(`Registered source: ${source.name} (${source.id})`);
    }
    /**
     * Get all registered sources
     */
    getAllSources() {
        return Array.from(this.sources.values());
    }
    /**
     * Get source that can handle a URL
     */
    getSourceForUrl(url) {
        for (const source of this.sources.values()) {
            if (source.canHandleUrl(url)) {
                logger$4.debug(`Found source for URL '${url}': ${source.id}`);
                return source;
            }
        }
        logger$4.debug(`No source found for URL: ${url}`);
        return null;
    }
    /**
     * Get source by ID
     */
    getSourceById(sourceId) {
        const source = this.sources.get(sourceId);
        return source || null;
    }
    /**
     * Extract paper ID from URL using appropriate source
     */
    extractPaperId(url) {
        for (const source of this.sources.values()) {
            if (source.canHandleUrl(url)) {
                const paperId = source.extractPaperId(url);
                if (paperId) {
                    logger$4.debug(`Extracted paper ID '${paperId}' from URL using ${source.id}`);
                    return { sourceId: source.id, paperId };
                }
            }
        }
        logger$4.debug(`Could not extract paper ID from URL: ${url}`);
        return null;
    }
    /**
     * Format a paper identifier using the appropriate source
     */
    formatPaperId(sourceId, paperId) {
        const source = this.sources.get(sourceId);
        if (source) {
            return source.formatPaperId(paperId);
        }
        // Fallback if source not found
        logger$4.warning(`Source '${sourceId}' not found, using default format for paper ID`);
        return `${sourceId}.${paperId}`;
    }
    /**
     * Format an object ID using the appropriate source
     */
    formatObjectId(type, sourceId, paperId) {
        const source = this.sources.get(sourceId);
        if (source) {
            return source.formatObjectId(type, paperId);
        }
        // Fallback if source not found
        logger$4.warning(`Source '${sourceId}' not found, using default format for object ID`);
        return `${type}:${sourceId}.${paperId}`;
    }
    /**
     * Get all content script match patterns
     */
    getAllContentScriptMatches() {
        const patterns = [];
        for (const source of this.sources.values()) {
            patterns.push(...source.contentScriptMatches);
        }
        return patterns;
    }
}

// extension/utils/metadata-extractor.ts
const logger$3 = loguru.getLogger('metadata-extractor');
// Constants for standard source types
const SOURCE_TYPES = {
    PDF: 'pdf',
    URL: 'url',
};
/**
 * Base class for metadata extraction with customizable extraction methods
 * Each method can be overridden to provide source-specific extraction
 */
class MetadataExtractor {
    /**
     * Create a new metadata extractor for a document
     */
    constructor(document) {
        this.document = document;
        this.url = document.location.href;
        logger$3.debug('Initialized metadata extractor for:', this.url);
    }
    /**
     * Helper method to get content from meta tags
     */
    getMetaContent(selector) {
        const element = this.document.querySelector(selector);
        return element ? element.getAttribute('content') || '' : '';
    }
    /**
     * Extract and return all metadata fields
     */
    extract() {
        logger$3.debug('Extracting metadata from page:', this.url);
        const metadata = {
            title: this.extractTitle(),
            authors: this.extractAuthors(),
            description: this.extractDescription(),
            publishedDate: this.extractPublishedDate(),
            doi: this.extractDoi(),
            journalName: this.extractJournalName(),
            tags: this.extractTags(),
            url: this.url
        };
        logger$3.debug('Metadata extraction complete:', metadata);
        return metadata;
    }
    /**
     * Extract title from document
     * Considers multiple metadata standards with priority order
     */
    extractTitle() {
        // Title extraction - priority order
        return (
        // Dublin Core
        this.getMetaContent('meta[name="DC.Title"]') ||
            // Citation
            this.getMetaContent('meta[name="citation_title"]') ||
            // Open Graph
            this.getMetaContent('meta[property="og:title"]') ||
            // Standard meta
            this.getMetaContent('meta[name="title"]') ||
            // Fallback to document title
            this.document.title);
    }
    /**
     * Extract authors from document
     * Handles multiple author formats and sources
     */
    extractAuthors() {
        // Get all citation authors (some pages have multiple citation_author tags)
        const citationAuthors = [];
        this.document.querySelectorAll('meta[name="citation_author"]').forEach(el => {
            const content = el.getAttribute('content');
            if (content)
                citationAuthors.push(content);
        });
        // Get all DC creators
        const dcCreators = [];
        this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach(el => {
            const content = el.getAttribute('content');
            if (content)
                dcCreators.push(content);
        });
        // Individual author elements
        const dcCreator = this.getMetaContent('meta[name="DC.Creator.PersonalName"]');
        const citationAuthor = this.getMetaContent('meta[name="citation_author"]');
        const ogAuthor = this.getMetaContent('meta[property="og:article:author"]') ||
            this.getMetaContent('meta[name="author"]');
        // Set authors with priority
        if (dcCreators.length > 0) {
            return dcCreators.join(', ');
        }
        else if (citationAuthors.length > 0) {
            return citationAuthors.join(', ');
        }
        else if (dcCreator) {
            return dcCreator;
        }
        else if (citationAuthor) {
            return citationAuthor;
        }
        else if (ogAuthor) {
            return ogAuthor;
        }
        return '';
    }
    /**
     * Extract description/abstract from document
     */
    extractDescription() {
        return (this.getMetaContent('meta[name="DC.Description"]') ||
            this.getMetaContent('meta[name="citation_abstract"]') ||
            this.getMetaContent('meta[property="og:description"]') ||
            this.getMetaContent('meta[name="description"]'));
    }
    /**
     * Extract publication date from document
     */
    extractPublishedDate() {
        return (this.getMetaContent('meta[name="DC.Date.issued"]') ||
            this.getMetaContent('meta[name="citation_date"]') ||
            this.getMetaContent('meta[property="article:published_time"]'));
    }
    /**
     * Extract DOI (Digital Object Identifier) from document
     */
    extractDoi() {
        return (this.getMetaContent('meta[name="DC.Identifier.DOI"]') ||
            this.getMetaContent('meta[name="citation_doi"]'));
    }
    /**
     * Extract journal name from document
     */
    extractJournalName() {
        return (this.getMetaContent('meta[name="DC.Source"]') ||
            this.getMetaContent('meta[name="citation_journal_title"]'));
    }
    /**
     * Extract keywords/tags from document
     */
    extractTags() {
        const keywords = this.getMetaContent('meta[name="keywords"]') ||
            this.getMetaContent('meta[name="DC.Subject"]');
        if (keywords) {
            return keywords.split(',').map(tag => tag.trim());
        }
        return [];
    }
    /**
     * Determine if the current URL is a PDF
     */
    isPdf() {
        return isPdfUrl(this.url);
    }
    /**
     * Get the source type (PDF or URL)
     */
    getSourceType() {
        return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;
    }
    /**
     * Generate a paper ID for the current URL
     */
    generatePaperId() {
        return generatePaperIdFromUrl(this.url);
    }
}
/**
 * Create a common metadata extractor for a document
 * Factory function for creating the default extractor
 */
function createMetadataExtractor(document) {
    return new MetadataExtractor(document);
}
/**
 * Generate a paper ID from a URL
 * Creates a consistent hash-based identifier
 */
function generatePaperIdFromUrl(url) {
    // Use a basic hash function to create an ID from the URL
    let hash = 0;
    for (let i = 0; i < url.length; i++) {
        const char = url.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    // Create a positive hexadecimal string
    const positiveHash = Math.abs(hash).toString(16).toUpperCase();
    // Use the first 8 characters as the ID
    return positiveHash.substring(0, 8);
}
/**
 * Determine if a URL is a PDF
 */
function isPdfUrl(url) {
    return url.toLowerCase().endsWith('.pdf');
}

// extension/source-integration/base-source.ts
const logger$2 = loguru.getLogger('base-source');
/**
 * Base class for source integrations
 * Provides default implementations for all methods
 * Specific sources can override as needed
 */
class BaseSourceIntegration {
    constructor() {
        // Default properties - set for generic web pages
        this.id = 'url';
        this.name = 'Web Page';
        this.urlPatterns = [
            /^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i // Match HTTP/HTTPS URLs that aren't PDFs
        ];
        this.contentScriptMatches = [];
    }
    /**
     * Check if this integration can handle the given URL
     * Default implementation checks against urlPatterns
     */
    canHandleUrl(url) {
        return this.urlPatterns.some(pattern => pattern.test(url));
    }
    /**
     * Extract paper ID from URL
     * Default implementation creates a hash from the URL
     */
    extractPaperId(url) {
        return generatePaperIdFromUrl(url);
    }
    /**
     * Create a metadata extractor for the given document
     * Override this method to provide a custom extractor for your source
     */
    createMetadataExtractor(document) {
        return createMetadataExtractor(document);
    }
    /**
     * Extract metadata from a page
     * Default implementation uses common metadata extraction
     */
    async extractMetadata(document, paperId) {
        try {
            logger$2.debug(`Extracting metadata using base extractor for ID: ${paperId}`);
            // Create a metadata extractor for this document
            const extractor = this.createMetadataExtractor(document);
            // Extract metadata
            const extracted = extractor.extract();
            const url = document.location.href;
            // Determine source type (PDF or URL)
            const sourceType = extractor.getSourceType();
            // Create PaperMetadata object
            return {
                sourceId: this.id,
                //paperId: this.formatPaperId(paperId),
                paperId: paperId,
                url: url,
                title: extracted.title || document.title || paperId,
                authors: extracted.authors || '',
                abstract: extracted.description || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: extracted.publishedDate || '',
                tags: extracted.tags || [],
                doi: extracted.doi,
                journalName: extracted.journalName,
                sourceType: sourceType // Store the source type for reference
            };
        }
        catch (error) {
            logger$2.error('Error extracting metadata with base extractor', error);
            return null;
        }
    }
    /**
     * Format a paper identifier for this source
     * Default implementation uses the format: sourceId.paperId
     */
    formatPaperId(paperId) {
        return `${this.id}.${paperId}`;
    }
    /**
     * Parse a paper identifier specific to this source
     * Default implementation handles source.paperId format and extracts paperId
     */
    parsePaperId(identifier) {
        const prefix = `${this.id}.`;
        if (identifier.startsWith(prefix)) {
            return identifier.substring(prefix.length);
        }
        // Try legacy format (sourceId:paperId)
        const legacyPrefix = `${this.id}:`;
        if (identifier.startsWith(legacyPrefix)) {
            logger$2.debug(`Parsed legacy format identifier: ${identifier}`);
            return identifier.substring(legacyPrefix.length);
        }
        return null;
    }
    /**
     * Format a storage object ID for this source
     * Default implementation uses the format: type:sourceId.paperId
     */
    formatObjectId(type, paperId) {
        return `${type}:${this.formatPaperId(paperId)}`;
    }
}

// extension/source-integration/arxiv/index.ts
const logger$1 = loguru.getLogger('arxiv-integration');
/**
 * ArXiv integration with custom metadata extraction
 */
class ArXivIntegration extends BaseSourceIntegration {
    constructor() {
        super(...arguments);
        this.id = 'arxiv';
        this.name = 'arXiv.org';
        // URL patterns for papers
        this.urlPatterns = [
            /arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,
            /arxiv\.org\/\w+\/([0-9.]+)/
        ];
        // Content script matches
        this.contentScriptMatches = [
            "*://*.arxiv.org/*"
        ];
    }
    /**
     * Extract paper ID from URL
     */
    extractPaperId(url) {
        for (const pattern of this.urlPatterns) {
            const match = url.match(pattern);
            if (match) {
                return match[2] || match[1]; // The capture group with the paper ID
            }
        }
        return null;
    }
    /**
     * Extract metadata from page or fetch from API
     * Override parent method to handle the API fallback
     */
    async extractMetadata(document, paperId) {
        logger$1.info(`Extracting metadata for arXiv ID: ${paperId}`);
        // Try to extract from page first using our custom extractor
        const pageMetadata = await super.extractMetadata(document, paperId);
        // if (pageMetadata && pageMetadata.title && pageMetadata.authors) {
        logger$1.debug('Extracted metadata from page');
        return pageMetadata;
        // }
    }
}
// Export a singleton instance that can be used by both background and content scripts
const arxivIntegration = new ArXivIntegration();

// background.ts
const logger = loguru.getLogger('background');
// Global state
let githubToken = '';
let githubRepo = '';
let paperManager = null;
let sessionService = null;
let popupManager = null;
let sourceManager = null;
// Initialize sources
function initializeSources() {
    sourceManager = new SourceIntegrationManager();
    // Register built-in sources directly
    sourceManager.registerSource(arxivIntegration);
    logger.info('Source manager initialized');
    return sourceManager;
}
// Initialize everything
async function initialize() {
    try {
        // Initialize sources first
        initializeSources();
        // Load GitHub credentials
        const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);
        githubToken = items.githubToken || '';
        githubRepo = items.githubRepo || '';
        logger.info('Credentials loaded', { hasToken: !!githubToken, hasRepo: !!githubRepo });
        // Initialize paper manager if we have credentials
        if (githubToken && githubRepo) {
            const githubClient = new f(githubToken, githubRepo);
            // Pass the source manager to the paper manager
            paperManager = new PaperManager(githubClient, sourceManager);
            logger.info('Paper manager initialized');
            // Initialize session service with paper manager
            sessionService = new SessionService(paperManager);
        }
        else {
            // Initialize session service without paper manager
            sessionService = new SessionService(null);
        }
        logger.info('Session service initialized');
        // Initialize popup manager
        popupManager = new PopupManager(() => sourceManager, () => paperManager);
        logger.info('Popup manager initialized');
        // Set up message listeners
        setupMessageListeners();
        // Initialize debug objects
        initializeDebugObjects();
    }
    catch (error) {
        logger.error('Initialization error', error);
    }
}
// Set up message listeners
function setupMessageListeners() {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.type === 'contentScriptReady' && sender.tab?.id) {
            logger.debug('Content script ready:', sender.tab.url);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'paperMetadata' && message.metadata) {
            // Store metadata received from content script
            handlePaperMetadata(message.metadata);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'getCurrentPaper') {
            const session = sessionService?.getCurrentSession();
            const paperMetadata = session
                ? sessionService?.getPaperMetadata(session.sourceId, session.paperId)
                : null;
            logger.debug('Popup requested current paper', paperMetadata);
            sendResponse(paperMetadata);
            return true;
        }
        if (message.type === 'updateRating') {
            logger.debug('Rating update requested:', message.rating);
            handleUpdateRating(message.rating, sendResponse);
            return true; // Will respond asynchronously
        }
        if (message.type === 'startSession') {
            handleStartSession(message.sourceId, message.paperId);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'sessionHeartbeat') {
            handleSessionHeartbeat();
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'endSession') {
            handleEndSession(message.reason || 'user_action');
            sendResponse({ success: true });
            return true;
        }
        // New handler for manual paper logging from popup
        if (message.type === 'manualPaperLog' && message.metadata) {
            handleManualPaperLog(message.metadata)
                .then(() => sendResponse({ success: true }))
                .catch(error => {
                logger.error('Error handling manual paper log', error);
                sendResponse({
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            });
            return true; // Will respond asynchronously
        }
        // Other message handlers are managed by PopupManager
        return false; // Not handled
    });
}
// Handle paper metadata from content script
async function handlePaperMetadata(metadata) {
    logger.info(`Received metadata for ${metadata.sourceId}:${metadata.paperId}`);
    try {
        // Store metadata in session service
        if (sessionService) {
            sessionService.storePaperMetadata(metadata);
        }
        // Store in GitHub if we have a paper manager
        if (paperManager) {
            await paperManager.getOrCreatePaper(metadata);
            logger.debug('Paper metadata stored in GitHub');
        }
    }
    catch (error) {
        logger.error('Error handling paper metadata', error);
    }
}
// Handle rating update
async function handleUpdateRating(rating, sendResponse) {
    if (!paperManager || !sessionService) {
        sendResponse({ success: false, error: 'Services not initialized' });
        return;
    }
    const session = sessionService.getCurrentSession();
    if (!session) {
        sendResponse({ success: false, error: 'No current session' });
        return;
    }
    const metadata = sessionService.getPaperMetadata();
    if (!metadata) {
        sendResponse({ success: false, error: 'No paper metadata available' });
        return;
    }
    try {
        await paperManager.updateRating(session.sourceId, session.paperId, rating, metadata);
        // Update stored metadata with new rating
        metadata.rating = rating;
        sendResponse({ success: true });
    }
    catch (error) {
        logger.error('Error updating rating:', error);
        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });
    }
}
// Handle session start request
function handleStartSession(sourceId, paperId) {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    // Get metadata if available
    const existingMetadata = sessionService.getPaperMetadata(sourceId, paperId);
    // Start the session
    sessionService.startSession(sourceId, paperId, existingMetadata);
    logger.info(`Started session for ${sourceId}:${paperId}`);
}
// Handle session heartbeat
function handleSessionHeartbeat() {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    sessionService.recordHeartbeat();
}
// Handle session end request
function handleEndSession(reason) {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    const session = sessionService.getCurrentSession();
    if (session) {
        logger.info(`Ending session: ${reason}`);
        sessionService.endSession();
    }
}
async function handleManualPaperLog(metadata) {
    logger.info(`Received manual paper log: ${metadata.sourceId}:${metadata.paperId}`);
    try {
        // Store metadata in session service
        if (sessionService) {
            sessionService.storePaperMetadata(metadata);
        }
        // Store in GitHub if we have a paper manager
        if (paperManager) {
            await paperManager.getOrCreatePaper(metadata);
            logger.debug('Manually logged paper stored in GitHub');
        }
    }
    catch (error) {
        logger.error('Error handling manual paper log', error);
        throw error;
    }
}
// Listen for credential changes
chrome.storage.onChanged.addListener(async (changes) => {
    logger.debug('Storage changes detected', Object.keys(changes));
    if (changes.githubToken) {
        githubToken = changes.githubToken.newValue;
    }
    if (changes.githubRepo) {
        githubRepo = changes.githubRepo.newValue;
    }
    // Reinitialize paper manager if credentials changed
    if (changes.githubToken || changes.githubRepo) {
        if (githubToken && githubRepo) {
            const githubClient = new f(githubToken, githubRepo);
            // Pass the source manager to the paper manager
            paperManager = new PaperManager(githubClient, sourceManager);
            logger.info('Paper manager reinitialized');
            // Reinitialize session service with new paper manager
            sessionService = new SessionService(paperManager);
            logger.info('Session service reinitialized');
        }
    }
});
// Initialize debug objects in service worker scope
function initializeDebugObjects() {
    // @ts-ignore
    self.__DEBUG__ = {
        get paperManager() { return paperManager; },
        get sessionService() { return sessionService; },
        get popupManager() { return popupManager; },
        get sourceManager() { return sourceManager; },
        getGithubClient: () => paperManager ? paperManager.getClient() : null,
        getCurrentPaper: () => {
            const session = sessionService?.getCurrentSession();
            return session ? sessionService?.getPaperMetadata(session.sourceId, session.paperId) : null;
        },
        getSessionStats: () => sessionService?.getSessionStats(),
        getSources: () => sourceManager?.getAllSources(),
        forceEndSession: () => sessionService?.endSession()
    };
    logger.info('Debug objects registered');
}
// Initialize extension
initialize();
//# sourceMappingURL=background.bundle.js.map



---
File: extension/dist/content-script.js
---
!function(){"use strict";class e{constructor(e){this.module=e}debug(e,t){console.debug(`[${this.module}] ${e}`,void 0!==t?t:"")}info(e,t){console.info(`[${this.module}] ${e}`,void 0!==t?t:"")}warning(e,t){console.warn(`[${this.module}] ${e}`,void 0!==t?t:"")}error(e,t){console.error(`[${this.module}] ${e}`,void 0!==t?t:"")}}const t=new class{getLogger(t){return new e(t)}},n=t.getLogger("link-processor");const r=t.getLogger("metadata-extractor"),a="pdf",o="url";class s{constructor(e){this.document=e,this.url=e.location.href,r.debug("Initialized metadata extractor for:",this.url)}getMetaContent(e){const t=this.document.querySelector(e);return t&&t.getAttribute("content")||""}extract(){r.debug("Extracting metadata from page:",this.url);const e={title:this.extractTitle(),authors:this.extractAuthors(),description:this.extractDescription(),publishedDate:this.extractPublishedDate(),doi:this.extractDoi(),journalName:this.extractJournalName(),tags:this.extractTags(),url:this.url};return r.debug("Metadata extraction complete:",e),e}extractTitle(){return this.getMetaContent('meta[name="DC.Title"]')||this.getMetaContent('meta[name="citation_title"]')||this.getMetaContent('meta[property="og:title"]')||this.getMetaContent('meta[name="title"]')||this.document.title}extractAuthors(){const e=[];this.document.querySelectorAll('meta[name="citation_author"]').forEach((t=>{const n=t.getAttribute("content");n&&e.push(n)}));const t=[];this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach((e=>{const n=e.getAttribute("content");n&&t.push(n)}));const n=this.getMetaContent('meta[name="DC.Creator.PersonalName"]'),r=this.getMetaContent('meta[name="citation_author"]'),a=this.getMetaContent('meta[property="og:article:author"]')||this.getMetaContent('meta[name="author"]');return t.length>0?t.join(", "):e.length>0?e.join(", "):n||(r||(a||""))}extractDescription(){return this.getMetaContent('meta[name="DC.Description"]')||this.getMetaContent('meta[name="citation_abstract"]')||this.getMetaContent('meta[property="og:description"]')||this.getMetaContent('meta[name="description"]')}extractPublishedDate(){return this.getMetaContent('meta[name="DC.Date.issued"]')||this.getMetaContent('meta[name="citation_date"]')||this.getMetaContent('meta[property="article:published_time"]')}extractDoi(){return this.getMetaContent('meta[name="DC.Identifier.DOI"]')||this.getMetaContent('meta[name="citation_doi"]')}extractJournalName(){return this.getMetaContent('meta[name="DC.Source"]')||this.getMetaContent('meta[name="citation_journal_title"]')}extractTags(){const e=this.getMetaContent('meta[name="keywords"]')||this.getMetaContent('meta[name="DC.Subject"]');return e?e.split(",").map((e=>e.trim())):[]}isPdf(){return this.url.toLowerCase().endsWith(".pdf")}getSourceType(){return this.isPdf()?a:o}generatePaperId(){return i(this.url)}}function i(e){let t=0;for(let n=0;n<e.length;n++){t=(t<<5)-t+e.charCodeAt(n),t|=0}return Math.abs(t).toString(16).toUpperCase().substring(0,8)}const c=t.getLogger("base-source");class d{constructor(){this.id="url",this.name="Web Page",this.urlPatterns=[/^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i],this.contentScriptMatches=[]}canHandleUrl(e){return this.urlPatterns.some((t=>t.test(e)))}extractPaperId(e){return i(e)}createMetadataExtractor(e){return function(e){return new s(e)}(e)}async extractMetadata(e,t){try{c.debug(`Extracting metadata using base extractor for ID: ${t}`);const n=this.createMetadataExtractor(e),r=n.extract(),a=e.location.href,o=n.getSourceType();return{sourceId:this.id,paperId:t,url:a,title:r.title||e.title||t,authors:r.authors||"",abstract:r.description||"",timestamp:(new Date).toISOString(),rating:"novote",publishedDate:r.publishedDate||"",tags:r.tags||[],doi:r.doi,journalName:r.journalName,sourceType:o}}catch(e){return c.error("Error extracting metadata with base extractor",e),null}}formatPaperId(e){return`${this.id}.${e}`}parsePaperId(e){const t=`${this.id}.`;if(e.startsWith(t))return e.substring(t.length);const n=`${this.id}:`;return e.startsWith(n)?(c.debug(`Parsed legacy format identifier: ${e}`),e.substring(n.length)):null}formatObjectId(e,t){return`${e}:${this.formatPaperId(t)}`}}const u=t.getLogger("arxiv-integration");const p=new class extends d{constructor(){super(...arguments),this.id="arxiv",this.name="arXiv.org",this.urlPatterns=[/arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,/arxiv\.org\/\w+\/([0-9.]+)/],this.contentScriptMatches=["*://*.arxiv.org/*"]}extractPaperId(e){for(const t of this.urlPatterns){const n=e.match(t);if(n)return n[2]||n[1]}return null}async extractMetadata(e,t){u.info(`Extracting metadata for arXiv ID: ${t}`);const n=await super.extractMetadata(e,t);return u.debug("Extracted metadata from page"),n}},l=t.getLogger("content-script");l.info("Paper Tracker content script loaded");const h=[p],g=new d;let m=null,b=null;let f=!0,x=null;const v=new class{constructor(e){this.patterns=[],this.observer=null,this.processedLinks=new Set,this.onLinkFound=e,n.debug("Link processor initialized")}registerPattern(e){this.patterns.push(e),n.debug(`Registered pattern for ${e.sourceId}`)}processLinks(e){e.querySelectorAll("a[href]").forEach((e=>{const t=this.getLinkId(e);if(!this.processedLinks.has(t)){this.processedLinks.add(t);for(const t of this.patterns)if(t.pattern.test(e.href)){const n=t.extractPaperId(e.href);if(n){this.onLinkFound(t.sourceId,n,e);break}}}}))}startObserving(e){this.observer&&this.observer.disconnect(),this.observer=new MutationObserver((t=>{let n=!1;t.forEach((e=>{e.addedNodes.forEach((e=>{if(e.nodeType===Node.ELEMENT_NODE){"A"===e.tagName&&(n=!0);e.querySelectorAll("a[href]").length>0&&(n=!0)}}))})),n&&this.processLinks(e)})),this.observer.observe(e.body,{childList:!0,subtree:!0}),n.debug("Started observing for DOM changes")}getLinkId(e){const t=this.getElementPath(e);return`${e.href}|${t}`}getElementPath(e){const t=[];let n=e;for(;n&&n!==document.body;){let e=n.tagName.toLowerCase();if(n.id)e+=`#${n.id}`;else{const t=Array.from(n.parentElement?.children||[]),r=t.indexOf(n)+1;t.length>1&&(e+=`:nth-child(${r})`)}t.unshift(e),n=n.parentElement}return t.join(" > ")}stopObserving(){this.observer&&(this.observer.disconnect(),this.observer=null,n.debug("Stopped observing DOM changes"))}}(((e,t,n)=>{!function(e,t,n){if(e.nextSibling&&e.nextSibling.nodeType===Node.ELEMENT_NODE&&e.nextSibling.classList.contains("paper-annotator"))return;const r=document.createElement("span");r.className="paper-annotator",r.textContent="ðŸ“",r.title="Add annotation",r.dataset.sourceId=t,r.dataset.paperId=n,r.addEventListener("click",(e=>{e.preventDefault(),e.stopPropagation(),chrome.runtime.sendMessage({type:"showAnnotationPopup",sourceId:t,paperId:n,position:{x:e.clientX,y:e.clientY}})})),e.parentNode?.insertBefore(r,e.nextSibling)}(n,e,t)}));function I(e,t){y(),f?(x={sourceId:e,paperId:t},chrome.runtime.sendMessage({type:"startSession",sourceId:e,paperId:t},(n=>{n?.success?(l.debug(`Started session for ${e}:${t}`),function(){if(!x)return;y(),b=window.setInterval((()=>{x&&chrome.runtime.sendMessage({type:"sessionHeartbeat",sourceId:x.sourceId,paperId:x.paperId,timestamp:Date.now()})}),5e3),l.debug(`Started heartbeat for ${x.sourceId}:${x.paperId}`)}()):l.error(`Failed to start session for ${e}:${t}`,n?.error)}))):l.debug(`Not starting session for ${e}:${t} because tab is not visible`)}function y(){null!==b&&(clearInterval(b),b=null,l.debug("Stopped heartbeat"))}function M(e){if(!x)return;const{sourceId:t,paperId:n}=x;y(),chrome.runtime.sendMessage({type:"endSession",sourceId:t,paperId:n,reason:e},(r=>{l.debug(`Ended session for ${t}:${n}`,{reason:e})})),x=null}async function w(e=!1){const t=window.location.href;let n=function(e){for(const t of h)if(t.canHandleUrl(e))return t;return null}(t);if(!n&&e&&(l.info(`No matching source found, but force parameter set. Using base source for: ${t}`),n=g),!n)return l.debug(`No source found for URL: ${t}`),null;const r=n.extractPaperId(t);if(!r)return l.info(`Unable to determine a paperId for url: ${t}`),null;try{const e=await n.extractMetadata(document,r);if(e)return chrome.runtime.sendMessage({type:"paperMetadata",metadata:e}),l.debug(`Sent extracted metadata to background script for ${e.sourceId}:${e.paperId}`),f&&I(e.sourceId,e.paperId),e}catch(e){l.error(`Error extracting metadata for ${n.id}:${r}`,e)}return null}document.addEventListener("click",(e=>{!m||m.contains(e.target)||e.target.classList.contains("paper-annotator")||(m.parentElement?.remove(),m=null)})),document.addEventListener("visibilitychange",(()=>{const e=f;f="visible"===document.visibilityState,f&&!e?(l.info("Tab became visible again"),x?I(x.sourceId,x.paperId):w()):!f&&e&&(l.info("Tab hidden"),x&&M("tab_hidden"))})),window.addEventListener("focus",(()=>{f&&(l.info("Window gained focus"),x?I(x.sourceId,x.paperId):w())})),window.addEventListener("blur",(()=>{l.info("Window lost focus"),x&&M("window_blur")})),window.addEventListener("beforeunload",(()=>{x&&(l.info("Page unloading"),M("page_unload"))})),chrome.runtime.onMessage.addListener(((e,t,n)=>{if(l.debug("Received message",e),"extractPaperMetadata"===e.type)return l.debug("Received request to force paper metadata extraction"),w(!0).then((e=>{n(e?{success:!0,metadata:e}:{success:!1,error:"Failed to extract metadata"})})).catch((e=>{l.error("Error extracting metadata",e),n({success:!1,error:e instanceof Error?e.message:"Unknown error"})})),!0;if("showPopup"===e.type){m&&(m.parentElement?.remove(),m=null);const t=document.createElement("div");t.className="paper-popup-wrapper",e.position&&(t.style.left=`${e.position.x}px`,t.style.top=`${e.position.y}px`);const r=document.createElement("div");if(r.className="paper-popup",r.innerHTML=e.html,t.appendChild(r),document.body.appendChild(t),e.handlers)for(const t of e.handlers){r.querySelectorAll(t.selector).forEach((n=>{n.addEventListener(t.event,(()=>{chrome.runtime.sendMessage({type:"popupAction",action:t.action,sourceId:e.sourceId,paperId:e.paperId,data:{value:"TEXTAREA"===n.tagName?n.value:n.getAttribute("data-vote"),checked:"INPUT"===n.tagName?n.checked:void 0,id:n.id}})}))}))}return m=r,n({success:!0}),!0}return"processPage"===e.type?(v.processLinks(document),w(),n({success:!0}),!0):void 0})),async function(){!function(){if(document.getElementById("paper-tracker-styles"))return;const e=document.createElement("style");e.id="paper-tracker-styles",e.textContent="\n  .paper-annotator {\n    display: inline-block;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    opacity: 0.7;\n    transition: opacity 0.2s;\n    vertical-align: baseline;\n  }\n\n  .paper-annotator:hover {\n    opacity: 1;\n  }\n\n  .paper-popup-wrapper {\n    position: fixed;\n    z-index: 10000;\n  }\n\n  .paper-popup {\n    position: relative;\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 12px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    width: 300px;\n    box-sizing: border-box;\n  }\n\n  .paper-popup-header {\n    font-weight: bold;\n    margin-bottom: 8px;\n    line-height: 1.4;\n    font-size: 1em;\n  }\n\n  .paper-popup-meta {\n    color: #666;\n    font-size: 0.85em;\n    margin-bottom: 12px;\n    line-height: 1.4;\n  }\n\n  .paper-popup-buttons {\n    display: flex;\n    gap: 8px;\n    margin: 8px 0;\n  }\n\n  .paper-popup button {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    background: #f5f5f5;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n  }\n\n  .paper-popup button:hover {\n    background: #e8e8e8;\n    border-color: #ccc;\n  }\n\n  .paper-popup button.active {\n    background: #e0e0e0;\n    border-color: #aaa;\n  }\n\n  .paper-popup textarea {\n    width: calc(100% - 16px);\n    min-height: 80px;\n    margin: 8px 0;\n    padding: 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 0.9em;\n    line-height: 1.4;\n    box-sizing: border-box;\n  }\n\n  .paper-popup textarea:focus {\n    outline: none;\n    border-color: #aaa;\n  }\n\n  .paper-popup-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n    margin-top: 12px;\n  }\n\n  .paper-popup .save-button {\n    background: #2563eb;\n    color: white;\n    border-color: #2563eb;\n  }\n\n  .paper-popup .save-button:hover {\n    background: #1d4ed8;\n    border-color: #1d4ed8;\n  }\n  ",document.head.appendChild(e),l.debug("Injected styles")}(),function(){for(const e of h)l.debug(`Initializing source: ${e.id}`),e.urlPatterns.forEach((t=>{v.registerPattern({sourceId:e.id,pattern:t,extractPaperId:t=>e.extractPaperId(t)})}))}(),v.processLinks(document),v.startObserving(document),f="visible"===document.visibilityState,w(),chrome.runtime.sendMessage({type:"contentScriptReady",url:window.location.href},(e=>{e?.success&&l.debug("Background script acknowledged ready status")}))}();let E=location.href;new MutationObserver((()=>{const e=location.href;e!==E&&(x&&M("url_change"),E=e,w())})).observe(document,{subtree:!0,childList:!0})}();
//# sourceMappingURL=content-script.js.map



---
File: extension/dist/options.bundle.js
---
// utils/logger.ts
// Logging utility wrapping loguru
/**
 * Logger class for consistent logging throughout the extension
 */
class Logger {
    constructor(module) {
        this.module = module;
    }
    /**
     * Log debug message
     */
    debug(message, data) {
        console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log info message
     */
    info(message, data) {
        console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log warning message
     */
    warning(message, data) {
        console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log error message
     */
    error(message, data) {
        console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
}
/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
    /**
     * Get logger for a module
     */
    getLogger(module) {
        return new Logger(module);
    }
}
// Export singleton instance
const loguru = new LoguruMock();

// config/session.ts
const logger = loguru.getLogger('session-config');
// Default configuration values
const DEFAULT_CONFIG = {
    idleThresholdMinutes: 5,
    minSessionDurationSeconds: 30,
    requireContinuousActivity: true, // If true, resets timer on idle
    logPartialSessions: false, // If true, logs sessions even if under minimum duration
    activityUpdateIntervalSeconds: 1 // How often to update active time
};
/**
 * Load session configuration from storage
 */
async function loadSessionConfig() {
    try {
        const items = await chrome.storage.sync.get('sessionConfig');
        const config = { ...DEFAULT_CONFIG, ...items.sessionConfig };
        logger.debug('Loaded session config', config);
        return config;
    }
    catch (error) {
        logger.error('Error loading session config', error);
        return DEFAULT_CONFIG;
    }
}
/**
 * Save session configuration to storage
 */
async function saveSessionConfig(config) {
    try {
        // Ensure values are the correct type
        const sanitizedConfig = {
            idleThresholdMinutes: Number(config.idleThresholdMinutes),
            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),
            requireContinuousActivity: Boolean(config.requireContinuousActivity),
            logPartialSessions: Boolean(config.logPartialSessions),
            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)
        };
        await chrome.storage.sync.set({ sessionConfig: sanitizedConfig });
        logger.debug('Saved session config', sanitizedConfig);
    }
    catch (error) {
        logger.error('Error saving session config', error);
        throw error;
    }
}

// options.ts
// Helper to set form values
function setFormValues(settings) {
    // GitHub settings
    if (settings.githubRepo) {
        document.getElementById('repo').value = settings.githubRepo;
    }
    if (settings.githubToken) {
        // Don't show the actual token, just indicate it's set
        document.getElementById('token').placeholder = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
    }
    // Session settings
    document.getElementById('idleThreshold').value =
        String(settings.sessionConfig?.idleThresholdMinutes ?? DEFAULT_CONFIG.idleThresholdMinutes);
    document.getElementById('minDuration').value =
        String(settings.sessionConfig?.minSessionDurationSeconds ?? DEFAULT_CONFIG.minSessionDurationSeconds);
    document.getElementById('requireContinuous').checked =
        settings.sessionConfig?.requireContinuousActivity ?? DEFAULT_CONFIG.requireContinuousActivity;
    document.getElementById('logPartial').checked =
        settings.sessionConfig?.logPartialSessions ?? DEFAULT_CONFIG.logPartialSessions;
}
// Helper to get form values
function getFormValues() {
    return {
        githubRepo: document.getElementById('repo').value.trim(),
        githubToken: document.getElementById('token').value.trim(),
        sessionConfig: {
            idleThresholdMinutes: Number(document.getElementById('idleThreshold').value),
            minSessionDurationSeconds: Number(document.getElementById('minDuration').value),
            requireContinuousActivity: document.getElementById('requireContinuous').checked,
            logPartialSessions: document.getElementById('logPartial').checked,
            activityUpdateIntervalSeconds: DEFAULT_CONFIG.activityUpdateIntervalSeconds // Keep default
        }
    };
}
// Display status message
function showStatus(message, isError = false) {
    const status = document.getElementById('status');
    if (!status)
        return;
    status.textContent = message;
    status.className = `status ${isError ? 'error' : 'success'}`;
    // Clear status after 3 seconds if it's a success message
    if (!isError) {
        setTimeout(() => {
            if (status) {
                status.textContent = '';
                status.className = 'status';
            }
        }, 3000);
    }
}
// Validate settings before saving
async function validateSettings(settings) {
    // Validate repository format
    if (!/^[\w-]+\/[\w-]+$/.test(settings.githubRepo)) {
        throw new Error('Invalid repository format. Use username/repository');
    }
    // Validate the token by making a test API call
    const response = await fetch(`https://api.github.com/repos/${settings.githubRepo}`, {
        headers: {
            'Authorization': `token ${settings.githubToken}`,
            'Accept': 'application/vnd.github.v3+json'
        }
    });
    if (!response.ok) {
        throw new Error('Invalid token or repository. Please check your credentials.');
    }
    // Validate session settings
    const { sessionConfig } = settings;
    if (sessionConfig.idleThresholdMinutes < 1 || sessionConfig.idleThresholdMinutes > 60) {
        throw new Error('Idle threshold must be between 1 and 60 minutes');
    }
    if (sessionConfig.minSessionDurationSeconds < 1 || sessionConfig.minSessionDurationSeconds > 300) {
        throw new Error('Minimum session duration must be between 10 and 300 seconds');
    }
}
// Save settings
async function saveSettings(settings) {
    await chrome.storage.sync.set({
        githubRepo: settings.githubRepo,
        githubToken: settings.githubToken
    });
    await saveSessionConfig(settings.sessionConfig);
}
// Initialize options page
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Load current settings
        const [storageItems, sessionConfig] = await Promise.all([
            chrome.storage.sync.get(['githubRepo', 'githubToken']),
            loadSessionConfig()
        ]);
        // Combine settings and display them
        setFormValues({
            ...storageItems,
            sessionConfig
        });
        // Add save button handler
        const saveButton = document.getElementById('save');
        if (saveButton) {
            saveButton.addEventListener('click', async () => {
                try {
                    const settings = getFormValues();
                    await validateSettings(settings);
                    await saveSettings(settings);
                    showStatus('Settings saved successfully!');
                }
                catch (error) {
                    showStatus(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
                }
            });
        }
    }
    catch (error) {
        showStatus(`Error loading settings: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
    }
});
//# sourceMappingURL=options.bundle.js.map



---
File: extension/dist/popup.bundle.js
---
// extension/popup.ts
// Popup script with refactored manual paper tracking
console.log('Popup script starting...');
// Function to get paper data from background script
async function getCurrentPaper() {
    return new Promise((resolve) => {
        chrome.runtime.sendMessage({ type: 'getCurrentPaper' }, (response) => {
            console.log('Got paper data from background:', response);
            resolve(response);
        });
    });
}
// Function to update UI with paper data
function updateUI(paperData) {
    const titleElement = document.getElementById('paperTitle');
    const authorsElement = document.getElementById('paperAuthors');
    const statusElement = document.getElementById('status');
    const manualLogSection = document.getElementById('manualLogSection');
    if (!titleElement || !authorsElement || !statusElement || !manualLogSection) {
        console.error('Required DOM elements not found');
        return;
    }
    if (paperData) {
        // Show detected paper data
        titleElement.textContent = paperData.title || paperData.paperId;
        authorsElement.textContent = paperData.authors;
        statusElement.textContent = 'Paper tracked! Issue created on GitHub.';
        // Enable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = false;
            thumbsDownButton.disabled = false;
            // Set active state on rating buttons
            thumbsUpButton.classList.toggle('active', paperData.rating === 'thumbsup');
            thumbsDownButton.classList.toggle('active', paperData.rating === 'thumbsdown');
        }
        // Hide manual log section
        manualLogSection.style.display = 'none';
    }
    else {
        // No paper detected - show manual log option
        titleElement.textContent = 'No paper detected';
        authorsElement.textContent = '';
        statusElement.textContent = 'Current page not recognized as a paper';
        // Disable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = true;
            thumbsDownButton.disabled = true;
        }
        // Show manual log section
        manualLogSection.style.display = 'block';
    }
}
// Function to log current page as a paper (using content script extraction)
async function logCurrentPage() {
    console.log("attempting to log paper");
    // Get the active tab
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tabs[0] || !tabs[0].id) {
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.textContent = 'Error: Could not access current tab';
        }
        return;
    }
    // Show loading state
    const statusElement = document.getElementById('status');
    if (statusElement) {
        statusElement.textContent = 'Extracting paper metadata...';
    }
    // Send message to content script requesting extraction
    chrome.tabs.sendMessage(tabs[0].id, {
        type: 'extractPaperMetadata'
    }, (response) => {
        if (chrome.runtime.lastError) {
            // Handle error
            if (statusElement) {
                statusElement.textContent = 'Error: ' + chrome.runtime.lastError.message;
            }
            return;
        }
        if (!response || !response.success || !response.metadata) {
            // Handle extraction failure
            if (statusElement) {
                statusElement.textContent = 'Error: ' + (response?.error || 'Failed to extract metadata');
            }
            return;
        }
        // Success - update UI
        updateUI(response.metadata);
        if (statusElement) {
            statusElement.textContent = 'Paper tracked successfully!';
        }
        // The content script has already:
        // 1. Sent metadata to background script
        // 2. Started a session if the tab is visible
        // Hide manual log section
        const manualLogSection = document.getElementById('manualLogSection');
        if (manualLogSection) {
            manualLogSection.style.display = 'none';
        }
        // Enable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = false;
            thumbsDownButton.disabled = false;
        }
    });
}
// Initialize popup
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Popup opened');
    // Get paper from the session tracker
    let paperData = null;
    let retries = 3;
    while (retries > 0 && !paperData) {
        paperData = await getCurrentPaper();
        if (!paperData) {
            await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
            retries--;
        }
    }
    updateUI(paperData);
    // Set up rating handlers
    const thumbsUpButton = document.getElementById('thumbsUp');
    if (thumbsUpButton) {
        thumbsUpButton.addEventListener('click', () => {
            chrome.runtime.sendMessage({
                type: 'updateRating',
                rating: 'thumbsup'
            }, (response) => {
                const statusElement = document.getElementById('status');
                const thumbsUpButton = document.getElementById('thumbsUp');
                const thumbsDownButton = document.getElementById('thumbsDown');
                if (!statusElement || !thumbsUpButton || !thumbsDownButton)
                    return;
                if (response && response.success) {
                    statusElement.textContent = 'Rating updated to: thumbs up';
                    thumbsUpButton.classList.add('active');
                    thumbsDownButton.classList.remove('active');
                    setTimeout(() => window.close(), 1500);
                }
                else {
                    statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
                }
            });
        });
    }
    const thumbsDownButton = document.getElementById('thumbsDown');
    if (thumbsDownButton) {
        thumbsDownButton.addEventListener('click', () => {
            chrome.runtime.sendMessage({
                type: 'updateRating',
                rating: 'thumbsdown'
            }, (response) => {
                const statusElement = document.getElementById('status');
                const thumbsUpButton = document.getElementById('thumbsUp');
                const thumbsDownButton = document.getElementById('thumbsDown');
                if (!statusElement || !thumbsUpButton || !thumbsDownButton)
                    return;
                if (response && response.success) {
                    statusElement.textContent = 'Rating updated to: thumbs down';
                    thumbsDownButton.classList.add('active');
                    thumbsUpButton.classList.remove('active');
                    setTimeout(() => window.close(), 1500);
                }
                else {
                    statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
                }
            });
        });
    }
    // Set up one-click logging button
    const logPageButton = document.getElementById('logPageButton');
    if (logPageButton) {
        console.log("Attaching logPageButton event listener...");
        logPageButton.addEventListener('click', () => {
            console.log("logPageButton clicked...");
            logCurrentPage();
        });
    }
});
//# sourceMappingURL=popup.bundle.js.map



---
File: extension/manifest.json
---
{
  "manifest_version": 3,
  "name": "Academic Paper Tracker",
  "version": "2.0",
  "description": "Track and annotate academic papers from various sources",
  "permissions": [
    "tabs",
    "storage",
    "webNavigation",
    "scripting",
    "activeTab"
  ],
  "host_permissions": [
    "*://*.arxiv.org/*", 
    "*://export.arxiv.org/*",
    "*://api.github.com/*",
    "<all_urls>"
  ],
  "background": {
    "service_worker": "dist/background.bundle.js",
    "type": "module"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["dist/content-script.js"],
    "run_at": "document_end",
    "type": "module"
  }],
  "action": {
    "default_popup": "popup.html"
  },
  "options_ui": {
    "page": "options.html",
    "open_in_tab": false
  }
}



---
File: extension/options.html
---
<!DOCTYPE html>
<html>
<head>
  <title>ArXiv Tracker Settings</title>
  <style>
    body {
      padding: 20px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .container {
      max-width: 500px;
      margin: 0 auto;
    }
    .field {
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    input[type="text"],
    input[type="password"],
    input[type="number"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }
    input[type="number"] {
      width: 100px;
    }
    .help-text {
      font-size: 0.9em;
      color: #666;
      margin-top: 4px;
    }
    .status {
      margin-top: 16px;
      padding: 8px;
      border-radius: 4px;
    }
    .success {
      background: #e6ffe6;
      color: #006600;
    }
    .error {
      background: #ffe6e6;
      color: #660000;
    }
    button {
      background: #0366d6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
    }
    button:hover {
      background: #0255b3;
    }
    .section {
      margin-bottom: 32px;
    }
    .section-title {
      font-size: 1.2em;
      font-weight: 600;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    .checkbox-field {
      margin-top: 12px;
    }
    .checkbox-field label {
      display: flex;
      align-items: center;
      font-weight: normal;
    }
    .checkbox-field input[type="checkbox"] {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ArXiv Tracker Settings</h2>
    
    <div class="section">
      <div class="section-title">GitHub Integration</div>
      <div class="field">
        <label for="repo">GitHub Repository</label>
        <input type="text" id="repo" placeholder="username/repository">
        <div class="help-text">Format: username/repository (e.g., johndoe/arxiv-tracker)</div>
      </div>

      <div class="field">
        <label for="token">GitHub Personal Access Token</label>
        <input type="password" id="token" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx">
        <div class="help-text">
          Token needs 'repo' scope for private repositories.<br>
          Never share this token with anyone.
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Reading Session Settings</div>
      
      <div class="field">
        <label for="idleThreshold">Idle Threshold (minutes)</label>
        <input type="number" id="idleThreshold" min="1" max="60" value="5">
        <div class="help-text">
          Time of inactivity before session is paused (1-60 minutes).<br>
          Default: 5 minutes
        </div>
      </div>

      <div class="field">
        <label for="minDuration">Minimum Session Duration (seconds)</label>
        <input type="number" id="minDuration" min="10" max="300" value="30">
        <div class="help-text">
          Minimum time required to log a reading session (10-300 seconds).<br>
          Default: 30 seconds
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="requireContinuous">
          Require Continuous Activity
        </label>
        <div class="help-text">
          When enabled, resets the session timer if you're idle for too long.<br>
          Default: Enabled
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="logPartial">
          Log Partial Sessions
        </label>
        <div class="help-text">
          When enabled, logs sessions even if they're shorter than the minimum duration.<br>
          Default: Disabled
        </div>
      </div>
    </div>

    <button id="save">Save Settings</button>
    <div id="status" class="status"></div>
  </div>
  <script type="module" src="dist/options.bundle.js"></script>
</body>
</html>



---
File: extension/options.ts
---
// options.ts
import { loadSessionConfig, DEFAULT_CONFIG, saveSessionConfig } from './config/session';
import { RawSessionConfig } from './config/types';

// Helper to set form values
function setFormValues(settings: {
  githubRepo?: string;
  githubToken?: string;
  sessionConfig?: RawSessionConfig;
}): void {
  // GitHub settings
  if (settings.githubRepo) {
    (document.getElementById('repo') as HTMLInputElement).value = settings.githubRepo;
  }
  if (settings.githubToken) {
    // Don't show the actual token, just indicate it's set
    (document.getElementById('token') as HTMLInputElement).placeholder = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
  }

  // Session settings
  (document.getElementById('idleThreshold') as HTMLInputElement).value = 
    String(settings.sessionConfig?.idleThresholdMinutes ?? DEFAULT_CONFIG.idleThresholdMinutes);
    
  (document.getElementById('minDuration') as HTMLInputElement).value = 
    String(settings.sessionConfig?.minSessionDurationSeconds ?? DEFAULT_CONFIG.minSessionDurationSeconds);
    
  (document.getElementById('requireContinuous') as HTMLInputElement).checked = 
    settings.sessionConfig?.requireContinuousActivity ?? DEFAULT_CONFIG.requireContinuousActivity;
    
  (document.getElementById('logPartial') as HTMLInputElement).checked = 
    settings.sessionConfig?.logPartialSessions ?? DEFAULT_CONFIG.logPartialSessions;
}

// Helper to get form values
function getFormValues(): {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
} {
  return {
    githubRepo: (document.getElementById('repo') as HTMLInputElement).value.trim(),
    githubToken: (document.getElementById('token') as HTMLInputElement).value.trim(),
    sessionConfig: {
      idleThresholdMinutes: Number((document.getElementById('idleThreshold') as HTMLInputElement).value),
      minSessionDurationSeconds: Number((document.getElementById('minDuration') as HTMLInputElement).value),
      requireContinuousActivity: (document.getElementById('requireContinuous') as HTMLInputElement).checked,
      logPartialSessions: (document.getElementById('logPartial') as HTMLInputElement).checked,
      activityUpdateIntervalSeconds: DEFAULT_CONFIG.activityUpdateIntervalSeconds // Keep default
    }
  };
}

// Display status message
function showStatus(message: string, isError = false): void {
  const status = document.getElementById('status');
  if (!status) return;
  
  status.textContent = message;
  status.className = `status ${isError ? 'error' : 'success'}`;

  // Clear status after 3 seconds if it's a success message
  if (!isError) {
    setTimeout(() => {
      if (status) {
        status.textContent = '';
        status.className = 'status';
      }
    }, 3000);
  }
}

// Validate settings before saving
async function validateSettings(settings: {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
}): Promise<void> {
  // Validate repository format
  if (!/^[\w-]+\/[\w-]+$/.test(settings.githubRepo)) {
    throw new Error('Invalid repository format. Use username/repository');
  }

  // Validate the token by making a test API call
  const response = await fetch(`https://api.github.com/repos/${settings.githubRepo}`, {
    headers: {
      'Authorization': `token ${settings.githubToken}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  if (!response.ok) {
    throw new Error('Invalid token or repository. Please check your credentials.');
  }

  // Validate session settings
  const { sessionConfig } = settings;
  if (sessionConfig.idleThresholdMinutes < 1 || sessionConfig.idleThresholdMinutes > 60) {
    throw new Error('Idle threshold must be between 1 and 60 minutes');
  }
  if (sessionConfig.minSessionDurationSeconds < 1 || sessionConfig.minSessionDurationSeconds > 300) {
    throw new Error('Minimum session duration must be between 10 and 300 seconds');
  }
}

// Save settings
async function saveSettings(settings: {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
}): Promise<void> {
  await chrome.storage.sync.set({
    githubRepo: settings.githubRepo,
    githubToken: settings.githubToken
  });

  await saveSessionConfig(settings.sessionConfig);
}

// Initialize options page
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Load current settings
    const [storageItems, sessionConfig] = await Promise.all([
      chrome.storage.sync.get(['githubRepo', 'githubToken']),
      loadSessionConfig()
    ]);

    // Combine settings and display them
    setFormValues({
      ...(storageItems as {
        githubRepo?: string;
        githubToken?: string;
      }),
      sessionConfig
    });

    // Add save button handler
    const saveButton = document.getElementById('save');
    if (saveButton) {
      saveButton.addEventListener('click', async () => {
        try {
          const settings = getFormValues();
          await validateSettings(settings);
          await saveSettings(settings);
          showStatus('Settings saved successfully!');
        } catch (error) {
          showStatus(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
        }
      });
    }

  } catch (error) {
    showStatus(`Error loading settings: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
  }
});



---
File: extension/package.json
---
{
  "name": "arxiv-tracker-extension",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "rollup -c",
    "watch": "rollup -c -w",
    "type-check": "tsc --noEmit",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write \"**/*.{ts,js}\"",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "gh-store-client": "^0.3.2"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^22.0.0",
    "@rollup/plugin-node-resolve": "^13.3.0",
    "@rollup/plugin-typescript": "^8.3.2",
    "@types/chrome": "^0.0.246",
    "@types/node": "^20.10.6",
    "@typescript-eslint/eslint-plugin": "^6.17.0",
    "@typescript-eslint/parser": "^6.17.0",
    "eslint": "^8.56.0",
    "prettier": "^3.1.1",
    "rollup": "^2.75.6",
    "rollup-plugin-terser": "^7.0.2",
    "tslib": "^2.4.0",
    "typescript": "^5.3.3"
  }
}



---
File: extension/papers/debug.d.ts
---
// extension/papers/debug.d.ts
import { GitHubStoreClient } from 'gh-store-client';
import { PaperManager } from './manager';

declare global {
    const __DEBUG__: {
        paperManager: PaperManager | null;
        getGithubClient: () => GitHubStoreClient | undefined;
        getCurrentPaper: () => any;
        getCurrentSession: () => any;
        getConfig: () => any;
    }
}



---
File: extension/papers/manager.ts
---
// extension/papers/manager.ts
import { GitHubStoreClient } from 'gh-store-client';
import type { Json } from 'gh-store-client';
import { 
  type PaperMetadata, 
  type InteractionLog, 
  type Interaction,
  type ReadingSessionData,
  isInteractionLog
} from './types';
import { SourceManager } from '../source-integration/types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('paper-manager');

export class PaperManager {
  constructor(
    private client: GitHubStoreClient,
    private sourceManager: SourceManager
  ) {
    logger.debug('Paper manager initialized');
  }
  
  /**
   * Get paper by source and ID
   */
  async getPaper(sourceId: string, paperId: string): Promise<PaperMetadata | null> {
    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      return obj.data as PaperMetadata;
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        return null;
      }
      throw error;
    }
  }
  
  /**
   * Get or create paper metadata
   */
  async getOrCreatePaper(paperData: PaperMetadata): Promise<PaperMetadata> {
    const { sourceId, paperId } = paperData;
    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      const data = obj.data as PaperMetadata;
      logger.debug(`Retrieved existing paper: ${paperIdentifier}`);
      return data;
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        // Create new paper
        const defaultPaperData: PaperMetadata = {
          ...paperData,
          timestamp: new Date().toISOString(),
          rating: paperData.rating || 'novote'
        };

        await this.client.createObject(objectId, defaultPaperData);
        logger.debug(`Created new paper: ${paperIdentifier}`);
        return defaultPaperData;
      }
      throw error;
    }
  }

  /**
   * Get or create interaction log for a paper
   */
  private async getOrCreateInteractionLog(sourceId: string, paperId: string): Promise<InteractionLog> {
    const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      const data = obj.data as unknown;
      if (isInteractionLog(data)) {
        return data;
      }
      throw new Error('Invalid interaction log format');
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        const newLog: InteractionLog = {
          sourceId,
          paperId,
          interactions: []
        };
        await this.client.createObject(objectId, newLog as unknown as { [key: string]: Json });
        logger.debug(`Created new interaction log: ${paperIdentifier}`);
        return newLog;
      }
      throw error;
    }
  }
  
  /**
   * Get GitHub client instance
   */
  getClient(): GitHubStoreClient {
    return this.client;
  }
  
  /**
   * Log a reading session
   */
  async logReadingSession(
    sourceId: string,
    paperId: string,
    session: ReadingSessionData,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists
    if (paperData) {
      await this.getOrCreatePaper({
        sourceId,
        paperId,
        url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
        title: paperData.title || paperId,
        authors: paperData.authors || '',
        abstract: paperData.abstract || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: paperData.publishedDate || '',
        tags: paperData.tags || []
      });
    }

    // Log the session as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'reading_session',
      timestamp: new Date().toISOString(),
      data: session as unknown as { [key: string]: Json }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Logged reading session for ${paperIdentifier}`, { duration: session.duration_seconds });
  }

  /**
   * Log an annotation
   */
  async logAnnotation(
    sourceId: string,
    paperId: string,
    key: string,
    value: Json,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists
    if (paperData) {
      await this.getOrCreatePaper({
        sourceId,
        paperId,
        url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
        title: paperData.title || paperId,
        authors: paperData.authors || '',
        abstract: paperData.abstract || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: paperData.publishedDate || '',
        tags: paperData.tags || []
      });
    }

    // Log the annotation as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'annotation',
      timestamp: new Date().toISOString(),
      data: { key, value }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Logged annotation for ${paperIdentifier}`, { key });
  }

  /**
   * Update paper rating
   */
  async updateRating(
    sourceId: string,
    paperId: string,
    rating: string,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists and get current data
    const paper = await this.getOrCreatePaper({
      sourceId,
      paperId,
      url: paperData?.url || this.sourceManager.formatPaperId(sourceId, paperId),
      title: paperData?.title || paperId,
      authors: paperData?.authors || '',
      abstract: paperData?.abstract || '',
      timestamp: new Date().toISOString(),
      rating: 'novote',
      publishedDate: paperData?.publishedDate || '',
      tags: paperData?.tags || []
    });

    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    
    // Update paper metadata with new rating
    await this.client.updateObject(objectId, { 
      ...paper,
      rating 
    });

    // Log rating change as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'rating',
      timestamp: new Date().toISOString(),
      data: { rating }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Updated rating for ${paperIdentifier} to ${rating}`);
  }

  /**
   * Add interaction to log
   */
  private async addInteraction(sourceId: string, paperId: string, interaction: Interaction): Promise<void> {
    const log = await this.getOrCreateInteractionLog(sourceId, paperId);
    log.interactions.push(interaction);
    
    const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
    await this.client.updateObject(objectId, log as unknown as { [key: string]: Json });
  }
}



---
File: extension/papers/types.ts
---
// extension/papers/types.ts
// Updated for heartbeat-based session tracking

import type { Json } from 'gh-store-client';

/**
 * Paper metadata from any source
 */
export interface PaperMetadata {
  // Source identifier
  sourceId: string;
  
  // Paper identifier within the source
  paperId: string;
  
  // Full URL to the paper
  url: string;
  
  // Paper title
  title: string;
  
  // Authors (comma-separated)
  authors: string;
  
  // Abstract or summary
  abstract: string;
  
  // When this paper was first added
  timestamp: string;
  
  // Publication date
  publishedDate: string;
  
  // Tags or categories
  tags: string[];
  
  // User-assigned rating (novote, thumbsup, thumbsdown)
  rating: string;
  
  // Allow additional source-specific properties
  [key: string]: any;
}

/**
 * Reading session data - updated for heartbeat tracking
 */
export interface ReadingSessionData {
  // Session identifier
  session_id: string;
  
  // Paper identifiers
  source_id?: string;
  paper_id?: string;
  
  // Session timing
  start_time: string;
  end_time: string;
  
  // Heartbeat data
  heartbeat_count: number;
  
  // Duration in seconds (derived from heartbeat count)
  duration_seconds: number;
  
  // Legacy properties for backward compatibility
  idle_seconds?: number;
  total_elapsed_seconds?: number;
}

/**
 * Interaction data
 */
export interface Interaction {
  // Type of interaction (reading_session, annotation, rating)
  type: string;
  
  // When interaction occurred
  timestamp: string;
  
  // Additional data
  data: Json;
}

/**
 * Interaction log
 */
export interface InteractionLog {
  // Source identifier
  sourceId: string;
  
  // Paper identifier within the source
  paperId: string;
  
  // List of interactions
  interactions: Interaction[];

  // Index signature to make it compatible with Json type
  [key: string]: string | Interaction[] | any;
}

/**
 * Type guard for interaction log
 */
export function isInteractionLog(data: unknown): data is InteractionLog {
  const log = data as InteractionLog;
  return (
    typeof log === 'object' &&
    log !== null &&
    typeof log.sourceId === 'string' &&
    typeof log.paperId === 'string' &&
    Array.isArray(log.interactions)
  );
}



---
File: extension/popup.html
---
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      width: 400px;
      padding: 15px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .paper-info {
      margin-bottom: 15px;
    }
    .paper-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }
    .paper-authors {
      font-size: 12px;
      color: #666;
      margin-bottom: 12px;
      line-height: 1.4;
    }
    .rating-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    button {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f5f5f5;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:not(:disabled):hover {
      background: #e5e5e5;
    }
    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #666;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 4px;
      text-align: center;
    }
    /* New styles for manual logging UI */
    .manual-log-section {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #eee;
      display: none; /* Hidden by default, shown when no paper detected */
    }
    .manual-log-section h3 {
      font-size: 14px;
      margin-top: 0;
      margin-bottom: 10px;
    }
    .log-button {
      width: 100%;
      padding: 10px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      margin-bottom: 10px;
    }
    .log-button:hover {
      background: #1d4ed8;
    }
  </style>
</head>
<body>
  <div id="currentPaper" class="paper-info">
    <div id="paperTitle" class="paper-title">Loading...</div>
    <div id="paperAuthors" class="paper-authors"></div>
    <div class="rating-buttons">
      <button id="thumbsUp" disabled>ðŸ‘ Interesting</button>
      <button id="thumbsDown" disabled>ðŸ‘Ž Not Relevant</button>
    </div>
    <div id="status" class="status">Loading paper details...</div>
  </div>
  
  <!-- New section for manually logging a paper with one-click -->
  <div id="manualLogSection" class="manual-log-section">
    <h3>This page is not tracked as a paper</h3>
    <button id="logPageButton" class="log-button">Track This Page</button>
  </div>
  
  <script src="dist/popup.bundle.js"></script>
</body>
</html>



---
File: extension/popup.ts
---
// extension/popup.ts
// Popup script with refactored manual paper tracking

import { PaperMetadata } from './papers/types';

console.log('Popup script starting...');

// Function to get paper data from background script
async function getCurrentPaper(): Promise<PaperMetadata | null> {
  return new Promise((resolve) => {
    chrome.runtime.sendMessage({type: 'getCurrentPaper'}, (response) => {
      console.log('Got paper data from background:', response);
      resolve(response as PaperMetadata | null);
    });
  });
}

// Interface for message response
interface MessageResponse {
  success: boolean;
  error?: string;
  metadata?: PaperMetadata;
}

// Function to update UI with paper data
function updateUI(paperData: PaperMetadata | null): void {
  const titleElement = document.getElementById('paperTitle');
  const authorsElement = document.getElementById('paperAuthors');
  const statusElement = document.getElementById('status');
  const manualLogSection = document.getElementById('manualLogSection');

  if (!titleElement || !authorsElement || !statusElement || !manualLogSection) {
    console.error('Required DOM elements not found');
    return;
  }

  if (paperData) {
    // Show detected paper data
    titleElement.textContent = paperData.title || paperData.paperId;
    authorsElement.textContent = paperData.authors;
    statusElement.textContent = 'Paper tracked! Issue created on GitHub.';
    
    // Enable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = false;
      thumbsDownButton.disabled = false;
      
      // Set active state on rating buttons
      thumbsUpButton.classList.toggle('active', paperData.rating === 'thumbsup');
      thumbsDownButton.classList.toggle('active', paperData.rating === 'thumbsdown');
    }
    
    // Hide manual log section
    manualLogSection.style.display = 'none';
  } else {
    // No paper detected - show manual log option
    titleElement.textContent = 'No paper detected';
    authorsElement.textContent = '';
    statusElement.textContent = 'Current page not recognized as a paper';
    
    // Disable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = true;
      thumbsDownButton.disabled = true;
    }
    
    // Show manual log section
    manualLogSection.style.display = 'block';
  }
}

// Function to log current page as a paper (using content script extraction)
async function logCurrentPage(): Promise<void> {
  console.log("attempting to log paper");
  
  // Get the active tab
  const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
  if (!tabs[0] || !tabs[0].id) {
    const statusElement = document.getElementById('status');
    if (statusElement) {
      statusElement.textContent = 'Error: Could not access current tab';
    }
    return;
  }
  
  // Show loading state
  const statusElement = document.getElementById('status');
  if (statusElement) {
    statusElement.textContent = 'Extracting paper metadata...';
  }
  
  // Send message to content script requesting extraction
  chrome.tabs.sendMessage(tabs[0].id, { 
    type: 'extractPaperMetadata' 
  }, (response: MessageResponse) => {
    if (chrome.runtime.lastError) {
      // Handle error
      if (statusElement) {
        statusElement.textContent = 'Error: ' + chrome.runtime.lastError.message;
      }
      return;
    }
    
    if (!response || !response.success || !response.metadata) {
      // Handle extraction failure
      if (statusElement) {
        statusElement.textContent = 'Error: ' + (response?.error || 'Failed to extract metadata');
      }
      return;
    }
    
    // Success - update UI
    updateUI(response.metadata);
    if (statusElement) {
      statusElement.textContent = 'Paper tracked successfully!';
    }
    
    // The content script has already:
    // 1. Sent metadata to background script
    // 2. Started a session if the tab is visible
    
    // Hide manual log section
    const manualLogSection = document.getElementById('manualLogSection');
    if (manualLogSection) {
      manualLogSection.style.display = 'none';
    }
    
    // Enable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = false;
      thumbsDownButton.disabled = false;
    }
  });
}

// Initialize popup
document.addEventListener('DOMContentLoaded', async () => {
  console.log('Popup opened');
  
  // Get paper from the session tracker
  let paperData: PaperMetadata | null = null;
  let retries = 3;
  
  while (retries > 0 && !paperData) {
    paperData = await getCurrentPaper();
    if (!paperData) {
      await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
      retries--;
    }
  }
  
  updateUI(paperData);
  
  // Set up rating handlers
  const thumbsUpButton = document.getElementById('thumbsUp');
  if (thumbsUpButton) {
    thumbsUpButton.addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsup'
      }, (response: MessageResponse) => {
        const statusElement = document.getElementById('status');
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        
        if (!statusElement || !thumbsUpButton || !thumbsDownButton) return;
        
        if (response && response.success) {
          statusElement.textContent = 'Rating updated to: thumbs up';
          thumbsUpButton.classList.add('active');
          thumbsDownButton.classList.remove('active');
          setTimeout(() => window.close(), 1500);
        } else {
          statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
        }
      });
    });
  }
  
  const thumbsDownButton = document.getElementById('thumbsDown');
  if (thumbsDownButton) {
    thumbsDownButton.addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsdown'
      }, (response: MessageResponse) => {
        const statusElement = document.getElementById('status');
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        
        if (!statusElement || !thumbsUpButton || !thumbsDownButton) return;
        
        if (response && response.success) {
          statusElement.textContent = 'Rating updated to: thumbs down';
          thumbsDownButton.classList.add('active');
          thumbsUpButton.classList.remove('active');
          setTimeout(() => window.close(), 1500);
        } else {
          statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
        }
      });
    });
  }
  
  // Set up one-click logging button
  const logPageButton = document.getElementById('logPageButton');
  if (logPageButton) {
    console.log("Attaching logPageButton event listener...");
    logPageButton.addEventListener('click', () => {
      console.log("logPageButton clicked...");
      logCurrentPage();
    });
  }
});



---
File: extension/rollup.config.js
---
// rollup.config.js
import typescript from '@rollup/plugin-typescript';
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import { terser } from 'rollup-plugin-terser';

export default [
  // Background script as ESM (module)
  {
    input: 'background.ts',
    output: {
      file: 'dist/background.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  },
  // Content script as IIFE (non-module)
  {
    input: 'content.ts',
    output: {
      file: 'dist/content-script.js',
      format: 'iife', // Immediately-invoked function expression - no imports needed
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs(),
      terser() // Minify for production (optional)
    ]
  },
  // Options script
  {
    input: 'options.ts',
    output: {
      file: 'dist/options.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  },
  // Popup script - converted to TypeScript
  {
    input: 'popup.ts',
    output: {
      file: 'dist/popup.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  }
];



---
File: extension/source-integration/arxiv/index.ts
---
// extension/source-integration/arxiv/index.ts
// ArXiv integration with custom metadata extractor

import { BaseSourceIntegration } from '../base-source';
import { PaperMetadata } from '../../papers/types';
import { MetadataExtractor, createMetadataExtractor } from '../../utils/metadata-extractor';
import { loguru } from '../../utils/logger';

const logger = loguru.getLogger('arxiv-integration');


/**
 * ArXiv integration with custom metadata extraction
 */
export class ArXivIntegration extends BaseSourceIntegration {
  readonly id = 'arxiv';
  readonly name = 'arXiv.org';
  
  // URL patterns for papers
  readonly urlPatterns = [
    /arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,
    /arxiv\.org\/\w+\/([0-9.]+)/
  ];
  
  // Content script matches
  readonly contentScriptMatches = [
    "*://*.arxiv.org/*"
  ];

  /**
   * Extract paper ID from URL
   */
  extractPaperId(url: string): string | null {
    for (const pattern of this.urlPatterns) {
      const match = url.match(pattern);
      if (match) {
        return match[2] || match[1]; // The capture group with the paper ID
      }
    }
    return null;
  }

  /**
   * Extract metadata from page or fetch from API
   * Override parent method to handle the API fallback
   */
  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {
    logger.info(`Extracting metadata for arXiv ID: ${paperId}`);
    
    // Try to extract from page first using our custom extractor
    const pageMetadata = await super.extractMetadata(document, paperId);
    
    // if (pageMetadata && pageMetadata.title && pageMetadata.authors) {
    logger.debug('Extracted metadata from page');
    return pageMetadata;
    // }
    
  }
}

// Export a singleton instance that can be used by both background and content scripts
export const arxivIntegration = new ArXivIntegration();



---
File: extension/source-integration/base-source.ts
---
// extension/source-integration/base-source.ts
// Base class for source integrations with default identifier formatting
// and metadata extraction capability

import { SourceIntegration } from './types';
import { PaperMetadata } from '../papers/types';
import { loguru } from '../utils/logger';
import { 
  MetadataExtractor, 
  createMetadataExtractor,
  generatePaperIdFromUrl
} from '../utils/metadata-extractor';

const logger = loguru.getLogger('base-source');

/**
 * Base class for source integrations
 * Provides default implementations for all methods
 * Specific sources can override as needed
 */
export class BaseSourceIntegration implements SourceIntegration {
  // Default properties - set for generic web pages
  readonly id: string = 'url';
  readonly name: string = 'Web Page';
  readonly urlPatterns: RegExp[] = [
    /^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i  // Match HTTP/HTTPS URLs that aren't PDFs
  ];
  readonly contentScriptMatches: string[] = [];

  /**
   * Check if this integration can handle the given URL
   * Default implementation checks against urlPatterns
   */
  canHandleUrl(url: string): boolean {
    return this.urlPatterns.some(pattern => pattern.test(url));
  }

  /**
   * Extract paper ID from URL
   * Default implementation creates a hash from the URL
   */
  extractPaperId(url: string): string | null {
    return generatePaperIdFromUrl(url);
  }
  
  /**
   * Create a metadata extractor for the given document
   * Override this method to provide a custom extractor for your source
   */
  protected createMetadataExtractor(document: Document): MetadataExtractor {
    return createMetadataExtractor(document);
  }
  
  /**
   * Extract metadata from a page
   * Default implementation uses common metadata extraction
   */
  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {
    try {
      logger.debug(`Extracting metadata using base extractor for ID: ${paperId}`);
      
      // Create a metadata extractor for this document
      const extractor = this.createMetadataExtractor(document);
      
      // Extract metadata
      const extracted = extractor.extract();
      const url = document.location.href;
      
      // Determine source type (PDF or URL)
      const sourceType = extractor.getSourceType();
      
      // Create PaperMetadata object
      return {
        sourceId: this.id,
        //paperId: this.formatPaperId(paperId),
        paperId: paperId,
        url: url,
        title: extracted.title || document.title || paperId,
        authors: extracted.authors || '',
        abstract: extracted.description || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: extracted.publishedDate || '',
        tags: extracted.tags || [],
        doi: extracted.doi,
        journalName: extracted.journalName,
        sourceType: sourceType // Store the source type for reference
      };
    } catch (error) {
      logger.error('Error extracting metadata with base extractor', error);
      return null;
    }
  }
  
  /**
   * Format a paper identifier for this source
   * Default implementation uses the format: sourceId.paperId
   */
  formatPaperId(paperId: string): string {
    return `${this.id}.${paperId}`;
  }
  
  /**
   * Parse a paper identifier specific to this source
   * Default implementation handles source.paperId format and extracts paperId
   */
  parsePaperId(identifier: string): string | null {
    const prefix = `${this.id}.`;
    
    if (identifier.startsWith(prefix)) {
      return identifier.substring(prefix.length);
    }
    
    // Try legacy format (sourceId:paperId)
    const legacyPrefix = `${this.id}:`;
    if (identifier.startsWith(legacyPrefix)) {
      logger.debug(`Parsed legacy format identifier: ${identifier}`);
      return identifier.substring(legacyPrefix.length);
    }
    
    return null;
  }
  
  /**
   * Format a storage object ID for this source
   * Default implementation uses the format: type:sourceId.paperId
   */
  formatObjectId(type: string, paperId: string): string {
    return `${type}:${this.formatPaperId(paperId)}`;
  }
}



---
File: extension/source-integration/index.ts
---
// extension/source-integration/index.ts
// Create a barrel file to export all source integrations

import { arxivIntegration } from './arxiv';

// Export all available integrations
export const availableIntegrations = [
  arxivIntegration,
];

// Export individual integrations
export {
  arxivIntegration,
};



---
File: extension/source-integration/link-processor.ts
---
// extension/source-integration/link-processor.ts
// Generic link detection and processing module

import { loguru } from '../utils/logger';

const logger = loguru.getLogger('link-processor');

interface LinkPattern {
  // Source integration ID
  sourceId: string;
  
  // Regular expression to match URLs
  pattern: RegExp;
  
  // Function to extract paper ID from URL
  extractPaperId: (url: string) => string | null;
}

export class LinkProcessor {
  private patterns: LinkPattern[] = [];
  private observer: MutationObserver | null = null;
  private processedLinks = new Set<string>();
  private onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void;
  
  constructor(onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void) {
    this.onLinkFound = onLinkFound;
    logger.debug('Link processor initialized');
  }
  
  /**
   * Register a new link pattern
   */
  registerPattern(pattern: LinkPattern): void {
    this.patterns.push(pattern);
    logger.debug(`Registered pattern for ${pattern.sourceId}`);
  }
  
  /**
   * Process all links in the document
   */
  processLinks(document: Document): void {
    // Process all links in the document
    const links = document.querySelectorAll<HTMLAnchorElement>('a[href]');
    
    links.forEach(link => {
      // Use a unique identifier for this link
      const linkId = this.getLinkId(link);
      
      // Skip if already processed
      if (this.processedLinks.has(linkId)) {
        return;
      }
      
      this.processedLinks.add(linkId);
      
      // Check each pattern
      for (const pattern of this.patterns) {
        if (pattern.pattern.test(link.href)) {
          const paperId = pattern.extractPaperId(link.href);
          
          if (paperId) {
            // Call the callback
            this.onLinkFound(pattern.sourceId, paperId, link);
            break; // Stop after first match
          }
        }
      }
    });
  }
  
  /**
   * Start observing for DOM changes
   */
  startObserving(document: Document): void {
    if (this.observer) {
      this.observer.disconnect();
    }
    
    this.observer = new MutationObserver((mutations) => {
      let newLinks = false;
      
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // If this is an anchor tag, check it
            if ((node as Element).tagName === 'A') {
              newLinks = true;
            }
            
            // Check for any anchor tags within this element
            const links = (node as Element).querySelectorAll('a[href]');
            if (links.length > 0) {
              newLinks = true;
            }
          }
        });
      });
      
      if (newLinks) {
        this.processLinks(document);
      }
    });
    
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    logger.debug('Started observing for DOM changes');
  }
  
  /**
   * Create a unique ID for a link
   */
  private getLinkId(link: HTMLAnchorElement): string {
    // Use href and position in document to create a unique ID
    const path = this.getElementPath(link);
    return `${link.href}|${path}`;
  }
  
  /**
   * Get element path in DOM for identification
   */
  private getElementPath(element: Element): string {
    const path: string[] = [];
    let current: Element | null = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.id) {
        selector += `#${current.id}`;
      } else {
        const siblings = Array.from(current.parentElement?.children || []);
        const index = siblings.indexOf(current) + 1;
        if (siblings.length > 1) {
          selector += `:nth-child(${index})`;
        }
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    return path.join(' > ');
  }
  
  /**
   * Stop observing DOM changes
   */
  stopObserving(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
      logger.debug('Stopped observing DOM changes');
    }
  }
}



---
File: extension/source-integration/source-manager.ts
---
// extension/source-integration/source-manager.ts
// Updated SourceIntegrationManager to use source-specific identifier formatting

import { SourceIntegration, SourceManager } from './types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('source-manager');

/**
 * Manages source integrations
 */
export class SourceIntegrationManager implements SourceManager {
  private sources: Map<string, SourceIntegration> = new Map();
  
  constructor() {
    logger.info('Source integration manager initialized');
  }
  
  /**
   * Register a source integration
   */
  registerSource(source: SourceIntegration): void {
    if (this.sources.has(source.id)) {
      logger.warning(`Source with ID '${source.id}' already registered, overwriting`);
    }
    
    this.sources.set(source.id, source);
    logger.info(`Registered source: ${source.name} (${source.id})`);
  }
  
  /**
   * Get all registered sources
   */
  getAllSources(): SourceIntegration[] {
    return Array.from(this.sources.values());
  }
  
  /**
   * Get source that can handle a URL
   */
  getSourceForUrl(url: string): SourceIntegration | null {
    for (const source of this.sources.values()) {
      if (source.canHandleUrl(url)) {
        logger.debug(`Found source for URL '${url}': ${source.id}`);
        return source;
      }
    }
    
    logger.debug(`No source found for URL: ${url}`);
    return null;
  }
  
  /**
   * Get source by ID
   */
  getSourceById(sourceId: string): SourceIntegration | null {
    const source = this.sources.get(sourceId);
    return source || null;
  }
  
  /**
   * Extract paper ID from URL using appropriate source
   */
  extractPaperId(url: string): { sourceId: string, paperId: string } | null {
    for (const source of this.sources.values()) {
      if (source.canHandleUrl(url)) {
        const paperId = source.extractPaperId(url);
        if (paperId) {
          logger.debug(`Extracted paper ID '${paperId}' from URL using ${source.id}`);
          return { sourceId: source.id, paperId };
        }
      }
    }
    
    logger.debug(`Could not extract paper ID from URL: ${url}`);
    return null;
  }
  
  /**
   * Format a paper identifier using the appropriate source
   */
  formatPaperId(sourceId: string, paperId: string): string {
    const source = this.sources.get(sourceId);
    
    if (source) {
      return source.formatPaperId(paperId);
    }
    
    // Fallback if source not found
    logger.warning(`Source '${sourceId}' not found, using default format for paper ID`);
    return `${sourceId}.${paperId}`;
  }
  
  /**
   * Format an object ID using the appropriate source
   */
  formatObjectId(type: string, sourceId: string, paperId: string): string {
    const source = this.sources.get(sourceId);
    
    if (source) {
      return source.formatObjectId(type, paperId);
    }
    
    // Fallback if source not found
    logger.warning(`Source '${sourceId}' not found, using default format for object ID`);
    return `${type}:${sourceId}.${paperId}`;
  }
  
  /**
   * Get all content script match patterns
   */
  getAllContentScriptMatches(): string[] {
    const patterns: string[] = [];
    
    for (const source of this.sources.values()) {
      patterns.push(...source.contentScriptMatches);
    }
    
    return patterns;
  }
}



---
File: extension/source-integration/types.ts
---
// extension/source-integration/types.ts
// Updated SourceIntegration interface with identifier formatting methods

import type { Json } from 'gh-store-client';
import type { PaperMetadata } from '../papers/types';

/**
 * Source integration interface
 * Implementations should be importable by both background and content scripts
 */
export interface SourceIntegration {
  // Unique identifier
  readonly id: string;
  
  // Human-readable name
  readonly name: string;
  
  // URL patterns for matching papers from this source (as RegExp patterns)
  readonly urlPatterns: RegExp[];
  
  // Domain match patterns for content script registration
  readonly contentScriptMatches: string[];
  
  // Check if URL is from this source
  canHandleUrl(url: string): boolean;
  
  // Extract paper ID from URL
  extractPaperId(url: string): string | null;
  
  // Extract metadata from page or API
  extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null>;
  
  // Format a paper identifier (sourceId + paperId) for this source
  formatPaperId(paperId: string): string;
  
  // Parse a paper identifier specific to this source
  parsePaperId(identifier: string): string | null;
  
  // Format a storage object ID for this source
  formatObjectId(type: string, paperId: string): string;
}

/**
 * Manager interface for source integrations
 */
export interface SourceManager {
  // Register a source integration
  registerSource(source: SourceIntegration): void;
  
  // Get all registered sources
  getAllSources(): SourceIntegration[];
  
  // Get source for a given URL
  getSourceForUrl(url: string): SourceIntegration | null;
  
  // Extract paper ID from URL using appropriate source
  extractPaperId(url: string): { sourceId: string, paperId: string } | null;
  
  // Format a paper identifier using the appropriate source
  formatPaperId(sourceId: string, paperId: string): string;
  
  // Format an object ID using the appropriate source
  formatObjectId(type: string, sourceId: string, paperId: string): string;
}

// Other existing types...
// Message types for communication between background and content scripts

// Content script ready notification
export interface ContentScriptReadyMessage {
  type: 'contentScriptReady';
  url: string;
}

// Paper metadata message
export interface PaperMetadataMessage {
  type: 'paperMetadata';
  metadata: PaperMetadata;
}

// Start session message (new)
export interface StartSessionMessage {
  type: 'startSession';
  sourceId: string;
  paperId: string;
}

// Session heartbeat message (new)
export interface SessionHeartbeatMessage {
  type: 'sessionHeartbeat';
  sourceId: string;
  paperId: string;
  timestamp: number;
}

// End session message (new)
export interface EndSessionMessage {
  type: 'endSession';
  sourceId: string;
  paperId: string;
  reason?: string;
}

// Show annotation popup request
export interface ShowAnnotationPopupMessage {
  type: 'showAnnotationPopup';
  sourceId: string;
  paperId: string;
  position: { x: number, y: number };
}

// Popup action message
export interface PopupActionMessage {
  type: 'popupAction';
  action: string;
  sourceId: string;
  paperId: string;
  data: any;
}

// Show popup message
export interface ShowPopupMessage {
  type: 'showPopup';
  sourceId: string;
  paperId: string;
  html: string;
  handlers: Array<{
    selector: string;
    event: string;
    action: string;
  }>;
  position?: { x: number, y: number };
}

// Process page message
export interface ProcessPageMessage {
  type: 'processPage';
}

// Get current paper message
export interface GetCurrentPaperMessage {
  type: 'getCurrentPaper';
}

// Update rating message
export interface UpdateRatingMessage {
  type: 'updateRating';
  rating: string;
}

// Union type for all message types
export type Message = 
  | ContentScriptReadyMessage
  | PaperMetadataMessage
  | StartSessionMessage
  | SessionHeartbeatMessage
  | EndSessionMessage
  | ShowAnnotationPopupMessage
  | PopupActionMessage
  | ShowPopupMessage
  | ProcessPageMessage
  | GetCurrentPaperMessage
  | UpdateRatingMessage;



---
File: extension/tsconfig.json
---
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2020", "DOM"],
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "types": ["chrome", "@types/node"],
    "outDir": "dist",
    "baseUrl": "."
  },
  "include": [
    "**/*.ts",
    "background.js",
    "content.js",
    "popup.js",
    "options.js"
  ],
  "exclude": ["node_modules", "dist"]
}



---
File: extension/utils/logger.ts
---
// utils/logger.ts
// Logging utility wrapping loguru

/**
 * Logger class for consistent logging throughout the extension
 */
export class Logger {
  constructor(private module: string) {}
  
  /**
   * Log debug message
   */
  debug(message: string, data?: any): void {
    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log info message
   */
  info(message: string, data?: any): void {
    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log warning message
   */
  warning(message: string, data?: any): void {
    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log error message
   */
  error(message: string, data?: any): void {
    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
}

/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
  /**
   * Get logger for a module
   */
  getLogger(module: string): Logger {
    return new Logger(module);
  }
}

// Export singleton instance
export const loguru = new LoguruMock();



---
File: extension/utils/metadata-extractor.ts
---
// extension/utils/metadata-extractor.ts
// Object-oriented metadata extraction system with customizable extraction methods

import { loguru } from './logger';

const logger = loguru.getLogger('metadata-extractor');

export interface ExtractedMetadata {
  title: string;
  authors: string;
  description: string;
  publishedDate: string;
  doi?: string;
  journalName?: string;
  tags?: string[];
  url?: string;
}

// Constants for standard source types
export const SOURCE_TYPES = {
  PDF: 'pdf',
  URL: 'url',
} as const;

export type SourceType = typeof SOURCE_TYPES[keyof typeof SOURCE_TYPES];

/**
 * Base class for metadata extraction with customizable extraction methods
 * Each method can be overridden to provide source-specific extraction
 */
export class MetadataExtractor {
  protected document: Document;
  protected url: string;
  
  /**
   * Create a new metadata extractor for a document
   */
  constructor(document: Document) {
    this.document = document;
    this.url = document.location.href;
    logger.debug('Initialized metadata extractor for:', this.url);
  }
  
  /**
   * Helper method to get content from meta tags
   */
  protected getMetaContent(selector: string): string {
    const element = this.document.querySelector(selector);
    return element ? element.getAttribute('content') || '' : '';
  }
  
  /**
   * Extract and return all metadata fields
   */
  public extract(): ExtractedMetadata {
    logger.debug('Extracting metadata from page:', this.url);
    
    const metadata: ExtractedMetadata = {
      title: this.extractTitle(),
      authors: this.extractAuthors(),
      description: this.extractDescription(),
      publishedDate: this.extractPublishedDate(),
      doi: this.extractDoi(),
      journalName: this.extractJournalName(),
      tags: this.extractTags(),
      url: this.url
    };
    
    logger.debug('Metadata extraction complete:', metadata);
    return metadata;
  }
  
  /**
   * Extract title from document
   * Considers multiple metadata standards with priority order
   */
  protected extractTitle(): string {
    // Title extraction - priority order
    return (
      // Dublin Core
      this.getMetaContent('meta[name="DC.Title"]') ||
      // Citation
      this.getMetaContent('meta[name="citation_title"]') ||
      // Open Graph
      this.getMetaContent('meta[property="og:title"]') ||
      // Standard meta
      this.getMetaContent('meta[name="title"]') ||
      // Fallback to document title
      this.document.title
    );
  }
  
  /**
   * Extract authors from document
   * Handles multiple author formats and sources
   */
  protected extractAuthors(): string {
    // Get all citation authors (some pages have multiple citation_author tags)
    const citationAuthors: string[] = [];
    this.document.querySelectorAll('meta[name="citation_author"]').forEach(el => {
      const content = el.getAttribute('content');
      if (content) citationAuthors.push(content);
    });
    
    // Get all DC creators
    const dcCreators: string[] = [];
    this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach(el => {
      const content = el.getAttribute('content');
      if (content) dcCreators.push(content);
    });
    
    // Individual author elements
    const dcCreator = this.getMetaContent('meta[name="DC.Creator.PersonalName"]');
    const citationAuthor = this.getMetaContent('meta[name="citation_author"]');
    const ogAuthor = this.getMetaContent('meta[property="og:article:author"]') ||
                    this.getMetaContent('meta[name="author"]');
    
    // Set authors with priority
    if (dcCreators.length > 0) {
      return dcCreators.join(', ');
    } else if (citationAuthors.length > 0) {
      return citationAuthors.join(', ');
    } else if (dcCreator) {
      return dcCreator;
    } else if (citationAuthor) {
      return citationAuthor;
    } else if (ogAuthor) {
      return ogAuthor;
    }
    
    return '';
  }
  
  /**
   * Extract description/abstract from document
   */
  protected extractDescription(): string {
    return (
      this.getMetaContent('meta[name="DC.Description"]') ||
      this.getMetaContent('meta[name="citation_abstract"]') ||
      this.getMetaContent('meta[property="og:description"]') ||
      this.getMetaContent('meta[name="description"]')
    );
  }
  
  /**
   * Extract publication date from document
   */
  protected extractPublishedDate(): string {
    return (
      this.getMetaContent('meta[name="DC.Date.issued"]') ||
      this.getMetaContent('meta[name="citation_date"]') ||
      this.getMetaContent('meta[property="article:published_time"]')
    );
  }
  
  /**
   * Extract DOI (Digital Object Identifier) from document
   */
  protected extractDoi(): string {
    return (
      this.getMetaContent('meta[name="DC.Identifier.DOI"]') ||
      this.getMetaContent('meta[name="citation_doi"]')
    );
  }
  
  /**
   * Extract journal name from document
   */
  protected extractJournalName(): string {
    return (
      this.getMetaContent('meta[name="DC.Source"]') ||
      this.getMetaContent('meta[name="citation_journal_title"]')
    );
  }
  
  /**
   * Extract keywords/tags from document
   */
  protected extractTags(): string[] {
    const keywords = this.getMetaContent('meta[name="keywords"]') ||
                    this.getMetaContent('meta[name="DC.Subject"]');
    
    if (keywords) {
      return keywords.split(',').map(tag => tag.trim());
    }
    
    return [];
  }
  
  /**
   * Determine if the current URL is a PDF
   */
  public isPdf(): boolean {
    return isPdfUrl(this.url);
  }
  
  /**
   * Get the source type (PDF or URL)
   */
  public getSourceType(): SourceType {
    return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;
  }
  
  /**
   * Generate a paper ID for the current URL
   */
  public generatePaperId(): string {
    return generatePaperIdFromUrl(this.url);
  }
}

/**
 * Create a common metadata extractor for a document
 * Factory function for creating the default extractor
 */
export function createMetadataExtractor(document: Document): MetadataExtractor {
  return new MetadataExtractor(document);
}

/**
 * Extract common metadata from a document
 * Convenience function for quick extraction
 */
export function extractCommonMetadata(document: Document): ExtractedMetadata {
  return createMetadataExtractor(document).extract();
}

/**
 * Generate a paper ID from a URL
 * Creates a consistent hash-based identifier
 */
export function generatePaperIdFromUrl(url: string): string {
  // Use a basic hash function to create an ID from the URL
  let hash = 0;
  for (let i = 0; i < url.length; i++) {
    const char = url.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Create a positive hexadecimal string
  const positiveHash = Math.abs(hash).toString(16).toUpperCase();
  
  // Use the first 8 characters as the ID
  return positiveHash.substring(0, 8);
}

/**
 * Determine if a URL is a PDF
 */
export function isPdfUrl(url: string): boolean {
  return url.toLowerCase().endsWith('.pdf');
}



---
File: extension/utils/popup-manager.ts
---
// extension/utils/popup-manager.ts
// Popup management system integrated with source manager

import { SourceManager } from '../source-integration/types';
import { PaperManager } from '../papers/manager';
import { PaperMetadata } from '../papers/types';
import { loguru } from './logger';

const logger = loguru.getLogger('popup-manager');

/**
 * Popup handler information
 */
interface PopupHandler {
  selector: string;
  event: string;
  action: string;
}

/**
 * Popup message type
 */
interface ShowPopupMessage {
  type: 'showPopup';
  sourceId: string;
  paperId: string;
  html: string;
  handlers: PopupHandler[];
  position?: { x: number, y: number };
}

/**
 * Manages all popup-related functionality
 */
export class PopupManager {
  // Source manager and paper manager
  private sourceManagerProvider: () => SourceManager | null;
  private paperManagerProvider: () => PaperManager | null;
  
  /**
   * Create a new popup manager
   */
  constructor(
    sourceManagerProvider: () => SourceManager | null,
    paperManagerProvider: () => PaperManager | null
  ) {
    this.sourceManagerProvider = sourceManagerProvider;
    this.paperManagerProvider = paperManagerProvider;
    
    this.setupMessageListeners();
    logger.debug('Popup manager initialized');
  }
  
  /**
   * Set up message listeners for popup-related messages
   */
  private setupMessageListeners(): void {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Handle popup actions (ratings, notes, etc.)
      if (message.type === 'popupAction') {
        this.handlePopupAction(
          message.sourceId,
          message.paperId,
          message.action,
          message.data
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error handling popup action', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      // Handle request to show annotation popup
      if (message.type === 'showAnnotationPopup' && sender.tab?.id) {
        this.handleShowAnnotationPopup(
          sender.tab.id,
          message.sourceId,
          message.paperId,
          message.position
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error showing popup', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      return false; // Not handled
    });
  }
  
  /**
   * Handle a request to show an annotation popup
   */
  private async handleShowAnnotationPopup(
    tabId: number,
    sourceId: string,
    paperId: string,
    position: { x: number, y: number }
  ): Promise<void> {
    logger.debug(`Showing annotation popup for ${sourceId}:${paperId}`);
    
    // Check if we have source and paper manager
    const sourceManager = this.sourceManagerProvider();
    const paperManager = this.paperManagerProvider();
    
    if (!sourceManager) {
      throw new Error('Source manager not initialized');
    }
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    try {
      // Get paper data
      const paper = await paperManager.getPaper(sourceId, paperId);
      
      // Create popup HTML
      const html = this.createPopupHtml(paper || { 
        sourceId, 
        paperId,
        title: paperId,
        authors: '',
        abstract: '',
        url: '',
        timestamp: new Date().toISOString(),
        publishedDate: '',
        tags: [],
        rating: 'novote'
      });
      
      // Get handlers
      const handlers = this.getStandardPopupHandlers();
      
      // Send message to content script to show popup
      const message: ShowPopupMessage = {
        type: 'showPopup',
        sourceId,
        paperId,
        html,
        handlers,
        position
      };
      
      await chrome.tabs.sendMessage(tabId, message);
      
      logger.debug(`Sent popup to content script for ${sourceId}:${paperId}`);
    } catch (error) {
      logger.error(`Error showing popup for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Handle popup actions (ratings, notes, etc.)
   */
  private async handlePopupAction(
    sourceId: string,
    paperId: string,
    action: string,
    data: any
  ): Promise<void> {
    const paperManager = this.paperManagerProvider();
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    logger.debug(`Handling popup action: ${action}`, { sourceId, paperId });
    
    try {
      if (action === 'rate') {
        await paperManager.updateRating(sourceId, paperId, data.value);
        logger.info(`Updated rating for ${sourceId}:${paperId} to ${data.value}`);
      } 
      else if (action === 'saveNotes') {
        if (data.value) {
          await paperManager.logAnnotation(sourceId, paperId, 'notes', data.value);
          logger.info(`Saved notes for ${sourceId}:${paperId}`);
        }
      }
    } catch (error) {
      logger.error(`Error handling action ${action} for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Create HTML for paper popup
   */
  private createPopupHtml(paper: PaperMetadata): string {
    return `
      <div class="paper-popup-header">${paper.title || paper.paperId}</div>
      <div class="paper-popup-meta">${paper.authors || ''}</div>
      
      <div class="paper-popup-buttons">
        <button class="vote-button" data-vote="thumbsup" id="btn-thumbsup" ${paper.rating === 'thumbsup' ? 'class="active"' : ''}>ðŸ‘ Interesting</button>
        <button class="vote-button" data-vote="thumbsdown" id="btn-thumbsdown" ${paper.rating === 'thumbsdown' ? 'class="active"' : ''}>ðŸ‘Ž Not Relevant</button>
      </div>
      
      <textarea placeholder="Add notes about this paper..." id="paper-notes"></textarea>
      
      <div class="paper-popup-actions">
        <button class="save-button" id="btn-save">Save</button>
      </div>
    `;
  }
  
  /**
   * Get standard popup event handlers
   */
  private getStandardPopupHandlers(): PopupHandler[] {
    return [
      { selector: '#btn-thumbsup', event: 'click', action: 'rate' },
      { selector: '#btn-thumbsdown', event: 'click', action: 'rate' },
      { selector: '#btn-save', event: 'click', action: 'saveNotes' }
    ];
  }
}



---
File: extension/utils/session-service.ts
---
// session-service.ts
// Simplified session tracking service for background script

import { loguru } from './logger';
import { PaperManager } from '../papers/manager';
import { ReadingSessionData, PaperMetadata } from '../papers/types';

const logger = loguru.getLogger('session-service');

/**
 * Session tracking service for paper reading sessions
 * 
 * Manages session state, heartbeats, and persistence
 * Designed for use in the background script (Service Worker)
 */
export class SessionService {
  private activeSession: {
    sourceId: string;
    paperId: string;
    startTime: Date;
    heartbeatCount: number;
    lastHeartbeatTime: Date;
  } | null = null;
  
  private timeoutId: number | null = null;
  private paperMetadata: Map<string, PaperMetadata> = new Map();
  
  // Configuration
  private readonly HEARTBEAT_TIMEOUT = 15000; // 15 seconds
  
  /**
   * Create a new session service
   */
  constructor(private paperManager: PaperManager | null) {
    logger.debug('Session service initialized');
  }
  
  /**
   * Start a new session for a paper
   */
  startSession(sourceId: string, paperId: string, metadata?: PaperMetadata): void {
    // End any existing session
    this.endSession();
    
    // Create new session
    this.activeSession = {
      sourceId,
      paperId,
      startTime: new Date(),
      heartbeatCount: 0,
      lastHeartbeatTime: new Date()
    };
    
    // Store metadata if provided
    if (metadata) {
      const key = `${sourceId}:${paperId}`;
      this.paperMetadata.set(key, metadata);
      logger.debug(`Stored metadata for ${key}`);
    }
    
    // Start timeout check
    this.scheduleTimeoutCheck();
    
    logger.info(`Started session for ${sourceId}:${paperId}`);
  }
  
  /**
   * Record a heartbeat for the current session
   */
  recordHeartbeat(): boolean {
    if (!this.activeSession) {
      return false;
    }
    
    this.activeSession.heartbeatCount++;
    this.activeSession.lastHeartbeatTime = new Date();
    
    // Reschedule timeout
    this.scheduleTimeoutCheck();
    
    if (this.activeSession.heartbeatCount % 12 === 0) { // Log every minute (12 x 5sec heartbeats)
      logger.debug(`Session received ${this.activeSession.heartbeatCount} heartbeats`);
    }
    
    return true;
  }
  
  /**
   * Schedule a check for heartbeat timeout
   */
  private scheduleTimeoutCheck(): void {
    // Clear existing timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
    }
    
    // Set new timeout
    this.timeoutId = self.setTimeout(() => {
      this.checkTimeout();
    }, this.HEARTBEAT_TIMEOUT);
  }
  
  /**
   * Check if the session has timed out due to missing heartbeats
   */
  private checkTimeout(): void {
    if (!this.activeSession) return;
    
    const now = Date.now();
    const lastTime = this.activeSession.lastHeartbeatTime.getTime();
    
    if ((now - lastTime) > this.HEARTBEAT_TIMEOUT) {
      logger.info('Session timeout detected');
      this.endSession();
    } else {
      this.scheduleTimeoutCheck();
    }
  }
  
  /**
   * End the current session and get the data
   */
  endSession(): ReadingSessionData | null {
    if (!this.activeSession) return null;
    
    // Clear timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    
    const { sourceId, paperId, startTime, heartbeatCount } = this.activeSession;
    const endTime = new Date();
    
    // Calculate duration (5 seconds per heartbeat)
    const duration = heartbeatCount * 5;
    
    // Calculate total elapsed time
    const totalElapsed = endTime.getTime() - startTime.getTime();
    const totalElapsedSeconds = Math.round(totalElapsed / 1000);
    
    // Set idle seconds to the difference (for backward compatibility)
    const idleSeconds = Math.max(0, totalElapsedSeconds - duration);
    
    // Create session data
    const sessionData: ReadingSessionData = {
      session_id: `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      source_id: sourceId,
      paper_id: paperId,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      heartbeat_count: heartbeatCount,
      duration_seconds: duration,
      // Legacy fields
      idle_seconds: idleSeconds,
      total_elapsed_seconds: totalElapsedSeconds
    };
    
    // Store session if it was meaningful and we have a paper manager
    if (this.paperManager && heartbeatCount > 0) {
      const metadata = this.getPaperMetadata(sourceId, paperId);
      
      this.paperManager.logReadingSession(sourceId, paperId, sessionData, metadata)
        .catch(err => logger.error('Failed to store session', err));
    }
    
    logger.info(`Ended session for ${sourceId}:${paperId}`, {
      duration,
      heartbeats: heartbeatCount
    });
    
    // Clear active session
    this.activeSession = null;
    
    return sessionData;
  }
  
  /**
   * Check if a session is currently active
   */
  hasActiveSession(): boolean {
    return this.activeSession !== null;
  }
  
  /**
   * Get information about the current session
   */
  getCurrentSession(): { sourceId: string, paperId: string } | null {
    if (!this.activeSession) return null;
    
    return {
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId
    };
  }
  
  /**
   * Get paper metadata for the current or specified session
   */
  getPaperMetadata(sourceId?: string, paperId?: string): PaperMetadata | undefined {
    if (!sourceId || !paperId) {
      if (!this.activeSession) return undefined;
      sourceId = this.activeSession.sourceId;
      paperId = this.activeSession.paperId;
    }
    
    return this.paperMetadata.get(`${sourceId}:${paperId}`);
  }
  
  /**
   * Store paper metadata
   */
  storePaperMetadata(metadata: PaperMetadata): void {
    const key = `${metadata.sourceId}:${metadata.paperId}`;
    this.paperMetadata.set(key, metadata);
  }
  
  /**
   * Get time since last heartbeat in milliseconds
   */
  getTimeSinceLastHeartbeat(): number | null {
    if (!this.activeSession) {
      return null;
    }
    
    return Date.now() - this.activeSession.lastHeartbeatTime.getTime();
  }
  
  /**
   * Get session statistics for debugging
   */
  getSessionStats(): any {
    if (!this.activeSession) {
      return { active: false };
    }
    
    return {
      active: true,
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId,
      startTime: this.activeSession.startTime.toISOString(),
      heartbeatCount: this.activeSession.heartbeatCount,
      lastHeartbeatTime: this.activeSession.lastHeartbeatTime.toISOString(),
      elapsedTime: Math.round((Date.now() - this.activeSession.startTime.getTime()) / 1000)
    };
  }
}


